{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "convolutional_neural_networks.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "convolutional_neural_networks.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that convolutional_neural_networks.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "convolutional_neural_networks.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_conv_padding.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\n__module_test__ = \"padding\"\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=7,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=7,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=30)\n\n\n@frames_comparison\ndef test_ConvPadding(scene):\n    # Make nn\n    nn = NeuralNetwork(\n        [\n            Convolutional2DLayer(\n                num_feature_maps=1, feature_map_size=7, padding=1, padding_dashed=True\n            ),\n            Convolutional2DLayer(\n                num_feature_maps=3,\n                feature_map_size=7,\n                filter_size=3,\n                padding=1,\n                filter_spacing=0.35,\n                padding_dashed=False,\n            ),\n            FeedForwardLayer(3),\n        ],\n        layer_spacing=0.25,\n    )\n    # Center the nn\n    nn.move_to(ORIGIN)\n    scene.add(nn)\n    # Play animation\n    forward_pass = nn.make_forward_pass_animation()\n    scene.play(forward_pass, run_time=30)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_conv_padding.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_conv_padding.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\n__module_test__ = \"padding\"\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=7,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=7,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=30)\n\n\n@frames_comparison\ndef test_ConvPadding(scene):\n    # Make nn\n    nn = NeuralNetwork(\n        [\n            Convolutional2DLayer(\n                num_feature_maps=1, feature_map_size=7, padding=1, padding_dashed=True\n            ),\n            Convolutional2DLayer(\n                num_feature_maps=3,\n                feature_map_size=7,\n                filter_size=3,\n                padding=1,\n                filter_spacing=0.35,\n                padding_dashed=False,\n            ),\n            FeedForwardLayer(3),\n        ],\n        layer_spacing=0.25,\n    )\n    # Center the nn\n    nn.move_to(ORIGIN)\n    scene.add(nn)\n    # Play animation\n    forward_pass = nn.make_forward_pass_animation()\n    scene.play(forward_pass, run_time=30)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_conv_padding.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a grayscale image created from a 2\u00d74 pixel array, where each pixel's brightness corresponds to its value. The image is scaled to a height of 7 units and shown centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ImageFromArray(Scene):\n    def construct(self):\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        self.add(image)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a grayscale image created from a 2\u00d74 pixel array, where each pixel's brightness corresponds to its value. The image is scaled to a height of 7 units and shown centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a grayscale image created from a 2\u00d74 pixel array, where each pixel's brightness corresponds to its value. the image is scaled to a height of 7 units and shown centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ImageFromArray(Scene):\n    def construct(self):\n        image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                       [255, 0, 5, 33]]))\n        image.height = 7\n        self.add(image)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a grayscale image created from a 2\u00d74 pixel array, where each pixel's brightness corresponds to its value. The image is scaled to a height of 7 units and shown centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a blue streamlines vector field where each line flows according to a sine and cosine-based function. The streamlines begin animating immediately with a smooth, continuous motion, simulating fluid flow at a moderate speed. After a brief moment, the animation gracefully stops, freezing the streamlines in place."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EndAnimation(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n        )\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n        self.wait(1)\n        self.play(stream_lines.end_animation())\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue streamlines vector field where each line flows according to a sine and cosine-based function. The streamlines begin animating immediately with a smooth, continuous motion, simulating fluid flow at a moderate speed. After a brief moment, the animation gracefully stops, freezing the streamlines in place."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a blue streamlines vector field where each line flows according to a sine and cosine-based function. the streamlines begin animating immediately with a smooth, continuous motion, simulating fluid flow at a moderate speed. after a brief moment, the animation gracefully stops, freezing the streamlines in place."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EndAnimation(Scene):\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(\n            func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n        )\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n        self.wait(1)\n        self.play(stream_lines.end_animation())\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue streamlines vector field where each line flows according to a sine and cosine-based function. The streamlines begin animating immediately with a smooth, continuous motion, simulating fluid flow at a moderate speed. After a brief moment, the animation gracefully stops, freezing the streamlines in place."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "activation_functions.py"}, {"from": "assistant", "value": "```python\nfrom pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork([\n            # ... Layers at start\n            Convolutional2DLayer(3, 5, 3, activation_function=\"ReLU\"),\n            # ... Layers at end\n        ])\n        # Play the animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        font=\"Monospace\",\n        background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.45)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7),\n                Convolutional2DLayer(3, 5, 3, activation_function=\"ReLU\"),\n                Convolutional2DLayer(5, 3, 3, activation_function=\"ReLU\"),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # nn.scale(0.7)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # nn.move_to(ORIGIN)\n        # Move everything up\n        # Group(nn, code).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "activation_functions.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that activation_functions.py"}, {"from": "assistant", "value": "```python\nfrom pathlib import Path\n\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork([\n            # ... Layers at start\n            Convolutional2DLayer(3, 5, 3, activation_function=\"ReLU\"),\n            # ... Layers at end\n        ])\n        # Play the animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        font=\"Monospace\",\n        background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.45)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7),\n                Convolutional2DLayer(3, 5, 3, activation_function=\"ReLU\"),\n                Convolutional2DLayer(5, 3, 3, activation_function=\"ReLU\"),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # nn.scale(0.7)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        # code = make_code_snippet()\n        # code.next_to(nn, DOWN)\n        # self.add(code)\n        # nn.move_to(ORIGIN)\n        # Move everything up\n        # Group(nn, code).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "activation_functions.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the Law of Large Numbers explain the stability of casino games and can this be modeled graphically?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CasinoLawOfLargeNumbers(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Why Casinos Always Have the Upper Hand\", font_size=40)\n        subtitle = Text(\"The Law of Large Numbers\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Explanation text\n        explanation = Text(\"As more games are played,\\noutcomes stabilize toward the house edge\", \n                         font_size=30)\n        self.play(Write(explanation))\n        self.wait(2)\n        self.play(FadeOut(explanation))\n        \n        # Simple graph - just create axes\n        axes = Axes(\n            x_range=[0, 10, 2],\n            y_range=[-1, 1, 0.5],\n            x_length=6,\n            y_length=4,\n        )\n        \n        # Graph labels\n        graph_title = Text(\"Casino Profit Over Time\", font_size=24).next_to(axes, UP)\n        x_label = Text(\"Number of Games\", font_size=20).next_to(axes, DOWN)\n        y_label = Text(\"Profit\", font_size=20).next_to(axes, LEFT)\n        \n        self.play(Create(axes))\n        self.play(Write(graph_title), Write(x_label), Write(y_label))\n        \n        # Create lines directly\n        line1 = Line(axes.c2p(0, 0), axes.c2p(2, 0.8), color=BLUE)\n        line2 = Line(axes.c2p(2, 0.8), axes.c2p(4, -0.5), color=BLUE)\n        line3 = Line(axes.c2p(4, -0.5), axes.c2p(6, 0.3), color=BLUE)\n        line4 = Line(axes.c2p(6, 0.3), axes.c2p(8, 0.15), color=BLUE)\n        line5 = Line(axes.c2p(8, 0.15), axes.c2p(10, 0.1), color=BLUE)\n        \n        # Create the house edge line\n        house_edge = Line(\n            start=axes.c2p(0, 0.1),\n            end=axes.c2p(10, 0.1),\n            color=GREEN\n        )\n        \n        # Add the lines to the graph\n        self.play(Create(line1))\n        self.play(Create(line2))\n        self.play(Create(line3))\n        self.play(Create(line4))\n        self.play(Create(line5))\n        self.play(Create(house_edge))\n        \n        # Add label for the house edge\n        edge_label = Text(\"House Edge\", font_size=16, color=GREEN)\n        edge_label.next_to(house_edge.get_end(), RIGHT)\n        self.play(Write(edge_label))\n        \n        self.wait(2)\n        \n        # Clear the screen\n        self.play(\n            FadeOut(axes), FadeOut(line1), FadeOut(line2), FadeOut(line3),\n            FadeOut(line4), FadeOut(line5), FadeOut(house_edge), \n            FadeOut(graph_title), FadeOut(x_label), FadeOut(y_label),\n            FadeOut(edge_label)\n        )\n        \n        # Law of Large Numbers equation\n        lln_eq = MathTex(r\"\\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=1}^{n} X_i = \\mu\")\n        eq_caption = Text(\"Law of Large Numbers\", font_size=24).next_to(lln_eq, UP)\n        \n        self.play(Write(eq_caption))\n        self.play(Write(lln_eq))\n        self.wait(2)\n        \n        # Probability equation (second equation requested)\n        self.play(FadeOut(lln_eq), FadeOut(eq_caption))\n        \n        prob_eq = MathTex(r\"P(|\\overline{X_n} - \\mu| < \\epsilon) \\rightarrow 1 \\text{ as } n \\rightarrow \\infty\")\n        prob_caption = Text(\"Probability Calculation\", font_size=24).next_to(prob_eq, UP)\n        \n        self.play(Write(prob_caption))\n        self.play(Write(prob_eq))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"The house always wins... eventually\", font_size=36, color=RED)\n        \n        self.play(FadeOut(prob_eq), FadeOut(prob_caption))\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Law of Large Numbers explain the stability of casino games and can this be modeled graphically?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the law of large numbers explain the stability of casino games and can this be modeled graphically?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CasinoLawOfLargeNumbers(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Why Casinos Always Have the Upper Hand\", font_size=40)\n        subtitle = Text(\"The Law of Large Numbers\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Explanation text\n        explanation = Text(\"As more games are played,\\noutcomes stabilize toward the house edge\", \n                         font_size=30)\n        self.play(Write(explanation))\n        self.wait(2)\n        self.play(FadeOut(explanation))\n        \n        # Simple graph - just create axes\n        axes = Axes(\n            x_range=[0, 10, 2],\n            y_range=[-1, 1, 0.5],\n            x_length=6,\n            y_length=4,\n        )\n        \n        # Graph labels\n        graph_title = Text(\"Casino Profit Over Time\", font_size=24).next_to(axes, UP)\n        x_label = Text(\"Number of Games\", font_size=20).next_to(axes, DOWN)\n        y_label = Text(\"Profit\", font_size=20).next_to(axes, LEFT)\n        \n        self.play(Create(axes))\n        self.play(Write(graph_title), Write(x_label), Write(y_label))\n        \n        # Create lines directly\n        line1 = Line(axes.c2p(0, 0), axes.c2p(2, 0.8), color=BLUE)\n        line2 = Line(axes.c2p(2, 0.8), axes.c2p(4, -0.5), color=BLUE)\n        line3 = Line(axes.c2p(4, -0.5), axes.c2p(6, 0.3), color=BLUE)\n        line4 = Line(axes.c2p(6, 0.3), axes.c2p(8, 0.15), color=BLUE)\n        line5 = Line(axes.c2p(8, 0.15), axes.c2p(10, 0.1), color=BLUE)\n        \n        # Create the house edge line\n        house_edge = Line(\n            start=axes.c2p(0, 0.1),\n            end=axes.c2p(10, 0.1),\n            color=GREEN\n        )\n        \n        # Add the lines to the graph\n        self.play(Create(line1))\n        self.play(Create(line2))\n        self.play(Create(line3))\n        self.play(Create(line4))\n        self.play(Create(line5))\n        self.play(Create(house_edge))\n        \n        # Add label for the house edge\n        edge_label = Text(\"House Edge\", font_size=16, color=GREEN)\n        edge_label.next_to(house_edge.get_end(), RIGHT)\n        self.play(Write(edge_label))\n        \n        self.wait(2)\n        \n        # Clear the screen\n        self.play(\n            FadeOut(axes), FadeOut(line1), FadeOut(line2), FadeOut(line3),\n            FadeOut(line4), FadeOut(line5), FadeOut(house_edge), \n            FadeOut(graph_title), FadeOut(x_label), FadeOut(y_label),\n            FadeOut(edge_label)\n        )\n        \n        # Law of Large Numbers equation\n        lln_eq = MathTex(r\"\\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=1}^{n} X_i = \\mu\")\n        eq_caption = Text(\"Law of Large Numbers\", font_size=24).next_to(lln_eq, UP)\n        \n        self.play(Write(eq_caption))\n        self.play(Write(lln_eq))\n        self.wait(2)\n        \n        # Probability equation (second equation requested)\n        self.play(FadeOut(lln_eq), FadeOut(eq_caption))\n        \n        prob_eq = MathTex(r\"P(|\\overline{X_n} - \\mu| < \\epsilon) \\rightarrow 1 \\text{ as } n \\rightarrow \\infty\")\n        prob_caption = Text(\"Probability Calculation\", font_size=24).next_to(prob_eq, UP)\n        \n        self.play(Write(prob_caption))\n        self.play(Write(prob_eq))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"The house always wins... eventually\", font_size=36, color=RED)\n        \n        self.play(FadeOut(prob_eq), FadeOut(prob_caption))\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Law of Large Numbers explain the stability of casino games and can this be modeled graphically?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation that shows a neural network with 5 layers, where the first layer has 3 neurons, the second has 5 neurons, the third has 3 neurons, the fourth has 5 neurons, and the fifth layer has 4 neurons, with a dropout effect demonstrating the deactivation of 25% neurons randomly during a forward pass in the network, and have the network be centered on the screen?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Highlighting the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2])\n        area = area = self.get_area(curve, 0, 2)\n        self.play(ShowCreation(curve), FadeIn(area))\n        self.wait(2)\n\n        # Explanation of the definite integral\n        explanation = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Show antiderivative formation\n        antiderivative = MathTex(r\"= \\frac{1}{3}x^3 \\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), antiderivative))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(antiderivative, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation that shows a neural network with 5 layers, where the first layer has 3 neurons, the second has 5 neurons, the third has 3 neurons, the fourth has 5 neurons, and the fifth layer has 4 neurons, with a dropout effect demonstrating the deactivation of 25% neurons randomly during a forward pass in the network, and have the network be centered on the screen?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation that shows a neural network with 5 layers, where the first layer has 3 neurons, the second has 5 neurons, the third has 3 neurons, the fourth has 5 neurons, and the fifth layer has 4 neurons, with a dropout effect demonstrating the deactivation of 25% neurons randomly during a forward pass in the network, and have the network be centered on the screen?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Highlighting the area under the curve\n        curve = FunctionGraph(lambda x: x**2, x_range=[0, 2])\n        area = area = self.get_area(curve, 0, 2)\n        self.play(ShowCreation(curve), FadeIn(area))\n        self.wait(2)\n\n        # Explanation of the definite integral\n        explanation = Text(\"Area under the curve from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Show antiderivative formation\n        antiderivative = MathTex(r\"= \\frac{1}{3}x^3 \\Big|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), antiderivative))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{8}{3}\")\n        self.play(ReplacementTransform(antiderivative, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation that shows a neural network with 5 layers, where the first layer has 3 neurons, the second has 5 neurons, the third has 3 neurons, the fourth has 5 neurons, and the fifth layer has 4 neurons, with a dropout effect demonstrating the deactivation of 25% neurons randomly during a forward pass in the network, and have the network be centered on the screen?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_variational_autoencoder.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import EmbeddingLayer, FeedForwardLayer, ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 8.0\nconfig.frame_width = 8.0\n\n\nclass VariationalAutoencoderScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\").scale(2)\n\n        image = Image.open(\"images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        neural_network = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.4),\n            ],\n            layer_spacing=0.1,\n        )\n\n        neural_network.scale(1.3)\n\n        self.play(Create(neural_network), run_time=3)\n        self.play(neural_network.make_forward_pass_animation(), run_time=5)\n        self.play(neural_network.make_forward_pass_animation(), run_time=5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_variational_autoencoder.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_variational_autoencoder.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import EmbeddingLayer, FeedForwardLayer, ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 8.0\nconfig.frame_width = 8.0\n\n\nclass VariationalAutoencoderScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer(dist_theme=\"ellipse\").scale(2)\n\n        image = Image.open(\"images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        neural_network = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.4),\n            ],\n            layer_spacing=0.1,\n        )\n\n        neural_network.scale(1.3)\n\n        self.play(Create(neural_network), run_time=3)\n        self.play(neural_network.make_forward_pass_animation(), run_time=5)\n        self.play(neural_network.make_forward_pass_animation(), run_time=5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_variational_autoencoder.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What visual patterns emerge when tracing the field extensions corresponding to intermediate fields over a given polynomial?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GaloisTheoryVisualization(Scene):\n    def construct(self):\n        # Set background color to a dark shade\n        self.camera.background_color = \"#0C0C2C\"\n        \n        # Introduction\n        title = Text(\"Unlocking the Hidden Hierarchies of Galois Theory\", color=WHITE, font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Creating the web-like lines in the background\n        num_lines = 8\n        web_lines = VGroup()\n        for i in range(num_lines):\n            angle = i * PI / num_lines\n            line = Line(\n                3 * (RIGHT * np.cos(angle) + UP * np.sin(angle)),\n                3 * (LEFT * np.cos(angle) + DOWN * np.sin(angle)),\n                stroke_width=0.5,\n                color=\"#4B5D8E\"  # Soft blue color\n            )\n            web_lines.add(line)\n        \n        self.play(Create(web_lines, lag_ratio=0.1))\n        \n        # Introducing the polynomial\n        polynomial = MathTex(\"x^3 - 2 = 0\", color=WHITE)\n        self.play(Write(polynomial))\n        self.wait(1)\n        \n        # Show a root\n        root = MathTex(r\"\\sqrt[3]{2} \\in \\mathbb{R}\", color=WHITE)\n        self.play(Transform(polynomial, root))\n        self.wait(1)\n        \n        # Show factorization\n        factorization = MathTex(r\"x^3 - 2 = (x - \\sqrt[3]{2})(x - \\omega\\sqrt[3]{2})(x - \\omega^2\\sqrt[3]{2})\", color=WHITE)\n        self.play(Transform(polynomial, factorization))\n        self.wait(1)\n        self.play(polynomial.animate.scale(0.8).to_edge(UP))\n        \n        # Create a lattice diagram\n        # Base field Q\n        q_field = Circle(radius=0.4, color=BLUE_D).move_to(DOWN * 2)\n        q_label = Text(\"Q\", font_size=24, color=WHITE).move_to(q_field.get_center())\n        \n        # Intermediate fields\n        mid_field1 = Circle(radius=0.4, color=BLUE_D).move_to(LEFT * 1.5 + UP * 0)\n        mid_label1 = Text(\"Q(\u221b2)\", font_size=20, color=WHITE).move_to(mid_field1.get_center())\n        \n        mid_field2 = Circle(radius=0.4, color=BLUE_D).move_to(RIGHT * 1.5 + UP * 0)\n        mid_label2 = Text(\"Q(\u03c9)\", font_size=20, color=WHITE).move_to(mid_field2.get_center())\n        \n        # Top field\n        top_field = Circle(radius=0.4, color=BLUE_D).move_to(UP * 2)\n        top_label = Text(\"Q(\u221b2,\u03c9)\", font_size=20, color=WHITE).move_to(top_field.get_center())\n        \n        # Connections\n        connection1 = Line(q_field.get_top(), mid_field1.get_bottom(), color=PURPLE)\n        connection2 = Line(q_field.get_top(), mid_field2.get_bottom(), color=PURPLE)\n        connection3 = Line(mid_field1.get_top(), top_field.get_bottom(), color=PURPLE)\n        connection4 = Line(mid_field2.get_top(), top_field.get_bottom(), color=PURPLE)\n        \n        # Animate the lattice\n        self.play(Create(q_field), Write(q_label))\n        self.wait(0.5)\n        \n        self.play(Create(connection1), Create(connection2))\n        self.play(Create(mid_field1), Write(mid_label1))\n        self.play(Create(mid_field2), Write(mid_label2))\n        self.wait(0.5)\n        \n        self.play(Create(connection3), Create(connection4))\n        self.play(Create(top_field), Write(top_label))\n        self.wait(1)\n        \n        # Group all lattice elements\n        lattice = VGroup(\n            q_field, q_label, \n            mid_field1, mid_label1, \n            mid_field2, mid_label2,\n            top_field, top_label,\n            connection1, connection2, connection3, connection4\n        )\n        \n        # Highlight connections\n        highlight_color = \"#E6A8D7\"  # Light purple\n        self.play(\n            connection1.animate.set_color(highlight_color),\n            connection3.animate.set_color(highlight_color)\n        )\n        self.wait(0.5)\n        self.play(\n            connection1.animate.set_color(PURPLE),\n            connection3.animate.set_color(PURPLE),\n            connection2.animate.set_color(highlight_color),\n            connection4.animate.set_color(highlight_color)\n        )\n        self.wait(0.5)\n        self.play(\n            connection2.animate.set_color(PURPLE),\n            connection4.animate.set_color(PURPLE)\n        )\n        \n        # Final message\n        conclusion = Text(\"This lattice reveals the structure of field extensions\\nand the symmetries of our polynomial\", \n                         font_size=24, color=WHITE)\n        \n        self.play(lattice.animate.scale(0.7).to_edge(LEFT))\n        self.play(Write(conclusion.to_edge(RIGHT)))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(FadeOut(lattice), FadeOut(conclusion), FadeOut(polynomial), FadeOut(web_lines))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What visual patterns emerge when tracing the field extensions corresponding to intermediate fields over a given polynomial?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what visual patterns emerge when tracing the field extensions corresponding to intermediate fields over a given polynomial?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GaloisTheoryVisualization(Scene):\n    def construct(self):\n        # Set background color to a dark shade\n        self.camera.background_color = \"#0C0C2C\"\n        \n        # Introduction\n        title = Text(\"Unlocking the Hidden Hierarchies of Galois Theory\", color=WHITE, font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Creating the web-like lines in the background\n        num_lines = 8\n        web_lines = VGroup()\n        for i in range(num_lines):\n            angle = i * PI / num_lines\n            line = Line(\n                3 * (RIGHT * np.cos(angle) + UP * np.sin(angle)),\n                3 * (LEFT * np.cos(angle) + DOWN * np.sin(angle)),\n                stroke_width=0.5,\n                color=\"#4B5D8E\"  # Soft blue color\n            )\n            web_lines.add(line)\n        \n        self.play(Create(web_lines, lag_ratio=0.1))\n        \n        # Introducing the polynomial\n        polynomial = MathTex(\"x^3 - 2 = 0\", color=WHITE)\n        self.play(Write(polynomial))\n        self.wait(1)\n        \n        # Show a root\n        root = MathTex(r\"\\sqrt[3]{2} \\in \\mathbb{R}\", color=WHITE)\n        self.play(Transform(polynomial, root))\n        self.wait(1)\n        \n        # Show factorization\n        factorization = MathTex(r\"x^3 - 2 = (x - \\sqrt[3]{2})(x - \\omega\\sqrt[3]{2})(x - \\omega^2\\sqrt[3]{2})\", color=WHITE)\n        self.play(Transform(polynomial, factorization))\n        self.wait(1)\n        self.play(polynomial.animate.scale(0.8).to_edge(UP))\n        \n        # Create a lattice diagram\n        # Base field Q\n        q_field = Circle(radius=0.4, color=BLUE_D).move_to(DOWN * 2)\n        q_label = Text(\"Q\", font_size=24, color=WHITE).move_to(q_field.get_center())\n        \n        # Intermediate fields\n        mid_field1 = Circle(radius=0.4, color=BLUE_D).move_to(LEFT * 1.5 + UP * 0)\n        mid_label1 = Text(\"Q(\u221b2)\", font_size=20, color=WHITE).move_to(mid_field1.get_center())\n        \n        mid_field2 = Circle(radius=0.4, color=BLUE_D).move_to(RIGHT * 1.5 + UP * 0)\n        mid_label2 = Text(\"Q(\u03c9)\", font_size=20, color=WHITE).move_to(mid_field2.get_center())\n        \n        # Top field\n        top_field = Circle(radius=0.4, color=BLUE_D).move_to(UP * 2)\n        top_label = Text(\"Q(\u221b2,\u03c9)\", font_size=20, color=WHITE).move_to(top_field.get_center())\n        \n        # Connections\n        connection1 = Line(q_field.get_top(), mid_field1.get_bottom(), color=PURPLE)\n        connection2 = Line(q_field.get_top(), mid_field2.get_bottom(), color=PURPLE)\n        connection3 = Line(mid_field1.get_top(), top_field.get_bottom(), color=PURPLE)\n        connection4 = Line(mid_field2.get_top(), top_field.get_bottom(), color=PURPLE)\n        \n        # Animate the lattice\n        self.play(Create(q_field), Write(q_label))\n        self.wait(0.5)\n        \n        self.play(Create(connection1), Create(connection2))\n        self.play(Create(mid_field1), Write(mid_label1))\n        self.play(Create(mid_field2), Write(mid_label2))\n        self.wait(0.5)\n        \n        self.play(Create(connection3), Create(connection4))\n        self.play(Create(top_field), Write(top_label))\n        self.wait(1)\n        \n        # Group all lattice elements\n        lattice = VGroup(\n            q_field, q_label, \n            mid_field1, mid_label1, \n            mid_field2, mid_label2,\n            top_field, top_label,\n            connection1, connection2, connection3, connection4\n        )\n        \n        # Highlight connections\n        highlight_color = \"#E6A8D7\"  # Light purple\n        self.play(\n            connection1.animate.set_color(highlight_color),\n            connection3.animate.set_color(highlight_color)\n        )\n        self.wait(0.5)\n        self.play(\n            connection1.animate.set_color(PURPLE),\n            connection3.animate.set_color(PURPLE),\n            connection2.animate.set_color(highlight_color),\n            connection4.animate.set_color(highlight_color)\n        )\n        self.wait(0.5)\n        self.play(\n            connection2.animate.set_color(PURPLE),\n            connection4.animate.set_color(PURPLE)\n        )\n        \n        # Final message\n        conclusion = Text(\"This lattice reveals the structure of field extensions\\nand the symmetries of our polynomial\", \n                         font_size=24, color=WHITE)\n        \n        self.play(lattice.animate.scale(0.7).to_edge(LEFT))\n        self.play(Write(conclusion.to_edge(RIGHT)))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(FadeOut(lattice), FadeOut(conclusion), FadeOut(polynomial), FadeOut(web_lines))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What visual patterns emerge when tracing the field extensions corresponding to intermediate fields over a given polynomial?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animated video that explains how to solve a triple integral, step by step, using a specific example of integrating the function xyz over the unit cube with bounds from 0 to 1. The animation should include on-screen text guiding through each step of the integration: first integrating with respect to z, then y, and finally x, showing the evaluated antiderivatives and results after each integration. After the calculation, display the final numerical answer clearly. The explanations should appear at the top of the screen and the mathematical steps should be shown in the center. Please ensure that each step is presented in a clear and easy-to-understand manner, and let there be pauses between steps so the viewer can follow along."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FourierSeriesVisual(Scene):\n    def construct(self):\n        # Introduction to Fourier Series\n        title = Text(\"Fourier Series Representation\", font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.wait()\n\n        # Example of a square wave\n        square_wave_text = Text(\"Square Wave\", font_size=28).to_edge(UP).shift(DOWN)\n        square_wave = Square(color=BLUE).scale(2)\n        self.play(Write(square_wave_text))\n        self.wait(0.5)\n        self.play(ShowCreation(square_wave))\n        self.wait()\n\n        # Display Fourier Series Equation\n        fourier_series_text = MathTex(\n            \"f(x) = a_0 + \\sum_{n=1}^\\infty (a_n \\cos(nx) + b_n \\sin(nx))\"\n        ).next_to(square_wave, DOWN)\n        self.play(ReplacementTransform(square_wave_text, fourier_series_text))\n        self.wait(2)\n\n        # Explanation for Fourier Analysis\n        explanation_fourier = Text(\"Fourier analysis breaks down\",\n                                   \"periodic functions into a sum of sine and cosine functions.\",\n                                   font_size=24).next_to(fourier_series_text, DOWN)\n        self.play(FadeIn(explanation_fourier, UP))\n        self.wait(2)\n\n        # Clear the scene for partial sum\n        self.clear()\n        self.wait()\n\n        # Fourier Series Partial Sum Equation\n        partial_sum_title = Text(\"Fourier Series Partial Sum\", font_size=36).to_edge(UP)\n        partial_sum_eq = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^N (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(partial_sum_title))\n        self.wait()\n        self.play(Write(partial_sum_eq))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"As N approaches infinity,\", \n                          \"the partial sum converges to the function\", font_size=24).next_to(partial_sum_eq, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear the scene at the end\n        self.play(FadeOut(partial_sum_title), FadeOut(partial_sum_eq), FadeOut(conclusion))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that explains how to solve a triple integral, step by step, using a specific example of integrating the function xyz over the unit cube with bounds from 0 to 1. The animation should include on-screen text guiding through each step of the integration: first integrating with respect to z, then y, and finally x, showing the evaluated antiderivatives and results after each integration. After the calculation, display the final numerical answer clearly. The explanations should appear at the top of the screen and the mathematical steps should be shown in the center. Please ensure that each step is presented in a clear and easy-to-understand manner, and let there be pauses between steps so the viewer can follow along."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animated video that explains how to solve a triple integral, step by step, using a specific example of integrating the function xyz over the unit cube with bounds from 0 to 1. the animation should include on-screen text guiding through each step of the integration: first integrating with respect to z, then y, and finally x, showing the evaluated antiderivatives and results after each integration. after the calculation, display the final numerical answer clearly. the explanations should appear at the top of the screen and the mathematical steps should be shown in the center. please ensure that each step is presented in a clear and easy-to-understand manner, and let there be pauses between steps so the viewer can follow along."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FourierSeriesVisual(Scene):\n    def construct(self):\n        # Introduction to Fourier Series\n        title = Text(\"Fourier Series Representation\", font_size=36).to_edge(UP)\n        self.play(Write(title))\n        self.wait()\n\n        # Example of a square wave\n        square_wave_text = Text(\"Square Wave\", font_size=28).to_edge(UP).shift(DOWN)\n        square_wave = Square(color=BLUE).scale(2)\n        self.play(Write(square_wave_text))\n        self.wait(0.5)\n        self.play(ShowCreation(square_wave))\n        self.wait()\n\n        # Display Fourier Series Equation\n        fourier_series_text = MathTex(\n            \"f(x) = a_0 + \\sum_{n=1}^\\infty (a_n \\cos(nx) + b_n \\sin(nx))\"\n        ).next_to(square_wave, DOWN)\n        self.play(ReplacementTransform(square_wave_text, fourier_series_text))\n        self.wait(2)\n\n        # Explanation for Fourier Analysis\n        explanation_fourier = Text(\"Fourier analysis breaks down\",\n                                   \"periodic functions into a sum of sine and cosine functions.\",\n                                   font_size=24).next_to(fourier_series_text, DOWN)\n        self.play(FadeIn(explanation_fourier, UP))\n        self.wait(2)\n\n        # Clear the scene for partial sum\n        self.clear()\n        self.wait()\n\n        # Fourier Series Partial Sum Equation\n        partial_sum_title = Text(\"Fourier Series Partial Sum\", font_size=36).to_edge(UP)\n        partial_sum_eq = MathTex(r\"S_N(x) = a_0 + \\sum_{n=1}^N (a_n \\cos(nx) + b_n \\sin(nx))\")\n        self.play(Write(partial_sum_title))\n        self.wait()\n        self.play(Write(partial_sum_eq))\n        self.wait(2)\n\n        # Conclusion\n        conclusion = Text(\"As N approaches infinity,\", \n                          \"the partial sum converges to the function\", font_size=24).next_to(partial_sum_eq, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clear the scene at the end\n        self.play(FadeOut(partial_sum_title), FadeOut(partial_sum_eq), FadeOut(conclusion))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that explains how to solve a triple integral, step by step, using a specific example of integrating the function xyz over the unit cube with bounds from 0 to 1. The animation should include on-screen text guiding through each step of the integration: first integrating with respect to z, then y, and finally x, showing the evaluated antiderivatives and results after each integration. After the calculation, display the final numerical answer clearly. The explanations should appear at the top of the screen and the mathematical steps should be shown in the center. Please ensure that each step is presented in a clear and easy-to-understand manner, and let there be pauses between steps so the viewer can follow along."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a blue ellipse on the left and a red ellipse on the right with the text \"Boolean Operation\" above them. Fade in the group of ellipses and text. Show the green intersection of the ellipses with the label \"Intersection\" above it. Display the orange union of the ellipses with the label \"Union\" above it. Show the yellow exclusion of the ellipses with the label \"Exclusion\" above it. Display the pink difference of the ellipses with the label \"Difference\" above it."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"<u>Boolean Operation</u>\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue ellipse on the left and a red ellipse on the right with the text \"Boolean Operation\" above them. Fade in the group of ellipses and text. Show the green intersection of the ellipses with the label \"Intersection\" above it. Display the orange union of the ellipses with the label \"Union\" above it. Show the yellow exclusion of the ellipses with the label \"Exclusion\" above it. Display the pink difference of the ellipses with the label \"Difference\" above it."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a blue ellipse on the left and a red ellipse on the right with the text \"boolean operation\" above them. fade in the group of ellipses and text. show the green intersection of the ellipses with the label \"intersection\" above it. display the orange union of the ellipses with the label \"union\" above it. show the yellow exclusion of the ellipses with the label \"exclusion\" above it. display the pink difference of the ellipses with the label \"difference\" above it."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BooleanOperations(Scene):\n    def construct(self):\n        ellipse1 = Ellipse(\n            width=4.0, height=5.0, fill_opacity=0.5, color=BLUE, stroke_width=10\n        ).move_to(LEFT)\n        ellipse2 = ellipse1.copy().set_color(color=RED).move_to(RIGHT)\n        bool_ops_text = MarkupText(\"<u>Boolean Operation</u>\").next_to(ellipse1, UP * 3)\n        ellipse_group = Group(bool_ops_text, ellipse1, ellipse2).move_to(LEFT * 3)\n        self.play(FadeIn(ellipse_group))\n\n        i = Intersection(ellipse1, ellipse2, color=GREEN, fill_opacity=0.5)\n        self.play(i.animate.scale(0.25).move_to(RIGHT * 5 + UP * 2.5))\n        intersection_text = Text(\"Intersection\", font_size=23).next_to(i, UP)\n        self.play(FadeIn(intersection_text))\n\n        u = Union(ellipse1, ellipse2, color=ORANGE, fill_opacity=0.5)\n        union_text = Text(\"Union\", font_size=23)\n        self.play(u.animate.scale(0.3).next_to(i, DOWN, buff=union_text.height * 3))\n        union_text.next_to(u, UP)\n        self.play(FadeIn(union_text))\n\n        e = Exclusion(ellipse1, ellipse2, color=YELLOW, fill_opacity=0.5)\n        exclusion_text = Text(\"Exclusion\", font_size=23)\n        self.play(e.animate.scale(0.3).next_to(u, DOWN, buff=exclusion_text.height * 3.5))\n        exclusion_text.next_to(e, UP)\n        self.play(FadeIn(exclusion_text))\n\n        d = Difference(ellipse1, ellipse2, color=PINK, fill_opacity=0.5)\n        difference_text = Text(\"Difference\", font_size=23)\n        self.play(d.animate.scale(0.3).next_to(u, LEFT, buff=difference_text.height * 3.5))\n        difference_text.next_to(d, UP)\n        self.play(FadeIn(difference_text))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue ellipse on the left and a red ellipse on the right with the text \"Boolean Operation\" above them. Fade in the group of ellipses and text. Show the green intersection of the ellipses with the label \"Intersection\" above it. Display the orange union of the ellipses with the label \"Union\" above it. Show the yellow exclusion of the ellipses with the label \"Exclusion\" above it. Display the pink difference of the ellipses with the label \"Difference\" above it."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "cnn_max_pool.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork([\n            ImageLayer(image),\n            Convolutional2DLayer(1, 8),\n            MaxPooling2DLayer(kernel_size=2),\n            Convolutional2DLayer(3, 2, 3),\n        ])\n        # Play the animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        font=\"Monospace\",\n        background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.4)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(3, 2, 3, filter_spacing=0.32),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        Group(code, nn).move_to(ORIGIN)\n        self.add(code)\n        self.wait(5)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "cnn_max_pool.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that cnn_max_pool.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork([\n            ImageLayer(image),\n            Convolutional2DLayer(1, 8),\n            MaxPooling2DLayer(kernel_size=2),\n            Convolutional2DLayer(3, 2, 3),\n        ])\n        # Play the animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        font=\"Monospace\",\n        background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.4)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(3, 2, 3, filter_spacing=0.32),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        Group(code, nn).move_to(ORIGIN)\n        self.add(code)\n        self.wait(5)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "cnn_max_pool.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the word \"Hello\" in large font with a smooth gradient transitioning from red to blue to green across the text."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GradientExample(Scene):\n    def construct(self):\n        t = Text(\"Hello\", gradient=(RED, BLUE, GREEN), font_size=96)\n        self.add(t)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \"Hello\" in large font with a smooth gradient transitioning from red to blue to green across the text."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the word \"hello\" in large font with a smooth gradient transitioning from red to blue to green across the text."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GradientExample(Scene):\n    def construct(self):\n        t = Text(\"Hello\", gradient=(RED, BLUE, GREEN), font_size=96)\n        self.add(t)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \"Hello\" in large font with a smooth gradient transitioning from red to blue to green across the text."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can the cohomology of Harish-Chandra modules provide insights into the structure of representations of real reductive Lie groups?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarishChandraModules(Scene):\n    def construct(self):\n        # Introduction with mathematical tapestry\n        title = Text(\"Unearthing Hidden Symmetries\", font_size=36).to_edge(UP)\n        subtitle = Text(\"in Harish-Chandra Modules\", font_size=28).next_to(title, DOWN)\n        \n        # Create a simple tapestry representation\n        tapestry = VGroup()\n        for i in range(-3, 4):\n            h_line = Line([-3, i, 0], [3, i, 0], color=BLUE_B)\n            v_line = Line([i, -3, 0], [i, 3, 0], color=GOLD)\n            tapestry.add(h_line, v_line)\n        \n        self.play(Write(title), Write(subtitle))\n        self.play(Create(tapestry), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle), FadeOut(tapestry))\n        \n        # Create nodes and connections (Harish-Chandra modules)\n        nodes = VGroup()\n        connections = VGroup()\n        \n        # Create 5 nodes in a circular arrangement\n        for i in range(5):\n            angle = i * TAU / 5\n            node = Circle(radius=0.3, color=BLUE).move_to([2.5 * np.cos(angle), 2 * np.sin(angle), 0])\n            nodes.add(node)\n        \n        # Create initial connections\n        for i, j in [(0, 2), (1, 3), (2, 4)]:\n            connection = Line(nodes[i].get_center(), nodes[j].get_center(), color=GOLD)\n            connections.add(connection)\n        \n        self.play(Create(nodes), run_time=1)\n        self.play(Create(connections), run_time=1)\n        self.wait(1)\n        \n        # Show the cohomology equation\n        cohomology_eq = Text(\"Cohomology: H^q(g,K;V)\", font_size=28).to_edge(UP)\n        self.play(Write(cohomology_eq))\n        self.wait(1)\n        \n        # Magnifying glass animation\n        magnifying_glass = VGroup(\n            Circle(radius=0.6, color=WHITE, fill_opacity=0.2),\n            Line([-0.4, -0.4, 0], [-0.8, -0.8, 0], color=WHITE)\n        ).move_to(nodes[0].get_center())\n        \n        self.play(Create(magnifying_glass))\n        \n        # Move magnifying glass to reveal hidden connections\n        self.play(magnifying_glass.animate.move_to(nodes[1].get_center()))\n        new_connection1 = Line(nodes[0].get_center(), nodes[1].get_center(), color=BLUE_D)\n        self.play(Create(new_connection1))\n        \n        self.play(magnifying_glass.animate.move_to(nodes[3].get_center()))\n        new_connection2 = Line(nodes[1].get_center(), nodes[4].get_center(), color=BLUE_D)\n        self.play(Create(new_connection2))\n        \n        self.play(FadeOut(magnifying_glass))\n        \n        # Show derived functors equation\n        derived_eq = Text(\"Derived functors: R^i(\u0393)\", font_size=28).next_to(cohomology_eq, DOWN)\n        self.play(Write(derived_eq))\n        self.wait(1)\n        \n        # Highlight invariant elements as glowing nodes\n        highlighted_nodes = VGroup()\n        for i in [0, 3]:\n            highlight = Circle(radius=0.4, color=GOLD, fill_opacity=0.5).move_to(nodes[i].get_center())\n            highlighted_nodes.add(highlight)\n        \n        self.play(Create(highlighted_nodes))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Hidden symmetries revealed\", font_size=32).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            FadeOut(nodes), \n            FadeOut(connections), \n            FadeOut(new_connection1),\n            FadeOut(new_connection2),\n            FadeOut(highlighted_nodes),\n            FadeOut(cohomology_eq),\n            FadeOut(derived_eq),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can the cohomology of Harish-Chandra modules provide insights into the structure of representations of real reductive Lie groups?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can the cohomology of harish-chandra modules provide insights into the structure of representations of real reductive lie groups?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarishChandraModules(Scene):\n    def construct(self):\n        # Introduction with mathematical tapestry\n        title = Text(\"Unearthing Hidden Symmetries\", font_size=36).to_edge(UP)\n        subtitle = Text(\"in Harish-Chandra Modules\", font_size=28).next_to(title, DOWN)\n        \n        # Create a simple tapestry representation\n        tapestry = VGroup()\n        for i in range(-3, 4):\n            h_line = Line([-3, i, 0], [3, i, 0], color=BLUE_B)\n            v_line = Line([i, -3, 0], [i, 3, 0], color=GOLD)\n            tapestry.add(h_line, v_line)\n        \n        self.play(Write(title), Write(subtitle))\n        self.play(Create(tapestry), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle), FadeOut(tapestry))\n        \n        # Create nodes and connections (Harish-Chandra modules)\n        nodes = VGroup()\n        connections = VGroup()\n        \n        # Create 5 nodes in a circular arrangement\n        for i in range(5):\n            angle = i * TAU / 5\n            node = Circle(radius=0.3, color=BLUE).move_to([2.5 * np.cos(angle), 2 * np.sin(angle), 0])\n            nodes.add(node)\n        \n        # Create initial connections\n        for i, j in [(0, 2), (1, 3), (2, 4)]:\n            connection = Line(nodes[i].get_center(), nodes[j].get_center(), color=GOLD)\n            connections.add(connection)\n        \n        self.play(Create(nodes), run_time=1)\n        self.play(Create(connections), run_time=1)\n        self.wait(1)\n        \n        # Show the cohomology equation\n        cohomology_eq = Text(\"Cohomology: H^q(g,K;V)\", font_size=28).to_edge(UP)\n        self.play(Write(cohomology_eq))\n        self.wait(1)\n        \n        # Magnifying glass animation\n        magnifying_glass = VGroup(\n            Circle(radius=0.6, color=WHITE, fill_opacity=0.2),\n            Line([-0.4, -0.4, 0], [-0.8, -0.8, 0], color=WHITE)\n        ).move_to(nodes[0].get_center())\n        \n        self.play(Create(magnifying_glass))\n        \n        # Move magnifying glass to reveal hidden connections\n        self.play(magnifying_glass.animate.move_to(nodes[1].get_center()))\n        new_connection1 = Line(nodes[0].get_center(), nodes[1].get_center(), color=BLUE_D)\n        self.play(Create(new_connection1))\n        \n        self.play(magnifying_glass.animate.move_to(nodes[3].get_center()))\n        new_connection2 = Line(nodes[1].get_center(), nodes[4].get_center(), color=BLUE_D)\n        self.play(Create(new_connection2))\n        \n        self.play(FadeOut(magnifying_glass))\n        \n        # Show derived functors equation\n        derived_eq = Text(\"Derived functors: R^i(\u0393)\", font_size=28).next_to(cohomology_eq, DOWN)\n        self.play(Write(derived_eq))\n        self.wait(1)\n        \n        # Highlight invariant elements as glowing nodes\n        highlighted_nodes = VGroup()\n        for i in [0, 3]:\n            highlight = Circle(radius=0.4, color=GOLD, fill_opacity=0.5).move_to(nodes[i].get_center())\n            highlighted_nodes.add(highlight)\n        \n        self.play(Create(highlighted_nodes))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Hidden symmetries revealed\", font_size=32).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            FadeOut(nodes), \n            FadeOut(connections), \n            FadeOut(new_connection1),\n            FadeOut(new_connection2),\n            FadeOut(highlighted_nodes),\n            FadeOut(cohomology_eq),\n            FadeOut(derived_eq),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can the cohomology of Harish-Chandra modules provide insights into the structure of representations of real reductive Lie groups?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation showing a chemical reaction where an electron transforms into an oxygen molecule, and then further changes into a metal oxide compound with the formula M2O3. The electron should first appear, then after a short pause morph into the oxygen molecule, followed by another pause before it changes into the metal oxide. There should be a brief moment to view the metal oxide before it all fades away from the screen. Can you design this simple chemistry-based transformation animation for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SineWaveExample(Scene):\n    def construct(self):\n        equation = MathTex(r\"\\sin(x) = y\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        text = Text(\"The graph of a sine function\", font_size=24).to_edge(UP)\n        self.play(Write(text))\n        self.wait(2)\n\n        # Create a sine curve\n        graph = self.get_graph(lambda x: np.sin(x), color=BLUE)\n        self.play(Create(graph))\n        self.wait(2)\n\n        new_text = Text(\"Sine waves have a periodic nature\", font_size=24).to_edge(UP)\n        self.play(Transform(text, new_text))\n        self.wait(2)\n\n        amplitude_text = Text(\"Amplitude: 1, Period: \\(2\\pi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(text, amplitude_text))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(equation))\n        self.wait(1)\n\n    def get_graph(self, function, color):\n        return FunctionGraph(function, color=color, x_range=[-PI, PI])\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation showing a chemical reaction where an electron transforms into an oxygen molecule, and then further changes into a metal oxide compound with the formula M2O3. The electron should first appear, then after a short pause morph into the oxygen molecule, followed by another pause before it changes into the metal oxide. There should be a brief moment to view the metal oxide before it all fades away from the screen. Can you design this simple chemistry-based transformation animation for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation showing a chemical reaction where an electron transforms into an oxygen molecule, and then further changes into a metal oxide compound with the formula m2o3. the electron should first appear, then after a short pause morph into the oxygen molecule, followed by another pause before it changes into the metal oxide. there should be a brief moment to view the metal oxide before it all fades away from the screen. can you design this simple chemistry-based transformation animation for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SineWaveExample(Scene):\n    def construct(self):\n        equation = MathTex(r\"\\sin(x) = y\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        text = Text(\"The graph of a sine function\", font_size=24).to_edge(UP)\n        self.play(Write(text))\n        self.wait(2)\n\n        # Create a sine curve\n        graph = self.get_graph(lambda x: np.sin(x), color=BLUE)\n        self.play(Create(graph))\n        self.wait(2)\n\n        new_text = Text(\"Sine waves have a periodic nature\", font_size=24).to_edge(UP)\n        self.play(Transform(text, new_text))\n        self.wait(2)\n\n        amplitude_text = Text(\"Amplitude: 1, Period: \\(2\\pi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(text, amplitude_text))\n        self.wait(2)\n\n        self.clear()\n        self.wait(1)\n        self.play(Write(equation))\n        self.wait(1)\n\n    def get_graph(self, function, color):\n        return FunctionGraph(function, color=color, x_range=[-PI, PI])\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation showing a chemical reaction where an electron transforms into an oxygen molecule, and then further changes into a metal oxide compound with the formula M2O3. The electron should first appear, then after a short pause morph into the oxygen molecule, followed by another pause before it changes into the metal oxide. There should be a brief moment to view the metal oxide before it all fades away from the screen. Can you design this simple chemistry-based transformation animation for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a line of Arabic text with each character or diacritic styled in different colors: the first character \"\u0627\" in purple, followed by red, blue, and green diacritics and letters forming the word \"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\" with colorful emphasis on pronunciation marks. The entire text is centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MarkupElaborateExample(Scene):\n    def construct(self):\n        text = MarkupText(\n            '<span foreground=\"purple\">\u0627</span><span foreground=\"red\">\u064e</span>'\n            '\u0644<span foreground=\"blue\">\u0652</span>\u0639<span foreground=\"red\">\u064e</span>\u0631'\n            '<span foreground=\"red\">\u064e</span>\u0628<span foreground=\"red\">\u0650</span>\u064a'\n            '<span foreground=\"green\">\u0651</span><span foreground=\"red\">\u064e</span>\u0629'\n            '<span foreground=\"blue\">\u064f</span>'\n        )\n        self.add(text)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a line of Arabic text with each character or diacritic styled in different colors: the first character \"\u0627\" in purple, followed by red, blue, and green diacritics and letters forming the word \"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\" with colorful emphasis on pronunciation marks. The entire text is centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a line of arabic text with each character or diacritic styled in different colors: the first character \"\u0627\" in purple, followed by red, blue, and green diacritics and letters forming the word \"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\" with colorful emphasis on pronunciation marks. the entire text is centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MarkupElaborateExample(Scene):\n    def construct(self):\n        text = MarkupText(\n            '<span foreground=\"purple\">\u0627</span><span foreground=\"red\">\u064e</span>'\n            '\u0644<span foreground=\"blue\">\u0652</span>\u0639<span foreground=\"red\">\u064e</span>\u0631'\n            '<span foreground=\"red\">\u064e</span>\u0628<span foreground=\"red\">\u0650</span>\u064a'\n            '<span foreground=\"green\">\u0651</span><span foreground=\"red\">\u064e</span>\u0629'\n            '<span foreground=\"blue\">\u064f</span>'\n        )\n        self.add(text)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a line of Arabic text with each character or diacritic styled in different colors: the first character \"\u0627\" in purple, followed by red, blue, and green diacritics and letters forming the word \"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\" with colorful emphasis on pronunciation marks. The entire text is centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can a semidirect product be used to model symmetries of a 3-dimensional object?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SemidirectProductSymmetries(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Symmetries with Semidirect Products\", color=WHITE).scale(0.7)\n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction: Symmetries in 3D objects\n        intro_text = Text(\"Symmetries in 3D objects\", color=WHITE).scale(0.6)\n        self.play(Write(intro_text))\n        self.wait(0.5)\n        self.play(FadeOut(intro_text))\n        \n        # Key Concept 1: Rotations (Group G)\n        sphere = Circle(radius=1.5, color=BLUE)\n        self.play(Create(sphere))\n        \n        rotation_arrow = Arrow(start=ORIGIN, end=UP, color=YELLOW)\n        self.play(Create(rotation_arrow))\n        \n        rotation_text = Text(\"Rotations (Group G)\", color=YELLOW).scale(0.6).next_to(sphere, DOWN)\n        self.play(Write(rotation_text))\n        self.play(Rotate(rotation_arrow, angle=PI, about_point=ORIGIN))\n        \n        # Key Concept 2: Reflections (Group H)\n        reflection_line = Line(start=sphere.get_center() + LEFT*2, end=sphere.get_center() + RIGHT*2, color=RED)\n        self.play(Create(reflection_line))\n        \n        reflection_text = Text(\"Reflections (Group H)\", color=RED).scale(0.6).next_to(rotation_text, DOWN)\n        self.play(Write(reflection_text))\n        self.wait(0.5)\n        \n        # Clean up visual elements\n        self.play(FadeOut(rotation_arrow, reflection_line))\n        \n        # Key Concept 3: Semidirect Product\n        semidirect_text = Text(\"G \u22ca H\", color=WHITE).scale(0.8)\n        self.play(Write(semidirect_text))\n        self.play(semidirect_text.animate.to_corner(UL).shift(RIGHT+DOWN))\n        \n        # Add the operation equation\n        operation_text = Text(\"gh = g\u00b7\u03c6(h)\", color=WHITE).scale(0.7)\n        self.play(Write(operation_text))\n        self.play(operation_text.animate.next_to(semidirect_text, DOWN).align_to(semidirect_text, LEFT))\n        \n        explanation_text = Text(\"Where \u03c6 represents how G acts on H\", color=WHITE).scale(0.5)\n        self.play(Write(explanation_text))\n        self.play(explanation_text.animate.next_to(operation_text, DOWN).align_to(operation_text, LEFT))\n        \n        # Key Insight: Polyhedra symmetries\n        cube = Square(side_length=1.5, color=GREEN).shift(RIGHT*3)  # Representing a cube with a square for simplicity\n        self.play(Create(cube))\n        \n        insight_text = Text(\"3D Object Symmetries\", color=GREEN).scale(0.6).next_to(cube, DOWN)\n        self.play(Write(insight_text))\n        \n        # Show rotation symmetry\n        self.play(Rotate(cube, angle=PI/2, about_point=cube.get_center()))\n        self.wait(0.3)\n        \n        # Show reflection symmetry (by scaling negatively in x-direction)\n        self.play(cube.animate.scale([-1, 1, 1]))\n        self.wait(0.5)\n        \n        # Clean up for conclusion\n        self.play(FadeOut(sphere, rotation_text, reflection_text, semidirect_text, \n                          operation_text, explanation_text, cube, insight_text))\n        self.wait(0.5)\n        \n        # Conclusion\n        conclusion_text = Text(\"Semidirect products model symmetries\", color=WHITE).scale(0.7)\n        self.play(Write(conclusion_text))\n        \n        final_text = Text(\"by combining rotations and reflections\", color=YELLOW).scale(0.6)\n        self.play(Write(final_text.next_to(conclusion_text, DOWN)))\n        self.wait(1)\n        \n        # Fade out everything\n        self.play(FadeOut(title, conclusion_text, final_text))\n        self.wait(0.5)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can a semidirect product be used to model symmetries of a 3-dimensional object?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can a semidirect product be used to model symmetries of a 3-dimensional object?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SemidirectProductSymmetries(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Symmetries with Semidirect Products\", color=WHITE).scale(0.7)\n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction: Symmetries in 3D objects\n        intro_text = Text(\"Symmetries in 3D objects\", color=WHITE).scale(0.6)\n        self.play(Write(intro_text))\n        self.wait(0.5)\n        self.play(FadeOut(intro_text))\n        \n        # Key Concept 1: Rotations (Group G)\n        sphere = Circle(radius=1.5, color=BLUE)\n        self.play(Create(sphere))\n        \n        rotation_arrow = Arrow(start=ORIGIN, end=UP, color=YELLOW)\n        self.play(Create(rotation_arrow))\n        \n        rotation_text = Text(\"Rotations (Group G)\", color=YELLOW).scale(0.6).next_to(sphere, DOWN)\n        self.play(Write(rotation_text))\n        self.play(Rotate(rotation_arrow, angle=PI, about_point=ORIGIN))\n        \n        # Key Concept 2: Reflections (Group H)\n        reflection_line = Line(start=sphere.get_center() + LEFT*2, end=sphere.get_center() + RIGHT*2, color=RED)\n        self.play(Create(reflection_line))\n        \n        reflection_text = Text(\"Reflections (Group H)\", color=RED).scale(0.6).next_to(rotation_text, DOWN)\n        self.play(Write(reflection_text))\n        self.wait(0.5)\n        \n        # Clean up visual elements\n        self.play(FadeOut(rotation_arrow, reflection_line))\n        \n        # Key Concept 3: Semidirect Product\n        semidirect_text = Text(\"G \u22ca H\", color=WHITE).scale(0.8)\n        self.play(Write(semidirect_text))\n        self.play(semidirect_text.animate.to_corner(UL).shift(RIGHT+DOWN))\n        \n        # Add the operation equation\n        operation_text = Text(\"gh = g\u00b7\u03c6(h)\", color=WHITE).scale(0.7)\n        self.play(Write(operation_text))\n        self.play(operation_text.animate.next_to(semidirect_text, DOWN).align_to(semidirect_text, LEFT))\n        \n        explanation_text = Text(\"Where \u03c6 represents how G acts on H\", color=WHITE).scale(0.5)\n        self.play(Write(explanation_text))\n        self.play(explanation_text.animate.next_to(operation_text, DOWN).align_to(operation_text, LEFT))\n        \n        # Key Insight: Polyhedra symmetries\n        cube = Square(side_length=1.5, color=GREEN).shift(RIGHT*3)  # Representing a cube with a square for simplicity\n        self.play(Create(cube))\n        \n        insight_text = Text(\"3D Object Symmetries\", color=GREEN).scale(0.6).next_to(cube, DOWN)\n        self.play(Write(insight_text))\n        \n        # Show rotation symmetry\n        self.play(Rotate(cube, angle=PI/2, about_point=cube.get_center()))\n        self.wait(0.3)\n        \n        # Show reflection symmetry (by scaling negatively in x-direction)\n        self.play(cube.animate.scale([-1, 1, 1]))\n        self.wait(0.5)\n        \n        # Clean up for conclusion\n        self.play(FadeOut(sphere, rotation_text, reflection_text, semidirect_text, \n                          operation_text, explanation_text, cube, insight_text))\n        self.wait(0.5)\n        \n        # Conclusion\n        conclusion_text = Text(\"Semidirect products model symmetries\", color=WHITE).scale(0.7)\n        self.play(Write(conclusion_text))\n        \n        final_text = Text(\"by combining rotations and reflections\", color=YELLOW).scale(0.6)\n        self.play(Write(final_text.next_to(conclusion_text, DOWN)))\n        self.wait(1)\n        \n        # Fade out everything\n        self.play(FadeOut(title, conclusion_text, final_text))\n        self.wait(0.5)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can a semidirect product be used to model symmetries of a 3-dimensional object?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a polar coordinate grid with a size of 6 units. The azimuth (angle) labels are shown in terms of \u03c0 radians, and both the angle and radius labels are styled with a larger font size for clarity. Coordinate labels are added to enhance readability of the polar layout."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolarPlaneExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(\n            azimuth_units=\"PI radians\",\n            size=6,\n            azimuth_label_font_size=33.6,\n            radius_config={\"font_size\": 33.6},\n        ).add_coordinates()\n        self.add(polarplane_pi)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a polar coordinate grid with a size of 6 units. The azimuth (angle) labels are shown in terms of \u03c0 radians, and both the angle and radius labels are styled with a larger font size for clarity. Coordinate labels are added to enhance readability of the polar layout."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a polar coordinate grid with a size of 6 units. the azimuth (angle) labels are shown in terms of \u03c0 radians, and both the angle and radius labels are styled with a larger font size for clarity. coordinate labels are added to enhance readability of the polar layout."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolarPlaneExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(\n            azimuth_units=\"PI radians\",\n            size=6,\n            azimuth_label_font_size=33.6,\n            radius_config={\"font_size\": 33.6},\n        ).add_coordinates()\n        self.add(polarplane_pi)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a polar coordinate grid with a size of 6 units. The azimuth (angle) labels are shown in terms of \u03c0 radians, and both the angle and radius labels are styled with a larger font size for clarity. Coordinate labels are added to enhance readability of the polar layout."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Set the background color to white. Display a red square, then animate it transforming into a slightly rotated red rectangle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleTransform(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1 = Square().set_color(RED)\n        m2 = Rectangle().set_color(RED).rotate(0.2)\n        self.play(Transform(m1,m2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Set the background color to white. Display a red square, then animate it transforming into a slightly rotated red rectangle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that set the background color to white. display a red square, then animate it transforming into a slightly rotated red rectangle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleTransform(Scene):\n    def construct(self):\n        self.camera.background_color = WHITE\n        m1 = Square().set_color(RED)\n        m2 = Rectangle().set_color(RED).rotate(0.2)\n        self.play(Transform(m1,m2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Set the background color to white. Display a red square, then animate it transforming into a slightly rotated red rectangle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display three shape pairs arranged horizontally:  \n- On the left, a triangle is tightly surrounded by a circle.  \n- In the center, a line is loosely enclosed by a larger circle with extra spacing.  \n- On the right, a square is enclosed by a smaller circle due to a reduced buffer, making the circle fit snugly inside the square."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CircleSurround(Scene):\n    def construct(self):\n        triangle1 = Triangle()\n        circle1 = Circle().surround(triangle1)\n        group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n        line2 = Line()\n        circle2 = Circle().surround(line2, buffer_factor=2.0)\n        group2 = Group(line2,circle2)\n\n        # buffer_factor < 1, so the circle is smaller than the square\n        square3 = Square()\n        circle3 = Circle().surround(square3, buffer_factor=0.5)\n        group3 = Group(square3, circle3)\n\n        group = Group(group1, group2, group3).arrange(buff=1)\n        self.add(group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display three shape pairs arranged horizontally:  \n- On the left, a triangle is tightly surrounded by a circle.  \n- In the center, a line is loosely enclosed by a larger circle with extra spacing.  \n- On the right, a square is enclosed by a smaller circle due to a reduced buffer, making the circle fit snugly inside the square."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display three shape pairs arranged horizontally:  \n- on the left, a triangle is tightly surrounded by a circle.  \n- in the center, a line is loosely enclosed by a larger circle with extra spacing.  \n- on the right, a square is enclosed by a smaller circle due to a reduced buffer, making the circle fit snugly inside the square."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CircleSurround(Scene):\n    def construct(self):\n        triangle1 = Triangle()\n        circle1 = Circle().surround(triangle1)\n        group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n        line2 = Line()\n        circle2 = Circle().surround(line2, buffer_factor=2.0)\n        group2 = Group(line2,circle2)\n\n        # buffer_factor < 1, so the circle is smaller than the square\n        square3 = Square()\n        circle3 = Circle().surround(square3, buffer_factor=0.5)\n        group3 = Group(square3, circle3)\n\n        group = Group(group1, group2, group3).arrange(buff=1)\n        self.add(group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display three shape pairs arranged horizontally:  \n- On the left, a triangle is tightly surrounded by a circle.  \n- In the center, a line is loosely enclosed by a larger circle with extra spacing.  \n- On the right, a square is enclosed by a smaller circle due to a reduced buffer, making the circle fit snugly inside the square."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "variational_autoencoder.py"}, {"from": "assistant", "value": "```python\n\"\"\"Autoencoder Manim Visualizations\n\nIn this module I define Manim visualizations for Variational Autoencoders\nand Traditional Autoencoders.\n\n\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\nimport numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import EmbeddingLayer\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.layers import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass VAEScene(Scene):\n    \"\"\"Scene object for a Variational Autoencoder and Autoencoder\"\"\"\n\n    def construct(self):\n        numpy_image = np.asarray(Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\"))\n        vae = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(dist_theme=\"ellipse\"),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.4),\n            ]\n        )\n\n        self.play(Create(vae))\n        self.play(vae.make_forward_pass_animation(run_time=15))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "variational_autoencoder.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that variational_autoencoder.py"}, {"from": "assistant", "value": "```python\n\"\"\"Autoencoder Manim Visualizations\n\nIn this module I define Manim visualizations for Variational Autoencoders\nand Traditional Autoencoders.\n\n\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\nimport numpy as np\nfrom PIL import Image\nfrom manim_ml.neural_network.layers import EmbeddingLayer\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.layers import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass VAEScene(Scene):\n    \"\"\"Scene object for a Variational Autoencoder and Autoencoder\"\"\"\n\n    def construct(self):\n        numpy_image = np.asarray(Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\"))\n        vae = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                EmbeddingLayer(dist_theme=\"ellipse\"),\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n                ImageLayer(numpy_image, height=1.4),\n            ]\n        )\n\n        self.play(Create(vae))\n        self.play(vae.make_forward_pass_animation(run_time=15))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "variational_autoencoder.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a complex plane with a red point cloud dot centered on it. After a brief pause, animate the dot as it transforms according to the complex exponential function \\( f(z) = e^z \\), creating a dynamic visual effect that warps the dot's shape across the plane."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PointCloudDotExample2(Scene):\n    def construct(self):\n        plane = ComplexPlane()\n        cloud = PointCloudDot(color=RED)\n        self.add(\n            plane, cloud\n        )\n        self.wait()\n        self.play(\n            cloud.animate.apply_complex_function(lambda z: np.exp(z))\n        )\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a complex plane with a red point cloud dot centered on it. After a brief pause, animate the dot as it transforms according to the complex exponential function \\( f(z) = e^z \\), creating a dynamic visual effect that warps the dot's shape across the plane."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a complex plane with a red point cloud dot centered on it. after a brief pause, animate the dot as it transforms according to the complex exponential function \\( f(z) = e^z \\), creating a dynamic visual effect that warps the dot's shape across the plane."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PointCloudDotExample2(Scene):\n    def construct(self):\n        plane = ComplexPlane()\n        cloud = PointCloudDot(color=RED)\n        self.add(\n            plane, cloud\n        )\n        self.wait()\n        self.play(\n            cloud.animate.apply_complex_function(lambda z: np.exp(z))\n        )\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a complex plane with a red point cloud dot centered on it. After a brief pause, animate the dot as it transforms according to the complex exponential function \\( f(z) = e^z \\), creating a dynamic visual effect that warps the dot's shape across the plane."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a solid red square on the left and a solid blue circle overlapping it from the top right. On the right side of the screen, show a green shape representing the union\u2014combining the full areas of both the square and the circle into a single merged shape."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UnionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Union(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0.3, 0])\n        self.add(sq, cr, un)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a solid red square on the left and a solid blue circle overlapping it from the top right. On the right side of the screen, show a green shape representing the union\u2014combining the full areas of both the square and the circle into a single merged shape."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a solid red square on the left and a solid blue circle overlapping it from the top right. on the right side of the screen, show a green shape representing the union\u2014combining the full areas of both the square and the circle into a single merged shape."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UnionExample(Scene):\n    def construct(self):\n        sq = Square(color=RED, fill_opacity=1)\n        sq.move_to([-2, 0, 0])\n        cr = Circle(color=BLUE, fill_opacity=1)\n        cr.move_to([-1.3, 0.7, 0])\n        un = Union(sq, cr, color=GREEN, fill_opacity=1)\n        un.move_to([1.5, 0.3, 0])\n        self.add(sq, cr, un)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a solid red square on the left and a solid blue circle overlapping it from the top right. On the right side of the screen, show a green shape representing the union\u2014combining the full areas of both the square and the circle into a single merged shape."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "image_nn_code_snippet.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass ImageNeuralNetworkScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make image object\n            image = Image.open('images/image.jpeg')\n            numpy_image = np.asarray(image)\n            # Make Neural Network\n            layers = [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(3), \n                FeedForwardLayer(5),\n                FeedForwardLayer(3)\n            ]\n            nn = NeuralNetwork(layers)\n            self.add(nn)\n            # Play animation\n            self.play(\n                nn.make_forward_pass_animation()\n            )\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            background_stroke_color=WHITE,\n            insert_line_no=False,\n            style=\"monokai\",\n            # background=\"window\",\n            language=\"py\",\n        )\n        code.scale(0.2)\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        layers = [\n            ImageLayer(numpy_image, height=1.4),\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(3),\n            FeedForwardLayer(6),\n        ]\n        nn = NeuralNetwork(layers)\n        nn.scale(0.9)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.rotate(-PI / 2)\n        nn.layers[0].image_mobject.rotate(PI / 2)\n        nn.layers[0].image_mobject.shift([0, -0.4, 0])\n        nn.shift([1.5, 0.3, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(1.9)\n        code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(run_time=10))\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Feed Forward Neural Network\n    ffnn_scene = FeedForwardNeuralNetworkScene()\n    ffnn_scene.render()\n    # Neural Network\n    nn_scene = NeuralNetworkScene()\n    nn_scene.render()\n```"}], "metadata": {"source": "thanks-manim", "original_description": "image_nn_code_snippet.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that image_nn_code_snippet.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer, ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass ImageNeuralNetworkScene(Scene):\n    def make_code_snippet(self):\n        code_str = \"\"\"\n            # Make image object\n            image = Image.open('images/image.jpeg')\n            numpy_image = np.asarray(image)\n            # Make Neural Network\n            layers = [\n                ImageLayer(numpy_image, height=1.4),\n                FeedForwardLayer(3), \n                FeedForwardLayer(5),\n                FeedForwardLayer(3)\n            ]\n            nn = NeuralNetwork(layers)\n            self.add(nn)\n            # Play animation\n            self.play(\n                nn.make_forward_pass_animation()\n            )\n        \"\"\"\n\n        code = Code(\n            code=code_str,\n            tab_width=4,\n            background_stroke_width=1,\n            background_stroke_color=WHITE,\n            insert_line_no=False,\n            style=\"monokai\",\n            # background=\"window\",\n            language=\"py\",\n        )\n        code.scale(0.2)\n\n        return code\n\n    def construct(self):\n        image = Image.open(\"../../tests/images/image.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        layers = [\n            ImageLayer(numpy_image, height=1.4),\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(3),\n            FeedForwardLayer(6),\n        ]\n        nn = NeuralNetwork(layers)\n        nn.scale(0.9)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.rotate(-PI / 2)\n        nn.layers[0].image_mobject.rotate(PI / 2)\n        nn.layers[0].image_mobject.shift([0, -0.4, 0])\n        nn.shift([1.5, 0.3, 0])\n        self.add(nn)\n        # Make code snippet\n        code_snippet = self.make_code_snippet()\n        code_snippet.scale(1.9)\n        code_snippet.shift([-1.25, 0, 0])\n        self.add(code_snippet)\n        # Play animation\n        self.play(nn.make_forward_pass_animation(run_time=10))\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    # Feed Forward Neural Network\n    ffnn_scene = FeedForwardNeuralNetworkScene()\n    ffnn_scene.render()\n    # Neural Network\n    nn_scene = NeuralNetworkScene()\n    nn_scene.render()\n```"}], "metadata": {"source": "thanks-manim", "original_description": "image_nn_code_snippet.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually explains the wave equation and its solutions, including d'Alembert's formula? The animation should introduce the classic wave equation, show the general solution form, emphasize the role of arbitrary functions determined by initial conditions, and conclude with d'Alembert's formula as a special solution, while also highlighting what phenomena the wave equation models. Please include textual explanations alongside the mathematical expressions and ensure there are transitions between each step of the explanation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AnotherScene(Scene):\n    def construct(self):\n        square = Square(color=BLUE)\n        square.rotate(PI / 4)\n        self.play(Create(square))\n        self.wait(1)\n        self.play(Transform(square, Circle()))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually explains the wave equation and its solutions, including d'Alembert's formula? The animation should introduce the classic wave equation, show the general solution form, emphasize the role of arbitrary functions determined by initial conditions, and conclude with d'Alembert's formula as a special solution, while also highlighting what phenomena the wave equation models. Please include textual explanations alongside the mathematical expressions and ensure there are transitions between each step of the explanation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually explains the wave equation and its solutions, including d'alembert's formula? the animation should introduce the classic wave equation, show the general solution form, emphasize the role of arbitrary functions determined by initial conditions, and conclude with d'alembert's formula as a special solution, while also highlighting what phenomena the wave equation models. please include textual explanations alongside the mathematical expressions and ensure there are transitions between each step of the explanation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AnotherScene(Scene):\n    def construct(self):\n        square = Square(color=BLUE)\n        square.rotate(PI / 4)\n        self.play(Create(square))\n        self.wait(1)\n        self.play(Transform(square, Circle()))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually explains the wave equation and its solutions, including d'Alembert's formula? The animation should introduce the classic wave equation, show the general solution form, emphasize the role of arbitrary functions determined by initial conditions, and conclude with d'Alembert's formula as a special solution, while also highlighting what phenomena the wave equation models. Please include textual explanations alongside the mathematical expressions and ensure there are transitions between each step of the explanation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation using a Python-based library that graphically demonstrates the following mathematical concepts? I would like a two-dimensional graph with axes ranging from -3 to 3 on both the x and y-axes. On this graph, please plot the cubic function f(x) = (x+2)x(x-2)/2 where x is between -3 and 3, and have the function's line shown in red. Afterward, I'd like to highlight the area under the curve between x = -2 and x = 0. The axes should appear first, and then the curve should be drawn gradually. Once the curve is fully drawn, the area under the curve should fade into view. Please ensure that the entire animation is smooth and has a reasonable duration for each step to enhance the educational value."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-4, 4])\n        curve = axes.plot(lambda x: x**3 - 3*x, color=GREEN)\n        line = axes.plot(lambda x: 3*x - 3, color=RED)\n        dot = Dot(color=ORANGE).move_to(axes.c2p(1, -2))\n\n        tangent = always_redraw(lambda: TangentLine(curve, alpha=dot.get_center()[0], length=4, color=ORANGE))\n        \n        self.play(Create(axes), Create(curve))\n        self.play(Create(line))\n        self.add(dot, tangent)\n        self.play(MoveAlongPath(dot, curve), run_time=4, rate_func=linear)\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation using a Python-based library that graphically demonstrates the following mathematical concepts? I would like a two-dimensional graph with axes ranging from -3 to 3 on both the x and y-axes. On this graph, please plot the cubic function f(x) = (x+2)x(x-2)/2 where x is between -3 and 3, and have the function's line shown in red. Afterward, I'd like to highlight the area under the curve between x = -2 and x = 0. The axes should appear first, and then the curve should be drawn gradually. Once the curve is fully drawn, the area under the curve should fade into view. Please ensure that the entire animation is smooth and has a reasonable duration for each step to enhance the educational value."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation using a python-based library that graphically demonstrates the following mathematical concepts? i would like a two-dimensional graph with axes ranging from -3 to 3 on both the x and y-axes. on this graph, please plot the cubic function f(x) = (x+2)x(x-2)/2 where x is between -3 and 3, and have the function's line shown in red. afterward, i'd like to highlight the area under the curve between x = -2 and x = 0. the axes should appear first, and then the curve should be drawn gradually. once the curve is fully drawn, the area under the curve should fade into view. please ensure that the entire animation is smooth and has a reasonable duration for each step to enhance the educational value."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-4, 4])\n        curve = axes.plot(lambda x: x**3 - 3*x, color=GREEN)\n        line = axes.plot(lambda x: 3*x - 3, color=RED)\n        dot = Dot(color=ORANGE).move_to(axes.c2p(1, -2))\n\n        tangent = always_redraw(lambda: TangentLine(curve, alpha=dot.get_center()[0], length=4, color=ORANGE))\n        \n        self.play(Create(axes), Create(curve))\n        self.play(Create(line))\n        self.add(dot, tangent)\n        self.play(MoveAlongPath(dot, curve), run_time=4, rate_func=linear)\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation using a Python-based library that graphically demonstrates the following mathematical concepts? I would like a two-dimensional graph with axes ranging from -3 to 3 on both the x and y-axes. On this graph, please plot the cubic function f(x) = (x+2)x(x-2)/2 where x is between -3 and 3, and have the function's line shown in red. Afterward, I'd like to highlight the area under the curve between x = -2 and x = 0. The axes should appear first, and then the curve should be drawn gradually. Once the curve is fully drawn, the area under the curve should fade into view. Please ensure that the entire animation is smooth and has a reasonable duration for each step to enhance the educational value."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the residue theorem illuminate the relationship between contour integrals over different complex plane regions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ResidueTheoremScene(Scene):\n    def construct(self):\n        # Create and display the title\n        title = Text(\"Illuminating Contours with the Residue Theorem\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Create complex plane with axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            x_length=6,\n            y_length=6,\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Label the axes for the complex plane\n        x_label = Text(\"Re\").next_to(axes.x_axis, RIGHT)\n        y_label = Text(\"Im\").next_to(axes.y_axis, UP)\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        \n        # Create and show singular points (poles/singularities)\n        singularity1 = Dot(axes.c2p(1, 1), color=RED)\n        singularity2 = Dot(axes.c2p(-1, -1), color=RED)\n        \n        self.play(Create(singularity1), Create(singularity2))\n        \n        # Draw a contour (closed path) that encircles both singularities\n        contour = Circle(radius=2, color=YELLOW).move_to(axes.c2p(0, 0))\n        \n        self.play(Create(contour))\n        \n        # Display the residue theorem equation\n        equation = MathTex(r\"\\oint_C f(z) \\, dz = 2\\pi i \\sum \\text{Res}(f, a_k)\")\n        equation.next_to(axes, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(2)\n        \n        # Show the key insight about the residue theorem\n        insight = Text(\"The integral depends on residues inside the contour\")\n        insight.scale(0.7).next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Fade all elements out to end the scene\n        self.play(\n            FadeOut(title), FadeOut(axes), FadeOut(x_label), FadeOut(y_label),\n            FadeOut(singularity1), FadeOut(singularity2), FadeOut(contour),\n            FadeOut(equation), FadeOut(insight)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the residue theorem illuminate the relationship between contour integrals over different complex plane regions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the residue theorem illuminate the relationship between contour integrals over different complex plane regions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ResidueTheoremScene(Scene):\n    def construct(self):\n        # Create and display the title\n        title = Text(\"Illuminating Contours with the Residue Theorem\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Create complex plane with axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            x_length=6,\n            y_length=6,\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Label the axes for the complex plane\n        x_label = Text(\"Re\").next_to(axes.x_axis, RIGHT)\n        y_label = Text(\"Im\").next_to(axes.y_axis, UP)\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        \n        # Create and show singular points (poles/singularities)\n        singularity1 = Dot(axes.c2p(1, 1), color=RED)\n        singularity2 = Dot(axes.c2p(-1, -1), color=RED)\n        \n        self.play(Create(singularity1), Create(singularity2))\n        \n        # Draw a contour (closed path) that encircles both singularities\n        contour = Circle(radius=2, color=YELLOW).move_to(axes.c2p(0, 0))\n        \n        self.play(Create(contour))\n        \n        # Display the residue theorem equation\n        equation = MathTex(r\"\\oint_C f(z) \\, dz = 2\\pi i \\sum \\text{Res}(f, a_k)\")\n        equation.next_to(axes, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(2)\n        \n        # Show the key insight about the residue theorem\n        insight = Text(\"The integral depends on residues inside the contour\")\n        insight.scale(0.7).next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Fade all elements out to end the scene\n        self.play(\n            FadeOut(title), FadeOut(axes), FadeOut(x_label), FadeOut(y_label),\n            FadeOut(singularity1), FadeOut(singularity2), FadeOut(contour),\n            FadeOut(equation), FadeOut(insight)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the residue theorem illuminate the relationship between contour integrals over different complex plane regions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What patterns emerge in the Euler's Totient Function when plotted for the sequence of natural numbers?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulersTotientFunction(Scene):\n    def construct(self):\n        # Set background color\n        self.camera.background_color = \"#0C1445\"  # Dark blue background\n        \n        # Introduction\n        title = Text(\"Unveiling Patterns: Euler's Totient Function\", color=ORANGE).scale(0.8)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        \n        # Definition\n        definition = Text(\"Euler's Totient Function \u03c6(n) counts numbers\\nless than n that are coprime to n\", color=WHITE).scale(0.6)\n        definition.next_to(title, DOWN, buff=0.5)\n        self.play(Write(definition))\n        self.wait(1)\n        \n        # Example with n=12\n        self.play(FadeOut(definition))\n        example_title = Text(\"Example: \u03c6(12)\", color=ORANGE).scale(0.7)\n        example_title.next_to(title, DOWN, buff=0.5)\n        self.play(Write(example_title))\n        \n        # Create grid of numbers 1 to 12\n        numbers = VGroup()\n        coprimes_to_12 = [1, 5, 7, 11]  # Numbers coprime to 12\n        \n        for i in range(1, 13):\n            color = ORANGE if i in coprimes_to_12 else WHITE\n            number = Text(str(i), color=color).scale(0.6)\n            row, col = divmod(i-1, 4)\n            number.move_to((col - 1.5) * RIGHT + (row - 0.5) * DOWN)\n            numbers.add(number)\n        \n        numbers.next_to(example_title, DOWN, buff=0.5)\n        self.play(Create(numbers))\n        \n        # Show result\n        result = Text(\"\u03c6(12) = 4\", color=ORANGE).scale(0.7)\n        result.next_to(numbers, DOWN, buff=0.5)\n        self.play(Write(result))\n        self.wait(1)\n        \n        # Clear for formula\n        self.play(FadeOut(example_title), FadeOut(numbers), FadeOut(result))\n        \n        # Show formula\n        formula = Text(\"\u03c6(12) = 12 \u00d7 (1-1/2) \u00d7 (1-1/3) = 4\", color=ORANGE).scale(0.6)\n        formula.next_to(title, DOWN, buff=1)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Clear for graph\n        self.play(FadeOut(formula))\n        \n        # Graph title\n        graph_title = Text(\"Patterns in \u03c6(n) for n = 1 to 20\", color=ORANGE).scale(0.7)\n        graph_title.next_to(title, DOWN, buff=0.5)\n        self.play(Write(graph_title))\n        \n        # Create axes\n        axes = Axes(\n            x_range=[0, 21, 5],\n            y_range=[0, 21, 5],\n            axis_config={\"color\": WHITE},\n        ).scale(0.7)\n        axes.next_to(graph_title, DOWN, buff=0.5)\n        \n        x_label = Text(\"n\", color=WHITE).scale(0.5)\n        x_label.next_to(axes.x_axis.get_end(), RIGHT, buff=0.2)\n        \n        y_label = Text(\"\u03c6(n)\", color=WHITE).scale(0.5)\n        y_label.next_to(axes.y_axis.get_end(), UP, buff=0.2)\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        \n        # Pre-computed \u03c6(n) values for n = 1 to 20\n        phi_values = [\n            1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8\n        ]\n        \n        # Plot points and connect them\n        dots = VGroup()\n        lines = VGroup()\n        \n        for n in range(1, 21):\n            dot = Dot(axes.c2p(n, phi_values[n-1]), color=ORANGE)\n            dots.add(dot)\n            \n            if n > 1:\n                line = Line(\n                    axes.c2p(n-1, phi_values[n-2]),\n                    axes.c2p(n, phi_values[n-1]),\n                    color=ORANGE\n                )\n                lines.add(line)\n        \n        self.play(Create(dots), Create(lines))\n        \n        # Highlight prime numbers\n        primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        prime_dots = VGroup()\n        \n        for p in primes:\n            prime_dot = Dot(axes.c2p(p, phi_values[p-1]), color=BLUE, radius=0.1)\n            prime_dots.add(prime_dot)\n        \n        prime_text = Text(\"For prime p, \u03c6(p) = p-1\", color=BLUE).scale(0.6)\n        prime_text.to_edge(DOWN, buff=1)\n        \n        self.play(Write(prime_text), Create(prime_dots))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph_title),\n            FadeOut(axes),\n            FadeOut(dots),\n            FadeOut(lines),\n            FadeOut(prime_text),\n            FadeOut(prime_dots),\n            FadeOut(x_label),\n            FadeOut(y_label)\n        )\n        \n        conclusion = Text(\n            \"Euler's Totient Function reveals beautiful\\npatterns in number theory\",\n            color=ORANGE\n        ).scale(0.7)\n        conclusion.next_to(title, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What patterns emerge in the Euler's Totient Function when plotted for the sequence of natural numbers?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what patterns emerge in the euler's totient function when plotted for the sequence of natural numbers?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulersTotientFunction(Scene):\n    def construct(self):\n        # Set background color\n        self.camera.background_color = \"#0C1445\"  # Dark blue background\n        \n        # Introduction\n        title = Text(\"Unveiling Patterns: Euler's Totient Function\", color=ORANGE).scale(0.8)\n        self.play(Write(title))\n        self.play(title.animate.to_edge(UP))\n        \n        # Definition\n        definition = Text(\"Euler's Totient Function \u03c6(n) counts numbers\\nless than n that are coprime to n\", color=WHITE).scale(0.6)\n        definition.next_to(title, DOWN, buff=0.5)\n        self.play(Write(definition))\n        self.wait(1)\n        \n        # Example with n=12\n        self.play(FadeOut(definition))\n        example_title = Text(\"Example: \u03c6(12)\", color=ORANGE).scale(0.7)\n        example_title.next_to(title, DOWN, buff=0.5)\n        self.play(Write(example_title))\n        \n        # Create grid of numbers 1 to 12\n        numbers = VGroup()\n        coprimes_to_12 = [1, 5, 7, 11]  # Numbers coprime to 12\n        \n        for i in range(1, 13):\n            color = ORANGE if i in coprimes_to_12 else WHITE\n            number = Text(str(i), color=color).scale(0.6)\n            row, col = divmod(i-1, 4)\n            number.move_to((col - 1.5) * RIGHT + (row - 0.5) * DOWN)\n            numbers.add(number)\n        \n        numbers.next_to(example_title, DOWN, buff=0.5)\n        self.play(Create(numbers))\n        \n        # Show result\n        result = Text(\"\u03c6(12) = 4\", color=ORANGE).scale(0.7)\n        result.next_to(numbers, DOWN, buff=0.5)\n        self.play(Write(result))\n        self.wait(1)\n        \n        # Clear for formula\n        self.play(FadeOut(example_title), FadeOut(numbers), FadeOut(result))\n        \n        # Show formula\n        formula = Text(\"\u03c6(12) = 12 \u00d7 (1-1/2) \u00d7 (1-1/3) = 4\", color=ORANGE).scale(0.6)\n        formula.next_to(title, DOWN, buff=1)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Clear for graph\n        self.play(FadeOut(formula))\n        \n        # Graph title\n        graph_title = Text(\"Patterns in \u03c6(n) for n = 1 to 20\", color=ORANGE).scale(0.7)\n        graph_title.next_to(title, DOWN, buff=0.5)\n        self.play(Write(graph_title))\n        \n        # Create axes\n        axes = Axes(\n            x_range=[0, 21, 5],\n            y_range=[0, 21, 5],\n            axis_config={\"color\": WHITE},\n        ).scale(0.7)\n        axes.next_to(graph_title, DOWN, buff=0.5)\n        \n        x_label = Text(\"n\", color=WHITE).scale(0.5)\n        x_label.next_to(axes.x_axis.get_end(), RIGHT, buff=0.2)\n        \n        y_label = Text(\"\u03c6(n)\", color=WHITE).scale(0.5)\n        y_label.next_to(axes.y_axis.get_end(), UP, buff=0.2)\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        \n        # Pre-computed \u03c6(n) values for n = 1 to 20\n        phi_values = [\n            1, 1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8\n        ]\n        \n        # Plot points and connect them\n        dots = VGroup()\n        lines = VGroup()\n        \n        for n in range(1, 21):\n            dot = Dot(axes.c2p(n, phi_values[n-1]), color=ORANGE)\n            dots.add(dot)\n            \n            if n > 1:\n                line = Line(\n                    axes.c2p(n-1, phi_values[n-2]),\n                    axes.c2p(n, phi_values[n-1]),\n                    color=ORANGE\n                )\n                lines.add(line)\n        \n        self.play(Create(dots), Create(lines))\n        \n        # Highlight prime numbers\n        primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        prime_dots = VGroup()\n        \n        for p in primes:\n            prime_dot = Dot(axes.c2p(p, phi_values[p-1]), color=BLUE, radius=0.1)\n            prime_dots.add(prime_dot)\n        \n        prime_text = Text(\"For prime p, \u03c6(p) = p-1\", color=BLUE).scale(0.6)\n        prime_text.to_edge(DOWN, buff=1)\n        \n        self.play(Write(prime_text), Create(prime_dots))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph_title),\n            FadeOut(axes),\n            FadeOut(dots),\n            FadeOut(lines),\n            FadeOut(prime_text),\n            FadeOut(prime_dots),\n            FadeOut(x_label),\n            FadeOut(y_label)\n        )\n        \n        conclusion = Text(\n            \"Euler's Totient Function reveals beautiful\\npatterns in number theory\",\n            color=ORANGE\n        ).scale(0.7)\n        conclusion.next_to(title, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What patterns emerge in the Euler's Totient Function when plotted for the sequence of natural numbers?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the preservation of community structures be ensured in compressed graphs?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphCompressionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Graph Compression & Community Structures\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Original graph with two communities\n        # Blue community (3 nodes)\n        blue1 = Dot(LEFT*2 + UP, color=BLUE)\n        blue2 = Dot(LEFT*3, color=BLUE)\n        blue3 = Dot(LEFT*2 + DOWN, color=BLUE)\n        \n        # Green community (3 nodes)\n        green1 = Dot(RIGHT*2 + UP, color=GREEN)\n        green2 = Dot(RIGHT*3, color=GREEN)\n        green3 = Dot(RIGHT*2 + DOWN, color=GREEN)\n        \n        # Create edges (within communities and one between)\n        edges = VGroup(\n            # Blue community edges\n            Line(blue1.get_center(), blue2.get_center()),\n            Line(blue2.get_center(), blue3.get_center()),\n            Line(blue3.get_center(), blue1.get_center()),\n            \n            # Green community edges\n            Line(green1.get_center(), green2.get_center()),\n            Line(green2.get_center(), green3.get_center()),\n            Line(green3.get_center(), green1.get_center()),\n            \n            # Inter-community edge\n            Line(blue1.get_center(), green1.get_center())\n        )\n        \n        # Group all elements into a graph\n        graph = VGroup(blue1, blue2, blue3, green1, green2, green3, edges)\n        \n        # Show the graph\n        self.play(Create(graph))\n        self.wait(1)\n        \n        # Highlight communities with circles\n        blue_circle = Circle(radius=1.2, color=BLUE).move_to(LEFT*2.3)\n        green_circle = Circle(radius=1.2, color=GREEN).move_to(RIGHT*2.3)\n        \n        community_text = Text(\"Communities in Graph\", font_size=24).next_to(title, DOWN)\n        self.play(Write(community_text), Create(blue_circle), Create(green_circle))\n        self.wait(1)\n        \n        # Show first equation\n        eq1 = MathTex(r\"C(G) = \\{C_1, C_2, ..., C_k\\}\")\n        eq1.next_to(community_text, DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Move to compression step\n        self.play(\n            FadeOut(community_text),\n            FadeOut(eq1),\n            graph.animate.scale(0.5).to_edge(LEFT),\n            blue_circle.animate.scale(0.5).to_edge(LEFT),\n            green_circle.animate.scale(0.5).to_edge(LEFT)\n        )\n        \n        # Show compression arrow and text\n        compression_text = Text(\"Compression Process\", font_size=24).next_to(title, DOWN)\n        self.play(Write(compression_text))\n        \n        arrow = Arrow(LEFT, RIGHT).next_to(graph, RIGHT)\n        self.play(Create(arrow))\n        \n        # Show compressed graph (simplified representation)\n        c_blue = Dot(RIGHT*2, color=BLUE)\n        c_green = Dot(RIGHT*4, color=GREEN)\n        c_edge = Line(c_blue.get_center(), c_green.get_center())\n        compressed = VGroup(c_blue, c_green, c_edge)\n        \n        self.play(Create(compressed))\n        self.wait(1)\n        \n        # Highlight preserved communities in compressed graph\n        c_blue_circle = Circle(radius=0.5, color=BLUE).move_to(RIGHT*2)\n        c_green_circle = Circle(radius=0.5, color=GREEN).move_to(RIGHT*4)\n        \n        self.play(Create(c_blue_circle), Create(c_green_circle))\n        \n        preserved_text = Text(\"Communities Preserved\", font_size=20).next_to(compressed, DOWN)\n        self.play(Write(preserved_text))\n        self.wait(1)\n        \n        # Show second equation\n        eq2 = MathTex(r\"f_{compression}(C) = \\hat{C}, \\text{ where } \\hat{C} \\approx C\")\n        eq2.next_to(compression_text, DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph), FadeOut(arrow), FadeOut(compressed),\n            FadeOut(blue_circle), FadeOut(green_circle),\n            FadeOut(c_blue_circle), FadeOut(c_green_circle),\n            FadeOut(title), FadeOut(compression_text),\n            FadeOut(preserved_text), FadeOut(eq2)\n        )\n        \n        conclusion = Text(\"Preserving community structures\\nin graph compression\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the preservation of community structures be ensured in compressed graphs?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the preservation of community structures be ensured in compressed graphs?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphCompressionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Graph Compression & Community Structures\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Original graph with two communities\n        # Blue community (3 nodes)\n        blue1 = Dot(LEFT*2 + UP, color=BLUE)\n        blue2 = Dot(LEFT*3, color=BLUE)\n        blue3 = Dot(LEFT*2 + DOWN, color=BLUE)\n        \n        # Green community (3 nodes)\n        green1 = Dot(RIGHT*2 + UP, color=GREEN)\n        green2 = Dot(RIGHT*3, color=GREEN)\n        green3 = Dot(RIGHT*2 + DOWN, color=GREEN)\n        \n        # Create edges (within communities and one between)\n        edges = VGroup(\n            # Blue community edges\n            Line(blue1.get_center(), blue2.get_center()),\n            Line(blue2.get_center(), blue3.get_center()),\n            Line(blue3.get_center(), blue1.get_center()),\n            \n            # Green community edges\n            Line(green1.get_center(), green2.get_center()),\n            Line(green2.get_center(), green3.get_center()),\n            Line(green3.get_center(), green1.get_center()),\n            \n            # Inter-community edge\n            Line(blue1.get_center(), green1.get_center())\n        )\n        \n        # Group all elements into a graph\n        graph = VGroup(blue1, blue2, blue3, green1, green2, green3, edges)\n        \n        # Show the graph\n        self.play(Create(graph))\n        self.wait(1)\n        \n        # Highlight communities with circles\n        blue_circle = Circle(radius=1.2, color=BLUE).move_to(LEFT*2.3)\n        green_circle = Circle(radius=1.2, color=GREEN).move_to(RIGHT*2.3)\n        \n        community_text = Text(\"Communities in Graph\", font_size=24).next_to(title, DOWN)\n        self.play(Write(community_text), Create(blue_circle), Create(green_circle))\n        self.wait(1)\n        \n        # Show first equation\n        eq1 = MathTex(r\"C(G) = \\{C_1, C_2, ..., C_k\\}\")\n        eq1.next_to(community_text, DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Move to compression step\n        self.play(\n            FadeOut(community_text),\n            FadeOut(eq1),\n            graph.animate.scale(0.5).to_edge(LEFT),\n            blue_circle.animate.scale(0.5).to_edge(LEFT),\n            green_circle.animate.scale(0.5).to_edge(LEFT)\n        )\n        \n        # Show compression arrow and text\n        compression_text = Text(\"Compression Process\", font_size=24).next_to(title, DOWN)\n        self.play(Write(compression_text))\n        \n        arrow = Arrow(LEFT, RIGHT).next_to(graph, RIGHT)\n        self.play(Create(arrow))\n        \n        # Show compressed graph (simplified representation)\n        c_blue = Dot(RIGHT*2, color=BLUE)\n        c_green = Dot(RIGHT*4, color=GREEN)\n        c_edge = Line(c_blue.get_center(), c_green.get_center())\n        compressed = VGroup(c_blue, c_green, c_edge)\n        \n        self.play(Create(compressed))\n        self.wait(1)\n        \n        # Highlight preserved communities in compressed graph\n        c_blue_circle = Circle(radius=0.5, color=BLUE).move_to(RIGHT*2)\n        c_green_circle = Circle(radius=0.5, color=GREEN).move_to(RIGHT*4)\n        \n        self.play(Create(c_blue_circle), Create(c_green_circle))\n        \n        preserved_text = Text(\"Communities Preserved\", font_size=20).next_to(compressed, DOWN)\n        self.play(Write(preserved_text))\n        self.wait(1)\n        \n        # Show second equation\n        eq2 = MathTex(r\"f_{compression}(C) = \\hat{C}, \\text{ where } \\hat{C} \\approx C\")\n        eq2.next_to(compression_text, DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph), FadeOut(arrow), FadeOut(compressed),\n            FadeOut(blue_circle), FadeOut(green_circle),\n            FadeOut(c_blue_circle), FadeOut(c_green_circle),\n            FadeOut(title), FadeOut(compression_text),\n            FadeOut(preserved_text), FadeOut(eq2)\n        )\n        \n        conclusion = Text(\"Preserving community structures\\nin graph compression\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the preservation of community structures be ensured in compressed graphs?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animated video tutorial that visually demonstrates the process of solving a triple integral. Start by showing the integral of xyz over the unit cube from 0 to 1. Then, in step by step fashion, first integrate with respect to z while providing a text explanation above, next integrate the resulting expression with respect to y with new text explanation, and finally integrate with respect to x with another text explanation. At each step, the previous mathematical expression should transform into the new one. End the tutorial by clearing the screen and presenting the final solution of the integral."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\", r\" \\Bigg|_0^2\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1}\", r\" \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution with bounds\n        integral_bound = MathTex(r\"= \\frac{x^4}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(solution1, integral_bound))\n        self.wait(1)\n\n        # Evaluating the bounds\n        solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integral_bound, solution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{16}{4} - 0\", \"=\", \"4\")\n        self.play(ReplacementTransform(solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video tutorial that visually demonstrates the process of solving a triple integral. Start by showing the integral of xyz over the unit cube from 0 to 1. Then, in step by step fashion, first integrate with respect to z while providing a text explanation above, next integrate the resulting expression with respect to y with new text explanation, and finally integrate with respect to x with another text explanation. At each step, the previous mathematical expression should transform into the new one. End the tutorial by clearing the screen and presenting the final solution of the integral."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animated video tutorial that visually demonstrates the process of solving a triple integral. start by showing the integral of xyz over the unit cube from 0 to 1. then, in step by step fashion, first integrate with respect to z while providing a text explanation above, next integrate the resulting expression with respect to y with new text explanation, and finally integrate with respect to x with another text explanation. at each step, the previous mathematical expression should transform into the new one. end the tutorial by clearing the screen and presenting the final solution of the integral."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^2 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\", r\" \\Bigg|_0^2\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= \\frac{x^{3+1}}{3+1}\", r\" \\Bigg|_0^2\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluating from 0 to 2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution with bounds\n        integral_bound = MathTex(r\"= \\frac{x^4}{4} \\Bigg|_0^2\")\n        self.play(ReplacementTransform(solution1, integral_bound))\n        self.wait(1)\n\n        # Evaluating the bounds\n        solution = MathTex(r\"= \\frac{2^4}{4} - \\frac{0^4}{4}\")\n        self.play(ReplacementTransform(integral_bound, solution))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{16}{4} - 0\", \"=\", \"4\")\n        self.play(ReplacementTransform(solution, final_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video tutorial that visually demonstrates the process of solving a triple integral. Start by showing the integral of xyz over the unit cube from 0 to 1. Then, in step by step fashion, first integrate with respect to z while providing a text explanation above, next integrate the resulting expression with respect to y with new text explanation, and finally integrate with respect to x with another text explanation. At each step, the previous mathematical expression should transform into the new one. End the tutorial by clearing the screen and presenting the final solution of the integral."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "\"Can you create an animated video that visually demonstrates how a simple convolutional neural network processes an image? The video should showcase an image going through layers of a neural network, including convolutional layers and fully connected layers, and highlight the transformation at each stage. I'd like the neural network to consist of an initial image layer, followed by two convolutional layers with specified parameters. The first with 1 feature map and 6-size with padding, the second with 3 feature maps and a 3-size filter with no padding. After that, it should include two fully connected layers. The animation should clearly show the data flowing from input to output and be simple enough for educational purposes.\""}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE\n        ode_text = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(ode_text))\n        self.wait(1)\n        \n        # Explain the concept of angular frequency\n        explanation1 = Text(\"Angular frequency\", font_size=24).to_edge(UP)\n        angular_freq = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(Write(explanation1))\n        self.wait(1)\n        self.play(FadeIn(angular_freq, shift=DOWN))\n        self.wait(2)\n\n        # Rewrite the ODE using angular frequency\n        rewritten_ode = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Transform(ode_text, rewritten_ode))\n        self.wait(1)\n        \n        # Solution of the ODE\n        explanation2 = Text(\"Solution of the ODE\", font_size=24).to_edge(UP)\n        general_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(Transform(explanation1, explanation2))\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Visual Representation\n        explanation3 = Text(\"Harmonic motion visualization\", font_size=24).to_edge(UP)\n        oscillator = Circle(radius=1).set_stroke(color=WHITE, opacity=0.5)\n        dot = Dot(oscillator.get_right(), color=RED)\n        path = TracedPath(dot.get_center, stroke_color=RED, stroke_opacity=0.6)\n        self.play(Transform(explanation1, explanation3))\n        self.play(FadeIn(oscillator), FadeIn(dot))\n        self.add_foreground_mobject(dot)\n        self.remove(angular_freq, rewritten_ode, general_solution)\n        self.play(MoveAlongPath(dot, oscillator), run_time=2, rate_func=linear)\n        self.add(path)\n        self.wait(2)\n\n        # Conclusion and clearing the scene\n        self.play(FadeOut(oscillator), FadeOut(dot), FadeOut(path), FadeOut(explanation1))\n        self.wait(1)\n        final_text = Text(\"Harmonic oscillator dynamics\", font_size=24)\n        self.play(Write(final_text))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "\"Can you create an animated video that visually demonstrates how a simple convolutional neural network processes an image? The video should showcase an image going through layers of a neural network, including convolutional layers and fully connected layers, and highlight the transformation at each stage. I'd like the neural network to consist of an initial image layer, followed by two convolutional layers with specified parameters. The first with 1 feature map and 6-size with padding, the second with 3 feature maps and a 3-size filter with no padding. After that, it should include two fully connected layers. The animation should clearly show the data flowing from input to output and be simple enough for educational purposes.\""}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that \"can you create an animated video that visually demonstrates how a simple convolutional neural network processes an image? the video should showcase an image going through layers of a neural network, including convolutional layers and fully connected layers, and highlight the transformation at each stage. i'd like the neural network to consist of an initial image layer, followed by two convolutional layers with specified parameters. the first with 1 feature map and 6-size with padding, the second with 3 feature maps and a 3-size filter with no padding. after that, it should include two fully connected layers. the animation should clearly show the data flowing from input to output and be simple enough for educational purposes.\""}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Displaying the ODE\n        ode_text = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(ode_text))\n        self.wait(1)\n        \n        # Explain the concept of angular frequency\n        explanation1 = Text(\"Angular frequency\", font_size=24).to_edge(UP)\n        angular_freq = MathTex(r\"\\omega = \\sqrt{\\frac{k}{m}}\")\n        self.play(Write(explanation1))\n        self.wait(1)\n        self.play(FadeIn(angular_freq, shift=DOWN))\n        self.wait(2)\n\n        # Rewrite the ODE using angular frequency\n        rewritten_ode = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Transform(ode_text, rewritten_ode))\n        self.wait(1)\n        \n        # Solution of the ODE\n        explanation2 = Text(\"Solution of the ODE\", font_size=24).to_edge(UP)\n        general_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(Transform(explanation1, explanation2))\n        self.play(Write(general_solution))\n        self.wait(2)\n\n        # Visual Representation\n        explanation3 = Text(\"Harmonic motion visualization\", font_size=24).to_edge(UP)\n        oscillator = Circle(radius=1).set_stroke(color=WHITE, opacity=0.5)\n        dot = Dot(oscillator.get_right(), color=RED)\n        path = TracedPath(dot.get_center, stroke_color=RED, stroke_opacity=0.6)\n        self.play(Transform(explanation1, explanation3))\n        self.play(FadeIn(oscillator), FadeIn(dot))\n        self.add_foreground_mobject(dot)\n        self.remove(angular_freq, rewritten_ode, general_solution)\n        self.play(MoveAlongPath(dot, oscillator), run_time=2, rate_func=linear)\n        self.add(path)\n        self.wait(2)\n\n        # Conclusion and clearing the scene\n        self.play(FadeOut(oscillator), FadeOut(dot), FadeOut(path), FadeOut(explanation1))\n        self.wait(1)\n        final_text = Text(\"Harmonic oscillator dynamics\", font_size=24)\n        self.play(Write(final_text))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "\"Can you create an animated video that visually demonstrates how a simple convolutional neural network processes an image? The video should showcase an image going through layers of a neural network, including convolutional layers and fully connected layers, and highlight the transformation at each stage. I'd like the neural network to consist of an initial image layer, followed by two convolutional layers with specified parameters. The first with 1 feature map and 6-size with padding, the second with 3 feature maps and a 3-size filter with no padding. After that, it should include two fully connected layers. The animation should clearly show the data flowing from input to output and be simple enough for educational purposes.\""}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the equation \u201cx\u00b2 + y\u00b2 = z\u00b2\u201d at the center of the screen. After a short pause, the variables are replaced with \u201ca\u00b2 + b\u00b2 = c\u00b2\u201d using a smooth transformation that matches corresponding parts. Then, the equation rearranges into \u201ca\u00b2 = c\u00b2 - b\u00b2,\u201d again transforming matching components to visually demonstrate the algebraic manipulation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the equation \u201cx\u00b2 + y\u00b2 = z\u00b2\u201d at the center of the screen. After a short pause, the variables are replaced with \u201ca\u00b2 + b\u00b2 = c\u00b2\u201d using a smooth transformation that matches corresponding parts. Then, the equation rearranges into \u201ca\u00b2 = c\u00b2 - b\u00b2,\u201d again transforming matching components to visually demonstrate the algebraic manipulation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the equation \u201cx\u00b2 + y\u00b2 = z\u00b2\u201d at the center of the screen. after a short pause, the variables are replaced with \u201ca\u00b2 + b\u00b2 = c\u00b2\u201d using a smooth transformation that matches corresponding parts. then, the equation rearranges into \u201ca\u00b2 = c\u00b2 - b\u00b2,\u201d again transforming matching components to visually demonstrate the algebraic manipulation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MatchingEquationParts(Scene):\n    def construct(self):\n        variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n        eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n        eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n        eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n        self.add(eq1)\n        self.wait(0.5)\n        self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n        self.wait(0.5)\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait(0.5)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the equation \u201cx\u00b2 + y\u00b2 = z\u00b2\u201d at the center of the screen. After a short pause, the variables are replaced with \u201ca\u00b2 + b\u00b2 = c\u00b2\u201d using a smooth transformation that matches corresponding parts. Then, the equation rearranges into \u201ca\u00b2 = c\u00b2 - b\u00b2,\u201d again transforming matching components to visually demonstrate the algebraic manipulation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to see an animated explanation of how to calculate the definite integral of x^3 from 0 to 2, with each step of the process displayed, including the use of the power rule for integration, the evaluation of the integral at the boundaries, and the final simplified answer. Can you also make sure to pause briefly after each new piece of information is shown so I can understand it fully before moving on?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PendulumMotion(Scene):\n    def construct(self):\n        pivot = Dot(UP * 2)\n        bob = Dot(DOWN * 1)\n        rod = Line(pivot.get_center(), bob.get_center()).set_stroke(width=2)\n        pendulum = VGroup(pivot, rod, bob)\n        \n        self.play(FadeIn(pivot), GrowFromCenter(bob), ShowCreation(rod))\n        self.play(Rotating(rod, radians=PI/4, about_point=pivot.get_center(), rate_func=there_and_back, run_time=2))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to see an animated explanation of how to calculate the definite integral of x^3 from 0 to 2, with each step of the process displayed, including the use of the power rule for integration, the evaluation of the integral at the boundaries, and the final simplified answer. Can you also make sure to pause briefly after each new piece of information is shown so I can understand it fully before moving on?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to see an animated explanation of how to calculate the definite integral of x^3 from 0 to 2, with each step of the process displayed, including the use of the power rule for integration, the evaluation of the integral at the boundaries, and the final simplified answer. can you also make sure to pause briefly after each new piece of information is shown so i can understand it fully before moving on?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PendulumMotion(Scene):\n    def construct(self):\n        pivot = Dot(UP * 2)\n        bob = Dot(DOWN * 1)\n        rod = Line(pivot.get_center(), bob.get_center()).set_stroke(width=2)\n        pendulum = VGroup(pivot, rod, bob)\n        \n        self.play(FadeIn(pivot), GrowFromCenter(bob), ShowCreation(rod))\n        self.play(Rotating(rod, radians=PI/4, about_point=pivot.get_center(), rate_func=there_and_back, run_time=2))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to see an animated explanation of how to calculate the definite integral of x^3 from 0 to 2, with each step of the process displayed, including the use of the power rule for integration, the evaluation of the integral at the boundaries, and the final simplified answer. Can you also make sure to pause briefly after each new piece of information is shown so I can understand it fully before moving on?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "How can I create an animated video that visually represents the forward propagation process in a simple neural network with three layers, where the first layer has three neurons, the second layer has five neurons, and the third layer has three neurons again, using a Python library for creating animations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralSphericalExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1} \\rho^2 \\sin \\phi\\, d\\rho\\,d\\theta\\,d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{2\\pi} [\\frac{1}{3}\\rho^3 \\sin \\phi]_{0}^{1} d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplified after inner integral\n        simplified_inner = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\sin \\phi \\, d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} [2\\pi \\sin \\phi]_{0}^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(simplified_inner, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution step\n        final_solution = MathTex(r\"= \\frac{2\\pi}{3} \\int_{0}^{\\pi} \\sin \\phi \\, d\\phi\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Explain final integral solution\n        explanation4 = Text(\"Evaluate the sine integral over phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{2\\pi}{3} [-\\cos \\phi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        \n        # Resolve to actual number\n        resolved_final_answer = MathTex(r\"= \\frac{4\\pi}{3}\")\n        self.play(ReplacementTransform(final_answer, resolved_final_answer))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an animated video that visually represents the forward propagation process in a simple neural network with three layers, where the first layer has three neurons, the second layer has five neurons, and the third layer has three neurons again, using a Python library for creating animations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that how can i create an animated video that visually represents the forward propagation process in a simple neural network with three layers, where the first layer has three neurons, the second layer has five neurons, and the third layer has three neurons again, using a python library for creating animations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralSphericalExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\int_{0}^{1} \\rho^2 \\sin \\phi\\, d\\rho\\,d\\theta\\,d\\phi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{2\\pi} [\\frac{1}{3}\\rho^3 \\sin \\phi]_{0}^{1} d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplified after inner integral\n        simplified_inner = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\sin \\phi \\, d\\theta\\,d\\phi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate with respect to theta\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\frac{1}{3} \\int_{0}^{\\pi} [2\\pi \\sin \\phi]_{0}^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(simplified_inner, middle_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation3 = Text(\"Finally, integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution step\n        final_solution = MathTex(r\"= \\frac{2\\pi}{3} \\int_{0}^{\\pi} \\sin \\phi \\, d\\phi\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Explain final integral solution\n        explanation4 = Text(\"Evaluate the sine integral over phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final answer\n        final_answer = MathTex(r\"= \\frac{2\\pi}{3} [-\\cos \\phi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        \n        # Resolve to actual number\n        resolved_final_answer = MathTex(r\"= \\frac{4\\pi}{3}\")\n        self.play(ReplacementTransform(final_answer, resolved_final_answer))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an animated video that visually represents the forward propagation process in a simple neural network with three layers, where the first layer has three neurons, the second layer has five neurons, and the third layer has three neurons again, using a Python library for creating animations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "a_simple_feed_forward_network.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network import FeedForwardLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1200\nconfig.frame_height = 4.0\nconfig.frame_width = 4.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(num_nodes=3),\n                FeedForwardLayer(num_nodes=5),\n                FeedForwardLayer(num_nodes=3),\n            ]\n        )\n        self.add(nn)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "a_simple_feed_forward_network.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that a_simple_feed_forward_network.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network import FeedForwardLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1200\nconfig.frame_height = 4.0\nconfig.frame_width = 4.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(num_nodes=3),\n                FeedForwardLayer(num_nodes=5),\n                FeedForwardLayer(num_nodes=3),\n            ]\n        )\n        self.add(nn)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "a_simple_feed_forward_network.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a tree graph with seven labeled nodes arranged hierarchically. Node 1 is the root at the top, branching into nodes 2 and 3. Node 2 further branches into nodes 4 and 5, while node 3 branches into nodes 6 and 7. The layout clearly shows the parent-child relationships in a balanced tree structure."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a tree graph with seven labeled nodes arranged hierarchically. Node 1 is the root at the top, branching into nodes 2 and 3. Node 2 further branches into nodes 4 and 5, while node 3 branches into nodes 6 and 7. The layout clearly shows the parent-child relationships in a balanced tree structure."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a tree graph with seven labeled nodes arranged hierarchically. node 1 is the root at the top, branching into nodes 2 and 3. node 2 further branches into nodes 4 and 5, while node 3 branches into nodes 6 and 7. the layout clearly shows the parent-child relationships in a balanced tree structure."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TreeLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6, 7],\n            [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            layout=\"tree\",\n            layout_config={\"root_vertex\": 1},\n            labels=True\n        )\n        self.add(graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a tree graph with seven labeled nodes arranged hierarchically. Node 1 is the root at the top, branching into nodes 2 and 3. Node 2 further branches into nodes 4 and 5, while node 3 branches into nodes 6 and 7. The layout clearly shows the parent-child relationships in a balanced tree structure."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_gridded_rectangle.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.utils.mobjects.gridded_rectangle import GriddedRectangle\n\n\nclass TestGriddedRectangleScene(ThreeDScene):\n    def construct(self):\n        rect = GriddedRectangle(color=ORANGE, width=3, height=3)\n        self.add(rect)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_gridded_rectangle.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_gridded_rectangle.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.utils.mobjects.gridded_rectangle import GriddedRectangle\n\n\nclass TestGriddedRectangleScene(ThreeDScene):\n    def construct(self):\n        rect = GriddedRectangle(color=ORANGE, width=3, height=3)\n        self.add(rect)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_gridded_rectangle.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_image_homotopy.py"}, {"from": "assistant", "value": "```python\nfrom PIL import Image\n\nfrom manim import *\nfrom manim_ml.utils.mobjects.image import GrayscaleImageMobject\nfrom manim_ml.neural_network.layers.parent_layers import ThreeDLayer\n\n\nclass TestImageHomotopy(Scene):\n    def compute_shape_at_time(self, time):\n        \"\"\"Computes the shape of a transformed image at a given time\"\"\"\n\n    def compute_center_offset_at_time(self, x, y, z, time):\n        \"\"\"Computes the center offset of a point at a given time\"\"\"\n        pass\n\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        image_mobject = GrayscaleImageMobject(numpy_image)\n        self.add(image_mobject)\n        self.wait(1)\n\n        rot = image_mobject.animate.rotate(\n            axis=[0, 1, 0], angle=ThreeDLayer.three_d_y_rotation\n        )\n        move = image_mobject.animate.move_to()\n        self.play(rot)\n        \"\"\"\n        # Make square\n        square = Square()\n        self.add(square)\n        # Make polygon\n        polygon = Polygon(\n            [1, 0, 0],\n            [0, 1, 0],\n            [-1, 0, 0],\n            [0, -1, 0],\n        )\n        polygon.shift(RIGHT)\n        self.play(\n            Transform(square, polygon)\n        )\n        # Make the homotopy\n\n        def shift_right_homotopy(x, y, z, t):\n            return x + 1, y, z\n        # Make the animation\n        animation = Homotopy(\n            mobject=image_mobject,\n            homotopy=shift_right_homotopy\n        )\n\n        self.play(animation, run_time=1)\n        \"\"\"\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_image_homotopy.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_image_homotopy.py"}, {"from": "assistant", "value": "```python\nfrom PIL import Image\n\nfrom manim import *\nfrom manim_ml.utils.mobjects.image import GrayscaleImageMobject\nfrom manim_ml.neural_network.layers.parent_layers import ThreeDLayer\n\n\nclass TestImageHomotopy(Scene):\n    def compute_shape_at_time(self, time):\n        \"\"\"Computes the shape of a transformed image at a given time\"\"\"\n\n    def compute_center_offset_at_time(self, x, y, z, time):\n        \"\"\"Computes the center offset of a point at a given time\"\"\"\n        pass\n\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        image_mobject = GrayscaleImageMobject(numpy_image)\n        self.add(image_mobject)\n        self.wait(1)\n\n        rot = image_mobject.animate.rotate(\n            axis=[0, 1, 0], angle=ThreeDLayer.three_d_y_rotation\n        )\n        move = image_mobject.animate.move_to()\n        self.play(rot)\n        \"\"\"\n        # Make square\n        square = Square()\n        self.add(square)\n        # Make polygon\n        polygon = Polygon(\n            [1, 0, 0],\n            [0, 1, 0],\n            [-1, 0, 0],\n            [0, -1, 0],\n        )\n        polygon.shift(RIGHT)\n        self.play(\n            Transform(square, polygon)\n        )\n        # Make the homotopy\n\n        def shift_right_homotopy(x, y, z, t):\n            return x + 1, y, z\n        # Make the animation\n        animation = Homotopy(\n            mobject=image_mobject,\n            homotopy=shift_right_homotopy\n        )\n\n        self.play(animation, run_time=1)\n        \"\"\"\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_image_homotopy.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Why does an orthonormal basis preserve the geometric shape in a Hilbert space when projecting vectors?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass OrthonormalBasisScene(Scene):\n    def construct(self):\n        # Title of our animation\n        title = Text(\"The Magic of Orthonormal Basis and Projections\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple coordinate system to represent our Hilbert space\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE},\n        )\n        \n        self.play(Create(axes))\n        self.wait(1)\n        \n        # Create a vector in our space\n        vector = Arrow(ORIGIN, 2*RIGHT + 2*UP, color=YELLOW, buff=0)\n        vector_label = Text(\"v\", font_size=24).next_to(vector.get_end(), UP+RIGHT, buff=0.1)\n        \n        self.play(Create(vector), Write(vector_label))\n        self.wait(1)\n        \n        # Introduce orthonormal basis concept\n        ortho_text = Text(\"Orthonormal Basis\", font_size=28)\n        ortho_text.next_to(title, DOWN)\n        \n        # Create orthonormal basis vectors (unit length and perpendicular)\n        x_axis = Arrow(ORIGIN, 2*RIGHT, color=GREEN, buff=0)\n        y_axis = Arrow(ORIGIN, 2*UP, color=RED, buff=0)\n        \n        self.play(\n            Write(ortho_text),\n            Create(x_axis),\n            Create(y_axis)\n        )\n        self.wait(1)\n        \n        # Show projection onto orthonormal basis\n        # The dashed lines represent the projection components\n        projection_x = DashedLine(\n            2*RIGHT + 2*UP,  # From the vector tip\n            2*RIGHT,         # To the x-axis\n            color=GREEN\n        )\n        projection_y = DashedLine(\n            2*RIGHT,         # From the x-projection\n            ORIGIN,          # To the origin\n            color=RED\n        )\n        \n        self.play(\n            Create(projection_x),\n            Create(projection_y)\n        )\n        self.wait(1)\n        \n        # Highlight that orthonormal basis preserves shape\n        preserves_text = Text(\"Preserves shape\", font_size=28, color=GREEN)\n        preserves_text.next_to(ortho_text, DOWN)\n        self.play(Write(preserves_text))\n        self.wait(1)\n        \n        # Display the inner product equation\n        eq1 = MathTex(r\"\\langle u, v \\rangle = u^Tv\")\n        eq1.to_edge(DOWN)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Transition to non-orthonormal basis\n        self.play(\n            FadeOut(x_axis),\n            FadeOut(y_axis),\n            FadeOut(projection_x),\n            FadeOut(projection_y),\n            FadeOut(preserves_text),\n            FadeOut(ortho_text),\n            FadeOut(eq1)\n        )\n        \n        # Introduce non-orthonormal basis concept\n        non_ortho_text = Text(\"Non-Orthonormal Basis\", font_size=28)\n        non_ortho_text.next_to(title, DOWN)\n        \n        # Create non-orthonormal basis vectors (not perpendicular)\n        skew_x = Arrow(ORIGIN, 2*RIGHT + 0.5*UP, color=ORANGE, buff=0)\n        skew_y = Arrow(ORIGIN, 0.5*RIGHT + 2*UP, color=PURPLE, buff=0)\n        \n        self.play(\n            Write(non_ortho_text),\n            Create(skew_x),\n            Create(skew_y)\n        )\n        self.wait(1)\n        \n        # Show distorted projection with non-orthonormal basis\n        skew_proj_x = DashedLine(\n            2*RIGHT + 2*UP,      # From the vector tip\n            1.5*RIGHT + 0.5*UP,  # To a point on the skewed basis\n            color=ORANGE\n        )\n        skew_proj_y = DashedLine(\n            1.5*RIGHT + 0.5*UP,  # From the first projection\n            ORIGIN,              # To the origin\n            color=PURPLE\n        )\n        \n        self.play(\n            Create(skew_proj_x),\n            Create(skew_proj_y)\n        )\n        self.wait(1)\n        \n        # Highlight that non-orthonormal basis distorts shape\n        distorts_text = Text(\"Distorts shape\", font_size=28, color=RED)\n        distorts_text.next_to(non_ortho_text, DOWN)\n        self.play(Write(distorts_text))\n        self.wait(1)\n        \n        # Display the projection formula\n        eq2 = MathTex(r\"\\|P_{W}(v)\\| = \\left|\\frac{\\langle v, w \\rangle}{\\langle w, w \\rangle}\\right|\", font_size=36)\n        eq2.to_edge(DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(2)\n        \n        # Clean up and prepare for conclusion\n        self.play(\n            FadeOut(eq2),\n            FadeOut(non_ortho_text),\n            FadeOut(distorts_text),\n            FadeOut(skew_x),\n            FadeOut(skew_y),\n            FadeOut(skew_proj_x),\n            FadeOut(skew_proj_y),\n            FadeOut(vector),\n            FadeOut(vector_label),\n            FadeOut(axes),\n            FadeOut(title)\n        )\n        \n        # Final conclusion\n        conclusion_text = Text(\"Orthonormal basis preserves geometric shape\", font_size=32)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        self.play(FadeOut(conclusion_text))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why does an orthonormal basis preserve the geometric shape in a Hilbert space when projecting vectors?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: why does an orthonormal basis preserve the geometric shape in a hilbert space when projecting vectors?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass OrthonormalBasisScene(Scene):\n    def construct(self):\n        # Title of our animation\n        title = Text(\"The Magic of Orthonormal Basis and Projections\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple coordinate system to represent our Hilbert space\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE},\n        )\n        \n        self.play(Create(axes))\n        self.wait(1)\n        \n        # Create a vector in our space\n        vector = Arrow(ORIGIN, 2*RIGHT + 2*UP, color=YELLOW, buff=0)\n        vector_label = Text(\"v\", font_size=24).next_to(vector.get_end(), UP+RIGHT, buff=0.1)\n        \n        self.play(Create(vector), Write(vector_label))\n        self.wait(1)\n        \n        # Introduce orthonormal basis concept\n        ortho_text = Text(\"Orthonormal Basis\", font_size=28)\n        ortho_text.next_to(title, DOWN)\n        \n        # Create orthonormal basis vectors (unit length and perpendicular)\n        x_axis = Arrow(ORIGIN, 2*RIGHT, color=GREEN, buff=0)\n        y_axis = Arrow(ORIGIN, 2*UP, color=RED, buff=0)\n        \n        self.play(\n            Write(ortho_text),\n            Create(x_axis),\n            Create(y_axis)\n        )\n        self.wait(1)\n        \n        # Show projection onto orthonormal basis\n        # The dashed lines represent the projection components\n        projection_x = DashedLine(\n            2*RIGHT + 2*UP,  # From the vector tip\n            2*RIGHT,         # To the x-axis\n            color=GREEN\n        )\n        projection_y = DashedLine(\n            2*RIGHT,         # From the x-projection\n            ORIGIN,          # To the origin\n            color=RED\n        )\n        \n        self.play(\n            Create(projection_x),\n            Create(projection_y)\n        )\n        self.wait(1)\n        \n        # Highlight that orthonormal basis preserves shape\n        preserves_text = Text(\"Preserves shape\", font_size=28, color=GREEN)\n        preserves_text.next_to(ortho_text, DOWN)\n        self.play(Write(preserves_text))\n        self.wait(1)\n        \n        # Display the inner product equation\n        eq1 = MathTex(r\"\\langle u, v \\rangle = u^Tv\")\n        eq1.to_edge(DOWN)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Transition to non-orthonormal basis\n        self.play(\n            FadeOut(x_axis),\n            FadeOut(y_axis),\n            FadeOut(projection_x),\n            FadeOut(projection_y),\n            FadeOut(preserves_text),\n            FadeOut(ortho_text),\n            FadeOut(eq1)\n        )\n        \n        # Introduce non-orthonormal basis concept\n        non_ortho_text = Text(\"Non-Orthonormal Basis\", font_size=28)\n        non_ortho_text.next_to(title, DOWN)\n        \n        # Create non-orthonormal basis vectors (not perpendicular)\n        skew_x = Arrow(ORIGIN, 2*RIGHT + 0.5*UP, color=ORANGE, buff=0)\n        skew_y = Arrow(ORIGIN, 0.5*RIGHT + 2*UP, color=PURPLE, buff=0)\n        \n        self.play(\n            Write(non_ortho_text),\n            Create(skew_x),\n            Create(skew_y)\n        )\n        self.wait(1)\n        \n        # Show distorted projection with non-orthonormal basis\n        skew_proj_x = DashedLine(\n            2*RIGHT + 2*UP,      # From the vector tip\n            1.5*RIGHT + 0.5*UP,  # To a point on the skewed basis\n            color=ORANGE\n        )\n        skew_proj_y = DashedLine(\n            1.5*RIGHT + 0.5*UP,  # From the first projection\n            ORIGIN,              # To the origin\n            color=PURPLE\n        )\n        \n        self.play(\n            Create(skew_proj_x),\n            Create(skew_proj_y)\n        )\n        self.wait(1)\n        \n        # Highlight that non-orthonormal basis distorts shape\n        distorts_text = Text(\"Distorts shape\", font_size=28, color=RED)\n        distorts_text.next_to(non_ortho_text, DOWN)\n        self.play(Write(distorts_text))\n        self.wait(1)\n        \n        # Display the projection formula\n        eq2 = MathTex(r\"\\|P_{W}(v)\\| = \\left|\\frac{\\langle v, w \\rangle}{\\langle w, w \\rangle}\\right|\", font_size=36)\n        eq2.to_edge(DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(2)\n        \n        # Clean up and prepare for conclusion\n        self.play(\n            FadeOut(eq2),\n            FadeOut(non_ortho_text),\n            FadeOut(distorts_text),\n            FadeOut(skew_x),\n            FadeOut(skew_y),\n            FadeOut(skew_proj_x),\n            FadeOut(skew_proj_y),\n            FadeOut(vector),\n            FadeOut(vector_label),\n            FadeOut(axes),\n            FadeOut(title)\n        )\n        \n        # Final conclusion\n        conclusion_text = Text(\"Orthonormal basis preserves geometric shape\", font_size=32)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        self.play(FadeOut(conclusion_text))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why does an orthonormal basis preserve the geometric shape in a Hilbert space when projecting vectors?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a block of placeholder text (\"Lorem ipsum...\") in two formats:\n\n1. Initially, the text appears left-aligned under the title \"Not Justified\".\n2. Then, the left-aligned text and its title fade out while a new version of the same text fades in, now fully justified (aligned evenly along both left and right margins), under the title \"Justified\".\n\nThe transition visually contrasts the difference between non-justified and justified text formatting."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass JustifyText(Scene):\n    def construct(self):\n        ipsum_text = (\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n            \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"\n            \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"\n            \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"\n            \"leo pulvinar, dignissim est at, venenatis nisi.\"\n        )\n        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)\n        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)\n        just_title = Title(\"Justified\")\n        njust_title = Title(\"Not Justified\")\n        self.add(njust_title, not_justified_text)\n        self.play(\n            FadeOut(not_justified_text),\n            FadeIn(justified_text),\n            FadeOut(njust_title),\n            FadeIn(just_title),\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a block of placeholder text (\"Lorem ipsum...\") in two formats:\n\n1. Initially, the text appears left-aligned under the title \"Not Justified\".\n2. Then, the left-aligned text and its title fade out while a new version of the same text fades in, now fully justified (aligned evenly along both left and right margins), under the title \"Justified\".\n\nThe transition visually contrasts the difference between non-justified and justified text formatting."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a block of placeholder text (\"lorem ipsum...\") in two formats:\n\n1. initially, the text appears left-aligned under the title \"not justified\".\n2. then, the left-aligned text and its title fade out while a new version of the same text fades in, now fully justified (aligned evenly along both left and right margins), under the title \"justified\".\n\nthe transition visually contrasts the difference between non-justified and justified text formatting."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass JustifyText(Scene):\n    def construct(self):\n        ipsum_text = (\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n            \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"\n            \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"\n            \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"\n            \"leo pulvinar, dignissim est at, venenatis nisi.\"\n        )\n        justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)\n        not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)\n        just_title = Title(\"Justified\")\n        njust_title = Title(\"Not Justified\")\n        self.add(njust_title, not_justified_text)\n        self.play(\n            FadeOut(not_justified_text),\n            FadeIn(justified_text),\n            FadeOut(njust_title),\n            FadeIn(just_title),\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a block of placeholder text (\"Lorem ipsum...\") in two formats:\n\n1. Initially, the text appears left-aligned under the title \"Not Justified\".\n2. Then, the left-aligned text and its title fade out while a new version of the same text fades in, now fully justified (aligned evenly along both left and right margins), under the title \"Justified\".\n\nThe transition visually contrasts the difference between non-justified and justified text formatting."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What roles do eigenvalues play in determining the stability of a periodic orbit formed through a Hopf bifurcation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HopfBifurcation(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Role of Eigenvalues in Hopf Bifurcation\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Eigenvalues determine system stability\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Element 1 & 2: Show the mathematical representation of dynamical system\n        eq = MathTex(r\"\\dot{\\mathbf{x}} = A \\mathbf{x}\")\n        self.play(Write(eq))\n        self.wait(1)\n        self.play(eq.animate.to_edge(UP).shift(DOWN))\n        \n        # Element 3: Create a complex plane to visualize eigenvalues\n        plane = Axes(\n            x_range=[-2, 2],\n            y_range=[-2, 2],\n        )\n        \n        plane_label = Text(\"Complex Plane\").next_to(plane, UP)\n        \n        # Add a fixed point at the origin\n        fixed_point = Dot(plane.c2p(0, 0), color=WHITE)\n        fixed_label = Text(\"Fixed Point\", font_size=16).next_to(fixed_point, DOWN, buff=0.2)\n        \n        # Highlight the imaginary axis\n        imag_axis = Line(\n            plane.c2p(0, -2),\n            plane.c2p(0, 2),\n            color=BLUE_D\n        )\n        imag_label = Text(\"Imaginary Axis\", font_size=16, color=BLUE_D)\n        imag_label.next_to(imag_axis, UP).shift(RIGHT)\n        \n        # Show the complex plane\n        self.play(\n            Create(plane), \n            Write(plane_label),\n            Create(fixed_point),\n            Write(fixed_label),\n            Create(imag_axis),\n            Write(imag_label)\n        )\n        self.wait(1)\n        \n        # Create eigenvalues as complex conjugate pair\n        eig1 = Dot(plane.c2p(-1, 1), color=RED)\n        eig2 = Dot(plane.c2p(-1, -1), color=RED)\n        \n        # Eigenvalue equation\n        eig_eq = MathTex(r\"\\lambda = \\alpha \\pm i\\omega\").next_to(plane, DOWN)\n        \n        # Show eigenvalues and equation\n        self.play(Create(eig1), Create(eig2), Write(eig_eq))\n        self.wait(1)\n        \n        # Element 4: Move eigenvalues toward imaginary axis\n        move_text = Text(\"Parameters change, eigenvalues move\").next_to(eig_eq, DOWN)\n        self.play(Write(move_text))\n        \n        self.play(\n            eig1.animate.move_to(plane.c2p(0, 1)),\n            eig2.animate.move_to(plane.c2p(0, -1))\n        )\n        \n        # Element 5: Show Hopf bifurcation when eigenvalues cross imaginary axis\n        bif_text = Text(\"Hopf Bifurcation\").next_to(plane, RIGHT)\n        self.play(\n            Write(bif_text),\n            imag_axis.animate.set_color(YELLOW)\n        )\n        self.wait(1)\n        \n        # Move eigenvalues across imaginary axis\n        self.play(\n            eig1.animate.move_to(plane.c2p(1, 1)),\n            eig2.animate.move_to(plane.c2p(1, -1))\n        )\n        \n        # Element 6: Show periodic orbit formation\n        orbit_text = Text(\"Periodic Orbit Forms\").next_to(move_text, DOWN)\n        self.play(Write(orbit_text))\n        \n        # Create a periodic orbit\n        orbit = Circle(radius=0.5, color=ORANGE).move_to(plane.c2p(0, 0))\n        self.play(Create(orbit))\n        self.wait(1)\n        \n        # Element 7: Final view and conclusion\n        conclusion = Text(\"Eigenvalues determine orbit stability\")\n        self.play(\n            FadeOut(plane), FadeOut(plane_label), \n            FadeOut(eig1), FadeOut(eig2),\n            FadeOut(eig_eq), FadeOut(bif_text),\n            FadeOut(orbit), FadeOut(orbit_text),\n            FadeOut(move_text), FadeOut(title),\n            FadeOut(eq), FadeOut(fixed_point),\n            FadeOut(fixed_label), FadeOut(imag_axis),\n            FadeOut(imag_label),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What roles do eigenvalues play in determining the stability of a periodic orbit formed through a Hopf bifurcation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what roles do eigenvalues play in determining the stability of a periodic orbit formed through a hopf bifurcation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HopfBifurcation(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Role of Eigenvalues in Hopf Bifurcation\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Eigenvalues determine system stability\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Element 1 & 2: Show the mathematical representation of dynamical system\n        eq = MathTex(r\"\\dot{\\mathbf{x}} = A \\mathbf{x}\")\n        self.play(Write(eq))\n        self.wait(1)\n        self.play(eq.animate.to_edge(UP).shift(DOWN))\n        \n        # Element 3: Create a complex plane to visualize eigenvalues\n        plane = Axes(\n            x_range=[-2, 2],\n            y_range=[-2, 2],\n        )\n        \n        plane_label = Text(\"Complex Plane\").next_to(plane, UP)\n        \n        # Add a fixed point at the origin\n        fixed_point = Dot(plane.c2p(0, 0), color=WHITE)\n        fixed_label = Text(\"Fixed Point\", font_size=16).next_to(fixed_point, DOWN, buff=0.2)\n        \n        # Highlight the imaginary axis\n        imag_axis = Line(\n            plane.c2p(0, -2),\n            plane.c2p(0, 2),\n            color=BLUE_D\n        )\n        imag_label = Text(\"Imaginary Axis\", font_size=16, color=BLUE_D)\n        imag_label.next_to(imag_axis, UP).shift(RIGHT)\n        \n        # Show the complex plane\n        self.play(\n            Create(plane), \n            Write(plane_label),\n            Create(fixed_point),\n            Write(fixed_label),\n            Create(imag_axis),\n            Write(imag_label)\n        )\n        self.wait(1)\n        \n        # Create eigenvalues as complex conjugate pair\n        eig1 = Dot(plane.c2p(-1, 1), color=RED)\n        eig2 = Dot(plane.c2p(-1, -1), color=RED)\n        \n        # Eigenvalue equation\n        eig_eq = MathTex(r\"\\lambda = \\alpha \\pm i\\omega\").next_to(plane, DOWN)\n        \n        # Show eigenvalues and equation\n        self.play(Create(eig1), Create(eig2), Write(eig_eq))\n        self.wait(1)\n        \n        # Element 4: Move eigenvalues toward imaginary axis\n        move_text = Text(\"Parameters change, eigenvalues move\").next_to(eig_eq, DOWN)\n        self.play(Write(move_text))\n        \n        self.play(\n            eig1.animate.move_to(plane.c2p(0, 1)),\n            eig2.animate.move_to(plane.c2p(0, -1))\n        )\n        \n        # Element 5: Show Hopf bifurcation when eigenvalues cross imaginary axis\n        bif_text = Text(\"Hopf Bifurcation\").next_to(plane, RIGHT)\n        self.play(\n            Write(bif_text),\n            imag_axis.animate.set_color(YELLOW)\n        )\n        self.wait(1)\n        \n        # Move eigenvalues across imaginary axis\n        self.play(\n            eig1.animate.move_to(plane.c2p(1, 1)),\n            eig2.animate.move_to(plane.c2p(1, -1))\n        )\n        \n        # Element 6: Show periodic orbit formation\n        orbit_text = Text(\"Periodic Orbit Forms\").next_to(move_text, DOWN)\n        self.play(Write(orbit_text))\n        \n        # Create a periodic orbit\n        orbit = Circle(radius=0.5, color=ORANGE).move_to(plane.c2p(0, 0))\n        self.play(Create(orbit))\n        self.wait(1)\n        \n        # Element 7: Final view and conclusion\n        conclusion = Text(\"Eigenvalues determine orbit stability\")\n        self.play(\n            FadeOut(plane), FadeOut(plane_label), \n            FadeOut(eig1), FadeOut(eig2),\n            FadeOut(eig_eq), FadeOut(bif_text),\n            FadeOut(orbit), FadeOut(orbit_text),\n            FadeOut(move_text), FadeOut(title),\n            FadeOut(eq), FadeOut(fixed_point),\n            FadeOut(fixed_label), FadeOut(imag_axis),\n            FadeOut(imag_label),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What roles do eigenvalues play in determining the stability of a periodic orbit formed through a Hopf bifurcation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animated video that shows how to test if an infinite series converges or not using the p-test. Start by displaying the sum of 1 over n squared from n equals 1 to infinity. Next, introduce text explaining we will apply the p-test and then show that p, in this case, is 2 which is greater than 1. Then, replace the initial text with a statement that concludes the series is convergent. Finally, clear the screen and end with the statement that the series is convergent being written once more. Can you make this animation engaging and easy to understand?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicOscillatorExample(Scene):\n    def construct(self):\n        # Displaying the equation of motion\n        equation = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Describing the system\n        system_description = Text(\"This represents a simple harmonic oscillator.\", font_size=24)\n        system_description.to_edge(UP)\n        self.play(Write(system_description))\n        self.wait(2)\n\n        # Explaining terms\n        terms_explanation = Text(\"Where m is mass, k is the spring constant.\", font_size=24)\n        terms_explanation.to_edge(UP)\n        self.play(Transform(system_description, terms_explanation))\n        self.wait(2)\n\n        # Displaying the solution\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(1)\n\n        # Explaining the solution\n        solution_explanation = Text(\"A is amplitude, \u03c9 is angular frequency, and \u03d5 is phase.\", font_size=24)\n        solution_explanation.to_edge(UP)\n        self.play(Transform(system_description, solution_explanation))\n        self.wait(2)\n\n        # Conclusion statement\n        conclusion = Text(\"Simple harmonic motion is periodic and sinusoidal.\", font_size=24)\n        conclusion.to_edge(UP)\n        self.play(Transform(system_description, conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        conclusion.set_opacity(0)  # Hide conclusion without removal animation\n        self.play(FadeIn(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that shows how to test if an infinite series converges or not using the p-test. Start by displaying the sum of 1 over n squared from n equals 1 to infinity. Next, introduce text explaining we will apply the p-test and then show that p, in this case, is 2 which is greater than 1. Then, replace the initial text with a statement that concludes the series is convergent. Finally, clear the screen and end with the statement that the series is convergent being written once more. Can you make this animation engaging and easy to understand?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animated video that shows how to test if an infinite series converges or not using the p-test. start by displaying the sum of 1 over n squared from n equals 1 to infinity. next, introduce text explaining we will apply the p-test and then show that p, in this case, is 2 which is greater than 1. then, replace the initial text with a statement that concludes the series is convergent. finally, clear the screen and end with the statement that the series is convergent being written once more. can you make this animation engaging and easy to understand?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicOscillatorExample(Scene):\n    def construct(self):\n        # Displaying the equation of motion\n        equation = MathTex(r\"m\\frac{d^2 x}{dt^2} + kx = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Describing the system\n        system_description = Text(\"This represents a simple harmonic oscillator.\", font_size=24)\n        system_description.to_edge(UP)\n        self.play(Write(system_description))\n        self.wait(2)\n\n        # Explaining terms\n        terms_explanation = Text(\"Where m is mass, k is the spring constant.\", font_size=24)\n        terms_explanation.to_edge(UP)\n        self.play(Transform(system_description, terms_explanation))\n        self.wait(2)\n\n        # Displaying the solution\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(equation, solution))\n        self.wait(1)\n\n        # Explaining the solution\n        solution_explanation = Text(\"A is amplitude, \u03c9 is angular frequency, and \u03d5 is phase.\", font_size=24)\n        solution_explanation.to_edge(UP)\n        self.play(Transform(system_description, solution_explanation))\n        self.wait(2)\n\n        # Conclusion statement\n        conclusion = Text(\"Simple harmonic motion is periodic and sinusoidal.\", font_size=24)\n        conclusion.to_edge(UP)\n        self.play(Transform(system_description, conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        conclusion.set_opacity(0)  # Hide conclusion without removal animation\n        self.play(FadeIn(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that shows how to test if an infinite series converges or not using the p-test. Start by displaying the sum of 1 over n squared from n equals 1 to infinity. Next, introduce text explaining we will apply the p-test and then show that p, in this case, is 2 which is greater than 1. Then, replace the initial text with a statement that concludes the series is convergent. Finally, clear the screen and end with the statement that the series is convergent being written once more. Can you make this animation engaging and easy to understand?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually demonstrates the concept of screen units and percentages of the screen dimensions in the context of computer graphics. Could you provide an animation that includes a grid as a reference, and then sequentially displays rectangles of increasing width, each representing a different percentage of the screen's width? Each rectangle should be a different color to clearly distinguish them, and also partially transparent so I can see how they overlap if they do. Finally, is it possible to place a dot at a precise location measured in pixels from the center of the screen, for example, 150 pixels up and to the right?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"MoveToTarget\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            circle.generate_target()\n            circle.move_to(RIGHT)\n            self.play(MoveToTarget(circle))\n            self.remove(circle)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually demonstrates the concept of screen units and percentages of the screen dimensions in the context of computer graphics. Could you provide an animation that includes a grid as a reference, and then sequentially displays rectangles of increasing width, each representing a different percentage of the screen's width? Each rectangle should be a different color to clearly distinguish them, and also partially transparent so I can see how they overlap if they do. Finally, is it possible to place a dot at a precise location measured in pixels from the center of the screen, for example, 150 pixels up and to the right?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually demonstrates the concept of screen units and percentages of the screen dimensions in the context of computer graphics. could you provide an animation that includes a grid as a reference, and then sequentially displays rectangles of increasing width, each representing a different percentage of the screen's width? each rectangle should be a different color to clearly distinguish them, and also partially transparent so i can see how they overlap if they do. finally, is it possible to place a dot at a precise location measured in pixels from the center of the screen, for example, 150 pixels up and to the right?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"MoveToTarget\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle().shift(LEFT)\n            circle.generate_target()\n            circle.move_to(RIGHT)\n            self.play(MoveToTarget(circle))\n            self.remove(circle)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually demonstrates the concept of screen units and percentages of the screen dimensions in the context of computer graphics. Could you provide an animation that includes a grid as a reference, and then sequentially displays rectangles of increasing width, each representing a different percentage of the screen's width? Each rectangle should be a different color to clearly distinguish them, and also partially transparent so I can see how they overlap if they do. Finally, is it possible to place a dot at a precise location measured in pixels from the center of the screen, for example, 150 pixels up and to the right?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do the principles of chaos theory apply to the behavior of large derangements, and how can this be visualized through simulations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DerangementChaos(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dance of Permutations: Derangements & Chaos\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Permutation explanation\n        perm_text = Text(\"Permutations: ways to arrange items\", font_size=30)\n        perm_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(perm_text))\n        self.wait(1)\n        \n        # Original arrangement\n        original_text = Text(\"Original arrangement:\", font_size=24)\n        original_text.to_edge(LEFT).shift(DOWN)\n        self.play(Write(original_text))\n        \n        # Visual of objects - create colored squares for original arrangement\n        squares = VGroup(\n            Square(fill_color=RED, fill_opacity=0.8),\n            Square(fill_color=GREEN, fill_opacity=0.8),\n            Square(fill_color=BLUE, fill_opacity=0.8)\n        ).arrange(RIGHT, buff=0.3).scale(0.5)\n        squares.next_to(original_text, RIGHT, buff=0.5)\n        \n        # Add labels 1, 2, 3 to the squares\n        labels = VGroup(*[Text(str(i+1), font_size=24).move_to(square.get_center()) \n                        for i, square in enumerate(squares)])\n        \n        self.play(Create(squares), Write(labels))\n        self.wait(1)\n        \n        # Derangement explanation\n        derange_text = Text(\"Derangements: no item stays in its original position\", font_size=30)\n        derange_text.next_to(title, DOWN, buff=0.5)\n        self.play(Transform(perm_text, derange_text))\n        self.wait(1)\n        \n        # Deranged arrangement text\n        deranged_text = Text(\"A derangement:\", font_size=24)\n        deranged_text.to_edge(LEFT).shift(DOWN * 2.5)\n        self.play(Write(deranged_text))\n        \n        # Create new squares for deranged arrangement\n        deranged_squares = VGroup(\n            Square(fill_color=GREEN, fill_opacity=0.8),\n            Square(fill_color=BLUE, fill_opacity=0.8),\n            Square(fill_color=RED, fill_opacity=0.8)\n        ).arrange(RIGHT, buff=0.3).scale(0.5)\n        deranged_squares.next_to(deranged_text, RIGHT, buff=0.5)\n        \n        # Add labels to show how items moved (2,3,1 is a valid derangement of 1,2,3)\n        deranged_labels = VGroup(\n            Text(\"2\", font_size=24).move_to(deranged_squares[0].get_center()),\n            Text(\"3\", font_size=24).move_to(deranged_squares[1].get_center()),\n            Text(\"1\", font_size=24).move_to(deranged_squares[2].get_center())\n        )\n        \n        self.play(Create(deranged_squares), Write(deranged_labels))\n        self.wait(1)\n        \n        # Formula for counting derangements\n        formula = MathTex(r\"D(n) = n! \\sum_{i=0}^{n} \\frac{(-1)^i}{i!}\")\n        formula.next_to(deranged_squares, DOWN, buff=0.7)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Connection to chaos theory\n        chaos_text = Text(\"As n grows, derangements show chaotic patterns\", font_size=24)\n        chaos_text.next_to(formula, DOWN, buff=0.5)\n        self.play(Write(chaos_text))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(squares), FadeOut(labels), FadeOut(original_text),\n            FadeOut(deranged_squares), FadeOut(deranged_labels), FadeOut(deranged_text),\n            FadeOut(formula), FadeOut(perm_text), FadeOut(chaos_text)\n        )\n        \n        conclusion = Text(\"The beautiful dance between order and chaos\", font_size=30)\n        conclusion.next_to(title, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fadeout\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do the principles of chaos theory apply to the behavior of large derangements, and how can this be visualized through simulations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do the principles of chaos theory apply to the behavior of large derangements, and how can this be visualized through simulations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DerangementChaos(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dance of Permutations: Derangements & Chaos\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Permutation explanation\n        perm_text = Text(\"Permutations: ways to arrange items\", font_size=30)\n        perm_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(perm_text))\n        self.wait(1)\n        \n        # Original arrangement\n        original_text = Text(\"Original arrangement:\", font_size=24)\n        original_text.to_edge(LEFT).shift(DOWN)\n        self.play(Write(original_text))\n        \n        # Visual of objects - create colored squares for original arrangement\n        squares = VGroup(\n            Square(fill_color=RED, fill_opacity=0.8),\n            Square(fill_color=GREEN, fill_opacity=0.8),\n            Square(fill_color=BLUE, fill_opacity=0.8)\n        ).arrange(RIGHT, buff=0.3).scale(0.5)\n        squares.next_to(original_text, RIGHT, buff=0.5)\n        \n        # Add labels 1, 2, 3 to the squares\n        labels = VGroup(*[Text(str(i+1), font_size=24).move_to(square.get_center()) \n                        for i, square in enumerate(squares)])\n        \n        self.play(Create(squares), Write(labels))\n        self.wait(1)\n        \n        # Derangement explanation\n        derange_text = Text(\"Derangements: no item stays in its original position\", font_size=30)\n        derange_text.next_to(title, DOWN, buff=0.5)\n        self.play(Transform(perm_text, derange_text))\n        self.wait(1)\n        \n        # Deranged arrangement text\n        deranged_text = Text(\"A derangement:\", font_size=24)\n        deranged_text.to_edge(LEFT).shift(DOWN * 2.5)\n        self.play(Write(deranged_text))\n        \n        # Create new squares for deranged arrangement\n        deranged_squares = VGroup(\n            Square(fill_color=GREEN, fill_opacity=0.8),\n            Square(fill_color=BLUE, fill_opacity=0.8),\n            Square(fill_color=RED, fill_opacity=0.8)\n        ).arrange(RIGHT, buff=0.3).scale(0.5)\n        deranged_squares.next_to(deranged_text, RIGHT, buff=0.5)\n        \n        # Add labels to show how items moved (2,3,1 is a valid derangement of 1,2,3)\n        deranged_labels = VGroup(\n            Text(\"2\", font_size=24).move_to(deranged_squares[0].get_center()),\n            Text(\"3\", font_size=24).move_to(deranged_squares[1].get_center()),\n            Text(\"1\", font_size=24).move_to(deranged_squares[2].get_center())\n        )\n        \n        self.play(Create(deranged_squares), Write(deranged_labels))\n        self.wait(1)\n        \n        # Formula for counting derangements\n        formula = MathTex(r\"D(n) = n! \\sum_{i=0}^{n} \\frac{(-1)^i}{i!}\")\n        formula.next_to(deranged_squares, DOWN, buff=0.7)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Connection to chaos theory\n        chaos_text = Text(\"As n grows, derangements show chaotic patterns\", font_size=24)\n        chaos_text.next_to(formula, DOWN, buff=0.5)\n        self.play(Write(chaos_text))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(squares), FadeOut(labels), FadeOut(original_text),\n            FadeOut(deranged_squares), FadeOut(deranged_labels), FadeOut(deranged_text),\n            FadeOut(formula), FadeOut(perm_text), FadeOut(chaos_text)\n        )\n        \n        conclusion = Text(\"The beautiful dance between order and chaos\", font_size=30)\n        conclusion.next_to(title, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fadeout\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do the principles of chaos theory apply to the behavior of large derangements, and how can this be visualized through simulations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can Zorn's Lemma be applied to demonstrate that every vector space has a Hamel basis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ZornsLemmaBasic(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling Vector Spaces: Zorn's Lemma and the Journey to a Basis\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Can every vector space have a basis?\").scale(0.8)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Vector Space visualization\n        vectors = VGroup()\n        colors = [RED, GREEN, BLUE, YELLOW]\n        \n        for i in range(4):\n            angle = i * PI / 2\n            vector = Arrow(ORIGIN, 1.5 * (np.cos(angle), np.sin(angle), 0), buff=0, color=colors[i])\n            vectors.add(vector)\n        \n        vector_text = Text(\"Vector Space\").scale(0.8).next_to(vectors, UP)\n        self.play(Create(vectors), Write(vector_text))\n        self.wait(1)\n        \n        # Linear Independence\n        li_text = Text(\"Linearly Independent Sets\").scale(0.7).next_to(vectors, DOWN)\n        self.play(Write(li_text))\n        self.wait(1)\n        \n        # Chains visualization\n        self.play(FadeOut(vectors), FadeOut(li_text), FadeOut(vector_text))\n        \n        # Create circles to represent growing chains\n        circles = VGroup()\n        for i in range(1, 4):\n            circle = Circle(radius=i*0.5, color=BLUE)\n            circles.add(circle)\n        \n        chain_text = Text(\"Chains of linearly independent sets\").scale(0.8)\n        self.play(Write(chain_text))\n        self.wait(0.5)\n        \n        self.play(FadeOut(chain_text))\n        for i in range(3):\n            self.play(Create(circles[i]))\n            self.wait(0.3)\n        \n        # Zorn's Lemma\n        zorns = Text(\"Zorn's Lemma:\").scale(0.9)\n        self.play(Write(zorns))\n        self.wait(0.5)\n        \n        zorns_explain = Text(\"If every chain has an upper bound\\n\u2192 There exists a maximal element\").scale(0.7)\n        self.play(zorns.animate.to_edge(UP), Write(zorns_explain))\n        self.wait(1)\n        \n        # Application equation\n        self.play(FadeOut(zorns_explain), FadeOut(circles))\n        eq = Text(\"If S \u2286 V and S is maximal, then S is a basis for V\").scale(0.7)\n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(eq), FadeOut(zorns), FadeOut(title))\n        conclusion = Text(\"Every vector space has a Hamel basis!\").scale(0.9)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can Zorn's Lemma be applied to demonstrate that every vector space has a Hamel basis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can zorn's lemma be applied to demonstrate that every vector space has a hamel basis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ZornsLemmaBasic(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling Vector Spaces: Zorn's Lemma and the Journey to a Basis\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Can every vector space have a basis?\").scale(0.8)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Vector Space visualization\n        vectors = VGroup()\n        colors = [RED, GREEN, BLUE, YELLOW]\n        \n        for i in range(4):\n            angle = i * PI / 2\n            vector = Arrow(ORIGIN, 1.5 * (np.cos(angle), np.sin(angle), 0), buff=0, color=colors[i])\n            vectors.add(vector)\n        \n        vector_text = Text(\"Vector Space\").scale(0.8).next_to(vectors, UP)\n        self.play(Create(vectors), Write(vector_text))\n        self.wait(1)\n        \n        # Linear Independence\n        li_text = Text(\"Linearly Independent Sets\").scale(0.7).next_to(vectors, DOWN)\n        self.play(Write(li_text))\n        self.wait(1)\n        \n        # Chains visualization\n        self.play(FadeOut(vectors), FadeOut(li_text), FadeOut(vector_text))\n        \n        # Create circles to represent growing chains\n        circles = VGroup()\n        for i in range(1, 4):\n            circle = Circle(radius=i*0.5, color=BLUE)\n            circles.add(circle)\n        \n        chain_text = Text(\"Chains of linearly independent sets\").scale(0.8)\n        self.play(Write(chain_text))\n        self.wait(0.5)\n        \n        self.play(FadeOut(chain_text))\n        for i in range(3):\n            self.play(Create(circles[i]))\n            self.wait(0.3)\n        \n        # Zorn's Lemma\n        zorns = Text(\"Zorn's Lemma:\").scale(0.9)\n        self.play(Write(zorns))\n        self.wait(0.5)\n        \n        zorns_explain = Text(\"If every chain has an upper bound\\n\u2192 There exists a maximal element\").scale(0.7)\n        self.play(zorns.animate.to_edge(UP), Write(zorns_explain))\n        self.wait(1)\n        \n        # Application equation\n        self.play(FadeOut(zorns_explain), FadeOut(circles))\n        eq = Text(\"If S \u2286 V and S is maximal, then S is a basis for V\").scale(0.7)\n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(eq), FadeOut(zorns), FadeOut(title))\n        conclusion = Text(\"Every vector space has a Hamel basis!\").scale(0.9)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can Zorn's Lemma be applied to demonstrate that every vector space has a Hamel basis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "How can I create an animation using ManimCE where text transforms into the message \"animate.match_y\" and moves upward, followed by a dot and a star appearing on the screen, with the star moving vertically to align with the dot on the y-axis before both the star and the dot disappear?"}, {"from": "assistant", "value": "```python\nfrom manim import * \nimport numpy as np\n\nclass AllMObjects(ThreeDScene):\n    def construct(self):\n        t = Text(\"Manim Objects\")\n        t.shift(UP*2.5)\n\n        mobject_list = [\n            # Geometry\n            Annulus(),\n            AnnularSector(),\n            Arc(),\n            Circle(),\n            Dot(),\n            Ellipse(),\n            Arrow(),\n            Vector(),\n            Square(),\n            Star(),\n            Triangle(),\n            ArrowCircleTip(),\n            \n            # Frame\n            FullScreenRectangle(),\n            ScreenRectangle(),\n\n            # Graph\n            Graph(vertices=(1,2,3,4,5), edges=[(1,2), (1,3), (4,2), (3,5), (1,5)]),\n\n            # Graphing\n            Axes(),\n            ComplexPlane(),\n            CoordinateSystem(),\n            NumberPlane(),\n            FunctionGraph(lambda x: (-1.0*x)**2),\n            NumberLine(),\n            BarChart(values=[1,2,3,4,5]),\n\n            # Logo\n            ManimBanner(),\n\n            # Matrix\n            DecimalMatrix([[1.0,2.0],[3.0,4.0]]),\n            IntegerMatrix([[1,2],[3,4]]),\n            Matrix([[1,2],[3,4]]),\n            MobjectMatrix([[Circle(),Square()],[Star(),Triangle()]]),\n\n            # Table\n            DecimalTable([[1,2,3,4], [5,6,7,8]], row_labels=[Text(\"Row 1\"), Text(\"Row 2\")]),\n            MathTable([[\"+\", 0, 5, 10],[0, 0, 5, 10],[2, 2, 7, 12],[4, 4, 9, 14]],include_outer_lines=True),\n            MobjectTable( [ [Circle(), Square()] , [Triangle(), Star()] ] ),\n\n            # Text\n            Code(file_name=\"dummy.py\", language=\"Python\"),\n            DecimalNumber(5.5),\n            Integer(5),\n            BulletedList(\"Apple\", \"Pear\", \"Grape\"),\n            MathTex(r\"\\frac{a}{b} = x^{2}\"),\n            SingleStringMathTex(r\"\\frac{a}{b} = x^{2}\"),\n            Tex(\"Hello World\"),\n            Title(\"Here Is a Ttitle\"),\n            MarkupText('<span foreground=\"red\" size=\"x-large\">Red text</span> is <i>fire</i>!\"'),\n            Paragraph('There once was a man', 'that lived in a van', 'with only one right hand'),\n            Text(\"Here is Text\"),\n\n            # Types\n            Point(color=RED),\n            PointCloudDot(),\n        ]\n\n        mobject_list_3d = [\n            ThreeDAxes(),\n            Dodecahedron(),\n            Icosahedron(),\n            Octahedron(),\n            Tetrahedron(edge_length=2),\n            Arrow3D(),\n            Cone(),\n            Cube(),\n            Cylinder(),\n            Dot3D(),\n            Line3D(start=np.array([-3,-3,-3]), end=np.array([3,3,3])),\n            Prism(),\n            Sphere(),\n            Torus(),\n        ]\n\n        # Show all 2D MObjects\n        self.add(t)\n        self.wait(0.2)\n        for mobj in mobject_list:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(0.5)\n                self.remove(mobj)\n            except:\n                continue\n        \n        # Show all 3D MObjects\n        self.play(Transform(t,Text(\"Looking at 3D Mobjects...\").shift(UP*2.5)), run_time=0.5)\n        self.wait(1)\n\n        self.begin_3dillusion_camera_rotation(rate=4)\n        self.wait(2)\n\n        for mobj in mobject_list_3d:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(1)\n                self.remove(mobj)\n            except:\n                continue\n        self.play(FadeOut(t))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an animation using ManimCE where text transforms into the message \"animate.match_y\" and moves upward, followed by a dot and a star appearing on the screen, with the star moving vertically to align with the dot on the y-axis before both the star and the dot disappear?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that how can i create an animation using manimce where text transforms into the message \"animate.match_y\" and moves upward, followed by a dot and a star appearing on the screen, with the star moving vertically to align with the dot on the y-axis before both the star and the dot disappear?"}, {"from": "assistant", "value": "```python\nfrom manim import * \nimport numpy as np\n\nclass AllMObjects(ThreeDScene):\n    def construct(self):\n        t = Text(\"Manim Objects\")\n        t.shift(UP*2.5)\n\n        mobject_list = [\n            # Geometry\n            Annulus(),\n            AnnularSector(),\n            Arc(),\n            Circle(),\n            Dot(),\n            Ellipse(),\n            Arrow(),\n            Vector(),\n            Square(),\n            Star(),\n            Triangle(),\n            ArrowCircleTip(),\n            \n            # Frame\n            FullScreenRectangle(),\n            ScreenRectangle(),\n\n            # Graph\n            Graph(vertices=(1,2,3,4,5), edges=[(1,2), (1,3), (4,2), (3,5), (1,5)]),\n\n            # Graphing\n            Axes(),\n            ComplexPlane(),\n            CoordinateSystem(),\n            NumberPlane(),\n            FunctionGraph(lambda x: (-1.0*x)**2),\n            NumberLine(),\n            BarChart(values=[1,2,3,4,5]),\n\n            # Logo\n            ManimBanner(),\n\n            # Matrix\n            DecimalMatrix([[1.0,2.0],[3.0,4.0]]),\n            IntegerMatrix([[1,2],[3,4]]),\n            Matrix([[1,2],[3,4]]),\n            MobjectMatrix([[Circle(),Square()],[Star(),Triangle()]]),\n\n            # Table\n            DecimalTable([[1,2,3,4], [5,6,7,8]], row_labels=[Text(\"Row 1\"), Text(\"Row 2\")]),\n            MathTable([[\"+\", 0, 5, 10],[0, 0, 5, 10],[2, 2, 7, 12],[4, 4, 9, 14]],include_outer_lines=True),\n            MobjectTable( [ [Circle(), Square()] , [Triangle(), Star()] ] ),\n\n            # Text\n            Code(file_name=\"dummy.py\", language=\"Python\"),\n            DecimalNumber(5.5),\n            Integer(5),\n            BulletedList(\"Apple\", \"Pear\", \"Grape\"),\n            MathTex(r\"\\frac{a}{b} = x^{2}\"),\n            SingleStringMathTex(r\"\\frac{a}{b} = x^{2}\"),\n            Tex(\"Hello World\"),\n            Title(\"Here Is a Ttitle\"),\n            MarkupText('<span foreground=\"red\" size=\"x-large\">Red text</span> is <i>fire</i>!\"'),\n            Paragraph('There once was a man', 'that lived in a van', 'with only one right hand'),\n            Text(\"Here is Text\"),\n\n            # Types\n            Point(color=RED),\n            PointCloudDot(),\n        ]\n\n        mobject_list_3d = [\n            ThreeDAxes(),\n            Dodecahedron(),\n            Icosahedron(),\n            Octahedron(),\n            Tetrahedron(edge_length=2),\n            Arrow3D(),\n            Cone(),\n            Cube(),\n            Cylinder(),\n            Dot3D(),\n            Line3D(start=np.array([-3,-3,-3]), end=np.array([3,3,3])),\n            Prism(),\n            Sphere(),\n            Torus(),\n        ]\n\n        # Show all 2D MObjects\n        self.add(t)\n        self.wait(0.2)\n        for mobj in mobject_list:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(0.5)\n                self.remove(mobj)\n            except:\n                continue\n        \n        # Show all 3D MObjects\n        self.play(Transform(t,Text(\"Looking at 3D Mobjects...\").shift(UP*2.5)), run_time=0.5)\n        self.wait(1)\n\n        self.begin_3dillusion_camera_rotation(rate=4)\n        self.wait(2)\n\n        for mobj in mobject_list_3d:\n            try:\n                self.play(Transform(t,Text(mobj.name).shift(UP*2.5)), FadeIn(mobj), run_time=0.5)\n                self.wait(1)\n                self.remove(mobj)\n            except:\n                continue\n        self.play(FadeOut(t))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an animation using ManimCE where text transforms into the message \"animate.match_y\" and moves upward, followed by a dot and a star appearing on the screen, with the star moving vertically to align with the dot on the y-axis before both the star and the dot disappear?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a group of 15 blue dots randomly scattered and slightly shifted upward. Below them, a red copy of the same dots is shown, but this time the dots are neatly arranged in a row using default spacing. Both groups are centered on the screen, with the blue dots above and the red dots below."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArrangeSumobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n        s.shift(UP).set_color(BLUE)\n        s2= s.copy().set_color(RED)\n        s2.arrange_submobjects()\n        s2.shift(DOWN)\n        self.add(s,s2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a group of 15 blue dots randomly scattered and slightly shifted upward. Below them, a red copy of the same dots is shown, but this time the dots are neatly arranged in a row using default spacing. Both groups are centered on the screen, with the blue dots above and the red dots below."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a group of 15 blue dots randomly scattered and slightly shifted upward. below them, a red copy of the same dots is shown, but this time the dots are neatly arranged in a row using default spacing. both groups are centered on the screen, with the blue dots above and the red dots below."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArrangeSumobjectsExample(Scene):\n    def construct(self):\n        s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n        s.shift(UP).set_color(BLUE)\n        s2= s.copy().set_color(RED)\n        s2.arrange_submobjects()\n        s2.shift(DOWN)\n        self.add(s,s2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a group of 15 blue dots randomly scattered and slightly shifted upward. Below them, a red copy of the same dots is shown, but this time the dots are neatly arranged in a row using default spacing. Both groups are centered on the screen, with the blue dots above and the red dots below."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 3D coordinate system with three colored dots placed at specific positions:\n\n1. A red dot located at the point (0, 0, 1), one unit above the origin along the Z-axis.\n2. A blue dot with a smaller radius positioned at (2, 0, 0), two units along the X-axis.\n3. An orange dot, also with a smaller radius, placed at the origin (0, 0, 0).\n\nThe camera is angled at 75\u00b0 vertically and -45\u00b0 horizontally, providing a clear, tilted view of the 3D space and the relative positions of the dots."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Dot3DExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n        axes = ThreeDAxes()\n        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\n        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\n        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\n        self.add(axes, dot_1, dot_2,dot_3)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D coordinate system with three colored dots placed at specific positions:\n\n1. A red dot located at the point (0, 0, 1), one unit above the origin along the Z-axis.\n2. A blue dot with a smaller radius positioned at (2, 0, 0), two units along the X-axis.\n3. An orange dot, also with a smaller radius, placed at the origin (0, 0, 0).\n\nThe camera is angled at 75\u00b0 vertically and -45\u00b0 horizontally, providing a clear, tilted view of the 3D space and the relative positions of the dots."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 3d coordinate system with three colored dots placed at specific positions:\n\n1. a red dot located at the point (0, 0, 1), one unit above the origin along the z-axis.\n2. a blue dot with a smaller radius positioned at (2, 0, 0), two units along the x-axis.\n3. an orange dot, also with a smaller radius, placed at the origin (0, 0, 0).\n\nthe camera is angled at 75\u00b0 vertically and -45\u00b0 horizontally, providing a clear, tilted view of the 3d space and the relative positions of the dots."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Dot3DExample(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n        axes = ThreeDAxes()\n        dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\n        dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\n        dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\n        self.add(axes, dot_1, dot_2,dot_3)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D coordinate system with three colored dots placed at specific positions:\n\n1. A red dot located at the point (0, 0, 1), one unit above the origin along the Z-axis.\n2. A blue dot with a smaller radius positioned at (2, 0, 0), two units along the X-axis.\n3. An orange dot, also with a smaller radius, placed at the origin (0, 0, 0).\n\nThe camera is angled at 75\u00b0 vertically and -45\u00b0 horizontally, providing a clear, tilted view of the 3D space and the relative positions of the dots."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can any two non-isomorphic graphs share the same multisets of subgraphs, and how can these be visually distinguished?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphReconstructionScene(Scene):\n    def construct(self):\n        # Title card\n        title = Text(\"Unraveling Graph Reconstruction\", font_size=36, color=BLUE)\n        subtitle = Text(\"A Visual Adventure\", font_size=24, color=BLUE_B).next_to(title, DOWN)\n        title_group = VGroup(title, subtitle)\n        \n        self.play(Write(title_group))\n        self.wait(1)\n        self.play(FadeOut(title_group))\n        \n        # Two non-isomorphic graphs side by side\n        # Graph 1: A path with 3 nodes\n        g1_v1 = Dot(point=np.array([-2, 1, 0]), color=BLUE_C)\n        g1_v2 = Dot(point=np.array([-1, 1, 0]), color=BLUE_C)\n        g1_v3 = Dot(point=np.array([0, 1, 0]), color=BLUE_C)\n        g1_e1 = Line(g1_v1.get_center(), g1_v2.get_center(), color=BLUE)\n        g1_e2 = Line(g1_v2.get_center(), g1_v3.get_center(), color=BLUE)\n        \n        g1 = VGroup(g1_v1, g1_v2, g1_v3, g1_e1, g1_e2)\n        g1_label = Text(\"Graph 1: Path\", font_size=24, color=BLUE_D).next_to(g1, DOWN)\n        \n        # Graph 2: A star with 3 nodes\n        g2_v1 = Dot(point=np.array([2, 1, 0]), color=GREEN_C)  # Center\n        g2_v2 = Dot(point=np.array([1, 1, 0]), color=GREEN_C)  # Left\n        g2_v3 = Dot(point=np.array([3, 1, 0]), color=GREEN_C)  # Right\n        g2_e1 = Line(g2_v1.get_center(), g2_v2.get_center(), color=GREEN)\n        g2_e2 = Line(g2_v1.get_center(), g2_v3.get_center(), color=GREEN)\n        \n        g2 = VGroup(g2_v1, g2_v2, g2_v3, g2_e1, g2_e2)\n        g2_label = Text(\"Graph 2: Star\", font_size=24, color=GREEN_D).next_to(g2, DOWN)\n        \n        # Display both graphs\n        self.play(Create(g1), Write(g1_label))\n        self.play(Create(g2), Write(g2_label))\n        self.wait(1)\n        \n        # Question about subgraphs\n        question = Text(\"Can these graphs share the same subgraphs?\", font_size=28, color=PURPLE)\n        self.play(FadeOut(g1_label), FadeOut(g2_label))\n        self.play(g1.animate.shift(UP), g2.animate.shift(UP))\n        self.play(Write(question.shift(DOWN*1.5)))\n        self.wait(1)\n        \n        # First equation\n        eq1 = MathTex(r\"G_1 \\cup G_2 = \\{subgraphs\\}\", color=PURPLE_B).shift(DOWN*3)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Key insight\n        self.play(FadeOut(question), FadeOut(eq1))\n        key_insight = Text(\"Key Insight: Non-isomorphic graphs have unique subgraph patterns\", \n                          font_size=24, color=YELLOW).shift(DOWN*1.5)\n        self.play(Write(key_insight))\n        self.wait(1)\n        \n        # Second equation\n        eq2 = MathTex(r\"G_1 \\not\\cong G_2 \\Rightarrow f(G_1) \\neq f(G_2)\", color=YELLOW_B).shift(DOWN*3)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(key_insight), FadeOut(eq2), FadeOut(g1), FadeOut(g2))\n        \n        conclusion = Text(\"Graph reconstruction reveals hidden structures\", \n                        font_size=28, color=PURPLE_A)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))\n        \n        # Final title\n        final_title = Text(\"Unraveling Graph Reconstruction\", font_size=36, color=BLUE)\n        final_subtitle = Text(\"A Visual Adventure\", font_size=24, color=BLUE_B).next_to(final_title, DOWN)\n        final_group = VGroup(final_title, final_subtitle)\n        \n        self.play(Write(final_group))\n        self.wait(1)\n        self.play(FadeOut(final_group))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can any two non-isomorphic graphs share the same multisets of subgraphs, and how can these be visually distinguished?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can any two non-isomorphic graphs share the same multisets of subgraphs, and how can these be visually distinguished?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphReconstructionScene(Scene):\n    def construct(self):\n        # Title card\n        title = Text(\"Unraveling Graph Reconstruction\", font_size=36, color=BLUE)\n        subtitle = Text(\"A Visual Adventure\", font_size=24, color=BLUE_B).next_to(title, DOWN)\n        title_group = VGroup(title, subtitle)\n        \n        self.play(Write(title_group))\n        self.wait(1)\n        self.play(FadeOut(title_group))\n        \n        # Two non-isomorphic graphs side by side\n        # Graph 1: A path with 3 nodes\n        g1_v1 = Dot(point=np.array([-2, 1, 0]), color=BLUE_C)\n        g1_v2 = Dot(point=np.array([-1, 1, 0]), color=BLUE_C)\n        g1_v3 = Dot(point=np.array([0, 1, 0]), color=BLUE_C)\n        g1_e1 = Line(g1_v1.get_center(), g1_v2.get_center(), color=BLUE)\n        g1_e2 = Line(g1_v2.get_center(), g1_v3.get_center(), color=BLUE)\n        \n        g1 = VGroup(g1_v1, g1_v2, g1_v3, g1_e1, g1_e2)\n        g1_label = Text(\"Graph 1: Path\", font_size=24, color=BLUE_D).next_to(g1, DOWN)\n        \n        # Graph 2: A star with 3 nodes\n        g2_v1 = Dot(point=np.array([2, 1, 0]), color=GREEN_C)  # Center\n        g2_v2 = Dot(point=np.array([1, 1, 0]), color=GREEN_C)  # Left\n        g2_v3 = Dot(point=np.array([3, 1, 0]), color=GREEN_C)  # Right\n        g2_e1 = Line(g2_v1.get_center(), g2_v2.get_center(), color=GREEN)\n        g2_e2 = Line(g2_v1.get_center(), g2_v3.get_center(), color=GREEN)\n        \n        g2 = VGroup(g2_v1, g2_v2, g2_v3, g2_e1, g2_e2)\n        g2_label = Text(\"Graph 2: Star\", font_size=24, color=GREEN_D).next_to(g2, DOWN)\n        \n        # Display both graphs\n        self.play(Create(g1), Write(g1_label))\n        self.play(Create(g2), Write(g2_label))\n        self.wait(1)\n        \n        # Question about subgraphs\n        question = Text(\"Can these graphs share the same subgraphs?\", font_size=28, color=PURPLE)\n        self.play(FadeOut(g1_label), FadeOut(g2_label))\n        self.play(g1.animate.shift(UP), g2.animate.shift(UP))\n        self.play(Write(question.shift(DOWN*1.5)))\n        self.wait(1)\n        \n        # First equation\n        eq1 = MathTex(r\"G_1 \\cup G_2 = \\{subgraphs\\}\", color=PURPLE_B).shift(DOWN*3)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Key insight\n        self.play(FadeOut(question), FadeOut(eq1))\n        key_insight = Text(\"Key Insight: Non-isomorphic graphs have unique subgraph patterns\", \n                          font_size=24, color=YELLOW).shift(DOWN*1.5)\n        self.play(Write(key_insight))\n        self.wait(1)\n        \n        # Second equation\n        eq2 = MathTex(r\"G_1 \\not\\cong G_2 \\Rightarrow f(G_1) \\neq f(G_2)\", color=YELLOW_B).shift(DOWN*3)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(key_insight), FadeOut(eq2), FadeOut(g1), FadeOut(g2))\n        \n        conclusion = Text(\"Graph reconstruction reveals hidden structures\", \n                        font_size=28, color=PURPLE_A)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))\n        \n        # Final title\n        final_title = Text(\"Unraveling Graph Reconstruction\", font_size=36, color=BLUE)\n        final_subtitle = Text(\"A Visual Adventure\", font_size=24, color=BLUE_B).next_to(final_title, DOWN)\n        final_group = VGroup(final_title, final_subtitle)\n        \n        self.play(Write(final_group))\n        self.wait(1)\n        self.play(FadeOut(final_group))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can any two non-isomorphic graphs share the same multisets of subgraphs, and how can these be visually distinguished?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like to create an educational animation that teaches algebra through the visual illustration of a simple equation solving process. The animation should start with a representation of an unknown value multiplied by 6 to equal 24, then gradually reveal that the unknown value is 4. I want the animation to include visual elements such as images, along with the text of the equations.\n\nThe unknown value should initially be represented by a visual placeholder image, then in subsequent steps by the letter 'a' highlighted in orange, and finally, it should be revealed to be the number 4, again highlighted in orange. I want each step of the equation to appear one after the other by shifting into view, and then transform smoothly into the next step.\n\nOnce the value of the unknown is found, both the image with the equation and the equation in the text form, which proves that 'a' is equal to 4, should appear with a special spinning effect. After the final result is shown, all elements should shift out of view to conclude the animation.\n\nFor the color scheme, let's use a light beige for the background, and various colors like light red, green, blue, etc., for other elements as per a provided color palette. The final animation should be in a portrait format, suitable for viewing on a smartphone screen.\n\nCan you create this animation that visually demonstrates the process of solving the equation \"a times 6 equals 24\" to find out that 'a' is equal to 4, using engaging visual and transformation effects?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iiint_V x^2 y^2 z \\,dV\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for z integral\n        explanation1 = Text(\"Integrate with respect to z first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Z integral step\n        z_integral = MathTex(r\"= \\iint_A x^2 y^2 \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dA\")\n        self.play(ReplacementTransform(problem.copy(), z_integral))\n        self.wait(1)\n\n        # Explanation for y integral\n        explanation2 = Text(\"Then, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Y integral step\n        y_integral = MathTex(r\"= \\int_B x^2 \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dx\")\n        self.play(ReplacementTransform(z_integral, y_integral))\n        self.wait(1)\n\n        # Explanation for x integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # X integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}x^4\\right]_{x_1}^{x_2} \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}\")\n        self.play(ReplacementTransform(y_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an educational animation that teaches algebra through the visual illustration of a simple equation solving process. The animation should start with a representation of an unknown value multiplied by 6 to equal 24, then gradually reveal that the unknown value is 4. I want the animation to include visual elements such as images, along with the text of the equations.\n\nThe unknown value should initially be represented by a visual placeholder image, then in subsequent steps by the letter 'a' highlighted in orange, and finally, it should be revealed to be the number 4, again highlighted in orange. I want each step of the equation to appear one after the other by shifting into view, and then transform smoothly into the next step.\n\nOnce the value of the unknown is found, both the image with the equation and the equation in the text form, which proves that 'a' is equal to 4, should appear with a special spinning effect. After the final result is shown, all elements should shift out of view to conclude the animation.\n\nFor the color scheme, let's use a light beige for the background, and various colors like light red, green, blue, etc., for other elements as per a provided color palette. The final animation should be in a portrait format, suitable for viewing on a smartphone screen.\n\nCan you create this animation that visually demonstrates the process of solving the equation \"a times 6 equals 24\" to find out that 'a' is equal to 4, using engaging visual and transformation effects?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like to create an educational animation that teaches algebra through the visual illustration of a simple equation solving process. the animation should start with a representation of an unknown value multiplied by 6 to equal 24, then gradually reveal that the unknown value is 4. i want the animation to include visual elements such as images, along with the text of the equations.\n\nthe unknown value should initially be represented by a visual placeholder image, then in subsequent steps by the letter 'a' highlighted in orange, and finally, it should be revealed to be the number 4, again highlighted in orange. i want each step of the equation to appear one after the other by shifting into view, and then transform smoothly into the next step.\n\nonce the value of the unknown is found, both the image with the equation and the equation in the text form, which proves that 'a' is equal to 4, should appear with a special spinning effect. after the final result is shown, all elements should shift out of view to conclude the animation.\n\nfor the color scheme, let's use a light beige for the background, and various colors like light red, green, blue, etc., for other elements as per a provided color palette. the final animation should be in a portrait format, suitable for viewing on a smartphone screen.\n\ncan you create this animation that visually demonstrates the process of solving the equation \"a times 6 equals 24\" to find out that 'a' is equal to 4, using engaging visual and transformation effects?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iiint_V x^2 y^2 z \\,dV\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for z integral\n        explanation1 = Text(\"Integrate with respect to z first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Z integral step\n        z_integral = MathTex(r\"= \\iint_A x^2 y^2 \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dA\")\n        self.play(ReplacementTransform(problem.copy(), z_integral))\n        self.wait(1)\n\n        # Explanation for y integral\n        explanation2 = Text(\"Then, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Y integral step\n        y_integral = MathTex(r\"= \\int_B x^2 \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}dx\")\n        self.play(ReplacementTransform(z_integral, y_integral))\n        self.wait(1)\n\n        # Explanation for x integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # X integral step and final solution\n        final_solution = MathTex(r\"= \\left[\\frac{1}{4}x^4\\right]_{x_1}^{x_2} \\left[\\frac{1}{3}y^3\\right]_{y_1}^{y_2} \\left[\\frac{1}{2}z^2\\right]_{z_1}^{z_2}\")\n        self.play(ReplacementTransform(y_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an educational animation that teaches algebra through the visual illustration of a simple equation solving process. The animation should start with a representation of an unknown value multiplied by 6 to equal 24, then gradually reveal that the unknown value is 4. I want the animation to include visual elements such as images, along with the text of the equations.\n\nThe unknown value should initially be represented by a visual placeholder image, then in subsequent steps by the letter 'a' highlighted in orange, and finally, it should be revealed to be the number 4, again highlighted in orange. I want each step of the equation to appear one after the other by shifting into view, and then transform smoothly into the next step.\n\nOnce the value of the unknown is found, both the image with the equation and the equation in the text form, which proves that 'a' is equal to 4, should appear with a special spinning effect. After the final result is shown, all elements should shift out of view to conclude the animation.\n\nFor the color scheme, let's use a light beige for the background, and various colors like light red, green, blue, etc., for other elements as per a provided color palette. The final animation should be in a portrait format, suitable for viewing on a smartphone screen.\n\nCan you create this animation that visually demonstrates the process of solving the equation \"a times 6 equals 24\" to find out that 'a' is equal to 4, using engaging visual and transformation effects?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a polar coordinate grid, then plot an orange polar graph defined by the equation \\( r = 2\\sin(5\\theta) \\). The resulting curve forms a five-petaled rose pattern, symmetrically arranged around the origin."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolarGraphExample(Scene):\n    def construct(self):\n        plane = PolarPlane()\n        r = lambda theta: 2 * np.sin(theta * 5)\n        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\n        self.add(plane, graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a polar coordinate grid, then plot an orange polar graph defined by the equation \\( r = 2\\sin(5\\theta) \\). The resulting curve forms a five-petaled rose pattern, symmetrically arranged around the origin."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a polar coordinate grid, then plot an orange polar graph defined by the equation \\( r = 2\\sin(5\\theta) \\). the resulting curve forms a five-petaled rose pattern, symmetrically arranged around the origin."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolarGraphExample(Scene):\n    def construct(self):\n        plane = PolarPlane()\n        r = lambda theta: 2 * np.sin(theta * 5)\n        graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\n        self.add(plane, graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a polar coordinate grid, then plot an orange polar graph defined by the equation \\( r = 2\\sin(5\\theta) \\). The resulting curve forms a five-petaled rose pattern, symmetrically arranged around the origin."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visualizes the movement of different molecular particles. Could you show an electron, a metal atom, a positively charged ion, and a negatively charged ion lining up next to each other and then moving in different directions? The electron should move upwards, the metal atom should move downwards, the positively charged ion should go to the left, and the negatively charged ion should go to the right. After moving to their new positions, I'd like all the particles to fade away. Can you create this animation in such a way that a viewer with no background in chemistry or physics can understand it?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_width\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_width(5))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visualizes the movement of different molecular particles. Could you show an electron, a metal atom, a positively charged ion, and a negatively charged ion lining up next to each other and then moving in different directions? The electron should move upwards, the metal atom should move downwards, the positively charged ion should go to the left, and the negatively charged ion should go to the right. After moving to their new positions, I'd like all the particles to fade away. Can you create this animation in such a way that a viewer with no background in chemistry or physics can understand it?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visualizes the movement of different molecular particles. could you show an electron, a metal atom, a positively charged ion, and a negatively charged ion lining up next to each other and then moving in different directions? the electron should move upwards, the metal atom should move downwards, the positively charged ion should go to the left, and the negatively charged ion should go to the right. after moving to their new positions, i'd like all the particles to fade away. can you create this animation in such a way that a viewer with no background in chemistry or physics can understand it?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_width\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_width(5))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visualizes the movement of different molecular particles. Could you show an electron, a metal atom, a positively charged ion, and a negatively charged ion lining up next to each other and then moving in different directions? The electron should move upwards, the metal atom should move downwards, the positively charged ion should go to the left, and the negatively charged ion should go to the right. After moving to their new positions, I'd like all the particles to fade away. Can you create this animation in such a way that a viewer with no background in chemistry or physics can understand it?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that demonstrates the process of evaluating the Gaussian integral using the substitution of polar coordinates, ending with the final result of the square root of pi? The animation should start by showing the problem on the integral of e to the power of negative x squared from negative infinity to infinity, followed by each step that includes explaining the switch to polar coordinates, setting up the integral in polar form over a circular region, carrying out the integration in polar coordinates, and then taking the square root of the result. Each step should be presented clearly with explanations and transformations of the mathematical expressions, and a pause at each step to let the viewers understand. Finally, the animation should clear the previous steps and conclude by emphasizing the final solution."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(2)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(2)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[1]))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that demonstrates the process of evaluating the Gaussian integral using the substitution of polar coordinates, ending with the final result of the square root of pi? The animation should start by showing the problem on the integral of e to the power of negative x squared from negative infinity to infinity, followed by each step that includes explaining the switch to polar coordinates, setting up the integral in polar form over a circular region, carrying out the integration in polar coordinates, and then taking the square root of the result. Each step should be presented clearly with explanations and transformations of the mathematical expressions, and a pause at each step to let the viewers understand. Finally, the animation should clear the previous steps and conclude by emphasizing the final solution."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that demonstrates the process of evaluating the gaussian integral using the substitution of polar coordinates, ending with the final result of the square root of pi? the animation should start by showing the problem on the integral of e to the power of negative x squared from negative infinity to infinity, followed by each step that includes explaining the switch to polar coordinates, setting up the integral in polar form over a circular region, carrying out the integration in polar coordinates, and then taking the square root of the result. each step should be presented clearly with explanations and transformations of the mathematical expressions, and a pause at each step to let the viewers understand. finally, the animation should clear the previous steps and conclude by emphasizing the final solution."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        innermost_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), innermost_integral))\n        self.wait(2)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(innermost_integral, middle_integral))\n        self.wait(2)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outer integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4}z^2]_{0}^{1}\", r\"= \\frac{1}{4}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution[1]))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that demonstrates the process of evaluating the Gaussian integral using the substitution of polar coordinates, ending with the final result of the square root of pi? The animation should start by showing the problem on the integral of e to the power of negative x squared from negative infinity to infinity, followed by each step that includes explaining the switch to polar coordinates, setting up the integral in polar form over a circular region, carrying out the integration in polar coordinates, and then taking the square root of the result. Each step should be presented clearly with explanations and transformations of the mathematical expressions, and a pause at each step to let the viewers understand. Finally, the animation should clear the previous steps and conclude by emphasizing the final solution."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a graph with eight labeled nodes arranged in a circular layout. Node 7 is highlighted in red, and three edges connected to it\u2014(1, 7), (2, 7), and (4, 7)\u2014are also colored red to emphasize its connections. The rest of the graph uses default styling, and all nodes are evenly spaced around the circle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with eight labeled nodes arranged in a circular layout. Node 7 is highlighted in red, and three edges connected to it\u2014(1, 7), (2, 7), and (4, 7)\u2014are also colored red to emphasize its connections. The rest of the graph uses default styling, and all nodes are evenly spaced around the circle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a graph with eight labeled nodes arranged in a circular layout. node 7 is highlighted in red, and three edges connected to it\u2014(1, 7), (2, 7), and (4, 7)\u2014are also colored red to emphasize its connections. the rest of the graph uses default styling, and all nodes are evenly spaced around the circle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LabeledModifiedGraph(Scene):\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n        edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                 (2, 8), (3, 4), (6, 1), (6, 2),\n                 (6, 3), (7, 2), (7, 4)]\n        g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                  labels=True, vertex_config={7: {\"fill_color\": RED}},\n                  edge_config={(1, 7): {\"stroke_color\": RED},\n                               (2, 7): {\"stroke_color\": RED},\n                               (4, 7): {\"stroke_color\": RED}})\n        self.add(g)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with eight labeled nodes arranged in a circular layout. Node 7 is highlighted in red, and three edges connected to it\u2014(1, 7), (2, 7), and (4, 7)\u2014are also colored red to emphasize its connections. The rest of the graph uses default styling, and all nodes are evenly spaced around the circle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a directed graph with five labeled nodes arranged in a circular layout. Arrows connect the nodes according to specified edges, with all edges styled using thin lines and square arrow tips. One specific edge, from node 3 to node 4, is highlighted in red and features a larger, more prominent arrow tip. The entire graph scales up slightly as it is drawn onto the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CustomDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\n                \"tip_shape\": ArrowSquareTip,\n                \"tip_length\": 0.15,\n            },\n            (3, 4): {\n                \"color\": RED,\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n            },\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a directed graph with five labeled nodes arranged in a circular layout. Arrows connect the nodes according to specified edges, with all edges styled using thin lines and square arrow tips. One specific edge, from node 3 to node 4, is highlighted in red and features a larger, more prominent arrow tip. The entire graph scales up slightly as it is drawn onto the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a directed graph with five labeled nodes arranged in a circular layout. arrows connect the nodes according to specified edges, with all edges styled using thin lines and square arrow tips. one specific edge, from node 3 to node 4, is highlighted in red and features a larger, more prominent arrow tip. the entire graph scales up slightly as it is drawn onto the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CustomDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\n                \"tip_shape\": ArrowSquareTip,\n                \"tip_length\": 0.15,\n            },\n            (3, 4): {\n                \"color\": RED,\n                \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n            },\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a directed graph with five labeled nodes arranged in a circular layout. Arrows connect the nodes according to specified edges, with all edges styled using thin lines and square arrow tips. One specific edge, from node 3 to node 4, is highlighted in red and features a larger, more prominent arrow tip. The entire graph scales up slightly as it is drawn onto the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can we interpret the Riemann curvature tensor as a measure of tidal forces in a gravitational field?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RiemannTensorTidalForces(Scene):\n    def construct(self):\n        # Set background color to dark blue for cosmic feel\n        self.camera.background_color = \"#0C0E30\"\n        \n        # Title\n        title = Text(\"Whispers of the Cosmos: Decoding Tidal Forces\", color=WHITE, font_size=32)\n        subtitle = Text(\"with Tensor Calculus\", color=WHITE, font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Lake with ripple animation - Element 1\n        lake = Circle(radius=2, color=BLUE_B).set_fill(BLUE, opacity=0.2)\n        ripple = Circle(radius=1, color=BLUE_A).set_fill(opacity=0)\n        \n        lake_text = Text(\"Ripples representing tidal forces\", color=WHITE, font_size=24)\n        lake_text.to_edge(UP)\n        \n        self.play(Create(lake), Write(lake_text))\n        self.play(Create(ripple))\n        self.play(ripple.animate.scale(2))\n        self.wait(1)\n        self.play(FadeOut(ripple), FadeOut(lake_text), FadeOut(lake))\n        \n        # Spacetime as rubber sheet - Element 3\n        grid = NumberPlane(\n            background_line_style={\"stroke_color\": BLUE_D, \"stroke_opacity\": 0.6}\n        ).scale(0.8)\n        \n        mass = Circle(radius=0.5, color=YELLOW).set_fill(YELLOW, opacity=1)\n        \n        spacetime_text = Text(\"Spacetime with a massive object\", color=WHITE, font_size=24)\n        spacetime_text.to_edge(UP)\n        \n        self.play(Create(grid), Write(spacetime_text))\n        self.play(Create(mass))\n        self.wait(1)\n        \n        # Object following path - Element 3 continued\n        path = Arrow(start=[-2, 2, 0], end=[0, -1, 0], color=RED).set_stroke(width=4)\n        path_text = Text(\"Object following curved path\", color=WHITE, font_size=24)\n        path_text.to_edge(UP)\n        \n        self.play(FadeOut(spacetime_text))\n        self.play(Create(path), Write(path_text))\n        self.wait(1)\n        \n        # Riemann tensor equation - Element 4\n        self.play(FadeOut(grid), FadeOut(mass), FadeOut(path), FadeOut(path_text))\n        \n        riemann_text = Text(\"The Riemann curvature tensor:\", color=WHITE, font_size=24)\n        riemann_text.to_edge(UP)\n        \n        # Simplified first display\n        simple_eq = MathTex(\n            r\"R^\\rho_{\\sigma\\mu\\nu}\", r\"=\", r\"\\text{measure of tidal forces}\",\n            color=WHITE\n        )\n        \n        self.play(Write(riemann_text))\n        self.play(Write(simple_eq))\n        self.wait(1)\n        \n        # Full equation\n        full_eq = MathTex(\n            r\"R^\\rho_{\\sigma\\mu\\nu} = \\partial_\\mu \\Gamma^\\rho_{\\nu\\sigma} - \\partial_\\nu \\Gamma^\\rho_{\\mu\\sigma} + \\Gamma^\\rho_{\\mu\\lambda} \\Gamma^\\lambda_{\\nu\\sigma} - \\Gamma^\\rho_{\\nu\\lambda} \\Gamma^\\lambda_{\\mu\\sigma}\",\n            color=WHITE\n        )\n        \n        self.play(Transform(simple_eq, full_eq))\n        self.wait(2)\n        \n        # Conclusion - Element 6\n        self.play(FadeOut(simple_eq), FadeOut(riemann_text))\n        \n        conclusion = Text(\"Measures how tidal forces vary in spacetime\", color=WHITE, font_size=28)\n        final_message = Text(\"Whispers of the cosmos, encoded in tensor calculus\", color=WHITE, font_size=24)\n        final_message.next_to(conclusion, DOWN, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(Write(final_message))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(final_message))\n\n# To run and save this animation:\n# manim -pql -o video.mp4 your_script.py RiemannTensorTidalForces\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we interpret the Riemann curvature tensor as a measure of tidal forces in a gravitational field?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can we interpret the riemann curvature tensor as a measure of tidal forces in a gravitational field?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RiemannTensorTidalForces(Scene):\n    def construct(self):\n        # Set background color to dark blue for cosmic feel\n        self.camera.background_color = \"#0C0E30\"\n        \n        # Title\n        title = Text(\"Whispers of the Cosmos: Decoding Tidal Forces\", color=WHITE, font_size=32)\n        subtitle = Text(\"with Tensor Calculus\", color=WHITE, font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Lake with ripple animation - Element 1\n        lake = Circle(radius=2, color=BLUE_B).set_fill(BLUE, opacity=0.2)\n        ripple = Circle(radius=1, color=BLUE_A).set_fill(opacity=0)\n        \n        lake_text = Text(\"Ripples representing tidal forces\", color=WHITE, font_size=24)\n        lake_text.to_edge(UP)\n        \n        self.play(Create(lake), Write(lake_text))\n        self.play(Create(ripple))\n        self.play(ripple.animate.scale(2))\n        self.wait(1)\n        self.play(FadeOut(ripple), FadeOut(lake_text), FadeOut(lake))\n        \n        # Spacetime as rubber sheet - Element 3\n        grid = NumberPlane(\n            background_line_style={\"stroke_color\": BLUE_D, \"stroke_opacity\": 0.6}\n        ).scale(0.8)\n        \n        mass = Circle(radius=0.5, color=YELLOW).set_fill(YELLOW, opacity=1)\n        \n        spacetime_text = Text(\"Spacetime with a massive object\", color=WHITE, font_size=24)\n        spacetime_text.to_edge(UP)\n        \n        self.play(Create(grid), Write(spacetime_text))\n        self.play(Create(mass))\n        self.wait(1)\n        \n        # Object following path - Element 3 continued\n        path = Arrow(start=[-2, 2, 0], end=[0, -1, 0], color=RED).set_stroke(width=4)\n        path_text = Text(\"Object following curved path\", color=WHITE, font_size=24)\n        path_text.to_edge(UP)\n        \n        self.play(FadeOut(spacetime_text))\n        self.play(Create(path), Write(path_text))\n        self.wait(1)\n        \n        # Riemann tensor equation - Element 4\n        self.play(FadeOut(grid), FadeOut(mass), FadeOut(path), FadeOut(path_text))\n        \n        riemann_text = Text(\"The Riemann curvature tensor:\", color=WHITE, font_size=24)\n        riemann_text.to_edge(UP)\n        \n        # Simplified first display\n        simple_eq = MathTex(\n            r\"R^\\rho_{\\sigma\\mu\\nu}\", r\"=\", r\"\\text{measure of tidal forces}\",\n            color=WHITE\n        )\n        \n        self.play(Write(riemann_text))\n        self.play(Write(simple_eq))\n        self.wait(1)\n        \n        # Full equation\n        full_eq = MathTex(\n            r\"R^\\rho_{\\sigma\\mu\\nu} = \\partial_\\mu \\Gamma^\\rho_{\\nu\\sigma} - \\partial_\\nu \\Gamma^\\rho_{\\mu\\sigma} + \\Gamma^\\rho_{\\mu\\lambda} \\Gamma^\\lambda_{\\nu\\sigma} - \\Gamma^\\rho_{\\nu\\lambda} \\Gamma^\\lambda_{\\mu\\sigma}\",\n            color=WHITE\n        )\n        \n        self.play(Transform(simple_eq, full_eq))\n        self.wait(2)\n        \n        # Conclusion - Element 6\n        self.play(FadeOut(simple_eq), FadeOut(riemann_text))\n        \n        conclusion = Text(\"Measures how tidal forces vary in spacetime\", color=WHITE, font_size=28)\n        final_message = Text(\"Whispers of the cosmos, encoded in tensor calculus\", color=WHITE, font_size=24)\n        final_message.next_to(conclusion, DOWN, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(Write(final_message))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(final_message))\n\n# To run and save this animation:\n# manim -pql -o video.mp4 your_script.py RiemannTensorTidalForces\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we interpret the Riemann curvature tensor as a measure of tidal forces in a gravitational field?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four groups of arrows arranged across the screen, each demonstrating different arrow properties:\n\n1. **Left Group (far left):** A vertical stack of arrows pointing right, each shorter than the last, showing how increasing the `buff` value reduces arrow length.\n2. **Middle Group (center):** A vertical stack of arrows with increasing stroke width, illustrating how a higher `max_stroke_width_to_length_ratio` thickens the arrow shaft.\n3. **Upper Right Group:** A vertical stack of arrows with increasingly longer arrow tips, demonstrating the effect of increasing `max_tip_length_to_length_ratio`.\n4. **Lower Right Group:** A vertical stack of arrows with different tip shapes and colors\u2014square, filled square, circle, and filled circle\u2014showing the variety of arrowhead styles."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArrowExample(Scene):\n    def construct(self):\n        left_group = VGroup()\n        # As buff increases, the size of the arrow decreases.\n        for buff in np.arange(0, 2.2, 0.45):\n            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\n        # Required to arrange arrows.\n        left_group.arrange(DOWN)\n        left_group.move_to(4 * LEFT)\n\n        middle_group = VGroup()\n        # As max_stroke_width_to_length_ratio gets bigger,\n        # the width of stroke increases.\n        for i in np.arange(0, 5, 0.5):\n            middle_group += Arrow(max_stroke_width_to_length_ratio=i)\n        middle_group.arrange(DOWN)\n\n        UR_group = VGroup()\n        # As max_tip_length_to_length_ratio increases,\n        # the length of the tip increases.\n        for i in np.arange(0, 0.3, 0.1):\n            UR_group += Arrow(max_tip_length_to_length_ratio=i)\n        UR_group.arrange(DOWN)\n        UR_group.move_to(4 * RIGHT + 2 * UP)\n\n        DR_group = VGroup()\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\n        DR_group.arrange(DOWN)\n        DR_group.move_to(4 * RIGHT + 2 * DOWN)\n\n        self.add(left_group, middle_group, UR_group, DR_group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four groups of arrows arranged across the screen, each demonstrating different arrow properties:\n\n1. **Left Group (far left):** A vertical stack of arrows pointing right, each shorter than the last, showing how increasing the `buff` value reduces arrow length.\n2. **Middle Group (center):** A vertical stack of arrows with increasing stroke width, illustrating how a higher `max_stroke_width_to_length_ratio` thickens the arrow shaft.\n3. **Upper Right Group:** A vertical stack of arrows with increasingly longer arrow tips, demonstrating the effect of increasing `max_tip_length_to_length_ratio`.\n4. **Lower Right Group:** A vertical stack of arrows with different tip shapes and colors\u2014square, filled square, circle, and filled circle\u2014showing the variety of arrowhead styles."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four groups of arrows arranged across the screen, each demonstrating different arrow properties:\n\n1. **left group (far left):** a vertical stack of arrows pointing right, each shorter than the last, showing how increasing the `buff` value reduces arrow length.\n2. **middle group (center):** a vertical stack of arrows with increasing stroke width, illustrating how a higher `max_stroke_width_to_length_ratio` thickens the arrow shaft.\n3. **upper right group:** a vertical stack of arrows with increasingly longer arrow tips, demonstrating the effect of increasing `max_tip_length_to_length_ratio`.\n4. **lower right group:** a vertical stack of arrows with different tip shapes and colors\u2014square, filled square, circle, and filled circle\u2014showing the variety of arrowhead styles."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArrowExample(Scene):\n    def construct(self):\n        left_group = VGroup()\n        # As buff increases, the size of the arrow decreases.\n        for buff in np.arange(0, 2.2, 0.45):\n            left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\n        # Required to arrange arrows.\n        left_group.arrange(DOWN)\n        left_group.move_to(4 * LEFT)\n\n        middle_group = VGroup()\n        # As max_stroke_width_to_length_ratio gets bigger,\n        # the width of stroke increases.\n        for i in np.arange(0, 5, 0.5):\n            middle_group += Arrow(max_stroke_width_to_length_ratio=i)\n        middle_group.arrange(DOWN)\n\n        UR_group = VGroup()\n        # As max_tip_length_to_length_ratio increases,\n        # the length of the tip increases.\n        for i in np.arange(0, 0.3, 0.1):\n            UR_group += Arrow(max_tip_length_to_length_ratio=i)\n        UR_group.arrange(DOWN)\n        UR_group.move_to(4 * RIGHT + 2 * UP)\n\n        DR_group = VGroup()\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\n        DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\n        DR_group.arrange(DOWN)\n        DR_group.move_to(4 * RIGHT + 2 * DOWN)\n\n        self.add(left_group, middle_group, UR_group, DR_group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four groups of arrows arranged across the screen, each demonstrating different arrow properties:\n\n1. **Left Group (far left):** A vertical stack of arrows pointing right, each shorter than the last, showing how increasing the `buff` value reduces arrow length.\n2. **Middle Group (center):** A vertical stack of arrows with increasing stroke width, illustrating how a higher `max_stroke_width_to_length_ratio` thickens the arrow shaft.\n3. **Upper Right Group:** A vertical stack of arrows with increasingly longer arrow tips, demonstrating the effect of increasing `max_tip_length_to_length_ratio`.\n4. **Lower Right Group:** A vertical stack of arrows with different tip shapes and colors\u2014square, filled square, circle, and filled circle\u2014showing the variety of arrowhead styles."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a pink circle with 50% transparency centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CreateCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n        self.play(Create(circle))  # show the circle on screen\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a pink circle with 50% transparency centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a pink circle with 50% transparency centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CreateCircle(Scene):\n    def construct(self):\n        circle = Circle()  # create a circle\n        circle.set_fill(PINK, opacity=0.5)  # set the color and transparency\n        self.play(Create(circle))  # show the circle on screen\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a pink circle with 50% transparency centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animation that visualizes the layers of a neural network processing an image from the MNIST dataset? I'd like to see the image pass through convolutional layers, max pooling, and finally some fully connected layers. Each layer should transition smoothly to the next to show the forward pass of the neural network. The scene should be in 3D and the neural network should be centered on the screen. It's important that the image used comes from an actual MNIST dataset image file. Can the animation be designed to fit a 1200 by 1900 pixel screen space?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the surface integral problem\n        problem = MathTex(r\"\\iint_{S} \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parametrization of S\n        explanation1 = Text(\"Parametrize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parametrized surface step\n        parametrized_surface = MathTex(r\"\\vec{r}(u, v) = f(u, v)\\hat{i} + g(u, v)\\hat{j} + h(u, v)\\hat{k}\")\n        self.play(ReplacementTransform(problem.copy(), parametrized_surface))\n        self.wait(1)\n\n        # Normal vector explanation\n        explanation2 = Text(\"Find the normal vector dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Normal vector calculation\n        normal_vector = MathTex(r\"d\\vec{S} = \\left| \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(parametrized_surface, normal_vector))\n        self.wait(1)\n\n        # Final surface integral with parametrization\n        explanation3 = Text(\"Write the surface integral with parametrization\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"\\iint_{D} \\vec{F}( \\vec{r}(u, v) ) \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) dudv\")\n        self.play(ReplacementTransform(normal_vector, final_integral))\n        self.wait(2)\n\n        # Complete the scene\n        self.play(FadeOut(final_integral), FadeOut(explanation1))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation that visualizes the layers of a neural network processing an image from the MNIST dataset? I'd like to see the image pass through convolutional layers, max pooling, and finally some fully connected layers. Each layer should transition smoothly to the next to show the forward pass of the neural network. The scene should be in 3D and the neural network should be centered on the screen. It's important that the image used comes from an actual MNIST dataset image file. Can the animation be designed to fit a 1200 by 1900 pixel screen space?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animation that visualizes the layers of a neural network processing an image from the mnist dataset? i'd like to see the image pass through convolutional layers, max pooling, and finally some fully connected layers. each layer should transition smoothly to the next to show the forward pass of the neural network. the scene should be in 3d and the neural network should be centered on the screen. it's important that the image used comes from an actual mnist dataset image file. can the animation be designed to fit a 1200 by 1900 pixel screen space?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the surface integral problem\n        problem = MathTex(r\"\\iint_{S} \\vec{F} \\cdot d\\vec{S}\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parametrization of S\n        explanation1 = Text(\"Parametrize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parametrized surface step\n        parametrized_surface = MathTex(r\"\\vec{r}(u, v) = f(u, v)\\hat{i} + g(u, v)\\hat{j} + h(u, v)\\hat{k}\")\n        self.play(ReplacementTransform(problem.copy(), parametrized_surface))\n        self.wait(1)\n\n        # Normal vector explanation\n        explanation2 = Text(\"Find the normal vector dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Normal vector calculation\n        normal_vector = MathTex(r\"d\\vec{S} = \\left| \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right| dudv\")\n        self.play(ReplacementTransform(parametrized_surface, normal_vector))\n        self.wait(1)\n\n        # Final surface integral with parametrization\n        explanation3 = Text(\"Write the surface integral with parametrization\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral calculation\n        final_integral = MathTex(r\"\\iint_{D} \\vec{F}( \\vec{r}(u, v) ) \\cdot \\left( \\frac{\\partial \\vec{r}}{\\partial u} \\times \\frac{\\partial \\vec{r}}{\\partial v} \\right) dudv\")\n        self.play(ReplacementTransform(normal_vector, final_integral))\n        self.wait(2)\n\n        # Complete the scene\n        self.play(FadeOut(final_integral), FadeOut(explanation1))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation that visualizes the layers of a neural network processing an image from the MNIST dataset? I'd like to see the image pass through convolutional layers, max pooling, and finally some fully connected layers. Each layer should transition smoothly to the next to show the forward pass of the neural network. The scene should be in 3D and the neural network should be centered on the screen. It's important that the image used comes from an actual MNIST dataset image file. Can the animation be designed to fit a 1200 by 1900 pixel screen space?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animation where a circle appears and is surrounded by a colorful moving boundary consisting of red, green, and blue colors. Additionally, I want the name \"AnimatedBoundary\" to appear above the circle quickly before the animation starts. After displaying the animated boundary around the circle for a short while, both the circle and the boundary should disappear. Can the boundary loop its animation three times every second?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AtomDistribution(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        atom_grid = self.create_atom_grid(5, 5)\n        # Animate the creation of the atom grid\n        self.play(Create(atom_grid))\n        # Show the scene\n        self.wait(2)\n\n    def atom_element(self, symbol: str, color: Color, text_color: Color) -> Mobject:\n        # Create a circle with element symbol text inside\n        atom_circle = Circle(radius=0.5, color=color).set_opacity(1).set_fill(color)\n        atom_text = Tex(symbol, color=text_color).scale(1.5)\n        atom = VGroup(atom_circle, atom_text)\n        return atom\n\n    def create_atom_grid(self, rows: int, cols: int) -> Mobject:\n        # Initialize empty list to hold atoms\n        atom_list = []\n        # Loop to populate the list with atoms\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom_list.append(self.atom_element(\"Cl\", GREEN, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n                else:\n                    atom_list.append(self.atom_element(\"Na\", ORANGE, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n        # Create a group with all atoms\n        atom_group = VGroup(*atom_list)\n        return atom_group\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animation where a circle appears and is surrounded by a colorful moving boundary consisting of red, green, and blue colors. Additionally, I want the name \"AnimatedBoundary\" to appear above the circle quickly before the animation starts. After displaying the animated boundary around the circle for a short while, both the circle and the boundary should disappear. Can the boundary loop its animation three times every second?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animation where a circle appears and is surrounded by a colorful moving boundary consisting of red, green, and blue colors. additionally, i want the name \"animatedboundary\" to appear above the circle quickly before the animation starts. after displaying the animated boundary around the circle for a short while, both the circle and the boundary should disappear. can the boundary loop its animation three times every second?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AtomDistribution(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        atom_grid = self.create_atom_grid(5, 5)\n        # Animate the creation of the atom grid\n        self.play(Create(atom_grid))\n        # Show the scene\n        self.wait(2)\n\n    def atom_element(self, symbol: str, color: Color, text_color: Color) -> Mobject:\n        # Create a circle with element symbol text inside\n        atom_circle = Circle(radius=0.5, color=color).set_opacity(1).set_fill(color)\n        atom_text = Tex(symbol, color=text_color).scale(1.5)\n        atom = VGroup(atom_circle, atom_text)\n        return atom\n\n    def create_atom_grid(self, rows: int, cols: int) -> Mobject:\n        # Initialize empty list to hold atoms\n        atom_list = []\n        # Loop to populate the list with atoms\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    atom_list.append(self.atom_element(\"Cl\", GREEN, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n                else:\n                    atom_list.append(self.atom_element(\"Na\", ORANGE, WHITE).shift([j - cols/2, rows/2 - i, 0]))\n        # Create a group with all atoms\n        atom_group = VGroup(*atom_list)\n        return atom_group\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animation where a circle appears and is surrounded by a colorful moving boundary consisting of red, green, and blue colors. Additionally, I want the name \"AnimatedBoundary\" to appear above the circle quickly before the animation starts. After displaying the animated boundary around the circle for a short while, both the circle and the boundary should disappear. Can the boundary loop its animation three times every second?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a line of text where the phrase \"Blue text\" appears in large blue font, followed by the words \"is *cool*!\" with \"cool\" italicized. The entire line is centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MarkupExample(Scene):\n    def construct(self):\n        text = MarkupText('<span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"')\n        self.add(text)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a line of text where the phrase \"Blue text\" appears in large blue font, followed by the words \"is *cool*!\" with \"cool\" italicized. The entire line is centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a line of text where the phrase \"blue text\" appears in large blue font, followed by the words \"is *cool*!\" with \"cool\" italicized. the entire line is centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MarkupExample(Scene):\n    def construct(self):\n        text = MarkupText('<span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"')\n        self.add(text)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a line of text where the phrase \"Blue text\" appears in large blue font, followed by the words \"is *cool*!\" with \"cool\" italicized. The entire line is centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create a 3D animation that shows a magnetic field generated by an electric current in a circular wire, with the ability to view the setup from different angles?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PlanetaryMotion(ThreeDScene):\n    def construct(self):\n        sun = Sphere(radius=0.5, color=YELLOW).shift(LEFT * 2)\n        earth = Sphere(radius=0.2, color=BLUE).shift(RIGHT * 3)\n\n        self.play(FadeIn(sun), FadeIn(earth))\n        description = Tex(\"The Earth orbits around the Sun due to gravitational forces.\")\n        self.play(Write(description))\n        self.wait(1)\n\n        orbit = Ellipse(width=6, height=3, color=WHITE)\n        self.play(ShowCreation(orbit))\n        self.wait(1)\n\n        self.play(Rotating(earth, about_point=sun.get_center(), run_time=5))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create a 3D animation that shows a magnetic field generated by an electric current in a circular wire, with the ability to view the setup from different angles?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create a 3d animation that shows a magnetic field generated by an electric current in a circular wire, with the ability to view the setup from different angles?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PlanetaryMotion(ThreeDScene):\n    def construct(self):\n        sun = Sphere(radius=0.5, color=YELLOW).shift(LEFT * 2)\n        earth = Sphere(radius=0.2, color=BLUE).shift(RIGHT * 3)\n\n        self.play(FadeIn(sun), FadeIn(earth))\n        description = Tex(\"The Earth orbits around the Sun due to gravitational forces.\")\n        self.play(Write(description))\n        self.wait(1)\n\n        orbit = Ellipse(width=6, height=3, color=WHITE)\n        self.play(ShowCreation(orbit))\n        self.wait(1)\n\n        self.play(Rotating(earth, about_point=sun.get_center(), run_time=5))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create a 3D animation that shows a magnetic field generated by an electric current in a circular wire, with the ability to view the setup from different angles?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_show_gaussian.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.utils.mobjects.probability import GaussianDistribution\n\n\nclass TestShowGaussian(Scene):\n    def construct(self):\n        axes = Axes()\n        self.add(axes)\n        gaussian = GaussianDistribution(\n            axes, mean=np.array([0.0, 0.0]), cov=np.array([[2.0, 0.0], [0.0, 1.0]])\n        )\n        self.add(gaussian)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_show_gaussian.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_show_gaussian.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.utils.mobjects.probability import GaussianDistribution\n\n\nclass TestShowGaussian(Scene):\n    def construct(self):\n        axes = Axes()\n        self.add(axes)\n        gaussian = GaussianDistribution(\n            axes, mean=np.array([0.0, 0.0]), cov=np.array([[2.0, 0.0], [0.0, 1.0]])\n        )\n        self.add(gaussian)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_show_gaussian.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like to create an animation that visually explains the process of calculating the value of the infinite series sum of 1 over n squared, from n equals 1 to infinity, which converges to pi squared over 6. Start by showing the formula of the series, then illustrate the concept of partial sums approaching the series' value, move on to show what the partial sum looks like for the first five terms, and finally, reveal that the series converges to the known value of pi squared over 6. Include textual explanations during the transitions between the different parts of the process, and make sure each step is easy to follow and displayed sequentially."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}z^3]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animation that visually explains the process of calculating the value of the infinite series sum of 1 over n squared, from n equals 1 to infinity, which converges to pi squared over 6. Start by showing the formula of the series, then illustrate the concept of partial sums approaching the series' value, move on to show what the partial sum looks like for the first five terms, and finally, reveal that the series converges to the known value of pi squared over 6. Include textual explanations during the transitions between the different parts of the process, and make sure each step is easy to follow and displayed sequentially."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like to create an animation that visually explains the process of calculating the value of the infinite series sum of 1 over n squared, from n equals 1 to infinity, which converges to pi squared over 6. start by showing the formula of the series, then illustrate the concept of partial sums approaching the series' value, move on to show what the partial sum looks like for the first five terms, and finally, reveal that the series converges to the known value of pi squared over 6. include textual explanations during the transitions between the different parts of the process, and make sure each step is easy to follow and displayed sequentially."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate the result with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{6}z^3]_{0}^{1}\", r\"= \\frac{1}{6}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animation that visually explains the process of calculating the value of the infinite series sum of 1 over n squared, from n equals 1 to infinity, which converges to pi squared over 6. Start by showing the formula of the series, then illustrate the concept of partial sums approaching the series' value, move on to show what the partial sum looks like for the first five terms, and finally, reveal that the series converges to the known value of pi squared over 6. Include textual explanations during the transitions between the different parts of the process, and make sure each step is easy to follow and displayed sequentially."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I want an animated visualization of a simple neural network architecture that consists of an input layer representing a 28x28 pixel image, two hidden layers with 128 and 64 units respectively and both using the ReLU activation function, and an output layer with 10 units using the softmax activation function. The layers should be represented as rectangles with their type, number of units, and activation function (if applicable) labeled above each rectangle. The animation should show each layer appearing one after the other with a slight delay between them. Can you create such an animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Transformation to another form\n        explanation2 = Text(\"For a string with fixed ends, solutions can be sinusoidal.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation, particular_solution))\n        self.wait(1)\n\n        # Explanation for harmonics\n        explanation3 = Text(\"Multiples of the fundamental frequency give harmonics.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clearing the scene to display harmonics\n        self.play(FadeOut(explanation1), FadeOut(particular_solution))\n        self.wait(1)\n\n        # Displaying first harmonic\n        first_harmonic = MathTex(r\"u_1(x, t) = A \\sin(\\frac{\\pi}{L}x - \\omega_1 t)\")\n        self.play(Write(first_harmonic))\n        self.wait(1)\n\n        # Displaying second harmonic\n        second_harmonic = MathTex(r\"u_2(x, t) = A \\sin(\\frac{2\\pi}{L}x - \\omega_2 t)\")\n        self.play(Transform(first_harmonic, second_harmonic))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The shape of the string at any given time is a standing wave.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I want an animated visualization of a simple neural network architecture that consists of an input layer representing a 28x28 pixel image, two hidden layers with 128 and 64 units respectively and both using the ReLU activation function, and an output layer with 10 units using the softmax activation function. The layers should be represented as rectangles with their type, number of units, and activation function (if applicable) labeled above each rectangle. The animation should show each layer appearing one after the other with a slight delay between them. Can you create such an animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i want an animated visualization of a simple neural network architecture that consists of an input layer representing a 28x28 pixel image, two hidden layers with 128 and 64 units respectively and both using the relu activation function, and an output layer with 10 units using the softmax activation function. the layers should be represented as rectangles with their type, number of units, and activation function (if applicable) labeled above each rectangle. the animation should show each layer appearing one after the other with a slight delay between them. can you create such an animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This represents the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Transformation to another form\n        explanation2 = Text(\"For a string with fixed ends, solutions can be sinusoidal.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the particular solution\n        particular_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(equation, particular_solution))\n        self.wait(1)\n\n        # Explanation for harmonics\n        explanation3 = Text(\"Multiples of the fundamental frequency give harmonics.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clearing the scene to display harmonics\n        self.play(FadeOut(explanation1), FadeOut(particular_solution))\n        self.wait(1)\n\n        # Displaying first harmonic\n        first_harmonic = MathTex(r\"u_1(x, t) = A \\sin(\\frac{\\pi}{L}x - \\omega_1 t)\")\n        self.play(Write(first_harmonic))\n        self.wait(1)\n\n        # Displaying second harmonic\n        second_harmonic = MathTex(r\"u_2(x, t) = A \\sin(\\frac{2\\pi}{L}x - \\omega_2 t)\")\n        self.play(Transform(first_harmonic, second_harmonic))\n        self.wait(1)\n\n        # Conclusion\n        conclusion = Text(\"The shape of the string at any given time is a standing wave.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I want an animated visualization of a simple neural network architecture that consists of an input layer representing a 28x28 pixel image, two hidden layers with 128 and 64 units respectively and both using the ReLU activation function, and an output layer with 10 units using the softmax activation function. The layers should be represented as rectangles with their type, number of units, and activation function (if applicable) labeled above each rectangle. The animation should show each layer appearing one after the other with a slight delay between them. Can you create such an animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a directed graph with five labeled nodes arranged in a circular layout, but with all arrows styled to appear undirected by removing their tips. One edge, from node 3 to node 4, is colored red for emphasis. After the graph is created, several nodes animate to new positions in 3D space: node 1 moves to the upper right, node 2 to the upper left and forward, node 3 to the lower left and back, and node 4 to the lower right and back. The edges dynamically adjust to maintain the connections between the repositioned nodes."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UndirectedMovingDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n            (3, 4): {\"color\": RED},\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([-1.5, -1.5, -1]),\n            g[4].animate.move_to([1, -2, -1]),\n        )\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a directed graph with five labeled nodes arranged in a circular layout, but with all arrows styled to appear undirected by removing their tips. One edge, from node 3 to node 4, is colored red for emphasis. After the graph is created, several nodes animate to new positions in 3D space: node 1 moves to the upper right, node 2 to the upper left and forward, node 3 to the lower left and back, and node 4 to the lower right and back. The edges dynamically adjust to maintain the connections between the repositioned nodes."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a directed graph with five labeled nodes arranged in a circular layout, but with all arrows styled to appear undirected by removing their tips. one edge, from node 3 to node 4, is colored red for emphasis. after the graph is created, several nodes animate to new positions in 3d space: node 1 moves to the upper right, node 2 to the upper left and forward, node 3 to the lower left and back, and node 4 to the lower right and back. the edges dynamically adjust to maintain the connections between the repositioned nodes."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UndirectedMovingDiGraph(Scene):\n    def construct(self):\n        vertices = [i for i in range(5)]\n        edges = [\n            (0, 1),\n            (1, 2),\n            (3, 2),\n            (3, 4),\n        ]\n\n        edge_config = {\n            \"stroke_width\": 2,\n            \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n            (3, 4): {\"color\": RED},\n        }\n\n        g = DiGraph(\n            vertices,\n            edges,\n            labels=True,\n            layout=\"circular\",\n            edge_config=edge_config,\n        ).scale(1.4)\n\n        self.play(Create(g))\n        self.wait()\n\n        self.play(\n            g[1].animate.move_to([1, 1, 1]),\n            g[2].animate.move_to([-1, 1, 2]),\n            g[3].animate.move_to([-1.5, -1.5, -1]),\n            g[4].animate.move_to([1, -2, -1]),\n        )\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a directed graph with five labeled nodes arranged in a circular layout, but with all arrows styled to appear undirected by removing their tips. One edge, from node 3 to node 4, is colored red for emphasis. After the graph is created, several nodes animate to new positions in 3D space: node 1 moves to the upper right, node 2 to the upper left and forward, node 3 to the lower left and back, and node 4 to the lower right and back. The edges dynamically adjust to maintain the connections between the repositioned nodes."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that illustrates basic probability concepts such as single event probability, complement probability, union and intersection of two events, and conditional probability. Can you visualize these concepts using a colorful and interactive raindrop analogy where falling drops change color when they hit certain areas? Additionally, I want the animation to include probability labels that update to match the concept being demonstrated."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SigmoidNeuron(VGroup):\n    def __init__(self, position, neuron_radius=0.2, color=BLUE, **kwargs):\n        super().__init__(**kwargs)\n        self.neuron_circle = Circle(radius=neuron_radius, color=color)\n        self.neuron_circle.move_to(position)\n        self.activation_text = MathTex(r'\\sigma').scale(0.5).move_to(self.neuron_circle.get_center())\n        self.add(self.neuron_circle, self.activation_text)\n\n    def get_activation_animation(self):\n        activation = ApplyMethod(self.neuron_circle.set_fill, YELLOW, rate_func=there_and_back)\n        return activation\n\n\nclass LayerOfSigmoidNeurons(VGroup):\n    def __init__(self, n_neurons, center, **kwargs):\n        super().__init__(**kwargs)\n        self.neurons = VGroup(*[\n            SigmoidNeuron(position=center + i * RIGHT * 0.5)\n            for i in range(n_neurons)\n        ])\n        self.add(self.neurons)\n\n    def get_layer_activation_animation(self):\n        return AnimationGroup(*[neuron.get_activation_animation() for neuron in self.neurons], lag_ratio=0.1)\n\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        sigmoid_layer = LayerOfSigmoidNeurons(n_neurons=5, center=UP*2)\n        output_neuron = SigmoidNeuron(position=DOWN*2, color=RED, neuron_radius=0.3)\n        self.add(sigmoid_layer, output_neuron)\n\n        # Creating animated edges\n        edges = VGroup()\n        for neuron in sigmoid_layer.neurons:\n            edge = Line(neuron.get_center(), output_neuron.get_center(), buff=0.2, stroke_width=2.0)\n            edges.add(edge)\n        self.add(edges)\n\n        # Animating neurons\n        self.play(sigmoid_layer.get_layer_activation_animation())\n        self.wait(1)\n\n        # Creating animated output edges with color change\n        edges_animation = [\n            ShowPassingFlash(\n                edge.copy().set_color(YELLOW),\n                time_width=0.5,\n                run_time=1\n            ) for edge in edges\n        ]\n        output_activation = output_neuron.get_activation_animation()\n\n        self.play(\n            AnimationGroup(*edges_animation, lag_ratio=0.1),\n            output_activation\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that illustrates basic probability concepts such as single event probability, complement probability, union and intersection of two events, and conditional probability. Can you visualize these concepts using a colorful and interactive raindrop analogy where falling drops change color when they hit certain areas? Additionally, I want the animation to include probability labels that update to match the concept being demonstrated."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that illustrates basic probability concepts such as single event probability, complement probability, union and intersection of two events, and conditional probability. can you visualize these concepts using a colorful and interactive raindrop analogy where falling drops change color when they hit certain areas? additionally, i want the animation to include probability labels that update to match the concept being demonstrated."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SigmoidNeuron(VGroup):\n    def __init__(self, position, neuron_radius=0.2, color=BLUE, **kwargs):\n        super().__init__(**kwargs)\n        self.neuron_circle = Circle(radius=neuron_radius, color=color)\n        self.neuron_circle.move_to(position)\n        self.activation_text = MathTex(r'\\sigma').scale(0.5).move_to(self.neuron_circle.get_center())\n        self.add(self.neuron_circle, self.activation_text)\n\n    def get_activation_animation(self):\n        activation = ApplyMethod(self.neuron_circle.set_fill, YELLOW, rate_func=there_and_back)\n        return activation\n\n\nclass LayerOfSigmoidNeurons(VGroup):\n    def __init__(self, n_neurons, center, **kwargs):\n        super().__init__(**kwargs)\n        self.neurons = VGroup(*[\n            SigmoidNeuron(position=center + i * RIGHT * 0.5)\n            for i in range(n_neurons)\n        ])\n        self.add(self.neurons)\n\n    def get_layer_activation_animation(self):\n        return AnimationGroup(*[neuron.get_activation_animation() for neuron in self.neurons], lag_ratio=0.1)\n\n\nclass NeuralNetworkScene(Scene):\n    def construct(self):\n        sigmoid_layer = LayerOfSigmoidNeurons(n_neurons=5, center=UP*2)\n        output_neuron = SigmoidNeuron(position=DOWN*2, color=RED, neuron_radius=0.3)\n        self.add(sigmoid_layer, output_neuron)\n\n        # Creating animated edges\n        edges = VGroup()\n        for neuron in sigmoid_layer.neurons:\n            edge = Line(neuron.get_center(), output_neuron.get_center(), buff=0.2, stroke_width=2.0)\n            edges.add(edge)\n        self.add(edges)\n\n        # Animating neurons\n        self.play(sigmoid_layer.get_layer_activation_animation())\n        self.wait(1)\n\n        # Creating animated output edges with color change\n        edges_animation = [\n            ShowPassingFlash(\n                edge.copy().set_color(YELLOW),\n                time_width=0.5,\n                run_time=1\n            ) for edge in edges\n        ]\n        output_activation = output_neuron.get_activation_animation()\n\n        self.play(\n            AnimationGroup(*edges_animation, lag_ratio=0.1),\n            output_activation\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that illustrates basic probability concepts such as single event probability, complement probability, union and intersection of two events, and conditional probability. Can you visualize these concepts using a colorful and interactive raindrop analogy where falling drops change color when they hit certain areas? Additionally, I want the animation to include probability labels that update to match the concept being demonstrated."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a complex plane with a dot initially positioned at the complex number \\(-2 + 1i\\). As the animation progresses, the dot moves smoothly to new positions based on updates to a complex value tracker:\n\n1. Moves to \\(3 + 2i\\),\n2. Rotates 90\u00b0 counterclockwise by multiplying the value by \\(i\\),\n3. Moves downward by subtracting \\(2i\\),\n4. Finally, shifts again by dividing the current value by \\(-2 + 3i\\).\n\nEach movement reflects the corresponding complex arithmetic operation visually on the plane."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ComplexValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ComplexValueTracker(-2+1j)\n        dot = Dot().add_updater(\n            lambda x: x.move_to(tracker.points)\n        )\n\n        self.add(NumberPlane(), dot)\n\n        self.play(tracker.animate.set_value(3+2j))\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a complex plane with a dot initially positioned at the complex number \\(-2 + 1i\\). As the animation progresses, the dot moves smoothly to new positions based on updates to a complex value tracker:\n\n1. Moves to \\(3 + 2i\\),\n2. Rotates 90\u00b0 counterclockwise by multiplying the value by \\(i\\),\n3. Moves downward by subtracting \\(2i\\),\n4. Finally, shifts again by dividing the current value by \\(-2 + 3i\\).\n\nEach movement reflects the corresponding complex arithmetic operation visually on the plane."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a complex plane with a dot initially positioned at the complex number \\(-2 + 1i\\). as the animation progresses, the dot moves smoothly to new positions based on updates to a complex value tracker:\n\n1. moves to \\(3 + 2i\\),\n2. rotates 90\u00b0 counterclockwise by multiplying the value by \\(i\\),\n3. moves downward by subtracting \\(2i\\),\n4. finally, shifts again by dividing the current value by \\(-2 + 3i\\).\n\neach movement reflects the corresponding complex arithmetic operation visually on the plane."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ComplexValueTrackerExample(Scene):\n    def construct(self):\n        tracker = ComplexValueTracker(-2+1j)\n        dot = Dot().add_updater(\n            lambda x: x.move_to(tracker.points)\n        )\n\n        self.add(NumberPlane(), dot)\n\n        self.play(tracker.animate.set_value(3+2j))\n        self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n        self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n        self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a complex plane with a dot initially positioned at the complex number \\(-2 + 1i\\). As the animation progresses, the dot moves smoothly to new positions based on updates to a complex value tracker:\n\n1. Moves to \\(3 + 2i\\),\n2. Rotates 90\u00b0 counterclockwise by multiplying the value by \\(i\\),\n3. Moves downward by subtracting \\(2i\\),\n4. Finally, shifts again by dividing the current value by \\(-2 + 3i\\).\n\nEach movement reflects the corresponding complex arithmetic operation visually on the plane."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an educational animation that displays a survey result for favorite fruits among a group of people. The video should be in portrait mode, suitable for mobile viewing. Begin with a nicely formatted table showing names and their corresponding favorite fruit. Use soft, pastel colors for the table and background to make it visually appealing.\n\nThe fruits listed include bananas, strawberries, and oranges. Next to the table, please show a segmented circle graph representing the quantities of each fruit choice within the group. For each fruit, display its segment growing in the graph to indicate the proportion of people who favor that fruit. Accompany the graph with a legend that uses colored squares to signify the corresponding fruit with labels next to them.\n\nAnimate the cells of the table highlighting corresponding names as the graph is being drawn for each fruit segment. Ensure that each cell highlights with the color corresponding to the fruit selected, and only remove the highlight after its segment on the graph is fully grown.\n\nOnce the graph is complete, shift the entire animation to the left and out of view, to potentially make space for additional content in the video if necessary. The colors, table, and graph should be modern and professional, aimed at delivering clear and informative content for an educational video."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral representing the area under the curve\n        integral_expr = MathTex(r\"\\int_0^3\", r\"x^2\", r\"\\,dx\")\n        self.play(Write(integral_expr))\n        self.wait(1)\n\n        # Highlight the function to integrate\n        function_highlight = SurroundingRectangle(integral_expr[1], color=YELLOW)\n        self.play(Create(function_highlight))\n        self.wait(1)\n\n        # Explain the definite integral represents area\n        explanation = Text(\"The definite integral represents the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Perform integration\n        integral_solution = MathTex(r\"=\\left[\\frac{x^3}{3}\\right]_0^3\")\n        self.play(ReplacementTransform(integral_expr, integral_solution))\n        self.wait(1)\n\n        # Calculate the final area value\n        final_area = MathTex(r\"= \\frac{3^3}{3} - \\frac{0^3}{3}\")\n        self.play(ReplacementTransform(integral_solution, final_area))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9\")\n        self.play(ReplacementTransform(final_area, final_value))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(final_value))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational animation that displays a survey result for favorite fruits among a group of people. The video should be in portrait mode, suitable for mobile viewing. Begin with a nicely formatted table showing names and their corresponding favorite fruit. Use soft, pastel colors for the table and background to make it visually appealing.\n\nThe fruits listed include bananas, strawberries, and oranges. Next to the table, please show a segmented circle graph representing the quantities of each fruit choice within the group. For each fruit, display its segment growing in the graph to indicate the proportion of people who favor that fruit. Accompany the graph with a legend that uses colored squares to signify the corresponding fruit with labels next to them.\n\nAnimate the cells of the table highlighting corresponding names as the graph is being drawn for each fruit segment. Ensure that each cell highlights with the color corresponding to the fruit selected, and only remove the highlight after its segment on the graph is fully grown.\n\nOnce the graph is complete, shift the entire animation to the left and out of view, to potentially make space for additional content in the video if necessary. The colors, table, and graph should be modern and professional, aimed at delivering clear and informative content for an educational video."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an educational animation that displays a survey result for favorite fruits among a group of people. the video should be in portrait mode, suitable for mobile viewing. begin with a nicely formatted table showing names and their corresponding favorite fruit. use soft, pastel colors for the table and background to make it visually appealing.\n\nthe fruits listed include bananas, strawberries, and oranges. next to the table, please show a segmented circle graph representing the quantities of each fruit choice within the group. for each fruit, display its segment growing in the graph to indicate the proportion of people who favor that fruit. accompany the graph with a legend that uses colored squares to signify the corresponding fruit with labels next to them.\n\nanimate the cells of the table highlighting corresponding names as the graph is being drawn for each fruit segment. ensure that each cell highlights with the color corresponding to the fruit selected, and only remove the highlight after its segment on the graph is fully grown.\n\nonce the graph is complete, shift the entire animation to the left and out of view, to potentially make space for additional content in the video if necessary. the colors, table, and graph should be modern and professional, aimed at delivering clear and informative content for an educational video."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral representing the area under the curve\n        integral_expr = MathTex(r\"\\int_0^3\", r\"x^2\", r\"\\,dx\")\n        self.play(Write(integral_expr))\n        self.wait(1)\n\n        # Highlight the function to integrate\n        function_highlight = SurroundingRectangle(integral_expr[1], color=YELLOW)\n        self.play(Create(function_highlight))\n        self.wait(1)\n\n        # Explain the definite integral represents area\n        explanation = Text(\"The definite integral represents the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Perform integration\n        integral_solution = MathTex(r\"=\\left[\\frac{x^3}{3}\\right]_0^3\")\n        self.play(ReplacementTransform(integral_expr, integral_solution))\n        self.wait(1)\n\n        # Calculate the final area value\n        final_area = MathTex(r\"= \\frac{3^3}{3} - \\frac{0^3}{3}\")\n        self.play(ReplacementTransform(integral_solution, final_area))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9\")\n        self.play(ReplacementTransform(final_area, final_value))\n        self.wait(1)\n\n        # Clear the scene and show the final result\n        self.clear()\n        self.wait(1)\n        self.play(FadeIn(final_value))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational animation that displays a survey result for favorite fruits among a group of people. The video should be in portrait mode, suitable for mobile viewing. Begin with a nicely formatted table showing names and their corresponding favorite fruit. Use soft, pastel colors for the table and background to make it visually appealing.\n\nThe fruits listed include bananas, strawberries, and oranges. Next to the table, please show a segmented circle graph representing the quantities of each fruit choice within the group. For each fruit, display its segment growing in the graph to indicate the proportion of people who favor that fruit. Accompany the graph with a legend that uses colored squares to signify the corresponding fruit with labels next to them.\n\nAnimate the cells of the table highlighting corresponding names as the graph is being drawn for each fruit segment. Ensure that each cell highlights with the color corresponding to the fruit selected, and only remove the highlight after its segment on the graph is fully grown.\n\nOnce the graph is complete, shift the entire animation to the left and out of view, to potentially make space for additional content in the video if necessary. The colors, table, and graph should be modern and professional, aimed at delivering clear and informative content for an educational video."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can a set on the real line be simultaneously open in one topology and closed in another, and what visualization depicts these differences?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TopologyOpenClosedSets(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Topology: The Dance of Open and Closed Sets\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a number line\n        number_line = NumberLine(\n            x_range=[-2, 3, 1],\n            length=10,\n            include_numbers=True,\n        )\n        self.play(Create(number_line))\n        self.wait(1)\n        \n        # Standard topology section\n        topology1 = Text(\"Standard Topology\", font_size=32, color=BLUE)\n        topology1.next_to(title, DOWN)\n        self.play(Write(topology1))\n        \n        # Show an interval on the number line\n        interval = Line(\n            number_line.n2p(0),\n            number_line.n2p(1),\n            color=BLUE,\n            stroke_width=10\n        )\n        self.play(Create(interval))\n        \n        # Candy visualization (small circles representing candies in the interval)\n        candies = VGroup(*[\n            Circle(radius=0.1, color=BLUE_A, fill_opacity=0.8).move_to(\n                number_line.n2p(0.1 + i*0.2)\n            ) for i in range(4)\n        ])\n        self.play(FadeIn(candies))\n        \n        # Label the interval\n        interval_label = Text(\"Open Interval (0,1)\", font_size=24).next_to(interval, DOWN)\n        self.play(Write(interval_label))\n        \n        # Highlight boundaries (excluded in open sets)\n        left_dot = Dot(number_line.n2p(0), color=RED)\n        right_dot = Dot(number_line.n2p(1), color=RED)\n        boundary_text = Text(\"Boundaries excluded\", font_size=24, color=RED)\n        boundary_text.next_to(interval_label, DOWN)\n        \n        self.play(Create(left_dot), Create(right_dot))\n        self.play(Write(boundary_text))\n        \n        # Equation for standard topology\n        eq1 = MathTex(r\"\\tau_1 = \\{...,(-\\infty,a) \\cup (b,\\infty),...\\}\")\n        eq1.next_to(topology1, DOWN).shift(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Clear for next topology\n        self.play(\n            FadeOut(interval),\n            FadeOut(interval_label),\n            FadeOut(left_dot),\n            FadeOut(right_dot),\n            FadeOut(boundary_text),\n            FadeOut(eq1),\n            FadeOut(topology1),\n            FadeOut(candies)\n        )\n        \n        # Lower limit topology\n        topology2 = Text(\"Lower Limit Topology\", font_size=32, color=ORANGE)\n        topology2.next_to(title, DOWN)\n        self.play(Write(topology2))\n        \n        # Show same interval with different properties\n        interval2 = Line(\n            number_line.n2p(0),\n            number_line.n2p(1),\n            color=ORANGE,\n            stroke_width=10\n        )\n        self.play(Create(interval2))\n        \n        # Candy visualization for lower limit topology\n        candies2 = VGroup(*[\n            Circle(radius=0.1, color=ORANGE_A, fill_opacity=0.8).move_to(\n                number_line.n2p(0 + i*0.2)\n            ) for i in range(5)\n        ])\n        self.play(FadeIn(candies2))\n        \n        # Label the interval\n        interval_label2 = Text(\"Half-Open Interval [0,1)\", font_size=24).next_to(interval2, DOWN)\n        self.play(Write(interval_label2))\n        \n        # Highlight boundaries (left included, right excluded)\n        left_dot2 = Dot(number_line.n2p(0), color=GREEN)\n        right_dot2 = Dot(number_line.n2p(1), color=RED)\n        boundary_text2 = Text(\"Left included, right excluded\", font_size=24, color=YELLOW)\n        boundary_text2.next_to(interval_label2, DOWN)\n        \n        self.play(Create(left_dot2), Create(right_dot2))\n        self.play(Write(boundary_text2))\n        \n        # Equation for lower limit topology\n        eq2 = MathTex(r\"\\tau_2 = \\{..., (-\\infty,a], [b,\\infty),...\\}\")\n        eq2.next_to(topology2, DOWN).shift(DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Key insight\n        self.play(\n            FadeOut(interval2),\n            FadeOut(interval_label2),\n            FadeOut(left_dot2),\n            FadeOut(right_dot2),\n            FadeOut(boundary_text2),\n            FadeOut(eq2),\n            FadeOut(topology2),\n            FadeOut(number_line),\n            FadeOut(candies2)\n        )\n        \n        insight = Text(\"Key Insight:\", font_size=36, color=YELLOW).to_edge(UP).shift(DOWN)\n        self.play(Write(insight))\n        \n        message = Text(\"A set can be OPEN in one topology\\nand CLOSED in another!\", \n                      font_size=32)\n        message.next_to(insight, DOWN)\n        self.play(Write(message))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(insight),\n            FadeOut(message),\n            FadeOut(title)\n        )\n        \n        conclusion = Text(\"Topology: Perspective Changes Everything\", font_size=40, color=BLUE)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can a set on the real line be simultaneously open in one topology and closed in another, and what visualization depicts these differences?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can a set on the real line be simultaneously open in one topology and closed in another, and what visualization depicts these differences?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TopologyOpenClosedSets(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Topology: The Dance of Open and Closed Sets\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a number line\n        number_line = NumberLine(\n            x_range=[-2, 3, 1],\n            length=10,\n            include_numbers=True,\n        )\n        self.play(Create(number_line))\n        self.wait(1)\n        \n        # Standard topology section\n        topology1 = Text(\"Standard Topology\", font_size=32, color=BLUE)\n        topology1.next_to(title, DOWN)\n        self.play(Write(topology1))\n        \n        # Show an interval on the number line\n        interval = Line(\n            number_line.n2p(0),\n            number_line.n2p(1),\n            color=BLUE,\n            stroke_width=10\n        )\n        self.play(Create(interval))\n        \n        # Candy visualization (small circles representing candies in the interval)\n        candies = VGroup(*[\n            Circle(radius=0.1, color=BLUE_A, fill_opacity=0.8).move_to(\n                number_line.n2p(0.1 + i*0.2)\n            ) for i in range(4)\n        ])\n        self.play(FadeIn(candies))\n        \n        # Label the interval\n        interval_label = Text(\"Open Interval (0,1)\", font_size=24).next_to(interval, DOWN)\n        self.play(Write(interval_label))\n        \n        # Highlight boundaries (excluded in open sets)\n        left_dot = Dot(number_line.n2p(0), color=RED)\n        right_dot = Dot(number_line.n2p(1), color=RED)\n        boundary_text = Text(\"Boundaries excluded\", font_size=24, color=RED)\n        boundary_text.next_to(interval_label, DOWN)\n        \n        self.play(Create(left_dot), Create(right_dot))\n        self.play(Write(boundary_text))\n        \n        # Equation for standard topology\n        eq1 = MathTex(r\"\\tau_1 = \\{...,(-\\infty,a) \\cup (b,\\infty),...\\}\")\n        eq1.next_to(topology1, DOWN).shift(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Clear for next topology\n        self.play(\n            FadeOut(interval),\n            FadeOut(interval_label),\n            FadeOut(left_dot),\n            FadeOut(right_dot),\n            FadeOut(boundary_text),\n            FadeOut(eq1),\n            FadeOut(topology1),\n            FadeOut(candies)\n        )\n        \n        # Lower limit topology\n        topology2 = Text(\"Lower Limit Topology\", font_size=32, color=ORANGE)\n        topology2.next_to(title, DOWN)\n        self.play(Write(topology2))\n        \n        # Show same interval with different properties\n        interval2 = Line(\n            number_line.n2p(0),\n            number_line.n2p(1),\n            color=ORANGE,\n            stroke_width=10\n        )\n        self.play(Create(interval2))\n        \n        # Candy visualization for lower limit topology\n        candies2 = VGroup(*[\n            Circle(radius=0.1, color=ORANGE_A, fill_opacity=0.8).move_to(\n                number_line.n2p(0 + i*0.2)\n            ) for i in range(5)\n        ])\n        self.play(FadeIn(candies2))\n        \n        # Label the interval\n        interval_label2 = Text(\"Half-Open Interval [0,1)\", font_size=24).next_to(interval2, DOWN)\n        self.play(Write(interval_label2))\n        \n        # Highlight boundaries (left included, right excluded)\n        left_dot2 = Dot(number_line.n2p(0), color=GREEN)\n        right_dot2 = Dot(number_line.n2p(1), color=RED)\n        boundary_text2 = Text(\"Left included, right excluded\", font_size=24, color=YELLOW)\n        boundary_text2.next_to(interval_label2, DOWN)\n        \n        self.play(Create(left_dot2), Create(right_dot2))\n        self.play(Write(boundary_text2))\n        \n        # Equation for lower limit topology\n        eq2 = MathTex(r\"\\tau_2 = \\{..., (-\\infty,a], [b,\\infty),...\\}\")\n        eq2.next_to(topology2, DOWN).shift(DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Key insight\n        self.play(\n            FadeOut(interval2),\n            FadeOut(interval_label2),\n            FadeOut(left_dot2),\n            FadeOut(right_dot2),\n            FadeOut(boundary_text2),\n            FadeOut(eq2),\n            FadeOut(topology2),\n            FadeOut(number_line),\n            FadeOut(candies2)\n        )\n        \n        insight = Text(\"Key Insight:\", font_size=36, color=YELLOW).to_edge(UP).shift(DOWN)\n        self.play(Write(insight))\n        \n        message = Text(\"A set can be OPEN in one topology\\nand CLOSED in another!\", \n                      font_size=32)\n        message.next_to(insight, DOWN)\n        self.play(Write(message))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(insight),\n            FadeOut(message),\n            FadeOut(title)\n        )\n        \n        conclusion = Text(\"Topology: Perspective Changes Everything\", font_size=40, color=BLUE)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can a set on the real line be simultaneously open in one topology and closed in another, and what visualization depicts these differences?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_nn_dropout.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.animations.dropout import (\n    make_neural_network_dropout_animation,\n)\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom PIL import Image\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport numpy as np\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\" \n        nn = NeuralNetwork([\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(4),\n        ])\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        language=\"py\",\n    )\n    code.scale(0.28)\n\n    return code\n\n\nclass DropoutNeuralNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(4, rectangle_color=BLUE),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code_snippet = make_code_snippet()\n        self.add(code_snippet)\n        code_snippet.next_to(nn, DOWN * 0.7)\n        Group(code_snippet, nn).move_to(ORIGIN)\n        # Play animation\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n        self.wait(1)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    dropout_nn_scene = DropoutNeuralNetworkScene()\n    dropout_nn_scene.render()\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_nn_dropout.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_nn_dropout.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.animations.dropout import (\n    make_neural_network_dropout_animation,\n)\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom PIL import Image\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport numpy as np\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\" \n        nn = NeuralNetwork([\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(3),\n            FeedForwardLayer(5),\n            FeedForwardLayer(4),\n        ])\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        language=\"py\",\n    )\n    code.scale(0.28)\n\n    return code\n\n\nclass DropoutNeuralNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(4, rectangle_color=BLUE),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Make code snippet\n        code_snippet = make_code_snippet()\n        self.add(code_snippet)\n        code_snippet.next_to(nn, DOWN * 0.7)\n        Group(code_snippet, nn).move_to(ORIGIN)\n        # Play animation\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n        self.wait(1)\n\n\nif __name__ == \"__main__\":\n    \"\"\"Render all scenes\"\"\"\n    dropout_nn_scene = DropoutNeuralNetworkScene()\n    dropout_nn_scene.render()\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_nn_dropout.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a polar coordinate grid labeled in terms of \u03c0 radians. A vector is drawn from the origin to the point corresponding to the polar coordinates \\( (3, \\frac{\\pi}{4}) \\), visually illustrating the conversion from polar to Cartesian coordinates."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolarToPointExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\n        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\n        self.add(polarplane_pi)\n        self.add(polartopoint_vector)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a polar coordinate grid labeled in terms of \u03c0 radians. A vector is drawn from the origin to the point corresponding to the polar coordinates \\( (3, \\frac{\\pi}{4}) \\), visually illustrating the conversion from polar to Cartesian coordinates."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a polar coordinate grid labeled in terms of \u03c0 radians. a vector is drawn from the origin to the point corresponding to the polar coordinates \\( (3, \\frac{\\pi}{4}) \\), visually illustrating the conversion from polar to cartesian coordinates."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolarToPointExample(Scene):\n    def construct(self):\n        polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\n        polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\n        self.add(polarplane_pi)\n        self.add(polartopoint_vector)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a polar coordinate grid labeled in terms of \u03c0 radians. A vector is drawn from the origin to the point corresponding to the polar coordinates \\( (3, \\frac{\\pi}{4}) \\), visually illustrating the conversion from polar to Cartesian coordinates."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can the Heisenberg group be represented as a topological group, and what geometric insights does its structure offer?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeisenbergGroupScene(Scene):\n    def construct(self):\n        # Introduction - Title slide\n        title = Text(\"Unveiling the Heisenberg Group\", font_size=40)\n        subtitle = Text(\"A Topological Adventure\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: The Heisenberg Matrix representation\n        concept1 = Text(\"The Heisenberg Group Matrix\")\n        self.play(Write(concept1))\n        self.wait(1)\n        self.play(concept1.animate.to_edge(UP))\n        \n        # Display the 3x3 matrix that defines the Heisenberg group\n        matrix = MathTex(r\"\\begin{bmatrix} 1 & a & b \\\\ 0 & 1 & c \\\\ 0 & 0 & 1 \\end{bmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n        \n        # Show non-commutativity property (AB \u2260 BA)\n        noncomm = MathTex(\"AB \\\\neq BA\")\n        noncomm.next_to(matrix, DOWN, buff=0.7)\n        self.play(Write(noncomm))\n        self.wait(1)\n        \n        self.play(FadeOut(concept1), FadeOut(matrix), FadeOut(noncomm))\n        \n        # Key Concept 2: Visualizing non-commutativity with movements\n        concept2 = Text(\"Non-commutative Movement\")\n        self.play(Write(concept2))\n        self.wait(1)\n        self.play(concept2.animate.to_edge(UP))\n        \n        # Create a dot to represent a point in space\n        dot = Dot(color=YELLOW)\n        self.play(Create(dot))\n        \n        # Show Path 1: Moving along a-axis then b-axis\n        arrow1 = Arrow(start=ORIGIN, end=RIGHT*2, color=RED)  # a-direction\n        arrow2 = Arrow(start=RIGHT*2, end=RIGHT*2+UP*2, color=BLUE)  # b-direction\n        \n        self.play(Create(arrow1))\n        self.play(dot.animate.shift(RIGHT*2))\n        self.play(Create(arrow2))\n        self.play(dot.animate.shift(UP*2))\n        \n        path1_text = Text(\"Path: a then b\")\n        path1_text.next_to(dot, RIGHT)\n        self.play(Write(path1_text))\n        self.wait(1)\n        \n        self.play(\n            FadeOut(dot),\n            FadeOut(arrow1),\n            FadeOut(arrow2),\n            FadeOut(path1_text)\n        )\n        \n        self.play(FadeOut(concept2))\n        \n        # Key Concept 3: Representing the topological structure\n        concept3 = Text(\"Topological Group Structure\")\n        self.play(Write(concept3))\n        self.wait(1)\n        self.play(concept3.animate.to_edge(UP))\n        \n        # Simple circle to represent the topological space\n        circle = Circle(radius=2, color=BLUE)\n        self.play(Create(circle))\n        self.wait(1)\n        \n        self.play(FadeOut(concept3), FadeOut(circle))\n        \n        # Conclusion: Summarizing the Heisenberg group concepts\n        conclusion = Text(\"The Heisenberg Group\")\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(conclusion.animate.to_edge(UP))\n        \n        final_text = Text(\"Connects algebra and topology\")\n        final_text.next_to(conclusion, DOWN, buff=0.5)\n        self.play(Write(final_text))\n        \n        # Show the matrix one last time to reinforce the concept\n        final_matrix = MathTex(r\"\\begin{bmatrix} 1 & a & b \\\\ 0 & 1 & c \\\\ 0 & 0 & 1 \\end{bmatrix}\")\n        final_matrix.next_to(final_text, DOWN, buff=0.7)\n        self.play(Write(final_matrix))\n        \n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(final_text), FadeOut(final_matrix))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can the Heisenberg group be represented as a topological group, and what geometric insights does its structure offer?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can the heisenberg group be represented as a topological group, and what geometric insights does its structure offer?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeisenbergGroupScene(Scene):\n    def construct(self):\n        # Introduction - Title slide\n        title = Text(\"Unveiling the Heisenberg Group\", font_size=40)\n        subtitle = Text(\"A Topological Adventure\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: The Heisenberg Matrix representation\n        concept1 = Text(\"The Heisenberg Group Matrix\")\n        self.play(Write(concept1))\n        self.wait(1)\n        self.play(concept1.animate.to_edge(UP))\n        \n        # Display the 3x3 matrix that defines the Heisenberg group\n        matrix = MathTex(r\"\\begin{bmatrix} 1 & a & b \\\\ 0 & 1 & c \\\\ 0 & 0 & 1 \\end{bmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n        \n        # Show non-commutativity property (AB \u2260 BA)\n        noncomm = MathTex(\"AB \\\\neq BA\")\n        noncomm.next_to(matrix, DOWN, buff=0.7)\n        self.play(Write(noncomm))\n        self.wait(1)\n        \n        self.play(FadeOut(concept1), FadeOut(matrix), FadeOut(noncomm))\n        \n        # Key Concept 2: Visualizing non-commutativity with movements\n        concept2 = Text(\"Non-commutative Movement\")\n        self.play(Write(concept2))\n        self.wait(1)\n        self.play(concept2.animate.to_edge(UP))\n        \n        # Create a dot to represent a point in space\n        dot = Dot(color=YELLOW)\n        self.play(Create(dot))\n        \n        # Show Path 1: Moving along a-axis then b-axis\n        arrow1 = Arrow(start=ORIGIN, end=RIGHT*2, color=RED)  # a-direction\n        arrow2 = Arrow(start=RIGHT*2, end=RIGHT*2+UP*2, color=BLUE)  # b-direction\n        \n        self.play(Create(arrow1))\n        self.play(dot.animate.shift(RIGHT*2))\n        self.play(Create(arrow2))\n        self.play(dot.animate.shift(UP*2))\n        \n        path1_text = Text(\"Path: a then b\")\n        path1_text.next_to(dot, RIGHT)\n        self.play(Write(path1_text))\n        self.wait(1)\n        \n        self.play(\n            FadeOut(dot),\n            FadeOut(arrow1),\n            FadeOut(arrow2),\n            FadeOut(path1_text)\n        )\n        \n        self.play(FadeOut(concept2))\n        \n        # Key Concept 3: Representing the topological structure\n        concept3 = Text(\"Topological Group Structure\")\n        self.play(Write(concept3))\n        self.wait(1)\n        self.play(concept3.animate.to_edge(UP))\n        \n        # Simple circle to represent the topological space\n        circle = Circle(radius=2, color=BLUE)\n        self.play(Create(circle))\n        self.wait(1)\n        \n        self.play(FadeOut(concept3), FadeOut(circle))\n        \n        # Conclusion: Summarizing the Heisenberg group concepts\n        conclusion = Text(\"The Heisenberg Group\")\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(conclusion.animate.to_edge(UP))\n        \n        final_text = Text(\"Connects algebra and topology\")\n        final_text.next_to(conclusion, DOWN, buff=0.5)\n        self.play(Write(final_text))\n        \n        # Show the matrix one last time to reinforce the concept\n        final_matrix = MathTex(r\"\\begin{bmatrix} 1 & a & b \\\\ 0 & 1 & c \\\\ 0 & 0 & 1 \\end{bmatrix}\")\n        final_matrix.next_to(final_text, DOWN, buff=0.7)\n        self.play(Write(final_matrix))\n        \n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(final_text), FadeOut(final_matrix))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can the Heisenberg group be represented as a topological group, and what geometric insights does its structure offer?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that first displays the formula of a Fourier series, followed by a brief textual explanation of what a Fourier series is? Then, replace the initial text with an explanation that the coefficients in the series are derived from the function itself. Next, can you transition to showing the actual formulas used to calculate these coefficients, and finish with another short explanation mentioning that each term in the series represents a harmonic of the base frequency? After all of this, clear everything away to conclude the presentation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass AnimationScene(Scene):\n    def construct(self):\n                self.play(Transform(text,Text(\"FadeIn\").shift(UP*2.5)), run_time=0.5)\n                square = Square()\n                self.play(FadeIn(square))\n                self.play(Transform(text,Text(\"FadeOut\").shift(UP*2.5)), run_time=0.5)\n                self.play(FadeOut(square))\n                self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that first displays the formula of a Fourier series, followed by a brief textual explanation of what a Fourier series is? Then, replace the initial text with an explanation that the coefficients in the series are derived from the function itself. Next, can you transition to showing the actual formulas used to calculate these coefficients, and finish with another short explanation mentioning that each term in the series represents a harmonic of the base frequency? After all of this, clear everything away to conclude the presentation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that first displays the formula of a fourier series, followed by a brief textual explanation of what a fourier series is? then, replace the initial text with an explanation that the coefficients in the series are derived from the function itself. next, can you transition to showing the actual formulas used to calculate these coefficients, and finish with another short explanation mentioning that each term in the series represents a harmonic of the base frequency? after all of this, clear everything away to conclude the presentation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass AnimationScene(Scene):\n    def construct(self):\n                self.play(Transform(text,Text(\"FadeIn\").shift(UP*2.5)), run_time=0.5)\n                square = Square()\n                self.play(FadeIn(square))\n                self.play(Transform(text,Text(\"FadeOut\").shift(UP*2.5)), run_time=0.5)\n                self.play(FadeOut(square))\n                self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that first displays the formula of a Fourier series, followed by a brief textual explanation of what a Fourier series is? Then, replace the initial text with an explanation that the coefficients in the series are derived from the function itself. Next, can you transition to showing the actual formulas used to calculate these coefficients, and finish with another short explanation mentioning that each term in the series represents a harmonic of the base frequency? After all of this, clear everything away to conclude the presentation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the Braess Paradox occur in congestion games, and can we illustrate a scenario where adding an extra road increases overall congestion?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BraessParadox(Scene):\n    def construct(self):\n        # Title introduction\n        title = Text(\"The Surprise of More: Understanding Braess's Paradox\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP).scale(0.6))\n        \n        # Create the network nodes (diamond shape)\n        point_a = Dot(LEFT * 3)  # Starting point\n        point_b = Dot(RIGHT * 3)  # Ending point\n        top = Dot(UP * 1.5)  # Top junction\n        bottom = Dot(DOWN * 1.5)  # Bottom junction\n        \n        # Add labels to the main points\n        label_a = Text(\"A (Home)\").next_to(point_a, DOWN)\n        label_b = Text(\"B (Workplace)\").next_to(point_b, DOWN)\n        \n        # Create the initial roads forming two paths\n        road1 = Line(point_a.get_center(), top.get_center(), color=BLUE)  # Upper-left road\n        road2 = Line(top.get_center(), point_b.get_center(), color=BLUE)  # Upper-right road\n        road3 = Line(point_a.get_center(), bottom.get_center(), color=GREEN)  # Lower-left road\n        road4 = Line(bottom.get_center(), point_b.get_center(), color=GREEN)  # Lower-right road\n        \n        # Show the network construction\n        self.play(Create(point_a), Create(point_b))\n        self.play(Write(label_a), Write(label_b))\n        self.play(Create(top), Create(bottom))\n        self.play(Create(road1), Create(road2), Create(road3), Create(road4))\n        \n        # Explain the initial state\n        explanation = Text(\"Two roads connect points A and B\").scale(0.8).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Add cars to represent traffic\n        car1 = Square(side_length=0.3, color=RED).move_to(road1.get_center())\n        car2 = Square(side_length=0.3, color=RED).move_to(road2.get_center())\n        car3 = Square(side_length=0.3, color=RED).move_to(road3.get_center())\n        car4 = Square(side_length=0.3, color=RED).move_to(road4.get_center())\n        \n        self.play(Create(car1), Create(car2), Create(car3), Create(car4))\n        self.wait(1)\n        \n        # Display the travel time equation\n        self.play(FadeOut(explanation))\n        travel_time = Text(\"Travel Time: T(x) = c + f(x)\").scale(0.8).next_to(title, DOWN)\n        self.play(Write(travel_time))\n        self.wait(1)\n        \n        # Introduce the new road\n        new_road_text = Text(\"What happens when we add a new road?\").scale(0.8).to_edge(DOWN)\n        self.play(Write(new_road_text))\n        \n        # Create the new shortcut road\n        new_road = Line(top.get_center(), bottom.get_center(), color=RED)\n        self.play(Create(new_road))\n        self.wait(1)\n        \n        # Explain rerouting and increased congestion\n        self.play(FadeOut(new_road_text))\n        reroute_text = Text(\"Drivers reroute to minimize personal travel time\").scale(0.7).to_edge(DOWN)\n        self.play(Write(reroute_text))\n        \n        # Add more cars to show increased congestion\n        car5 = Square(side_length=0.3, color=RED).move_to(new_road.point_from_proportion(0.3))\n        car6 = Square(side_length=0.3, color=RED).move_to(new_road.point_from_proportion(0.7))\n        \n        self.play(Create(car5), Create(car6))\n        self.wait(1)\n        \n        # Explain the paradox that occurs\n        self.play(FadeOut(reroute_text))\n        paradox = Text(\"Paradox: Overall travel time increases!\").scale(0.8).to_edge(DOWN)\n        self.play(Write(paradox))\n        self.wait(1)\n        \n        # Introduce Nash Equilibrium concept\n        nash = Text(\"Nash Equilibrium: Each driver optimizes their own route\").scale(0.7).next_to(travel_time, DOWN)\n        self.play(Write(nash))\n        self.wait(1)\n        \n        # Conclusion - clean up and summarize\n        self.play(\n            FadeOut(paradox), FadeOut(nash), FadeOut(travel_time),\n            FadeOut(car1), FadeOut(car2), FadeOut(car3), FadeOut(car4), FadeOut(car5), FadeOut(car6),\n            FadeOut(point_a), FadeOut(point_b), FadeOut(top), FadeOut(bottom),\n            FadeOut(label_a), FadeOut(label_b),\n            FadeOut(road1), FadeOut(road2), FadeOut(road3), FadeOut(road4), FadeOut(new_road),\n            FadeOut(title)\n        )\n        \n        # Final message\n        conclusion = Text(\"In game theory, adding resources\\ncan sometimes worsen collective outcomes\").scale(0.9)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Braess Paradox occur in congestion games, and can we illustrate a scenario where adding an extra road increases overall congestion?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the braess paradox occur in congestion games, and can we illustrate a scenario where adding an extra road increases overall congestion?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BraessParadox(Scene):\n    def construct(self):\n        # Title introduction\n        title = Text(\"The Surprise of More: Understanding Braess's Paradox\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP).scale(0.6))\n        \n        # Create the network nodes (diamond shape)\n        point_a = Dot(LEFT * 3)  # Starting point\n        point_b = Dot(RIGHT * 3)  # Ending point\n        top = Dot(UP * 1.5)  # Top junction\n        bottom = Dot(DOWN * 1.5)  # Bottom junction\n        \n        # Add labels to the main points\n        label_a = Text(\"A (Home)\").next_to(point_a, DOWN)\n        label_b = Text(\"B (Workplace)\").next_to(point_b, DOWN)\n        \n        # Create the initial roads forming two paths\n        road1 = Line(point_a.get_center(), top.get_center(), color=BLUE)  # Upper-left road\n        road2 = Line(top.get_center(), point_b.get_center(), color=BLUE)  # Upper-right road\n        road3 = Line(point_a.get_center(), bottom.get_center(), color=GREEN)  # Lower-left road\n        road4 = Line(bottom.get_center(), point_b.get_center(), color=GREEN)  # Lower-right road\n        \n        # Show the network construction\n        self.play(Create(point_a), Create(point_b))\n        self.play(Write(label_a), Write(label_b))\n        self.play(Create(top), Create(bottom))\n        self.play(Create(road1), Create(road2), Create(road3), Create(road4))\n        \n        # Explain the initial state\n        explanation = Text(\"Two roads connect points A and B\").scale(0.8).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Add cars to represent traffic\n        car1 = Square(side_length=0.3, color=RED).move_to(road1.get_center())\n        car2 = Square(side_length=0.3, color=RED).move_to(road2.get_center())\n        car3 = Square(side_length=0.3, color=RED).move_to(road3.get_center())\n        car4 = Square(side_length=0.3, color=RED).move_to(road4.get_center())\n        \n        self.play(Create(car1), Create(car2), Create(car3), Create(car4))\n        self.wait(1)\n        \n        # Display the travel time equation\n        self.play(FadeOut(explanation))\n        travel_time = Text(\"Travel Time: T(x) = c + f(x)\").scale(0.8).next_to(title, DOWN)\n        self.play(Write(travel_time))\n        self.wait(1)\n        \n        # Introduce the new road\n        new_road_text = Text(\"What happens when we add a new road?\").scale(0.8).to_edge(DOWN)\n        self.play(Write(new_road_text))\n        \n        # Create the new shortcut road\n        new_road = Line(top.get_center(), bottom.get_center(), color=RED)\n        self.play(Create(new_road))\n        self.wait(1)\n        \n        # Explain rerouting and increased congestion\n        self.play(FadeOut(new_road_text))\n        reroute_text = Text(\"Drivers reroute to minimize personal travel time\").scale(0.7).to_edge(DOWN)\n        self.play(Write(reroute_text))\n        \n        # Add more cars to show increased congestion\n        car5 = Square(side_length=0.3, color=RED).move_to(new_road.point_from_proportion(0.3))\n        car6 = Square(side_length=0.3, color=RED).move_to(new_road.point_from_proportion(0.7))\n        \n        self.play(Create(car5), Create(car6))\n        self.wait(1)\n        \n        # Explain the paradox that occurs\n        self.play(FadeOut(reroute_text))\n        paradox = Text(\"Paradox: Overall travel time increases!\").scale(0.8).to_edge(DOWN)\n        self.play(Write(paradox))\n        self.wait(1)\n        \n        # Introduce Nash Equilibrium concept\n        nash = Text(\"Nash Equilibrium: Each driver optimizes their own route\").scale(0.7).next_to(travel_time, DOWN)\n        self.play(Write(nash))\n        self.wait(1)\n        \n        # Conclusion - clean up and summarize\n        self.play(\n            FadeOut(paradox), FadeOut(nash), FadeOut(travel_time),\n            FadeOut(car1), FadeOut(car2), FadeOut(car3), FadeOut(car4), FadeOut(car5), FadeOut(car6),\n            FadeOut(point_a), FadeOut(point_b), FadeOut(top), FadeOut(bottom),\n            FadeOut(label_a), FadeOut(label_b),\n            FadeOut(road1), FadeOut(road2), FadeOut(road3), FadeOut(road4), FadeOut(new_road),\n            FadeOut(title)\n        )\n        \n        # Final message\n        conclusion = Text(\"In game theory, adding resources\\ncan sometimes worsen collective outcomes\").scale(0.9)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Braess Paradox occur in congestion games, and can we illustrate a scenario where adding an extra road increases overall congestion?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create a simple animation using ManimCE that depicts a hydrogen atom, consisting of a proton and an electron, where the proton is represented by a red circle with a plus sign and the electron by a blue circle with a minus sign, both labeled accordingly, and then group them together with a little space in between? Once the atom is shown, I would like the whole atom to shift upwards on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\nabla^2 u = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the equation\n        explanation1 = Text(\"This is the classical wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Introduce the speed of waves\n        explanation2 = Text(\"Here, c represents the speed of waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution format\n        solution_format = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(equation, solution_format))\n        self.wait(2)\n\n        # Explanation for d'Alembert's formula\n        explanation3 = Text(\"Solutions can be described by d'Alembert's formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Displaying specific example\n        specific_example = MathTex(r\"u(x, t) = A \\sin(k(x - ct))\")\n        self.play(Transform(equation, specific_example))\n        self.wait(2)\n\n        # Explanation for the specific solution\n        explanation4 = Text(\"This represents a sinusoidal traveling wave.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_example))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create a simple animation using ManimCE that depicts a hydrogen atom, consisting of a proton and an electron, where the proton is represented by a red circle with a plus sign and the electron by a blue circle with a minus sign, both labeled accordingly, and then group them together with a little space in between? Once the atom is shown, I would like the whole atom to shift upwards on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create a simple animation using manimce that depicts a hydrogen atom, consisting of a proton and an electron, where the proton is represented by a red circle with a plus sign and the electron by a blue circle with a minus sign, both labeled accordingly, and then group them together with a little space in between? once the atom is shown, i would like the whole atom to shift upwards on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        equation = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\nabla^2 u = 0\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for the equation\n        explanation1 = Text(\"This is the classical wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Introduce the speed of waves\n        explanation2 = Text(\"Here, c represents the speed of waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution format\n        solution_format = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(equation, solution_format))\n        self.wait(2)\n\n        # Explanation for d'Alembert's formula\n        explanation3 = Text(\"Solutions can be described by d'Alembert's formula.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Displaying specific example\n        specific_example = MathTex(r\"u(x, t) = A \\sin(k(x - ct))\")\n        self.play(Transform(equation, specific_example))\n        self.wait(2)\n\n        # Explanation for the specific solution\n        explanation4 = Text(\"This represents a sinusoidal traveling wave.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Clear the scene and end\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_example))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create a simple animation using ManimCE that depicts a hydrogen atom, consisting of a proton and an electron, where the proton is represented by a red circle with a plus sign and the electron by a blue circle with a minus sign, both labeled accordingly, and then group them together with a little space in between? Once the atom is shown, I would like the whole atom to shift upwards on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a fully opaque circle with a sheen effect applied. The sheen has a subtle reflective highlight that appears to come from the down-right (bottom-right) direction, giving the circle a slightly glossy, three-dimensional appearance."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SetSheen(Scene):\n    def construct(self):\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n        self.add(circle)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a fully opaque circle with a sheen effect applied. The sheen has a subtle reflective highlight that appears to come from the down-right (bottom-right) direction, giving the circle a slightly glossy, three-dimensional appearance."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a fully opaque circle with a sheen effect applied. the sheen has a subtle reflective highlight that appears to come from the down-right (bottom-right) direction, giving the circle a slightly glossy, three-dimensional appearance."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SetSheen(Scene):\n    def construct(self):\n        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n        self.add(circle)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a fully opaque circle with a sheen effect applied. The sheen has a subtle reflective highlight that appears to come from the down-right (bottom-right) direction, giving the circle a slightly glossy, three-dimensional appearance."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does modifying the Christoffel symbols affect the curvature of a manifold?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChristoffelSymbolsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling Curvature: The Secret World of Christoffel Symbols\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction - Globe representing a manifold\n        circle = Circle(radius=2, color=BLUE)\n        \n        # Create a simple grid on the circle to represent a manifold\n        grid_lines = VGroup()\n        for i in range(-2, 3):\n            h_line = Line(LEFT * 2, RIGHT * 2, color=WHITE).shift(UP * i/2)\n            v_line = Line(UP * 2, DOWN * 2, color=WHITE).shift(RIGHT * i/2)\n            grid_lines.add(h_line, v_line)\n        \n        manifold = VGroup(circle, grid_lines)\n        \n        intro_text = Text(\"Imagine standing on a planet's surface\", font_size=24)\n        intro_text.next_to(manifold, DOWN)\n        \n        self.play(Create(circle))\n        self.play(Create(grid_lines))\n        self.play(Write(intro_text))\n        self.play(Rotate(manifold, angle=PI/2))\n        self.wait(1)\n        \n        # Key Concept 1: Christoffel Symbols\n        self.play(FadeOut(intro_text))\n        concept1_text = Text(\"Christoffel Symbols\", font_size=28)\n        concept1_text.next_to(title, DOWN)\n        \n        christoffel_eq = MathTex(r\"\\Gamma^k_{ij}\")\n        christoffel_eq.next_to(concept1_text, DOWN)\n        \n        self.play(Write(concept1_text))\n        self.play(Write(christoffel_eq))\n        self.wait(1)\n        \n        # Key Concept 2: Parallel Transport\n        self.play(FadeOut(concept1_text), FadeOut(christoffel_eq))\n        concept2_text = Text(\"Parallel Transport\", font_size=28)\n        concept2_text.next_to(title, DOWN)\n        \n        # Simple curved path\n        path = Arc(radius=1.5, start_angle=PI, angle=-PI, color=YELLOW)\n        \n        # Vector to be transported\n        vector = Arrow(start=path.get_start(), end=path.get_start() + UP, color=RED)\n        \n        self.play(Write(concept2_text))\n        self.play(Create(path))\n        self.play(Create(vector))\n        \n        # Show vector at different position (simplified parallel transport)\n        new_vector = Arrow(start=path.get_end(), end=path.get_end() + DOWN, color=RED)\n        self.play(Transform(vector, new_vector))\n        self.wait(1)\n        \n        # Key Concept 3: Curvature and Geodesics\n        self.play(FadeOut(concept2_text), FadeOut(path), FadeOut(vector))\n        concept3_text = Text(\"Curvature and Geodesics\", font_size=28)\n        concept3_text.next_to(title, DOWN)\n        \n        # Geodesic visualization\n        geodesic1 = Line(LEFT * 1.5, RIGHT * 1.5, color=RED)\n        geodesic2 = Arc(radius=1.5, start_angle=-PI/4, angle=PI/2, color=GREEN)\n        \n        geodesic_text = Text(\"Altering Christoffel symbols changes geodesics\", font_size=24)\n        geodesic_text.next_to(geodesic1, DOWN)\n        \n        self.play(Write(concept3_text))\n        self.play(Create(geodesic1))\n        self.play(Write(geodesic_text))\n        self.play(Transform(geodesic1, geodesic2))\n        self.wait(1)\n        \n        # Key Insight: Influence of Modification\n        self.play(\n            FadeOut(concept3_text),\n            FadeOut(geodesic1),\n            FadeOut(geodesic_text)\n        )\n        \n        insight_text = Text(\"Modifying Christoffel symbols affects curvature\", font_size=28)\n        insight_text.next_to(title, DOWN)\n        \n        curvature_eq = MathTex(r\"R^k_{lij} = \\partial_i \\Gamma^k_{lj} - \\partial_j \\Gamma^k_{li} + \\Gamma \\Gamma\")\n        curvature_eq.scale(0.7)\n        curvature_eq.next_to(insight_text, DOWN)\n        \n        self.play(Write(insight_text))\n        self.play(Write(curvature_eq))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(insight_text), FadeOut(curvature_eq))\n        \n        conclusion_text = Text(\"A complex dance of mathematical elegance\", font_size=28)\n        conclusion_text.next_to(title, DOWN)\n        \n        self.play(Write(conclusion_text))\n        self.play(Rotate(manifold, angle=PI/2))\n        self.wait(1)\n        \n        # Final fade out\n        self.play(\n            FadeOut(manifold),\n            FadeOut(title),\n            FadeOut(conclusion_text)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does modifying the Christoffel symbols affect the curvature of a manifold?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does modifying the christoffel symbols affect the curvature of a manifold?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChristoffelSymbolsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling Curvature: The Secret World of Christoffel Symbols\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction - Globe representing a manifold\n        circle = Circle(radius=2, color=BLUE)\n        \n        # Create a simple grid on the circle to represent a manifold\n        grid_lines = VGroup()\n        for i in range(-2, 3):\n            h_line = Line(LEFT * 2, RIGHT * 2, color=WHITE).shift(UP * i/2)\n            v_line = Line(UP * 2, DOWN * 2, color=WHITE).shift(RIGHT * i/2)\n            grid_lines.add(h_line, v_line)\n        \n        manifold = VGroup(circle, grid_lines)\n        \n        intro_text = Text(\"Imagine standing on a planet's surface\", font_size=24)\n        intro_text.next_to(manifold, DOWN)\n        \n        self.play(Create(circle))\n        self.play(Create(grid_lines))\n        self.play(Write(intro_text))\n        self.play(Rotate(manifold, angle=PI/2))\n        self.wait(1)\n        \n        # Key Concept 1: Christoffel Symbols\n        self.play(FadeOut(intro_text))\n        concept1_text = Text(\"Christoffel Symbols\", font_size=28)\n        concept1_text.next_to(title, DOWN)\n        \n        christoffel_eq = MathTex(r\"\\Gamma^k_{ij}\")\n        christoffel_eq.next_to(concept1_text, DOWN)\n        \n        self.play(Write(concept1_text))\n        self.play(Write(christoffel_eq))\n        self.wait(1)\n        \n        # Key Concept 2: Parallel Transport\n        self.play(FadeOut(concept1_text), FadeOut(christoffel_eq))\n        concept2_text = Text(\"Parallel Transport\", font_size=28)\n        concept2_text.next_to(title, DOWN)\n        \n        # Simple curved path\n        path = Arc(radius=1.5, start_angle=PI, angle=-PI, color=YELLOW)\n        \n        # Vector to be transported\n        vector = Arrow(start=path.get_start(), end=path.get_start() + UP, color=RED)\n        \n        self.play(Write(concept2_text))\n        self.play(Create(path))\n        self.play(Create(vector))\n        \n        # Show vector at different position (simplified parallel transport)\n        new_vector = Arrow(start=path.get_end(), end=path.get_end() + DOWN, color=RED)\n        self.play(Transform(vector, new_vector))\n        self.wait(1)\n        \n        # Key Concept 3: Curvature and Geodesics\n        self.play(FadeOut(concept2_text), FadeOut(path), FadeOut(vector))\n        concept3_text = Text(\"Curvature and Geodesics\", font_size=28)\n        concept3_text.next_to(title, DOWN)\n        \n        # Geodesic visualization\n        geodesic1 = Line(LEFT * 1.5, RIGHT * 1.5, color=RED)\n        geodesic2 = Arc(radius=1.5, start_angle=-PI/4, angle=PI/2, color=GREEN)\n        \n        geodesic_text = Text(\"Altering Christoffel symbols changes geodesics\", font_size=24)\n        geodesic_text.next_to(geodesic1, DOWN)\n        \n        self.play(Write(concept3_text))\n        self.play(Create(geodesic1))\n        self.play(Write(geodesic_text))\n        self.play(Transform(geodesic1, geodesic2))\n        self.wait(1)\n        \n        # Key Insight: Influence of Modification\n        self.play(\n            FadeOut(concept3_text),\n            FadeOut(geodesic1),\n            FadeOut(geodesic_text)\n        )\n        \n        insight_text = Text(\"Modifying Christoffel symbols affects curvature\", font_size=28)\n        insight_text.next_to(title, DOWN)\n        \n        curvature_eq = MathTex(r\"R^k_{lij} = \\partial_i \\Gamma^k_{lj} - \\partial_j \\Gamma^k_{li} + \\Gamma \\Gamma\")\n        curvature_eq.scale(0.7)\n        curvature_eq.next_to(insight_text, DOWN)\n        \n        self.play(Write(insight_text))\n        self.play(Write(curvature_eq))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(insight_text), FadeOut(curvature_eq))\n        \n        conclusion_text = Text(\"A complex dance of mathematical elegance\", font_size=28)\n        conclusion_text.next_to(title, DOWN)\n        \n        self.play(Write(conclusion_text))\n        self.play(Rotate(manifold, angle=PI/2))\n        self.wait(1)\n        \n        # Final fade out\n        self.play(\n            FadeOut(manifold),\n            FadeOut(title),\n            FadeOut(conclusion_text)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does modifying the Christoffel symbols affect the curvature of a manifold?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animation that visualizes the training process of a simple neural network with three layers, where the first layer has 4 neurons, the second layer has 7 neurons, and the third layer has 2 neurons? The neural network should be centered on the screen and the animation should clearly show some kind of training activity or process happening. Also, please ensure the animation ends with a pause so we can see the final state of the network."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define the problem of calculating a definite integral\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the method to evaluate the definite integral\n        explanation1 = Text(\"Evaluate the integral using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the indefinite integral using the power rule\n        indefinite_integral = MathTex(r\"\\int x^2 \\,dx = \\frac{x^{3}}{3} + C\")\n        self.play(Write(indefinite_integral))\n        self.wait(2)\n\n        # Evaluating at the bounds\n        evaluation = MathTex(r\"\\bigg[ \\frac{x^{3}}{3} \\bigg]_2^3\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(1)\n\n        # Explanation for the evaluation step\n        explanation2 = Text(\"Substitute the bounds and subtract:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Performing the subtraction\n        subtraction = MathTex(r\"\\bigg( \\frac{3^{3}}{3} \\bigg) - \\bigg( \\frac{2^{3}}{3} \\bigg)\")\n        self.play(ReplacementTransform(evaluation, subtraction))\n        self.wait(2)\n\n        # Final calculation\n        final_calculation = MathTex(r\"= \\frac{27}{3} - \\frac{8}{3}\")\n        self.play(Transform(subtraction, final_calculation))\n        self.wait(1)\n\n        solution = MathTex(r\"= 19 / 3\")\n        self.play(Transform(final_calculation, solution))\n        self.wait(1)\n\n        # Clear scene and display the solution\n        self.clear()\n        self.wait(1)\n\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation that visualizes the training process of a simple neural network with three layers, where the first layer has 4 neurons, the second layer has 7 neurons, and the third layer has 2 neurons? The neural network should be centered on the screen and the animation should clearly show some kind of training activity or process happening. Also, please ensure the animation ends with a pause so we can see the final state of the network."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animation that visualizes the training process of a simple neural network with three layers, where the first layer has 4 neurons, the second layer has 7 neurons, and the third layer has 2 neurons? the neural network should be centered on the screen and the animation should clearly show some kind of training activity or process happening. also, please ensure the animation ends with a pause so we can see the final state of the network."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define the problem of calculating a definite integral\n        problem = MathTex(r\"\\int_2^3 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the method to evaluate the definite integral\n        explanation1 = Text(\"Evaluate the integral using the power rule:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the indefinite integral using the power rule\n        indefinite_integral = MathTex(r\"\\int x^2 \\,dx = \\frac{x^{3}}{3} + C\")\n        self.play(Write(indefinite_integral))\n        self.wait(2)\n\n        # Evaluating at the bounds\n        evaluation = MathTex(r\"\\bigg[ \\frac{x^{3}}{3} \\bigg]_2^3\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(1)\n\n        # Explanation for the evaluation step\n        explanation2 = Text(\"Substitute the bounds and subtract:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Performing the subtraction\n        subtraction = MathTex(r\"\\bigg( \\frac{3^{3}}{3} \\bigg) - \\bigg( \\frac{2^{3}}{3} \\bigg)\")\n        self.play(ReplacementTransform(evaluation, subtraction))\n        self.wait(2)\n\n        # Final calculation\n        final_calculation = MathTex(r\"= \\frac{27}{3} - \\frac{8}{3}\")\n        self.play(Transform(subtraction, final_calculation))\n        self.wait(1)\n\n        solution = MathTex(r\"= 19 / 3\")\n        self.play(Transform(final_calculation, solution))\n        self.wait(1)\n\n        # Clear scene and display the solution\n        self.clear()\n        self.wait(1)\n\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation that visualizes the training process of a simple neural network with three layers, where the first layer has 4 neurons, the second layer has 7 neurons, and the third layer has 2 neurons? The neural network should be centered on the screen and the animation should clearly show some kind of training activity or process happening. Also, please ensure the animation ends with a pause so we can see the final state of the network."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an educational animation that starts by displaying the mathematical function f(x) = x^2 on the screen. Then, I want the animation to present a task to calculate the area under this curve from x = 0 to x = 2 with a text description. Next, the animation should show the formula for the definite integral of x squared from 0 to 2, as a means to find that area under the curve, with an added text explanation about using the definite integral. After that, it should transform the integral into the antiderivative, which is (1/3)x^3 evaluated from 0 to 2, and finally show the numerical result of the area calculation, which is 8/3. At the end, clean up the animation so only the final numerical result is displayed."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HydrogenScene(Scene):\n    def construct(self):\n        hydrogen = self.hydrogen_atom()\n        self.play(ShowCreation(hydrogen))\n        self.wait(2)\n\n    def hydrogen_atom(self) -> Mobject:\n        electron_orbit = self.get_electron_orbit()\n        proton = self.proton()\n        electron = self.electron()\n        return VGroup(proton, electron_orbit, electron)\n\n    def get_electron_orbit(self) -> Mobject:\n        orbit = Circle(radius=1, color=BLUE)\n        orbit.set_stroke(width=2)\n        return orbit\n\n    def proton(self) -> Mobject:\n        return circle_with_text(0.3, \"P$^+$\", RED, 24, BLACK, 2, RED)\n\n    def electron(self) -> Mobject:\n        electron = Dot(point=RIGHT, radius=0.08, color=BLUE)\n        electron.shift(UP * self.get_electron_orbit().radius)\n        orbit_animation = Rotate(electron, angle=2 * PI, about_point=ORIGIN, rate_func=linear)\n        self.play(orbit_animation, run_time=5, rate_func=linear)\n        return electron\n\ndef circle_with_text(\n    radius: float, txt: str, color=WHITE, font_size: int = 10, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n) -> Mobject:\n    circle = Circle(radius, color=color, fill_opacity=1).set_fill(color=fill_color)\n    text = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(circle, text).move_to(ORIGIN)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational animation that starts by displaying the mathematical function f(x) = x^2 on the screen. Then, I want the animation to present a task to calculate the area under this curve from x = 0 to x = 2 with a text description. Next, the animation should show the formula for the definite integral of x squared from 0 to 2, as a means to find that area under the curve, with an added text explanation about using the definite integral. After that, it should transform the integral into the antiderivative, which is (1/3)x^3 evaluated from 0 to 2, and finally show the numerical result of the area calculation, which is 8/3. At the end, clean up the animation so only the final numerical result is displayed."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an educational animation that starts by displaying the mathematical function f(x) = x^2 on the screen. then, i want the animation to present a task to calculate the area under this curve from x = 0 to x = 2 with a text description. next, the animation should show the formula for the definite integral of x squared from 0 to 2, as a means to find that area under the curve, with an added text explanation about using the definite integral. after that, it should transform the integral into the antiderivative, which is (1/3)x^3 evaluated from 0 to 2, and finally show the numerical result of the area calculation, which is 8/3. at the end, clean up the animation so only the final numerical result is displayed."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HydrogenScene(Scene):\n    def construct(self):\n        hydrogen = self.hydrogen_atom()\n        self.play(ShowCreation(hydrogen))\n        self.wait(2)\n\n    def hydrogen_atom(self) -> Mobject:\n        electron_orbit = self.get_electron_orbit()\n        proton = self.proton()\n        electron = self.electron()\n        return VGroup(proton, electron_orbit, electron)\n\n    def get_electron_orbit(self) -> Mobject:\n        orbit = Circle(radius=1, color=BLUE)\n        orbit.set_stroke(width=2)\n        return orbit\n\n    def proton(self) -> Mobject:\n        return circle_with_text(0.3, \"P$^+$\", RED, 24, BLACK, 2, RED)\n\n    def electron(self) -> Mobject:\n        electron = Dot(point=RIGHT, radius=0.08, color=BLUE)\n        electron.shift(UP * self.get_electron_orbit().radius)\n        orbit_animation = Rotate(electron, angle=2 * PI, about_point=ORIGIN, rate_func=linear)\n        self.play(orbit_animation, run_time=5, rate_func=linear)\n        return electron\n\ndef circle_with_text(\n    radius: float, txt: str, color=WHITE, font_size: int = 10, font_color=WHITE, stroke_width: int = 2, fill_color=WHITE\n) -> Mobject:\n    circle = Circle(radius, color=color, fill_opacity=1).set_fill(color=fill_color)\n    text = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n    return VGroup(circle, text).move_to(ORIGIN)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational animation that starts by displaying the mathematical function f(x) = x^2 on the screen. Then, I want the animation to present a task to calculate the area under this curve from x = 0 to x = 2 with a text description. Next, the animation should show the formula for the definite integral of x squared from 0 to 2, as a means to find that area under the curve, with an added text explanation about using the definite integral. After that, it should transform the integral into the antiderivative, which is (1/3)x^3 evaluated from 0 to 2, and finally show the numerical result of the area calculation, which is 8/3. At the end, clean up the animation so only the final numerical result is displayed."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation where two squares are side by side with a small gap between them. They should then simultaneously rotate 180 degrees over a period of 2 seconds. Can you create this using an animation software?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying the speed of wave propagation\n        speed_of_wave = Text(\"Here, \\(c\\) represents the speed of wave propagation.\", font_size=24)\n        self.play(Transform(explanation1, speed_of_wave))\n        self.wait(2)\n\n        # D'Alembert's Solution to the wave equation\n        dalembert_solution = MathTex(r\"u(x, t) = f(x-ct) + g(x+ct)\")\n        self.play(ReplacementTransform(wave_eq, dalembert_solution))\n        self.wait(2)\n\n        # Conclusion text\n        conclusion = Text(\"D'Alembert's solution uses two arbitrary functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Restate D'Alembert's Solution\n        self.play(Write(dalembert_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation where two squares are side by side with a small gap between them. They should then simultaneously rotate 180 degrees over a period of 2 seconds. Can you create this using an animation software?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation where two squares are side by side with a small gap between them. they should then simultaneously rotate 180 degrees over a period of 2 seconds. can you create this using an animation software?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Explanation for the wave equation\n        explanation1 = Text(\"This is the classic wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Displaying the speed of wave propagation\n        speed_of_wave = Text(\"Here, \\(c\\) represents the speed of wave propagation.\", font_size=24)\n        self.play(Transform(explanation1, speed_of_wave))\n        self.wait(2)\n\n        # D'Alembert's Solution to the wave equation\n        dalembert_solution = MathTex(r\"u(x, t) = f(x-ct) + g(x+ct)\")\n        self.play(ReplacementTransform(wave_eq, dalembert_solution))\n        self.wait(2)\n\n        # Conclusion text\n        conclusion = Text(\"D'Alembert's solution uses two arbitrary functions.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, conclusion))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Restate D'Alembert's Solution\n        self.play(Write(dalembert_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation where two squares are side by side with a small gap between them. They should then simultaneously rotate 180 degrees over a period of 2 seconds. Can you create this using an animation software?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the text \"Hello World!\" at the center of the screen, then animate its color gradually fading into red, creating a smooth transition effect."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text(\"Hello World!\"), color=RED))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \"Hello World!\" at the center of the screen, then animate its color gradually fading into red, creating a smooth transition effect."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the text \"hello world!\" at the center of the screen, then animate its color gradually fading into red, creating a smooth transition effect."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FadeToColorExample(Scene):\n    def construct(self):\n        self.play(FadeToColor(Text(\"Hello World!\"), color=RED))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \"Hello World!\" at the center of the screen, then animate its color gradually fading into red, creating a smooth transition effect."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What impact does Cayley's Theorem have on understanding the structure of non-abelian groups?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CayleysTheorem(Scene):\n    def construct(self):\n        # Set background to garden-like color\n        self.camera.background_color = \"#1a3a1a\"\n        \n        # Title\n        title = Text(\"The Beauty of Cayley's Theorem\", color=GOLD)\n        title.scale(0.8)\n        title.to_edge(UP)\n        \n        # Introduction\n        intro_text = Text(\"Every group is isomorphic to a group of permutations\", color=WHITE)\n        intro_text.scale(0.6)\n        intro_text.next_to(title, DOWN, buff=1)\n        \n        # Garden-like path visualization for groups\n        garden = VGroup()\n        for i in range(3):\n            path = CubicBezier(\n                start=[-3 + i, -2, 0],\n                end=[3 - i, -2, 0],\n                control1=[-1, 0.5 + i/2, 0],\n                control2=[1, 0.5 + i/2, 0]\n            )\n            path.set_stroke(color=GREEN, width=3)\n            garden.add(path)\n        \n        # Cayley's Theorem equation\n        eq = MathTex(r\"G \\cong \\text{subgroup of } S_n\", color=GOLD)\n        eq.next_to(garden, UP, buff=0.5)\n        \n        # Animation sequence for introduction\n        self.play(Write(title))\n        self.wait(1)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(Create(garden))\n        self.wait(1)\n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Clear for next section\n        self.play(FadeOut(garden), FadeOut(eq), FadeOut(intro_text))\n        \n        # Dihedral group example\n        d3_text = Text(\"Example: Dihedral Group D\u2083\", color=GOLD)\n        d3_text.next_to(title, DOWN, buff=1)\n        \n        # Create a triangle for D3 visualization\n        triangle = Polygon(\n            [-1, -0.5, 0], [1, -0.5, 0], [0, 1, 0], \n            color=GREEN, fill_opacity=0.4\n        )\n        triangle.move_to([0, 0, 0])\n        \n        # Elements of D3\n        d3_eq = MathTex(r\"D_3 = \\{ e, r, r^2, s, sr, sr^2 \\}\", color=GOLD)\n        d3_eq.next_to(triangle, DOWN, buff=1)\n        \n        # Animation for D3\n        self.play(Write(d3_text))\n        self.wait(1)\n        self.play(Create(triangle))\n        self.wait(1)\n        self.play(Write(d3_eq))\n        self.wait(2)\n        \n        # Show a simple rotation (r)\n        rotated = triangle.copy().rotate(2*PI/3)\n        self.play(Transform(triangle, rotated))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Non-abelian groups are understood through permutations\", color=GOLD)\n        conclusion.scale(0.6)\n        conclusion.to_edge(DOWN, buff=1)\n        \n        # Final animation\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(triangle), FadeOut(d3_eq), FadeOut(d3_text), FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What impact does Cayley's Theorem have on understanding the structure of non-abelian groups?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what impact does cayley's theorem have on understanding the structure of non-abelian groups?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CayleysTheorem(Scene):\n    def construct(self):\n        # Set background to garden-like color\n        self.camera.background_color = \"#1a3a1a\"\n        \n        # Title\n        title = Text(\"The Beauty of Cayley's Theorem\", color=GOLD)\n        title.scale(0.8)\n        title.to_edge(UP)\n        \n        # Introduction\n        intro_text = Text(\"Every group is isomorphic to a group of permutations\", color=WHITE)\n        intro_text.scale(0.6)\n        intro_text.next_to(title, DOWN, buff=1)\n        \n        # Garden-like path visualization for groups\n        garden = VGroup()\n        for i in range(3):\n            path = CubicBezier(\n                start=[-3 + i, -2, 0],\n                end=[3 - i, -2, 0],\n                control1=[-1, 0.5 + i/2, 0],\n                control2=[1, 0.5 + i/2, 0]\n            )\n            path.set_stroke(color=GREEN, width=3)\n            garden.add(path)\n        \n        # Cayley's Theorem equation\n        eq = MathTex(r\"G \\cong \\text{subgroup of } S_n\", color=GOLD)\n        eq.next_to(garden, UP, buff=0.5)\n        \n        # Animation sequence for introduction\n        self.play(Write(title))\n        self.wait(1)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(Create(garden))\n        self.wait(1)\n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Clear for next section\n        self.play(FadeOut(garden), FadeOut(eq), FadeOut(intro_text))\n        \n        # Dihedral group example\n        d3_text = Text(\"Example: Dihedral Group D\u2083\", color=GOLD)\n        d3_text.next_to(title, DOWN, buff=1)\n        \n        # Create a triangle for D3 visualization\n        triangle = Polygon(\n            [-1, -0.5, 0], [1, -0.5, 0], [0, 1, 0], \n            color=GREEN, fill_opacity=0.4\n        )\n        triangle.move_to([0, 0, 0])\n        \n        # Elements of D3\n        d3_eq = MathTex(r\"D_3 = \\{ e, r, r^2, s, sr, sr^2 \\}\", color=GOLD)\n        d3_eq.next_to(triangle, DOWN, buff=1)\n        \n        # Animation for D3\n        self.play(Write(d3_text))\n        self.wait(1)\n        self.play(Create(triangle))\n        self.wait(1)\n        self.play(Write(d3_eq))\n        self.wait(2)\n        \n        # Show a simple rotation (r)\n        rotated = triangle.copy().rotate(2*PI/3)\n        self.play(Transform(triangle, rotated))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Non-abelian groups are understood through permutations\", color=GOLD)\n        conclusion.scale(0.6)\n        conclusion.to_edge(DOWN, buff=1)\n        \n        # Final animation\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(triangle), FadeOut(d3_eq), FadeOut(d3_text), FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What impact does Cayley's Theorem have on understanding the structure of non-abelian groups?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the x and y axes with labels for \\(\\pi\\), \\(2\\pi\\), \\(3\\pi\\), and \\(4\\pi\\) on the x-axis. Show a unit circle centered at (-4, 0). Move a yellow dot around the circle, with a blue line connecting the origin to the dot and a yellow line from the dot to the sine curve which is drawn dynamically on the plane as the dot moves around the circle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SineCurveUnitCircle(Scene):\n    # contributed by heejin_park, https://infograph.tistory.com/230\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6,0,0])\n        x_end = np.array([6,0,0])\n\n        y_start = np.array([-4,-2,0])\n        y_end = np.array([-4,2,0])\n\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n\n        self.origin_point = np.array([-4,0,0])\n        self.curve_start = np.array([-3,0,0])\n\n    def add_x_labels(self):\n        x_labels = [\n            MathTex(r\"\\pi\"), MathTex(r\"2 \\pi\"),\n            MathTex(r\"3 \\pi\"), MathTex(r\"4 \\pi\"),\n        ]\n\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += (dt * rate)\n            # print(self.t_offset)\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )\n\n\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start,self.curve_start))\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)\n            self.curve.add(new_line)\n\n            return self.curve\n\n        dot.add_updater(go_around_circle)\n\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n\n        dot.remove_updater(go_around_circle)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the x and y axes with labels for \\(\\pi\\), \\(2\\pi\\), \\(3\\pi\\), and \\(4\\pi\\) on the x-axis. Show a unit circle centered at (-4, 0). Move a yellow dot around the circle, with a blue line connecting the origin to the dot and a yellow line from the dot to the sine curve which is drawn dynamically on the plane as the dot moves around the circle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the x and y axes with labels for \\(\\pi\\), \\(2\\pi\\), \\(3\\pi\\), and \\(4\\pi\\) on the x-axis. show a unit circle centered at (-4, 0). move a yellow dot around the circle, with a blue line connecting the origin to the dot and a yellow line from the dot to the sine curve which is drawn dynamically on the plane as the dot moves around the circle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SineCurveUnitCircle(Scene):\n    # contributed by heejin_park, https://infograph.tistory.com/230\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6,0,0])\n        x_end = np.array([6,0,0])\n\n        y_start = np.array([-4,-2,0])\n        y_end = np.array([-4,2,0])\n\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n\n        self.origin_point = np.array([-4,0,0])\n        self.curve_start = np.array([-3,0,0])\n\n    def add_x_labels(self):\n        x_labels = [\n            MathTex(r\"\\pi\"), MathTex(r\"2 \\pi\"),\n            MathTex(r\"3 \\pi\"), MathTex(r\"4 \\pi\"),\n        ]\n\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2*i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += (dt * rate)\n            # print(self.t_offset)\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x,y,0]), color=YELLOW_A, stroke_width=2 )\n\n\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start,self.curve_start))\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(),np.array([x,y,0]), color=YELLOW_D)\n            self.curve.add(new_line)\n\n            return self.curve\n\n        dot.add_updater(go_around_circle)\n\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n\n        dot.remove_updater(go_around_circle)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the x and y axes with labels for \\(\\pi\\), \\(2\\pi\\), \\(3\\pi\\), and \\(4\\pi\\) on the x-axis. Show a unit circle centered at (-4, 0). Move a yellow dot around the circle, with a blue line connecting the origin to the dot and a yellow line from the dot to the sine curve which is drawn dynamically on the plane as the dot moves around the circle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 3D square pyramid centered in the scene, constructed from five vertices: four forming a square base and one apex above the center. The pyramid consists of four triangular side faces and one square base. The camera is angled at 75\u00b0 vertically and 30\u00b0 horizontally, providing a clear, tilted view of the pyramid\u2019s structure."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SquarePyramidScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        vertex_coords = [\n            [1, 1, 0],\n            [1, -1, 0],\n            [-1, -1, 0],\n            [-1, 1, 0],\n            [0, 0, 2]\n        ]\n        faces_list = [\n            [0, 1, 4],\n            [1, 2, 4],\n            [2, 3, 4],\n            [3, 0, 4],\n            [0, 1, 2, 3]\n        ]\n        pyramid = Polyhedron(vertex_coords, faces_list)\n        self.add(pyramid)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D square pyramid centered in the scene, constructed from five vertices: four forming a square base and one apex above the center. The pyramid consists of four triangular side faces and one square base. The camera is angled at 75\u00b0 vertically and 30\u00b0 horizontally, providing a clear, tilted view of the pyramid\u2019s structure."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 3d square pyramid centered in the scene, constructed from five vertices: four forming a square base and one apex above the center. the pyramid consists of four triangular side faces and one square base. the camera is angled at 75\u00b0 vertically and 30\u00b0 horizontally, providing a clear, tilted view of the pyramid\u2019s structure."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SquarePyramidScene(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        vertex_coords = [\n            [1, 1, 0],\n            [1, -1, 0],\n            [-1, -1, 0],\n            [-1, 1, 0],\n            [0, 0, 2]\n        ]\n        faces_list = [\n            [0, 1, 4],\n            [1, 2, 4],\n            [2, 3, 4],\n            [3, 0, 4],\n            [0, 1, 2, 3]\n        ]\n        pyramid = Polyhedron(vertex_coords, faces_list)\n        self.add(pyramid)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D square pyramid centered in the scene, constructed from five vertices: four forming a square base and one apex above the center. The pyramid consists of four triangular side faces and one square base. The camera is angled at 75\u00b0 vertically and 30\u00b0 horizontally, providing a clear, tilted view of the pyramid\u2019s structure."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the word \u201cDeleting\u201d in purple text on the left side of the screen, with a grey cursor positioned at the start. Animate the text being erased character by character with the cursor moving along, then make the cursor blink twice."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DeletingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(UntypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \u201cDeleting\u201d in purple text on the left side of the screen, with a grey cursor positioned at the start. Animate the text being erased character by character with the cursor moving along, then make the cursor blink twice."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the word \u201cdeleting\u201d in purple text on the left side of the screen, with a grey cursor positioned at the start. animate the text being erased character by character with the cursor moving along, then make the cursor blink twice."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DeletingTextExample(Scene):\n    def construct(self):\n        text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n        cursor = Rectangle(\n            color = GREY_A,\n            fill_color = GREY_A,\n            fill_opacity = 1.0,\n            height = 1.1,\n            width = 0.5,\n        ).move_to(text[0]) # Position the cursor\n\n        self.play(UntypeWithCursor(text, cursor))\n        self.play(Blink(cursor, blinks=2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \u201cDeleting\u201d in purple text on the left side of the screen, with a grey cursor positioned at the start. Animate the text being erased character by character with the cursor moving along, then make the cursor blink twice."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the significance of the contact structure extracted from Knot Floer Homology?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass KnotFloerHomology(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Tangled Secrets: The Beauty of Knot Floer Homology\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.5).to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Ever wondered how a simple knot can unlock hidden structures?\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Visualize a simple knot (using just a circle for simplicity)\n        knot = Circle().scale(1.5)\n        knot_label = Text(\"A simple knot\", font_size=20).next_to(knot, DOWN)\n        self.play(Create(knot), Write(knot_label))\n        self.wait(1)\n        \n        # Add a second circle to suggest complexity\n        second_circle = Circle().scale(0.8).shift(RIGHT*0.5)\n        complex_label = Text(\"Mathematical entity\", font_size=20).next_to(second_circle, DOWN)\n        self.play(Create(second_circle), Write(complex_label))\n        self.wait(1)\n        \n        # Knot Floer Homology equation (simplified)\n        self.play(FadeOut(knot), FadeOut(second_circle), FadeOut(knot_label), FadeOut(complex_label))\n        eq_text = Text(\"Knot Floer Homology assigns algebraic structures to knots\", font_size=24)\n        self.play(Write(eq_text))\n        self.wait(1)\n        self.play(FadeOut(eq_text))\n        \n        eq1 = Text(\"HF^hat(K) = Ker(\u2202) / Im(\u2202)\", font_size=24)\n        eq2 = Text(\"\u2202\u00b2 = 0\", font_size=24)\n        eq_group = VGroup(eq1, eq2).arrange(DOWN)\n        self.play(Write(eq_group))\n        self.wait(1)\n        \n        # Contact structures\n        self.play(eq_group.animate.scale(0.7).to_edge(UP))\n        contact_text = Text(\"Contact structures emerge from knots\", font_size=24)\n        self.play(Write(contact_text))\n        self.wait(1)\n        self.play(FadeOut(contact_text))\n        \n        # Simple contact structure visualization\n        contact_circle = Circle().scale(1.5)\n        h_line = Line(LEFT, RIGHT).scale(1.5)\n        v_line = Line(UP, DOWN).scale(1.5)\n        contact_label = Text(\"Contact Structure\", font_size=20).next_to(contact_circle, DOWN)\n        self.play(Create(contact_circle))\n        self.play(Create(h_line), Create(v_line), Write(contact_label))\n        self.wait(1)\n        \n        # Significance\n        significance_text = Text(\"Extending our understanding of knot interactions\", font_size=24)\n        self.play(FadeOut(contact_circle), FadeOut(h_line), FadeOut(v_line), FadeOut(contact_label))\n        self.play(Write(significance_text))\n        self.wait(1)\n        \n        # Use FadeOut/FadeIn sequence for different texts\n        deeper_text = Text(\"Translates spaces, curves, and surfaces\\ninto combinatorial language\", font_size=24)\n        self.play(FadeOut(significance_text))\n        self.play(Write(deeper_text))\n        self.wait(1)\n        self.play(FadeOut(deeper_text))\n        \n        # Conclusion\n        conclusion_text = Text(\"Elevating knots from curious loops\\nto key players in topology\", font_size=24)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        self.play(FadeOut(conclusion_text), FadeOut(eq_group), FadeOut(title))\n        self.wait(1)\n\n# To run this code, save it as knot_floer_homology.py and run:\n# manim -pql knot_floer_homology.py KnotFloerHomology\n# This will render the animation at low quality (-ql) and play it (-p)\n# For high quality, use -qh instead of -ql\n# The output will be saved as video.mp4 in the media/videos folder\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the significance of the contact structure extracted from Knot Floer Homology?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the significance of the contact structure extracted from knot floer homology?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass KnotFloerHomology(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Tangled Secrets: The Beauty of Knot Floer Homology\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.5).to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Ever wondered how a simple knot can unlock hidden structures?\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Visualize a simple knot (using just a circle for simplicity)\n        knot = Circle().scale(1.5)\n        knot_label = Text(\"A simple knot\", font_size=20).next_to(knot, DOWN)\n        self.play(Create(knot), Write(knot_label))\n        self.wait(1)\n        \n        # Add a second circle to suggest complexity\n        second_circle = Circle().scale(0.8).shift(RIGHT*0.5)\n        complex_label = Text(\"Mathematical entity\", font_size=20).next_to(second_circle, DOWN)\n        self.play(Create(second_circle), Write(complex_label))\n        self.wait(1)\n        \n        # Knot Floer Homology equation (simplified)\n        self.play(FadeOut(knot), FadeOut(second_circle), FadeOut(knot_label), FadeOut(complex_label))\n        eq_text = Text(\"Knot Floer Homology assigns algebraic structures to knots\", font_size=24)\n        self.play(Write(eq_text))\n        self.wait(1)\n        self.play(FadeOut(eq_text))\n        \n        eq1 = Text(\"HF^hat(K) = Ker(\u2202) / Im(\u2202)\", font_size=24)\n        eq2 = Text(\"\u2202\u00b2 = 0\", font_size=24)\n        eq_group = VGroup(eq1, eq2).arrange(DOWN)\n        self.play(Write(eq_group))\n        self.wait(1)\n        \n        # Contact structures\n        self.play(eq_group.animate.scale(0.7).to_edge(UP))\n        contact_text = Text(\"Contact structures emerge from knots\", font_size=24)\n        self.play(Write(contact_text))\n        self.wait(1)\n        self.play(FadeOut(contact_text))\n        \n        # Simple contact structure visualization\n        contact_circle = Circle().scale(1.5)\n        h_line = Line(LEFT, RIGHT).scale(1.5)\n        v_line = Line(UP, DOWN).scale(1.5)\n        contact_label = Text(\"Contact Structure\", font_size=20).next_to(contact_circle, DOWN)\n        self.play(Create(contact_circle))\n        self.play(Create(h_line), Create(v_line), Write(contact_label))\n        self.wait(1)\n        \n        # Significance\n        significance_text = Text(\"Extending our understanding of knot interactions\", font_size=24)\n        self.play(FadeOut(contact_circle), FadeOut(h_line), FadeOut(v_line), FadeOut(contact_label))\n        self.play(Write(significance_text))\n        self.wait(1)\n        \n        # Use FadeOut/FadeIn sequence for different texts\n        deeper_text = Text(\"Translates spaces, curves, and surfaces\\ninto combinatorial language\", font_size=24)\n        self.play(FadeOut(significance_text))\n        self.play(Write(deeper_text))\n        self.wait(1)\n        self.play(FadeOut(deeper_text))\n        \n        # Conclusion\n        conclusion_text = Text(\"Elevating knots from curious loops\\nto key players in topology\", font_size=24)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        self.play(FadeOut(conclusion_text), FadeOut(eq_group), FadeOut(title))\n        self.wait(1)\n\n# To run this code, save it as knot_floer_homology.py and run:\n# manim -pql knot_floer_homology.py KnotFloerHomology\n# This will render the animation at low quality (-ql) and play it (-p)\n# For high quality, use -qh instead of -ql\n# The output will be saved as video.mp4 in the media/videos folder\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the significance of the contact structure extracted from Knot Floer Homology?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do Eulerian circuits help in solving practical problems, such as garbage collection or mail delivery routes?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerianCircuits(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Eulerian Circuits: The Invisible Roads Less Traveled\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Designing efficient routes for mail carriers and garbage collectors\", font_size=22)\n        self.play(Write(intro_text))\n        self.wait(2)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple graph\n        # Create vertices\n        v1 = Dot(LEFT*2 + UP*2)\n        v2 = Dot(RIGHT*2 + UP*2)\n        v3 = Dot(LEFT*2 + DOWN*2)\n        v4 = Dot(RIGHT*2 + DOWN*2)\n        \n        vertices = VGroup(v1, v2, v3, v4)\n        \n        # Create edges\n        e1 = Line(v1.get_center(), v2.get_center())\n        e2 = Line(v2.get_center(), v4.get_center())\n        e3 = Line(v4.get_center(), v3.get_center())\n        e4 = Line(v3.get_center(), v1.get_center())\n        e5 = Line(v1.get_center(), v4.get_center())\n        e6 = Line(v2.get_center(), v3.get_center())\n        \n        edges = VGroup(e1, e2, e3, e4, e5, e6)\n        \n        graph = VGroup(vertices, edges)\n        \n        self.play(Create(graph))\n        self.wait(1)\n        \n        # Explain traditional paths\n        trad_text = Text(\"Traditional paths may lead to redundant travel\", font_size=22)\n        trad_text.to_edge(DOWN)\n        self.play(Write(trad_text))\n        \n        # Highlight a non-optimized path\n        self.play(e1.animate.set_color(RED))\n        self.play(e5.animate.set_color(RED))\n        self.play(e3.animate.set_color(RED))\n        self.play(e6.animate.set_color(RED))\n        \n        self.wait(1)\n        \n        # Reset edge colors\n        self.play(\n            e1.animate.set_color(WHITE),\n            e5.animate.set_color(WHITE),\n            e3.animate.set_color(WHITE),\n            e6.animate.set_color(WHITE)\n        )\n        \n        self.play(FadeOut(trad_text))\n        \n        # Explain Euler's criteria\n        criteria_text = Text(\"Euler's criteria: Every vertex must have an even degree\", font_size=22)\n        criteria_text.to_edge(DOWN)\n        self.play(Write(criteria_text))\n        \n        # Highlight vertices\n        self.play(\n            v1.animate.set_color(GREEN),\n            v2.animate.set_color(GREEN),\n            v3.animate.set_color(GREEN),\n            v4.animate.set_color(GREEN)\n        )\n        \n        self.wait(1)\n        \n        # Show equation\n        eq = MathTex(r\"E=\\sum_{i=1}^{n}(d_i \\equiv 0 \\pmod{2})\")\n        eq.next_to(criteria_text, UP)\n        self.play(Write(eq))\n        self.wait(2)\n        \n        self.play(\n            FadeOut(criteria_text),\n            FadeOut(eq)\n        )\n        \n        # Explain Eulerian circuit\n        circuit_text = Text(\"An Eulerian circuit visits every edge exactly once\", font_size=22)\n        circuit_text.to_edge(DOWN)\n        self.play(Write(circuit_text))\n        \n        # Highlight edges to show the circuit\n        self.play(e1.animate.set_color(YELLOW))\n        self.play(e2.animate.set_color(YELLOW))\n        self.play(e3.animate.set_color(YELLOW))\n        self.play(e4.animate.set_color(YELLOW))\n        self.play(e5.animate.set_color(YELLOW))\n        self.play(e6.animate.set_color(YELLOW))\n        \n        self.wait(1)\n        self.play(FadeOut(circuit_text))\n        \n        # Efficiency demonstration\n        efficiency_text = Text(\"Eulerian circuits optimize routes, saving time and resources\", font_size=22)\n        efficiency_text.to_edge(DOWN)\n        self.play(Write(efficiency_text))\n        \n        self.wait(2)\n        self.play(FadeOut(efficiency_text))\n        \n        # Conclusion\n        conclusion_text = Text(\"Embrace the power of Eulerian insights!\", font_size=28)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            FadeOut(conclusion_text),\n            FadeOut(graph),\n            FadeOut(title)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do Eulerian circuits help in solving practical problems, such as garbage collection or mail delivery routes?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do eulerian circuits help in solving practical problems, such as garbage collection or mail delivery routes?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerianCircuits(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Eulerian Circuits: The Invisible Roads Less Traveled\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Designing efficient routes for mail carriers and garbage collectors\", font_size=22)\n        self.play(Write(intro_text))\n        self.wait(2)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple graph\n        # Create vertices\n        v1 = Dot(LEFT*2 + UP*2)\n        v2 = Dot(RIGHT*2 + UP*2)\n        v3 = Dot(LEFT*2 + DOWN*2)\n        v4 = Dot(RIGHT*2 + DOWN*2)\n        \n        vertices = VGroup(v1, v2, v3, v4)\n        \n        # Create edges\n        e1 = Line(v1.get_center(), v2.get_center())\n        e2 = Line(v2.get_center(), v4.get_center())\n        e3 = Line(v4.get_center(), v3.get_center())\n        e4 = Line(v3.get_center(), v1.get_center())\n        e5 = Line(v1.get_center(), v4.get_center())\n        e6 = Line(v2.get_center(), v3.get_center())\n        \n        edges = VGroup(e1, e2, e3, e4, e5, e6)\n        \n        graph = VGroup(vertices, edges)\n        \n        self.play(Create(graph))\n        self.wait(1)\n        \n        # Explain traditional paths\n        trad_text = Text(\"Traditional paths may lead to redundant travel\", font_size=22)\n        trad_text.to_edge(DOWN)\n        self.play(Write(trad_text))\n        \n        # Highlight a non-optimized path\n        self.play(e1.animate.set_color(RED))\n        self.play(e5.animate.set_color(RED))\n        self.play(e3.animate.set_color(RED))\n        self.play(e6.animate.set_color(RED))\n        \n        self.wait(1)\n        \n        # Reset edge colors\n        self.play(\n            e1.animate.set_color(WHITE),\n            e5.animate.set_color(WHITE),\n            e3.animate.set_color(WHITE),\n            e6.animate.set_color(WHITE)\n        )\n        \n        self.play(FadeOut(trad_text))\n        \n        # Explain Euler's criteria\n        criteria_text = Text(\"Euler's criteria: Every vertex must have an even degree\", font_size=22)\n        criteria_text.to_edge(DOWN)\n        self.play(Write(criteria_text))\n        \n        # Highlight vertices\n        self.play(\n            v1.animate.set_color(GREEN),\n            v2.animate.set_color(GREEN),\n            v3.animate.set_color(GREEN),\n            v4.animate.set_color(GREEN)\n        )\n        \n        self.wait(1)\n        \n        # Show equation\n        eq = MathTex(r\"E=\\sum_{i=1}^{n}(d_i \\equiv 0 \\pmod{2})\")\n        eq.next_to(criteria_text, UP)\n        self.play(Write(eq))\n        self.wait(2)\n        \n        self.play(\n            FadeOut(criteria_text),\n            FadeOut(eq)\n        )\n        \n        # Explain Eulerian circuit\n        circuit_text = Text(\"An Eulerian circuit visits every edge exactly once\", font_size=22)\n        circuit_text.to_edge(DOWN)\n        self.play(Write(circuit_text))\n        \n        # Highlight edges to show the circuit\n        self.play(e1.animate.set_color(YELLOW))\n        self.play(e2.animate.set_color(YELLOW))\n        self.play(e3.animate.set_color(YELLOW))\n        self.play(e4.animate.set_color(YELLOW))\n        self.play(e5.animate.set_color(YELLOW))\n        self.play(e6.animate.set_color(YELLOW))\n        \n        self.wait(1)\n        self.play(FadeOut(circuit_text))\n        \n        # Efficiency demonstration\n        efficiency_text = Text(\"Eulerian circuits optimize routes, saving time and resources\", font_size=22)\n        efficiency_text.to_edge(DOWN)\n        self.play(Write(efficiency_text))\n        \n        self.wait(2)\n        self.play(FadeOut(efficiency_text))\n        \n        # Conclusion\n        conclusion_text = Text(\"Embrace the power of Eulerian insights!\", font_size=28)\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            FadeOut(conclusion_text),\n            FadeOut(graph),\n            FadeOut(title)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do Eulerian circuits help in solving practical problems, such as garbage collection or mail delivery routes?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Animate the creation of a 2\u00d72 table with row and column labels and outer borders. The table appears gradually on screen, then remains visible during a brief pause."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Animate the creation of a 2\u00d72 table with row and column labels and outer borders. The table appears gradually on screen, then remains visible during a brief pause."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that animate the creation of a 2\u00d72 table with row and column labels and outer borders. the table appears gradually on screen, then remains visible during a brief pause."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CreateTableExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")],\n            include_outer_lines=True)\n        self.play(table.create())\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Animate the creation of a 2\u00d72 table with row and column labels and outer borders. The table appears gradually on screen, then remains visible during a brief pause."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a decimal table with two rows:\n\n- The first row shows the values of \\( x = [-2, -1, 0, 1, 2] \\).\n- The second row shows the corresponding values of \\( f(x) = e^x \\), each rounded to two decimal places.\n\nThe rows are labeled with LaTeX-style expressions \u201c\\( x \\)\u201d and \u201c\\( f(x) = e^x \\)\u201d, and there is extra horizontal spacing between the columns. The table is centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DecimalTableExample(Scene):\n    def construct(self):\n        x_vals = [-2,-1,0,1,2]\n        y_vals = np.exp(x_vals)\n        t0 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n            h_buff=1,\n            element_to_mobject_config={\"num_decimal_places\": 2})\n        self.add(t0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a decimal table with two rows:\n\n- The first row shows the values of \\( x = [-2, -1, 0, 1, 2] \\).\n- The second row shows the corresponding values of \\( f(x) = e^x \\), each rounded to two decimal places.\n\nThe rows are labeled with LaTeX-style expressions \u201c\\( x \\)\u201d and \u201c\\( f(x) = e^x \\)\u201d, and there is extra horizontal spacing between the columns. The table is centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a decimal table with two rows:\n\n- the first row shows the values of \\( x = [-2, -1, 0, 1, 2] \\).\n- the second row shows the corresponding values of \\( f(x) = e^x \\), each rounded to two decimal places.\n\nthe rows are labeled with latex-style expressions \u201c\\( x \\)\u201d and \u201c\\( f(x) = e^x \\)\u201d, and there is extra horizontal spacing between the columns. the table is centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DecimalTableExample(Scene):\n    def construct(self):\n        x_vals = [-2,-1,0,1,2]\n        y_vals = np.exp(x_vals)\n        t0 = DecimalTable(\n            [x_vals, y_vals],\n            row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n            h_buff=1,\n            element_to_mobject_config={\"num_decimal_places\": 2})\n        self.add(t0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a decimal table with two rows:\n\n- The first row shows the values of \\( x = [-2, -1, 0, 1, 2] \\).\n- The second row shows the corresponding values of \\( f(x) = e^x \\), each rounded to two decimal places.\n\nThe rows are labeled with LaTeX-style expressions \u201c\\( x \\)\u201d and \u201c\\( f(x) = e^x \\)\u201d, and there is extra horizontal spacing between the columns. The table is centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that explains a third-order ordinary differential equation and its solution process. The animation should start by displaying the differential equation \"y''' - 3y'' + 3y' - y = 0\". Then, it should introduce the concept of the characteristic equation with a title and show the characteristic polynomial \"r^3 - 3r^2 + 3r - 1 = 0\", transitioning from the differential equation. I would like the next part of the animation to instruct on how to solve the characteristic polynomial with a new title and then display its roots, specifically if the root is \"r = 1\". Finally, the animation should reveal the general solution \"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\" to the ODE with an explanation title, followed by clearing the scene and reiterating the general solution at the end. Each step should be shown clearly with pauses in between for emphasis."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ApplyWave\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Mathematical Animations\")\n            self.play(ApplyWave(some_text))\n            self.play(ApplyWave(some_text, direction=RIGHT))\n            self.remove(some_text)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that explains a third-order ordinary differential equation and its solution process. The animation should start by displaying the differential equation \"y''' - 3y'' + 3y' - y = 0\". Then, it should introduce the concept of the characteristic equation with a title and show the characteristic polynomial \"r^3 - 3r^2 + 3r - 1 = 0\", transitioning from the differential equation. I would like the next part of the animation to instruct on how to solve the characteristic polynomial with a new title and then display its roots, specifically if the root is \"r = 1\". Finally, the animation should reveal the general solution \"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\" to the ODE with an explanation title, followed by clearing the scene and reiterating the general solution at the end. Each step should be shown clearly with pauses in between for emphasis."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that explains a third-order ordinary differential equation and its solution process. the animation should start by displaying the differential equation \"y''' - 3y'' + 3y' - y = 0\". then, it should introduce the concept of the characteristic equation with a title and show the characteristic polynomial \"r^3 - 3r^2 + 3r - 1 = 0\", transitioning from the differential equation. i would like the next part of the animation to instruct on how to solve the characteristic polynomial with a new title and then display its roots, specifically if the root is \"r = 1\". finally, the animation should reveal the general solution \"y = c_1 e^{x} + c_2 x e^{x} + c_3 x^2 e^{x}\" to the ode with an explanation title, followed by clearing the scene and reiterating the general solution at the end. each step should be shown clearly with pauses in between for emphasis."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"ApplyWave\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Mathematical Animations\")\n            self.play(ApplyWave(some_text))\n            self.play(ApplyWave(some_text, direction=RIGHT))\n            self.remove(some_text)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that explains a third-order ordinary differential equation and its solution process. The animation should start by displaying the differential equation \"y''' - 3y'' + 3y' - y = 0\". Then, it should introduce the concept of the characteristic equation with a title and show the characteristic polynomial \"r^3 - 3r^2 + 3r - 1 = 0\", transitioning from the differential equation. I would like the next part of the animation to instruct on how to solve the characteristic polynomial with a new title and then display its roots, specifically if the root is \"r = 1\". Finally, the animation should reveal the general solution \"y = C_1 e^{x} + C_2 x e^{x} + C_3 x^2 e^{x}\" to the ODE with an explanation title, followed by clearing the scene and reiterating the general solution at the end. Each step should be shown clearly with pauses in between for emphasis."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_paired_query.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import PairedQueryLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass PairedQueryScene(Scene):\n    def construct(self):\n        positive_path = \"../assets/triplet/positive.jpg\"\n        negative_path = \"../assets/triplet/negative.jpg\"\n\n        paired_layer = PairedQueryLayer.from_paths(\n            positive_path, negative_path, grayscale=False\n        )\n\n        paired_layer.scale(0.08)\n\n        neural_network = NeuralNetwork(\n            [paired_layer, FeedForwardLayer(5), FeedForwardLayer(3)]\n        )\n\n        neural_network.scale(1)\n\n        self.play(Create(neural_network), run_time=3)\n\n        self.play(neural_network.make_forward_pass_animation(), run_time=10)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_paired_query.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_paired_query.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import PairedQueryLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass PairedQueryScene(Scene):\n    def construct(self):\n        positive_path = \"../assets/triplet/positive.jpg\"\n        negative_path = \"../assets/triplet/negative.jpg\"\n\n        paired_layer = PairedQueryLayer.from_paths(\n            positive_path, negative_path, grayscale=False\n        )\n\n        paired_layer.scale(0.08)\n\n        neural_network = NeuralNetwork(\n            [paired_layer, FeedForwardLayer(5), FeedForwardLayer(3)]\n        )\n\n        neural_network.scale(1)\n\n        self.play(Create(neural_network), run_time=3)\n\n        self.play(neural_network.make_forward_pass_animation(), run_time=10)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_paired_query.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "How can I create an educational video animation using ManimCE that displays a basic arithmetic multiplication problem, starts with a white background, shows the numbers 3 and 2 being multiplied with a blue times symbol, resulting in the number 6, follows up by highlighting the multiplication operation, and then fades everything out after a short pause?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} f(r,\\theta) r \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ F(r,\\theta) \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ G(\\theta) \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final answer reveal\n        answer_explanation = Text(\"This gives us the final answer\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, answer_explanation))\n        self.wait(1)\n\n        answer = MathTex(r\"= G(2\\pi) - G(0)\")\n        self.play(Write(answer))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an educational video animation using ManimCE that displays a basic arithmetic multiplication problem, starts with a white background, shows the numbers 3 and 2 being multiplied with a blue times symbol, resulting in the number 6, follows up by highlighting the multiplication operation, and then fades everything out after a short pause?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that how can i create an educational video animation using manimce that displays a basic arithmetic multiplication problem, starts with a white background, shows the numbers 3 and 2 being multiplied with a blue times symbol, resulting in the number 6, follows up by highlighting the multiplication operation, and then fades everything out after a short pause?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} f(r,\\theta) r \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ F(r,\\theta) \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ G(\\theta) \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Final answer reveal\n        answer_explanation = Text(\"This gives us the final answer\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, answer_explanation))\n        self.wait(1)\n\n        answer = MathTex(r\"= G(2\\pi) - G(0)\")\n        self.play(Write(answer))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an educational video animation using ManimCE that displays a basic arithmetic multiplication problem, starts with a white background, shows the numbers 3 and 2 being multiplied with a blue times symbol, resulting in the number 6, follows up by highlighting the multiplication operation, and then fades everything out after a short pause?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational video animation where a virtual chalkboard displays three different mathematical equations, one after the other, with a visual indication next to each whether it is correct or incorrect? The first equation should be \"2x + 1 = 5\" marked as correct, the second \"4y - 2 = 7\" marked as incorrect, and the third \"3a^2 - 9 = 0\" marked as correct. Each equation should appear with a visually distinctive check mark for correct and an X mark for incorrect, and please use a gentle, soothing background color for the chalkboard with the symbols and text in contrasting colors suitable for educational content."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of alternating electrons and oxygen atoms\n        grid = self.create_alternating_grid(rows=5, cols=5)\n        \n        # Position the grid\n        grid.move_to(ORIGIN)\n        \n        # Animate the creation of the grid\n        self.play(AnimationGroup(*[FadeIn(mobj, shift=UP*0.1) for mobj in grid], lag_ratio=0.1))\n        self.wait()\n\n        # Animate electrons moving in a pattern on the grid\n        path_indices = [0, 5, 6, 11, 16, 17, 22, 23, 18, 13, 8, 7, 2, 3, 4, 9, 14, 19, 24, 20, 15, 10]\n        electrons = self.get_electrons_on_grid(grid)\n        # Define the complex path for our electron to move along\n        points = [grid[i].get_center() for i in path_indices]\n        \n        # Create the move animations for the electron\n        move_animations = move_along_complex_path(electrons, stop_indices=[], points=points, run_time=2)\n        self.play(AnimationGroup(*move_animations, lag_ratio=0))\n        self.wait()\n\n    def create_alternating_grid(self, rows, cols):\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    grid.add(electron().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n                else:\n                    grid.add(oxygen().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n        return grid\n    \n    def get_electrons_on_grid(self, grid):\n        electrons = VGroup()\n        for atom in grid:\n            if \"e$^-$\" in atom.submobjects[1].get_tex_string():\n                electrons.add(atom)\n        return electrons\n\n# Additional functions used within the code may be identical to the functions provided by the user, e.g., 'electron()' and 'oxygen()' functions.\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational video animation where a virtual chalkboard displays three different mathematical equations, one after the other, with a visual indication next to each whether it is correct or incorrect? The first equation should be \"2x + 1 = 5\" marked as correct, the second \"4y - 2 = 7\" marked as incorrect, and the third \"3a^2 - 9 = 0\" marked as correct. Each equation should appear with a visually distinctive check mark for correct and an X mark for incorrect, and please use a gentle, soothing background color for the chalkboard with the symbols and text in contrasting colors suitable for educational content."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational video animation where a virtual chalkboard displays three different mathematical equations, one after the other, with a visual indication next to each whether it is correct or incorrect? the first equation should be \"2x + 1 = 5\" marked as correct, the second \"4y - 2 = 7\" marked as incorrect, and the third \"3a^2 - 9 = 0\" marked as correct. each equation should appear with a visually distinctive check mark for correct and an x mark for incorrect, and please use a gentle, soothing background color for the chalkboard with the symbols and text in contrasting colors suitable for educational content."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CustomScene(Scene):\n    def construct(self):\n        # Create a grid of alternating electrons and oxygen atoms\n        grid = self.create_alternating_grid(rows=5, cols=5)\n        \n        # Position the grid\n        grid.move_to(ORIGIN)\n        \n        # Animate the creation of the grid\n        self.play(AnimationGroup(*[FadeIn(mobj, shift=UP*0.1) for mobj in grid], lag_ratio=0.1))\n        self.wait()\n\n        # Animate electrons moving in a pattern on the grid\n        path_indices = [0, 5, 6, 11, 16, 17, 22, 23, 18, 13, 8, 7, 2, 3, 4, 9, 14, 19, 24, 20, 15, 10]\n        electrons = self.get_electrons_on_grid(grid)\n        # Define the complex path for our electron to move along\n        points = [grid[i].get_center() for i in path_indices]\n        \n        # Create the move animations for the electron\n        move_animations = move_along_complex_path(electrons, stop_indices=[], points=points, run_time=2)\n        self.play(AnimationGroup(*move_animations, lag_ratio=0))\n        self.wait()\n\n    def create_alternating_grid(self, rows, cols):\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                if (i + j) % 2 == 0:\n                    grid.add(electron().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n                else:\n                    grid.add(oxygen().next_to(ORIGIN, RIGHT, buff=0.6).shift(RIGHT*j*0.6+UP*i*0.6))\n        return grid\n    \n    def get_electrons_on_grid(self, grid):\n        electrons = VGroup()\n        for atom in grid:\n            if \"e$^-$\" in atom.submobjects[1].get_tex_string():\n                electrons.add(atom)\n        return electrons\n\n# Additional functions used within the code may be identical to the functions provided by the user, e.g., 'electron()' and 'oxygen()' functions.\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational video animation where a virtual chalkboard displays three different mathematical equations, one after the other, with a visual indication next to each whether it is correct or incorrect? The first equation should be \"2x + 1 = 5\" marked as correct, the second \"4y - 2 = 7\" marked as incorrect, and the third \"3a^2 - 9 = 0\" marked as correct. Each equation should appear with a visually distinctive check mark for correct and an X mark for incorrect, and please use a gentle, soothing background color for the chalkboard with the symbols and text in contrasting colors suitable for educational content."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display 3D axes. Set the camera orientation to a specific angle. Show the text \"This is a 3D text\" fixed in the upper left corner of the frame."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FixedInFrameMObjectTest(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        text3d = Text(\"This is a 3D text\")\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes. Set the camera orientation to a specific angle. Show the text \"This is a 3D text\" fixed in the upper left corner of the frame."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display 3d axes. set the camera orientation to a specific angle. show the text \"this is a 3d text\" fixed in the upper left corner of the frame."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FixedInFrameMObjectTest(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        text3d = Text(\"This is a 3D text\")\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes. Set the camera orientation to a specific angle. Show the text \"This is a 3D text\" fixed in the upper left corner of the frame."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that visually explains the convergence of the series sum from n equals 1 to infinity of 1 over n squared using the p-test? The animation should introduce the series, explain how to use the p-test for convergence by displaying a condition, apply the p-test to show that the series converges because p equals 2 is greater than 1, and conclude by stating that the series is convergent. Can you also ensure that each part of the explanation is displayed clearly before moving on to the next, and at the end, clear everything and display the final conclusion again for emphasis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        title = Text(\"Manim Wave Effects\").to_edge(UP)\n        self.play(Write(title))\n\n        subtitle = Text(\"Various wave animations\").next_to(title, DOWN)\n        self.play(Write(subtitle))\n\n        square_wave = Square().set_fill(BLUE, opacity=0.5)\n        self.play(FadeIn(square_wave))\n        self.play(ApplyWave(square_wave))\n        self.play(ApplyWave(square_wave, rate_func=linear))\n        self.play(ApplyWave(square_wave, amplitude=0.2))\n        \n        self.play(FadeOut(square_wave))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visually explains the convergence of the series sum from n equals 1 to infinity of 1 over n squared using the p-test? The animation should introduce the series, explain how to use the p-test for convergence by displaying a condition, apply the p-test to show that the series converges because p equals 2 is greater than 1, and conclude by stating that the series is convergent. Can you also ensure that each part of the explanation is displayed clearly before moving on to the next, and at the end, clear everything and display the final conclusion again for emphasis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that visually explains the convergence of the series sum from n equals 1 to infinity of 1 over n squared using the p-test? the animation should introduce the series, explain how to use the p-test for convergence by displaying a condition, apply the p-test to show that the series converges because p equals 2 is greater than 1, and conclude by stating that the series is convergent. can you also ensure that each part of the explanation is displayed clearly before moving on to the next, and at the end, clear everything and display the final conclusion again for emphasis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        title = Text(\"Manim Wave Effects\").to_edge(UP)\n        self.play(Write(title))\n\n        subtitle = Text(\"Various wave animations\").next_to(title, DOWN)\n        self.play(Write(subtitle))\n\n        square_wave = Square().set_fill(BLUE, opacity=0.5)\n        self.play(FadeIn(square_wave))\n        self.play(ApplyWave(square_wave))\n        self.play(ApplyWave(square_wave, rate_func=linear))\n        self.play(ApplyWave(square_wave, amplitude=0.2))\n        \n        self.play(FadeOut(square_wave))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visually explains the convergence of the series sum from n equals 1 to infinity of 1 over n squared using the p-test? The animation should introduce the series, explain how to use the p-test for convergence by displaying a condition, apply the p-test to show that the series converges because p equals 2 is greater than 1, and conclude by stating that the series is convergent. Can you also ensure that each part of the explanation is displayed clearly before moving on to the next, and at the end, clear everything and display the final conclusion again for emphasis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated step-by-step visualization of solving a triple integral problem where the integral is first taken with respect to z, showing the intermediate result, then with respect to y, and finally with respect to x, including brief textual explanations before each integration step?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MObjectShowcase(Scene):\n    def construct(self):\n        title = Text(\"A Showcase of MObjects\").to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        \n        mobject_grid = VGroup(*[\n            VGroup(\n                Square(),\n                Circle(),\n                Triangle(),\n                Annulus(),\n                Ellipse(),\n                Dot(),\n                Arrow(),\n                Star()\n            ),\n            VGroup(\n                Text(\"Text\"),\n                MathTex(r\"\\int_a^b f(x)\\,dx\"),\n                Integer(42),\n                DecimalNumber(3.14),\n                BulletedList(\"First\", \"Second\", \"Third\"),\n                Code(\"print('Hello, World!')\", language=\"Python\")\n            )\n        ]).arrange(DOWN, buff=LARGE_BUFF)\n        \n        for submobjects in mobject_grid:\n            submobjects.arrange(RIGHT, buff=LARGE_BUFF)\n        \n        mobject_grid.scale(0.5)\n        mobject_grid.move_to(ORIGIN)\n        \n        self.play(LaggedStart(*[FadeIn(mobj, shift=DOWN) for mobj in mobject_grid], lag_ratio=0.2))\n        self.wait(2)\n\n        self.play(LaggedStart(*[ApplyWave(mobj) for mobj in mobject_grid[0]], lag_ratio=0.2))\n        self.play(LaggedStart(*[Indicate(mobj) for mobj in mobject_grid[1]], lag_ratio=0.2))\n        self.wait()\n\n        self.play(FadeOut(mobject_grid), FadeOut(title))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated step-by-step visualization of solving a triple integral problem where the integral is first taken with respect to z, showing the intermediate result, then with respect to y, and finally with respect to x, including brief textual explanations before each integration step?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated step-by-step visualization of solving a triple integral problem where the integral is first taken with respect to z, showing the intermediate result, then with respect to y, and finally with respect to x, including brief textual explanations before each integration step?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MObjectShowcase(Scene):\n    def construct(self):\n        title = Text(\"A Showcase of MObjects\").to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        \n        mobject_grid = VGroup(*[\n            VGroup(\n                Square(),\n                Circle(),\n                Triangle(),\n                Annulus(),\n                Ellipse(),\n                Dot(),\n                Arrow(),\n                Star()\n            ),\n            VGroup(\n                Text(\"Text\"),\n                MathTex(r\"\\int_a^b f(x)\\,dx\"),\n                Integer(42),\n                DecimalNumber(3.14),\n                BulletedList(\"First\", \"Second\", \"Third\"),\n                Code(\"print('Hello, World!')\", language=\"Python\")\n            )\n        ]).arrange(DOWN, buff=LARGE_BUFF)\n        \n        for submobjects in mobject_grid:\n            submobjects.arrange(RIGHT, buff=LARGE_BUFF)\n        \n        mobject_grid.scale(0.5)\n        mobject_grid.move_to(ORIGIN)\n        \n        self.play(LaggedStart(*[FadeIn(mobj, shift=DOWN) for mobj in mobject_grid], lag_ratio=0.2))\n        self.wait(2)\n\n        self.play(LaggedStart(*[ApplyWave(mobj) for mobj in mobject_grid[0]], lag_ratio=0.2))\n        self.play(LaggedStart(*[Indicate(mobj) for mobj in mobject_grid[1]], lag_ratio=0.2))\n        self.wait()\n\n        self.play(FadeOut(mobject_grid), FadeOut(title))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated step-by-step visualization of solving a triple integral problem where the integral is first taken with respect to z, showing the intermediate result, then with respect to y, and finally with respect to x, including brief textual explanations before each integration step?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do we graphically represent coordination games with multiple Nash equilibria on a Cartesian plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GameTheoryCoordinationGames(Scene):\n    def construct(self):\n        # Introduction (0:00) - Start with a circle that transitions to a plane\n        circle = Circle(radius=1.5, color=BLUE)\n        self.play(Create(circle))\n        self.play(circle.animate.rotate(PI/2))  # Simple rotation to give 3D impression\n        \n        # Create Cartesian plane\n        axes = Axes(\n            x_range=[-1, 10, 1],\n            y_range=[-1, 10, 1],\n            axis_config={\"color\": WHITE},\n        )\n        \n        # Transform circle to axes\n        self.play(Transform(circle, axes))\n        self.remove(circle)\n        self.add(axes)  # Make sure axes is properly added\n        \n        # Add title after transformation\n        title = Text(\"The Dance of Decisions: Gamers Finding Harmony\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Label axes (1:00)\n        x_label = Text(\"Player 1's Strategy\", font_size=24).next_to(axes, DOWN)\n        y_label = Text(\"Player 2's Strategy\", font_size=24).next_to(axes, LEFT).rotate(PI/2)\n        \n        self.play(Write(x_label), Write(y_label))\n        self.wait(1)\n        \n        # Add payoff curves (1:30)\n        player1_payoff = Text(\"R\u2081(x) = Player 1's Payoff\", font_size=20, color=BLUE_C).to_edge(UP + LEFT)\n        player2_payoff = Text(\"R\u2082(y) = Player 2's Payoff\", font_size=20, color=YELLOW_C).next_to(player1_payoff, DOWN)\n        \n        # In this simplified model, we're plotting both payoff functions against Player 1's strategy (x-axis)\n        # Player 1's payoff (blue curve)\n        player1_curve = axes.plot(\n            lambda x: 5 + 3 * np.sin(x / 2),\n            x_range=[0, 9],\n            color=BLUE_C,\n        )\n        \n        # Player 2's payoff (yellow curve)\n        player2_curve = axes.plot(\n            lambda x: 5 + 3 * np.cos(x / 2),\n            x_range=[0, 9],\n            color=YELLOW_C,\n        )\n        \n        self.play(Write(player1_payoff), Create(player1_curve))\n        self.play(Write(player2_payoff), Create(player2_curve))\n        self.wait(1)\n        \n        # Nash equilibria (2:00)\n        equilibrium_text = Text(\"Nash Equilibria\", font_size=24, color=GREEN).to_edge(UP + RIGHT)\n        \n        # Intersection points\n        intersection1 = Dot(axes.c2p(1.5, 6.5), color=GREEN)\n        intersection2 = Dot(axes.c2p(4.6, 3.5), color=GREEN)\n        intersection3 = Dot(axes.c2p(7.8, 6.5), color=GREEN)\n        \n        self.play(Write(equilibrium_text))\n        self.play(FadeIn(intersection1), FadeIn(intersection2), FadeIn(intersection3))\n        \n        # Pulse animation for the intersections\n        self.play(\n            intersection1.animate.scale(1.5),\n            intersection2.animate.scale(1.5),\n            intersection3.animate.scale(1.5),\n        )\n        self.play(\n            intersection1.animate.scale(1/1.5),\n            intersection2.animate.scale(1/1.5),\n            intersection3.animate.scale(1/1.5),\n        )\n        \n        # Conclusion (2:30)\n        conclusion = Text(\"Every curve holds a potential path to equilibrium\", \n                         font_size=28).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects]\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do we graphically represent coordination games with multiple Nash equilibria on a Cartesian plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do we graphically represent coordination games with multiple nash equilibria on a cartesian plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GameTheoryCoordinationGames(Scene):\n    def construct(self):\n        # Introduction (0:00) - Start with a circle that transitions to a plane\n        circle = Circle(radius=1.5, color=BLUE)\n        self.play(Create(circle))\n        self.play(circle.animate.rotate(PI/2))  # Simple rotation to give 3D impression\n        \n        # Create Cartesian plane\n        axes = Axes(\n            x_range=[-1, 10, 1],\n            y_range=[-1, 10, 1],\n            axis_config={\"color\": WHITE},\n        )\n        \n        # Transform circle to axes\n        self.play(Transform(circle, axes))\n        self.remove(circle)\n        self.add(axes)  # Make sure axes is properly added\n        \n        # Add title after transformation\n        title = Text(\"The Dance of Decisions: Gamers Finding Harmony\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Label axes (1:00)\n        x_label = Text(\"Player 1's Strategy\", font_size=24).next_to(axes, DOWN)\n        y_label = Text(\"Player 2's Strategy\", font_size=24).next_to(axes, LEFT).rotate(PI/2)\n        \n        self.play(Write(x_label), Write(y_label))\n        self.wait(1)\n        \n        # Add payoff curves (1:30)\n        player1_payoff = Text(\"R\u2081(x) = Player 1's Payoff\", font_size=20, color=BLUE_C).to_edge(UP + LEFT)\n        player2_payoff = Text(\"R\u2082(y) = Player 2's Payoff\", font_size=20, color=YELLOW_C).next_to(player1_payoff, DOWN)\n        \n        # In this simplified model, we're plotting both payoff functions against Player 1's strategy (x-axis)\n        # Player 1's payoff (blue curve)\n        player1_curve = axes.plot(\n            lambda x: 5 + 3 * np.sin(x / 2),\n            x_range=[0, 9],\n            color=BLUE_C,\n        )\n        \n        # Player 2's payoff (yellow curve)\n        player2_curve = axes.plot(\n            lambda x: 5 + 3 * np.cos(x / 2),\n            x_range=[0, 9],\n            color=YELLOW_C,\n        )\n        \n        self.play(Write(player1_payoff), Create(player1_curve))\n        self.play(Write(player2_payoff), Create(player2_curve))\n        self.wait(1)\n        \n        # Nash equilibria (2:00)\n        equilibrium_text = Text(\"Nash Equilibria\", font_size=24, color=GREEN).to_edge(UP + RIGHT)\n        \n        # Intersection points\n        intersection1 = Dot(axes.c2p(1.5, 6.5), color=GREEN)\n        intersection2 = Dot(axes.c2p(4.6, 3.5), color=GREEN)\n        intersection3 = Dot(axes.c2p(7.8, 6.5), color=GREEN)\n        \n        self.play(Write(equilibrium_text))\n        self.play(FadeIn(intersection1), FadeIn(intersection2), FadeIn(intersection3))\n        \n        # Pulse animation for the intersections\n        self.play(\n            intersection1.animate.scale(1.5),\n            intersection2.animate.scale(1.5),\n            intersection3.animate.scale(1.5),\n        )\n        self.play(\n            intersection1.animate.scale(1/1.5),\n            intersection2.animate.scale(1/1.5),\n            intersection3.animate.scale(1/1.5),\n        )\n        \n        # Conclusion (2:30)\n        conclusion = Text(\"Every curve holds a potential path to equilibrium\", \n                         font_size=28).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects]\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do we graphically represent coordination games with multiple Nash equilibria on a Cartesian plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the minimum size of a dominating set for a toroidal grid graph, and how does it change with the grid's dimensions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DominatingSetsInToroidalGrids(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dominating the Toroidal Grid\", color=BLUE)\n        subtitle = Text(\"Uncovering Patterns of Coverage\", color=BLUE).scale(0.7)\n        subtitle.next_to(title, DOWN)\n        \n        # Display title and subtitle\n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introduction to dominating sets\n        intro_text = Text(\"A dominating set covers the entire graph\", color=WHITE).scale(0.8)\n        intro_text.to_edge(UP)\n        \n        self.play(Write(intro_text))\n        \n        # Create a simple 3x3 grid with vertices\n        squares = VGroup()\n        dots = VGroup()\n        \n        for i in range(3):\n            for j in range(3):\n                square = Square(side_length=1, color=WHITE)\n                square.move_to([j, -i, 0])\n                squares.add(square)\n                \n                dot = Dot(square.get_center(), color=WHITE)\n                dots.add(dot)\n        \n        squares.center()\n        \n        # Show the grid and vertices\n        self.play(Create(squares), Create(dots))\n        self.wait(1)\n        \n        # Highlight a vertex in the dominating set (center vertex)\n        center_idx = 4  # Center of 3x3 grid\n        self.play(dots[center_idx].animate.set_color(GOLD).scale(1.5))\n        \n        # Show vertices that are dominated by the center vertex\n        # These are the adjacent vertices (top, right, bottom, left)\n        for i in range(9):\n            if i != center_idx and (\n                i == 1 or i == 3 or i == 5 or i == 7  # Adjacent to center\n            ):\n                self.play(dots[i].animate.set_color(BLUE), run_time=0.5)\n        \n        self.wait(1)\n        \n        # Introduce toroidal grid concept\n        self.play(FadeOut(intro_text))\n        \n        toroidal_text = Text(\"In a toroidal grid, edges wrap around\", color=WHITE).scale(0.8)\n        toroidal_text.to_edge(UP)\n        \n        self.play(Write(toroidal_text))\n        \n        # Show toroidal connections with arrows\n        arrows = VGroup()\n        \n        # Top-bottom connection (bottom to top)\n        arrow1 = Arrow(dots[6].get_center() + DOWN*0.2, dots[0].get_center() + UP*0.2, color=YELLOW)\n        # Left-right connection (right to left)\n        arrow2 = Arrow(dots[2].get_center() + RIGHT*0.2, dots[0].get_center() + LEFT*0.2, color=YELLOW)\n        \n        arrows.add(arrow1, arrow2)\n        \n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Show the equation for minimum dominating set size\n        self.play(FadeOut(toroidal_text), FadeOut(arrows))\n        \n        equation_text = Text(\"Minimum dominating set size bound:\", color=WHITE).scale(0.8)\n        equation_text.to_edge(UP)\n        \n        self.play(Write(equation_text))\n        \n        # The key equation that bounds the size of minimum dominating set\n        equation = MathTex(r\"D(G) \\leq 3 \\left\\lceil \\frac{m}{2} \\right\\rceil \\left\\lceil \\frac{n}{2} \\right\\rceil\")\n        equation.next_to(equation_text, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(equation_text), FadeOut(equation), \n                 FadeOut(squares), FadeOut(dots))\n        \n        conclusion = Text(\"Mathematics reveals patterns of coverage\", color=BLUE)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the minimum size of a dominating set for a toroidal grid graph, and how does it change with the grid's dimensions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the minimum size of a dominating set for a toroidal grid graph, and how does it change with the grid's dimensions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DominatingSetsInToroidalGrids(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dominating the Toroidal Grid\", color=BLUE)\n        subtitle = Text(\"Uncovering Patterns of Coverage\", color=BLUE).scale(0.7)\n        subtitle.next_to(title, DOWN)\n        \n        # Display title and subtitle\n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introduction to dominating sets\n        intro_text = Text(\"A dominating set covers the entire graph\", color=WHITE).scale(0.8)\n        intro_text.to_edge(UP)\n        \n        self.play(Write(intro_text))\n        \n        # Create a simple 3x3 grid with vertices\n        squares = VGroup()\n        dots = VGroup()\n        \n        for i in range(3):\n            for j in range(3):\n                square = Square(side_length=1, color=WHITE)\n                square.move_to([j, -i, 0])\n                squares.add(square)\n                \n                dot = Dot(square.get_center(), color=WHITE)\n                dots.add(dot)\n        \n        squares.center()\n        \n        # Show the grid and vertices\n        self.play(Create(squares), Create(dots))\n        self.wait(1)\n        \n        # Highlight a vertex in the dominating set (center vertex)\n        center_idx = 4  # Center of 3x3 grid\n        self.play(dots[center_idx].animate.set_color(GOLD).scale(1.5))\n        \n        # Show vertices that are dominated by the center vertex\n        # These are the adjacent vertices (top, right, bottom, left)\n        for i in range(9):\n            if i != center_idx and (\n                i == 1 or i == 3 or i == 5 or i == 7  # Adjacent to center\n            ):\n                self.play(dots[i].animate.set_color(BLUE), run_time=0.5)\n        \n        self.wait(1)\n        \n        # Introduce toroidal grid concept\n        self.play(FadeOut(intro_text))\n        \n        toroidal_text = Text(\"In a toroidal grid, edges wrap around\", color=WHITE).scale(0.8)\n        toroidal_text.to_edge(UP)\n        \n        self.play(Write(toroidal_text))\n        \n        # Show toroidal connections with arrows\n        arrows = VGroup()\n        \n        # Top-bottom connection (bottom to top)\n        arrow1 = Arrow(dots[6].get_center() + DOWN*0.2, dots[0].get_center() + UP*0.2, color=YELLOW)\n        # Left-right connection (right to left)\n        arrow2 = Arrow(dots[2].get_center() + RIGHT*0.2, dots[0].get_center() + LEFT*0.2, color=YELLOW)\n        \n        arrows.add(arrow1, arrow2)\n        \n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Show the equation for minimum dominating set size\n        self.play(FadeOut(toroidal_text), FadeOut(arrows))\n        \n        equation_text = Text(\"Minimum dominating set size bound:\", color=WHITE).scale(0.8)\n        equation_text.to_edge(UP)\n        \n        self.play(Write(equation_text))\n        \n        # The key equation that bounds the size of minimum dominating set\n        equation = MathTex(r\"D(G) \\leq 3 \\left\\lceil \\frac{m}{2} \\right\\rceil \\left\\lceil \\frac{n}{2} \\right\\rceil\")\n        equation.next_to(equation_text, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(equation_text), FadeOut(equation), \n                 FadeOut(squares), FadeOut(dots))\n        \n        conclusion = Text(\"Mathematics reveals patterns of coverage\", color=BLUE)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the minimum size of a dominating set for a toroidal grid graph, and how does it change with the grid's dimensions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do the properties of a covering space change when the base space undergoes a continuous deformation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CoveringSpacesAnimation(Scene):\n    def construct(self):\n        # Title with smaller font size, split into two lines\n        title = Text(\"Exploring Covering Spaces\", font_size=32)\n        subtitle = Text(\"through Continuous Deformation\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        title_group = VGroup(title, subtitle)\n        \n        self.play(Write(title_group))\n        self.wait(1)\n        self.play(FadeOut(title_group))\n        \n        # Introduction to covering spaces\n        base = Circle(radius=1.2, color=BLUE, fill_opacity=0.3)\n        base_label = Text(\"Base Space X\", font_size=24).next_to(base, DOWN)\n        \n        covering = VGroup(\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).shift(LEFT * 0.6),\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).shift(RIGHT * 0.6)\n        )\n        covering_label = Text(\"Covering Space\", font_size=24).next_to(covering, UP)\n        \n        # Show initial spaces\n        self.play(Create(base), Write(base_label))\n        self.wait(0.5)\n        self.play(Create(covering), Write(covering_label))\n        self.wait(1)\n        \n        # Show covering map equation - simplified\n        eq = MathTex(r\"f : \\tilde{X} \\to X\")\n        eq.to_edge(UP)\n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Deform spaces (simulate continuous deformation)\n        deformed_base = base.copy().stretch(1.5, 0)\n        deformed_label = Text(\"Deformed Space Y\", font_size=24).next_to(deformed_base, DOWN)\n        \n        deformed_covering = VGroup(\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).stretch(1.5, 0).shift(LEFT * 0.9),\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).stretch(1.5, 0).shift(RIGHT * 0.9)\n        )\n        \n        # Show deformation\n        self.play(\n            Transform(base, deformed_base),\n            Transform(base_label, deformed_label),\n            Transform(covering, deformed_covering)\n        )\n        self.wait(1)\n        \n        # Show homotopy equivalence - simplified\n        new_eq = MathTex(r\"\\pi_1(X) \\cong \\pi_1(Y)\")\n        new_eq.to_edge(UP)\n        self.play(Transform(eq, new_eq))\n        self.wait(1)\n        \n        # Demonstrate coffee mug to donut transformation\n        self.play(\n            FadeOut(base),\n            FadeOut(base_label),\n            FadeOut(covering),\n            FadeOut(covering_label),\n            FadeOut(eq)\n        )\n        \n        # Simple mug representation\n        mug = VGroup(\n            Circle(radius=0.8, color=GREEN, fill_opacity=0.3),  # Mug body\n            Arc(angle=PI, radius=0.4, color=GREEN).shift(LEFT * 0.8)  # Handle\n        )\n        mug_label = Text(\"Coffee Mug\", font_size=24).next_to(mug, DOWN)\n        \n        # Simple donut representation\n        donut = Circle(radius=1.0, color=GREEN, fill_opacity=0.3)\n        donut_label = Text(\"Donut (Torus)\", font_size=24).next_to(donut, DOWN)\n        \n        # Show mug-to-donut homotopy\n        self.play(Create(mug), Write(mug_label))\n        self.wait(0.5)\n        self.play(Transform(mug, donut), Transform(mug_label, donut_label))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Properties preserved under\\ncontinuous deformation\", font_size=32)\n        self.play(\n            FadeOut(mug),\n            FadeOut(mug_label),\n            Write(conclusion)\n        )\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n\n# To render this animation with the output filename \"video.mp4\", run:\n# manim -pqh -o video.mp4 script_name.py CoveringSpacesAnimation\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do the properties of a covering space change when the base space undergoes a continuous deformation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do the properties of a covering space change when the base space undergoes a continuous deformation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CoveringSpacesAnimation(Scene):\n    def construct(self):\n        # Title with smaller font size, split into two lines\n        title = Text(\"Exploring Covering Spaces\", font_size=32)\n        subtitle = Text(\"through Continuous Deformation\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        title_group = VGroup(title, subtitle)\n        \n        self.play(Write(title_group))\n        self.wait(1)\n        self.play(FadeOut(title_group))\n        \n        # Introduction to covering spaces\n        base = Circle(radius=1.2, color=BLUE, fill_opacity=0.3)\n        base_label = Text(\"Base Space X\", font_size=24).next_to(base, DOWN)\n        \n        covering = VGroup(\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).shift(LEFT * 0.6),\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).shift(RIGHT * 0.6)\n        )\n        covering_label = Text(\"Covering Space\", font_size=24).next_to(covering, UP)\n        \n        # Show initial spaces\n        self.play(Create(base), Write(base_label))\n        self.wait(0.5)\n        self.play(Create(covering), Write(covering_label))\n        self.wait(1)\n        \n        # Show covering map equation - simplified\n        eq = MathTex(r\"f : \\tilde{X} \\to X\")\n        eq.to_edge(UP)\n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Deform spaces (simulate continuous deformation)\n        deformed_base = base.copy().stretch(1.5, 0)\n        deformed_label = Text(\"Deformed Space Y\", font_size=24).next_to(deformed_base, DOWN)\n        \n        deformed_covering = VGroup(\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).stretch(1.5, 0).shift(LEFT * 0.9),\n            Circle(radius=0.6, color=RED, fill_opacity=0.3).stretch(1.5, 0).shift(RIGHT * 0.9)\n        )\n        \n        # Show deformation\n        self.play(\n            Transform(base, deformed_base),\n            Transform(base_label, deformed_label),\n            Transform(covering, deformed_covering)\n        )\n        self.wait(1)\n        \n        # Show homotopy equivalence - simplified\n        new_eq = MathTex(r\"\\pi_1(X) \\cong \\pi_1(Y)\")\n        new_eq.to_edge(UP)\n        self.play(Transform(eq, new_eq))\n        self.wait(1)\n        \n        # Demonstrate coffee mug to donut transformation\n        self.play(\n            FadeOut(base),\n            FadeOut(base_label),\n            FadeOut(covering),\n            FadeOut(covering_label),\n            FadeOut(eq)\n        )\n        \n        # Simple mug representation\n        mug = VGroup(\n            Circle(radius=0.8, color=GREEN, fill_opacity=0.3),  # Mug body\n            Arc(angle=PI, radius=0.4, color=GREEN).shift(LEFT * 0.8)  # Handle\n        )\n        mug_label = Text(\"Coffee Mug\", font_size=24).next_to(mug, DOWN)\n        \n        # Simple donut representation\n        donut = Circle(radius=1.0, color=GREEN, fill_opacity=0.3)\n        donut_label = Text(\"Donut (Torus)\", font_size=24).next_to(donut, DOWN)\n        \n        # Show mug-to-donut homotopy\n        self.play(Create(mug), Write(mug_label))\n        self.wait(0.5)\n        self.play(Transform(mug, donut), Transform(mug_label, donut_label))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Properties preserved under\\ncontinuous deformation\", font_size=32)\n        self.play(\n            FadeOut(mug),\n            FadeOut(mug_label),\n            Write(conclusion)\n        )\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n\n# To render this animation with the output filename \"video.mp4\", run:\n# manim -pqh -o video.mp4 script_name.py CoveringSpacesAnimation\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do the properties of a covering space change when the base space undergoes a continuous deformation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n\\pi & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith a surrounding rectangle highlighting the second column (containing the numbers 3 and 5). The matrix and highlight appear on screen without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n\\pi & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith a surrounding rectangle highlighting the second column (containing the numbers 3 and 5). The matrix and highlight appear on screen without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n\\pi & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith a surrounding rectangle highlighting the second column (containing the numbers 3 and 5). the matrix and highlight appear on screen without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetColumnsExample(Scene):\n    def construct(self):\n        m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n        m0.add(SurroundingRectangle(m0.get_columns()[1]))\n        self.add(m0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n\\pi & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith a surrounding rectangle highlighting the second column (containing the numbers 3 and 5). The matrix and highlight appear on screen without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation where the word \"Broadcast\" appears and moves upward, followed by a triangle shape emanating some sort of broadcast signal and then the triangle disappearing?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InfiniteGeometricSeries(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for the sum of an infinite geometric series\n        explanation1 = Text(\"Use formula for sum of infinite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing the sum formula\n        sum_formula = MathTex(r\"S = \\frac{a}{1 - r}\", r\",\\ |r| < 1\")\n        self.play(ReplacementTransform(series, sum_formula))\n        self.wait(1)\n\n        # Explanation for a specific example\n        explanation2 = Text(\"Example with a=1, r=1/2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Specific example calculation\n        example_calculation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}} = 2\")\n        self.play(ReplacementTransform(sum_formula, example_calculation))\n        self.wait(1)\n\n        # Clear screen and conclude with the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(example_calculation))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where the word \"Broadcast\" appears and moves upward, followed by a triangle shape emanating some sort of broadcast signal and then the triangle disappearing?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation where the word \"broadcast\" appears and moves upward, followed by a triangle shape emanating some sort of broadcast signal and then the triangle disappearing?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InfiniteGeometricSeries(Scene):\n    def construct(self):\n        # Display the series\n        series = MathTex(r\"S = \\sum_{n=0}^{\\infty} ar^n\")\n        self.play(Write(series))\n        self.wait(1)\n\n        # Explanation for the sum of an infinite geometric series\n        explanation1 = Text(\"Use formula for sum of infinite geometric series\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Showing the sum formula\n        sum_formula = MathTex(r\"S = \\frac{a}{1 - r}\", r\",\\ |r| < 1\")\n        self.play(ReplacementTransform(series, sum_formula))\n        self.wait(1)\n\n        # Explanation for a specific example\n        explanation2 = Text(\"Example with a=1, r=1/2\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Specific example calculation\n        example_calculation = MathTex(r\"S = \\frac{1}{1 - \\frac{1}{2}} = 2\")\n        self.play(ReplacementTransform(sum_formula, example_calculation))\n        self.wait(1)\n\n        # Clear screen and conclude with the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(example_calculation))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where the word \"Broadcast\" appears and moves upward, followed by a triangle shape emanating some sort of broadcast signal and then the triangle disappearing?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four different matrix styles arranged in a grid:\n\n- The first is a symbolic matrix with elements like \\( \\pi \\), 0, -1, and 1, enclosed in square brackets.\n- The second is an integer matrix with decimal and whole numbers, enclosed in parentheses.\n- The third is a decimal matrix with values rounded to two decimal places, enclosed in curly braces.\n- The fourth is a matrix of graphical objects including a circle, square, large \\( \\pi \\), and a star, enclosed in angle brackets.\n\nAll matrices appear on screen simultaneously without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 0], [-1, 1]])\n        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m2 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12.33]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m3 = MobjectMatrix(\n            [[Circle().scale(0.3), Square().scale(0.3)],\n            [MathTex(\"\\\\pi\").scale(2), Star().scale(0.3)]],\n            left_bracket=\"\\\\langle\",\n            right_bracket=\"\\\\rangle\")\n        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)\n        self.add(g)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four different matrix styles arranged in a grid:\n\n- The first is a symbolic matrix with elements like \\( \\pi \\), 0, -1, and 1, enclosed in square brackets.\n- The second is an integer matrix with decimal and whole numbers, enclosed in parentheses.\n- The third is a decimal matrix with values rounded to two decimal places, enclosed in curly braces.\n- The fourth is a matrix of graphical objects including a circle, square, large \\( \\pi \\), and a star, enclosed in angle brackets.\n\nAll matrices appear on screen simultaneously without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four different matrix styles arranged in a grid:\n\n- the first is a symbolic matrix with elements like \\( \\pi \\), 0, -1, and 1, enclosed in square brackets.\n- the second is an integer matrix with decimal and whole numbers, enclosed in parentheses.\n- the third is a decimal matrix with values rounded to two decimal places, enclosed in curly braces.\n- the fourth is a matrix of graphical objects including a circle, square, large \\( \\pi \\), and a star, enclosed in angle brackets.\n\nall matrices appear on screen simultaneously without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MatrixExamples(Scene):\n    def construct(self):\n        m0 = Matrix([[\"\\\\pi\", 0], [-1, 1]])\n        m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        m2 = DecimalMatrix(\n            [[3.456, 2.122], [33.2244, 12.33]],\n            element_to_mobject_config={\"num_decimal_places\": 2},\n            left_bracket=r\"\\{\",\n            right_bracket=r\"\\}\")\n        m3 = MobjectMatrix(\n            [[Circle().scale(0.3), Square().scale(0.3)],\n            [MathTex(\"\\\\pi\").scale(2), Star().scale(0.3)]],\n            left_bracket=\"\\\\langle\",\n            right_bracket=\"\\\\rangle\")\n        g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)\n        self.add(g)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four different matrix styles arranged in a grid:\n\n- The first is a symbolic matrix with elements like \\( \\pi \\), 0, -1, and 1, enclosed in square brackets.\n- The second is an integer matrix with decimal and whole numbers, enclosed in parentheses.\n- The third is a decimal matrix with values rounded to two decimal places, enclosed in curly braces.\n- The fourth is a matrix of graphical objects including a circle, square, large \\( \\pi \\), and a star, enclosed in angle brackets.\n\nAll matrices appear on screen simultaneously without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation of a simple neural network with three layers that have different numbers of neurons, where the neurons are blue circles connected by lines to show the connections between them? Let's have the first layer have 4 neurons, the second have 5, and the third have 3. Also, can the camera rotate around the network so we can view it from different angles?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        initial_text = Text(\"Wave Propagation\")\n        self.play(Write(initial_text))\n        self.wait(1)\n        self.play(ApplyWave(initial_text))\n        self.wait(1)\n        transformed_text = Text(\"Wave Effect\").shift(DOWN*2)\n        self.play(Transform(initial_text, transformed_text))\n        self.wait(1)\n        self.play(ApplyWave(transformed_text, direction=UP))\n        self.wait(1)\n        self.remove(transformed_text)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation of a simple neural network with three layers that have different numbers of neurons, where the neurons are blue circles connected by lines to show the connections between them? Let's have the first layer have 4 neurons, the second have 5, and the third have 3. Also, can the camera rotate around the network so we can view it from different angles?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation of a simple neural network with three layers that have different numbers of neurons, where the neurons are blue circles connected by lines to show the connections between them? let's have the first layer have 4 neurons, the second have 5, and the third have 3. also, can the camera rotate around the network so we can view it from different angles?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveAnimationExample(Scene):\n    def construct(self):\n        initial_text = Text(\"Wave Propagation\")\n        self.play(Write(initial_text))\n        self.wait(1)\n        self.play(ApplyWave(initial_text))\n        self.wait(1)\n        transformed_text = Text(\"Wave Effect\").shift(DOWN*2)\n        self.play(Transform(initial_text, transformed_text))\n        self.wait(1)\n        self.play(ApplyWave(transformed_text, direction=UP))\n        self.wait(1)\n        self.remove(transformed_text)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation of a simple neural network with three layers that have different numbers of neurons, where the neurons are blue circles connected by lines to show the connections between them? Let's have the first layer have 4 neurons, the second have 5, and the third have 3. Also, can the camera rotate around the network so we can view it from different angles?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that explains the concept of simple harmonic motion using the mass-spring system? Start by displaying the differential equation that represents the motion, explain what each variable means, then show the formation of the characteristic equation from the differential equation. Afterwards, please show the characteristic roots and then present the general solution to the system. Finally, clear the scene and conclude with a text \"Visualizing Simple Harmonic Motion\" along with the general solution equation displayed once more."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CalculateAreaUnderCurve(Scene):\n    def construct(self):\n        # Display the integral\n        integral = MathTex(r\"\\int_1^3\", r\"x^2\\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Set up the integral calculation\n        setup = Text(\"Calculating the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(setup))\n        self.wait(2)\n\n        # Show integration steps\n        integration_steps = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(ReplacementTransform(integral.copy(), integration_steps))\n        self.wait(2)\n\n        # Evaluation part\n        evaluation = Text(\"Substitute the upper and lower bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(setup, evaluation))\n        self.wait(2)\n        \n        # Showing final calculation\n        final_calculation = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= \\frac{27}{3} - \\frac{1}{3}\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_steps, final_calculation))\n        self.wait(1)\n\n        # Clear the scene and show the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_calculation))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that explains the concept of simple harmonic motion using the mass-spring system? Start by displaying the differential equation that represents the motion, explain what each variable means, then show the formation of the characteristic equation from the differential equation. Afterwards, please show the characteristic roots and then present the general solution to the system. Finally, clear the scene and conclude with a text \"Visualizing Simple Harmonic Motion\" along with the general solution equation displayed once more."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that explains the concept of simple harmonic motion using the mass-spring system? start by displaying the differential equation that represents the motion, explain what each variable means, then show the formation of the characteristic equation from the differential equation. afterwards, please show the characteristic roots and then present the general solution to the system. finally, clear the scene and conclude with a text \"visualizing simple harmonic motion\" along with the general solution equation displayed once more."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CalculateAreaUnderCurve(Scene):\n    def construct(self):\n        # Display the integral\n        integral = MathTex(r\"\\int_1^3\", r\"x^2\\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Set up the integral calculation\n        setup = Text(\"Calculating the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(setup))\n        self.wait(2)\n\n        # Show integration steps\n        integration_steps = MathTex(r\"= \\left[\\frac{1}{3}x^3\\right]_1^3\")\n        self.play(ReplacementTransform(integral.copy(), integration_steps))\n        self.wait(2)\n\n        # Evaluation part\n        evaluation = Text(\"Substitute the upper and lower bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(setup, evaluation))\n        self.wait(2)\n        \n        # Showing final calculation\n        final_calculation = MathTex(r\"= \\frac{1}{3}(3)^3 - \\frac{1}{3}(1)^3\", r\"= \\frac{27}{3} - \\frac{1}{3}\", r\"= 9 - \\frac{1}{3}\", r\"= \\frac{26}{3}\")\n        self.play(ReplacementTransform(integration_steps, final_calculation))\n        self.wait(1)\n\n        # Clear the scene and show the result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_calculation))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that explains the concept of simple harmonic motion using the mass-spring system? Start by displaying the differential equation that represents the motion, explain what each variable means, then show the formation of the characteristic equation from the differential equation. Afterwards, please show the characteristic roots and then present the general solution to the system. Finally, clear the scene and conclude with a text \"Visualizing Simple Harmonic Motion\" along with the general solution equation displayed once more."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Please create an animated math video that explains the process of evaluating the definite integral of sine from 0 to pi. Start by displaying the integral problem, then show the steps to compute the integral with the antiderivative of sine, and evaluate it at the upper and lower bounds. Include on-screen text to guide me through the evaluation of the antiderivative at the bounds. Finally, display the simplified solution and present the final result separately before ending the video."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Broadcast\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(Broadcast(triangle))\n            self.remove(triangle)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an animated math video that explains the process of evaluating the definite integral of sine from 0 to pi. Start by displaying the integral problem, then show the steps to compute the integral with the antiderivative of sine, and evaluate it at the upper and lower bounds. Include on-screen text to guide me through the evaluation of the antiderivative at the bounds. Finally, display the simplified solution and present the final result separately before ending the video."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that please create an animated math video that explains the process of evaluating the definite integral of sine from 0 to pi. start by displaying the integral problem, then show the steps to compute the integral with the antiderivative of sine, and evaluate it at the upper and lower bounds. include on-screen text to guide me through the evaluation of the antiderivative at the bounds. finally, display the simplified solution and present the final result separately before ending the video."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Broadcast\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(Broadcast(triangle))\n            self.remove(triangle)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an animated math video that explains the process of evaluating the definite integral of sine from 0 to pi. Start by displaying the integral problem, then show the steps to compute the integral with the antiderivative of sine, and evaluate it at the upper and lower bounds. Include on-screen text to guide me through the evaluation of the antiderivative at the bounds. Finally, display the simplified solution and present the final result separately before ending the video."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation where a text appears and moves upwards, followed by transforming a circle into a star on screen while both shapes are initially positioned on opposite sides of the screen, and eventually both shapes disappear?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        title = Text(\"Wave Equation in One Dimension\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        wave_eq.next_to(title, DOWN)\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Describing the wave equation\n        description = Text(\"Describes the propagation of waves, like sound and light.\", font_size=24)\n        description.to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying the general solution to the wave equation\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        general_solution.next_to(wave_eq, DOWN)\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(2)\n\n        # Explanation for the general solution\n        explanation = Text(\"The general solution consists of two functions representing waves travelling in opposite directions.\", font_size=24)\n        explanation.to_edge(UP)\n        self.play(Transform(description, explanation))\n        self.wait(3)\n\n        # Specific Example of a sine wave solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        specific_solution.next_to(general_solution, DOWN)\n        self.play(Write(specific_solution))\n        self.wait(2)\n\n        # Explanation for specific sine wave solution\n        explanation2 = Text(\"An example of a specific solution: a sine wave with amplitude A, wavenumber k, and angular frequency \u03c9.\", font_size=24)\n        explanation2.to_edge(UP)\n        self.play(Transform(description, explanation2))\n        self.wait(3)\n\n        # Clear the scene and conclude with the sine wave solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a text appears and moves upwards, followed by transforming a circle into a star on screen while both shapes are initially positioned on opposite sides of the screen, and eventually both shapes disappear?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation where a text appears and moves upwards, followed by transforming a circle into a star on screen while both shapes are initially positioned on opposite sides of the screen, and eventually both shapes disappear?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        title = Text(\"Wave Equation in One Dimension\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        wave_eq.next_to(title, DOWN)\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Describing the wave equation\n        description = Text(\"Describes the propagation of waves, like sound and light.\", font_size=24)\n        description.to_edge(UP)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying the general solution to the wave equation\n        general_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        general_solution.next_to(wave_eq, DOWN)\n        self.play(ReplacementTransform(wave_eq, general_solution))\n        self.wait(2)\n\n        # Explanation for the general solution\n        explanation = Text(\"The general solution consists of two functions representing waves travelling in opposite directions.\", font_size=24)\n        explanation.to_edge(UP)\n        self.play(Transform(description, explanation))\n        self.wait(3)\n\n        # Specific Example of a sine wave solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        specific_solution.next_to(general_solution, DOWN)\n        self.play(Write(specific_solution))\n        self.wait(2)\n\n        # Explanation for specific sine wave solution\n        explanation2 = Text(\"An example of a specific solution: a sine wave with amplitude A, wavenumber k, and angular frequency \u03c9.\", font_size=24)\n        explanation2.to_edge(UP)\n        self.play(Transform(description, explanation2))\n        self.wait(3)\n\n        # Clear the scene and conclude with the sine wave solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(specific_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a text appears and moves upwards, followed by transforming a circle into a star on screen while both shapes are initially positioned on opposite sides of the screen, and eventually both shapes disappear?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four squares arranged in a row. Animate each square growing outward from a different edge: the first from the bottom, the second from the right, the third from the upper right corner, and the fourth from the top with its starting edge highlighted in red."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four squares arranged in a row. Animate each square growing outward from a different edge: the first from the bottom, the second from the right, the third from the upper right corner, and the fourth from the top with its starting edge highlighted in red."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four squares arranged in a row. animate each square growing outward from a different edge: the first from the bottom, the second from the right, the third from the upper right corner, and the fourth from the top with its starting edge highlighted in red."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GrowFromEdgeExample(Scene):\n    def construct(self):\n        squares = [Square() for _ in range(4)]\n        VGroup(*squares).set_x(0).arrange(buff=1)\n        self.play(GrowFromEdge(squares[0], DOWN))\n        self.play(GrowFromEdge(squares[1], RIGHT))\n        self.play(GrowFromEdge(squares[2], UR))\n        self.play(GrowFromEdge(squares[3], UP, point_color=RED))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four squares arranged in a row. Animate each square growing outward from a different edge: the first from the bottom, the second from the right, the third from the upper right corner, and the fourth from the top with its starting edge highlighted in red."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "old_example.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        self.play(nn.make_forward_pass_animation())\n```"}], "metadata": {"source": "thanks-manim", "original_description": "old_example.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that old_example.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass ConvolutionalNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        self.play(nn.make_forward_pass_animation())\n```"}], "metadata": {"source": "thanks-manim", "original_description": "old_example.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a dot positioned at the upper left. Then animate the text \u201cFadeOut with shift or target_position and scale\u201d disappearing in four parts: the first part fades out normally, the second fades out while shifting downward, the third fades out while moving toward the dot, and the fourth fades out while scaling down. Each part disappears with a delay between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a dot positioned at the upper left. Then animate the text \u201cFadeOut with shift or target_position and scale\u201d disappearing in four parts: the first part fades out normally, the second fades out while shifting downward, the third fades out while moving toward the dot, and the fourth fades out while scaling down. Each part disappears with a delay between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a dot positioned at the upper left. then animate the text \u201cfadeout with shift or target_position and scale\u201d disappearing in four parts: the first part fades out normally, the second fades out while shifting downward, the third fades out while moving toward the dot, and the fourth fades out while scaling down. each part disappears with a delay between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FadeInExample(Scene):\n    def construct(self):\n        dot = Dot(UP * 2 + LEFT)\n        self.add(dot)\n        tex = Tex(\n            \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n        ).scale(1)\n        animations = [\n            FadeOut(tex[0]),\n            FadeOut(tex[1], shift=DOWN),\n            FadeOut(tex[2], target_position=dot),\n            FadeOut(tex[3], scale=0.5),\n        ]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a dot positioned at the upper left. Then animate the text \u201cFadeOut with shift or target_position and scale\u201d disappearing in four parts: the first part fades out normally, the second fades out while shifting downward, the third fades out while moving toward the dot, and the fourth fades out while scaling down. Each part disappears with a delay between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation where a text saying \"Hello, Manim!\" appears on the screen, then has a wave effect applied to it twice\u2014with the second wave being less intense than the first\u2014and finally disappears from the screen?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting u = 2x\n        explanation1 = Text(\"Let u = 2x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Step to integrate by substitution\n        subst_step = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(subst_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a text saying \"Hello, Manim!\" appears on the screen, then has a wave effect applied to it twice\u2014with the second wave being less intense than the first\u2014and finally disappears from the screen?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation where a text saying \"hello, manim!\" appears on the screen, then has a wave effect applied to it twice\u2014with the second wave being less intense than the first\u2014and finally disappears from the screen?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting u = 2x\n        explanation1 = Text(\"Let u = 2x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Step to integrate by substitution\n        subst_step = MathTex(r\"\\int \\frac{1}{2}e^u \\,du\")\n        self.play(ReplacementTransform(problem.copy(), subst_step))\n        self.wait(1)\n\n        # Explanation for integration\n        explanation2 = Text(\"Integrate with respect to u\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{2}e^{2x} + C\")\n        self.play(ReplacementTransform(subst_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a text saying \"Hello, Manim!\" appears on the screen, then has a wave effect applied to it twice\u2014with the second wave being less intense than the first\u2014and finally disappears from the screen?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a square at the center of the screen that continuously rotates clockwise at a rate of 90 degrees per second for two seconds."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DtUpdater(Scene):\n    def construct(self):\n        square = Square()\n\n        #Let the square rotate 90\u00b0 per second\n        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n        self.add(square)\n        self.wait(2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a square at the center of the screen that continuously rotates clockwise at a rate of 90 degrees per second for two seconds."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a square at the center of the screen that continuously rotates clockwise at a rate of 90 degrees per second for two seconds."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DtUpdater(Scene):\n    def construct(self):\n        square = Square()\n\n        #Let the square rotate 90\u00b0 per second\n        square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n        self.add(square)\n        self.wait(2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a square at the center of the screen that continuously rotates clockwise at a rate of 90 degrees per second for two seconds."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can we use boundary properties and orientability to differentiate between a sphere and a projective plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TopologySurfaceClassification(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Hidden Flip: Topology of Surfaces\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Comparing a Sphere and a Projective Plane\", font_size=28)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Sphere representation\n        sphere = Circle(radius=1.5, color=BLUE, fill_opacity=0.3)\n        sphere_label = Text(\"Sphere\", font_size=24).next_to(sphere, UP)\n        sphere_props = Text(\"Closed & Orientable\", font_size=20).next_to(sphere, DOWN)\n        \n        sphere_group = VGroup(sphere, sphere_label, sphere_props)\n        sphere_group.to_edge(LEFT)\n        \n        self.play(FadeIn(sphere_group))\n        self.wait(1)\n        \n        # Projective plane representation\n        pp = Circle(radius=1.5, color=GREEN, fill_opacity=0.3)\n        pp_arrow = Arrow(start=pp.get_top(), end=pp.get_bottom(), buff=0, color=RED)\n        pp_group_visual = VGroup(pp, pp_arrow)\n        pp_label = Text(\"Projective Plane\", font_size=24).next_to(pp_group_visual, UP)\n        pp_props = Text(\"Closed & Non-orientable\", font_size=20).next_to(pp_group_visual, DOWN)\n        \n        pp_group = VGroup(pp_group_visual, pp_label, pp_props)\n        pp_group.to_edge(RIGHT)\n        \n        self.play(FadeIn(pp_group))\n        self.wait(1)\n        \n        # Key equations\n        eq_title = Text(\"Mathematical Representation\", font_size=28)\n        eq_title.next_to(title, DOWN, buff=0.5)\n        \n        sphere_eq = MathTex(r\"S^2 = \\{x \\in \\mathbb{R}^3 : ||x|| = 1\\}\")\n        pp_eq = MathTex(r\"RP^2 = S^2 / (x \\sim -x)\")\n        \n        equations = VGroup(sphere_eq, pp_eq)\n        equations.arrange(DOWN, buff=0.5)\n        equations.next_to(eq_title, DOWN, buff=0.5)\n        \n        self.play(Write(eq_title))\n        self.play(Write(equations))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(sphere_group),\n            FadeOut(pp_group),\n            FadeOut(equations),\n            FadeOut(eq_title)\n        )\n        \n        conclusion = Text(\"The key difference: Orientability\", font_size=32)\n        conclusion.next_to(title, DOWN, buff=1)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        self.play(FadeOut(conclusion), FadeOut(title))\n        \n        # Final message\n        final = Text(\"The Hidden Flip: Topology of Surfaces\", font_size=36)\n        self.play(Write(final))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we use boundary properties and orientability to differentiate between a sphere and a projective plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can we use boundary properties and orientability to differentiate between a sphere and a projective plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TopologySurfaceClassification(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Hidden Flip: Topology of Surfaces\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Comparing a Sphere and a Projective Plane\", font_size=28)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Sphere representation\n        sphere = Circle(radius=1.5, color=BLUE, fill_opacity=0.3)\n        sphere_label = Text(\"Sphere\", font_size=24).next_to(sphere, UP)\n        sphere_props = Text(\"Closed & Orientable\", font_size=20).next_to(sphere, DOWN)\n        \n        sphere_group = VGroup(sphere, sphere_label, sphere_props)\n        sphere_group.to_edge(LEFT)\n        \n        self.play(FadeIn(sphere_group))\n        self.wait(1)\n        \n        # Projective plane representation\n        pp = Circle(radius=1.5, color=GREEN, fill_opacity=0.3)\n        pp_arrow = Arrow(start=pp.get_top(), end=pp.get_bottom(), buff=0, color=RED)\n        pp_group_visual = VGroup(pp, pp_arrow)\n        pp_label = Text(\"Projective Plane\", font_size=24).next_to(pp_group_visual, UP)\n        pp_props = Text(\"Closed & Non-orientable\", font_size=20).next_to(pp_group_visual, DOWN)\n        \n        pp_group = VGroup(pp_group_visual, pp_label, pp_props)\n        pp_group.to_edge(RIGHT)\n        \n        self.play(FadeIn(pp_group))\n        self.wait(1)\n        \n        # Key equations\n        eq_title = Text(\"Mathematical Representation\", font_size=28)\n        eq_title.next_to(title, DOWN, buff=0.5)\n        \n        sphere_eq = MathTex(r\"S^2 = \\{x \\in \\mathbb{R}^3 : ||x|| = 1\\}\")\n        pp_eq = MathTex(r\"RP^2 = S^2 / (x \\sim -x)\")\n        \n        equations = VGroup(sphere_eq, pp_eq)\n        equations.arrange(DOWN, buff=0.5)\n        equations.next_to(eq_title, DOWN, buff=0.5)\n        \n        self.play(Write(eq_title))\n        self.play(Write(equations))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(sphere_group),\n            FadeOut(pp_group),\n            FadeOut(equations),\n            FadeOut(eq_title)\n        )\n        \n        conclusion = Text(\"The key difference: Orientability\", font_size=32)\n        conclusion.next_to(title, DOWN, buff=1)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        self.play(FadeOut(conclusion), FadeOut(title))\n        \n        # Final message\n        final = Text(\"The Hidden Flip: Topology of Surfaces\", font_size=36)\n        self.play(Write(final))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we use boundary properties and orientability to differentiate between a sphere and a projective plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display three colored circles: red on the left, green in the center, and blue on the right. Initially, the red and green circles are grouped together, and the blue circle is in a separate group. After a pause, the blue circle is added to the first group, and the entire group shifts downward. Then, the blue circle is removed from the group, and the two groups animate separately\u2014one shifting left and the other shifting up. Next, all three circles shift right together. Finally, only the green and blue circles (excluding the red) shift right."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AddToVGroup(Scene):\n    def construct(self):\n        circle_red = Circle(color=RED)\n        circle_green = Circle(color=GREEN)\n        circle_blue = Circle(color=BLUE)\n        circle_red.shift(LEFT)\n        circle_blue.shift(RIGHT)\n        gr = VGroup(circle_red, circle_green)\n        gr2 = VGroup(circle_blue) # Constructor uses add directly\n        self.add(gr,gr2)\n        self.wait()\n        gr += gr2 # Add group to another\n        self.play(\n            gr.animate.shift(DOWN),\n        )\n        gr -= gr2 # Remove group\n        self.play( # Animate groups separately\n            gr.animate.shift(LEFT),\n            gr2.animate.shift(UP),\n        )\n        self.play( #Animate groups without modification\n            (gr+gr2).animate.shift(RIGHT)\n        )\n        self.play( # Animate group without component\n            (gr-circle_red).animate.shift(RIGHT)\n        )\n```"}], "metadata": {"source": "manimbench", "original_description": "Display three colored circles: red on the left, green in the center, and blue on the right. Initially, the red and green circles are grouped together, and the blue circle is in a separate group. After a pause, the blue circle is added to the first group, and the entire group shifts downward. Then, the blue circle is removed from the group, and the two groups animate separately\u2014one shifting left and the other shifting up. Next, all three circles shift right together. Finally, only the green and blue circles (excluding the red) shift right."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display three colored circles: red on the left, green in the center, and blue on the right. initially, the red and green circles are grouped together, and the blue circle is in a separate group. after a pause, the blue circle is added to the first group, and the entire group shifts downward. then, the blue circle is removed from the group, and the two groups animate separately\u2014one shifting left and the other shifting up. next, all three circles shift right together. finally, only the green and blue circles (excluding the red) shift right."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AddToVGroup(Scene):\n    def construct(self):\n        circle_red = Circle(color=RED)\n        circle_green = Circle(color=GREEN)\n        circle_blue = Circle(color=BLUE)\n        circle_red.shift(LEFT)\n        circle_blue.shift(RIGHT)\n        gr = VGroup(circle_red, circle_green)\n        gr2 = VGroup(circle_blue) # Constructor uses add directly\n        self.add(gr,gr2)\n        self.wait()\n        gr += gr2 # Add group to another\n        self.play(\n            gr.animate.shift(DOWN),\n        )\n        gr -= gr2 # Remove group\n        self.play( # Animate groups separately\n            gr.animate.shift(LEFT),\n            gr2.animate.shift(UP),\n        )\n        self.play( #Animate groups without modification\n            (gr+gr2).animate.shift(RIGHT)\n        )\n        self.play( # Animate group without component\n            (gr-circle_red).animate.shift(RIGHT)\n        )\n```"}], "metadata": {"source": "manimbench", "original_description": "Display three colored circles: red on the left, green in the center, and blue on the right. Initially, the red and green circles are grouped together, and the blue circle is in a separate group. After a pause, the blue circle is added to the first group, and the entire group shifts downward. Then, the blue circle is removed from the group, and the two groups animate separately\u2014one shifting left and the other shifting up. Next, all three circles shift right together. Finally, only the green and blue circles (excluding the red) shift right."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the result of applying the concept of homotopy to continuous functions on a torus, and how can this interaction be visually represented?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TorusHomotopy(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Unraveling the Mysteries of Torus Topology\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction to the torus concept\n        torus_text = Text(\"A torus is a donut-shaped surface\", font_size=18)\n        self.play(Write(torus_text))\n        self.wait(1)\n        self.play(FadeOut(torus_text))\n        \n        # Represent torus in 2D with two concentric circles\n        # The outer circle represents the outer boundary of the torus\n        # The inner circle represents the hole of the torus\n        torus_outer = Circle(radius=2.0, color=BLUE)\n        torus_inner = Circle(radius=1.0, color=BLUE)\n        torus_label = Text(\"Torus (2D view)\", font_size=16).next_to(torus_inner, DOWN)\n        \n        self.play(Create(torus_outer), Create(torus_inner))\n        self.play(Write(torus_label))\n        self.wait(1)\n        \n        # Show a loop on the torus (represented as a circle between inner and outer circles)\n        # This loop can be thought of as wrapped around the torus\n        loop = Circle(radius=1.5, color=YELLOW)\n        loop_label = Text(\"Loop on torus\", font_size=16).next_to(loop, RIGHT)\n        \n        self.play(Create(loop))\n        self.play(Write(loop_label))\n        self.wait(1)\n        self.play(FadeOut(loop_label))\n        \n        # Introduce the concept of homotopy - continuous deformation of one function into another\n        homotopy_text = Text(\"Homotopy: Continuous deformation\", font_size=18).to_edge(DOWN)\n        self.play(Write(homotopy_text))\n        self.wait(1)\n        \n        # Animate the loop expanding and contracting to show continuous deformation (homotopy)\n        self.play(loop.animate.scale(1.1))  # Expand\n        self.wait(0.5)\n        self.play(loop.animate.scale(0.9/1.1))  # Contract\n        self.wait(0.5)\n        self.play(loop.animate.scale(1.2/0.9))  # Expand more\n        self.wait(0.5)\n        self.play(loop.animate.scale(0.8/1.2))  # Contract more\n        self.wait(1)\n        \n        # Show the equation for a loop on a torus\n        eq1 = MathTex(r\"L(\\theta, \\varphi) = (\\cos \\varphi + 2) \\cos \\theta\").next_to(homotopy_text, UP)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Show the formal definition of homotopy\n        eq2 = MathTex(r\"H(f(t)): [0,1] \\times X \\to Y\").next_to(eq1, UP)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Cleanup middle section to prepare for conclusion\n        self.play(FadeOut(homotopy_text, eq1, eq2))\n        \n        # Conclusion highlighting the significance of torus topology\n        conclusion = Text(\"The magic of the torus lies in its unique topology\", font_size=18).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fadeout of all elements\n        self.play(FadeOut(title, torus_outer, torus_inner, torus_label, loop, conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the result of applying the concept of homotopy to continuous functions on a torus, and how can this interaction be visually represented?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the result of applying the concept of homotopy to continuous functions on a torus, and how can this interaction be visually represented?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TorusHomotopy(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Unraveling the Mysteries of Torus Topology\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction to the torus concept\n        torus_text = Text(\"A torus is a donut-shaped surface\", font_size=18)\n        self.play(Write(torus_text))\n        self.wait(1)\n        self.play(FadeOut(torus_text))\n        \n        # Represent torus in 2D with two concentric circles\n        # The outer circle represents the outer boundary of the torus\n        # The inner circle represents the hole of the torus\n        torus_outer = Circle(radius=2.0, color=BLUE)\n        torus_inner = Circle(radius=1.0, color=BLUE)\n        torus_label = Text(\"Torus (2D view)\", font_size=16).next_to(torus_inner, DOWN)\n        \n        self.play(Create(torus_outer), Create(torus_inner))\n        self.play(Write(torus_label))\n        self.wait(1)\n        \n        # Show a loop on the torus (represented as a circle between inner and outer circles)\n        # This loop can be thought of as wrapped around the torus\n        loop = Circle(radius=1.5, color=YELLOW)\n        loop_label = Text(\"Loop on torus\", font_size=16).next_to(loop, RIGHT)\n        \n        self.play(Create(loop))\n        self.play(Write(loop_label))\n        self.wait(1)\n        self.play(FadeOut(loop_label))\n        \n        # Introduce the concept of homotopy - continuous deformation of one function into another\n        homotopy_text = Text(\"Homotopy: Continuous deformation\", font_size=18).to_edge(DOWN)\n        self.play(Write(homotopy_text))\n        self.wait(1)\n        \n        # Animate the loop expanding and contracting to show continuous deformation (homotopy)\n        self.play(loop.animate.scale(1.1))  # Expand\n        self.wait(0.5)\n        self.play(loop.animate.scale(0.9/1.1))  # Contract\n        self.wait(0.5)\n        self.play(loop.animate.scale(1.2/0.9))  # Expand more\n        self.wait(0.5)\n        self.play(loop.animate.scale(0.8/1.2))  # Contract more\n        self.wait(1)\n        \n        # Show the equation for a loop on a torus\n        eq1 = MathTex(r\"L(\\theta, \\varphi) = (\\cos \\varphi + 2) \\cos \\theta\").next_to(homotopy_text, UP)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Show the formal definition of homotopy\n        eq2 = MathTex(r\"H(f(t)): [0,1] \\times X \\to Y\").next_to(eq1, UP)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Cleanup middle section to prepare for conclusion\n        self.play(FadeOut(homotopy_text, eq1, eq2))\n        \n        # Conclusion highlighting the significance of torus topology\n        conclusion = Text(\"The magic of the torus lies in its unique topology\", font_size=18).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fadeout of all elements\n        self.play(FadeOut(title, torus_outer, torus_inner, torus_label, loop, conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the result of applying the concept of homotopy to continuous functions on a torus, and how can this interaction be visually represented?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the concept of a \"tree of prime ideals\" help visualize the relationships outlined by the Hauptidealsatz in a Noetherian ring?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PrimeIdealTree(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Tree of Prime Ideals in Noetherian Rings\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple tree with just 3 levels\n        # Root (zero ideal)\n        root = Circle(radius=0.3, color=BLUE).shift(DOWN * 2)\n        root_label = Text(\"(0)\", font_size=20).next_to(root, DOWN)\n        \n        # Level 1 (two prime ideals)\n        p1 = Circle(radius=0.3, color=GREEN).shift(DOWN * 0.5 + LEFT * 2)\n        p2 = Circle(radius=0.3, color=GREEN).shift(DOWN * 0.5 + RIGHT * 2)\n        p1_label = Text(\"P1\", font_size=20).next_to(p1, DOWN)\n        p2_label = Text(\"P2\", font_size=20).next_to(p2, DOWN)\n        \n        # Level 2 (maximal ideals)\n        m1 = Circle(radius=0.3, color=RED).shift(UP * 1 + LEFT * 2)\n        m2 = Circle(radius=0.3, color=RED).shift(UP * 1 + RIGHT * 2)\n        m1_label = Text(\"M1\", font_size=20).next_to(m1, UP)\n        m2_label = Text(\"M2\", font_size=20).next_to(m2, UP)\n        \n        # Connect with lines\n        line1 = Line(root.get_center(), p1.get_center())\n        line2 = Line(root.get_center(), p2.get_center())\n        line3 = Line(p1.get_center(), m1.get_center())\n        line4 = Line(p2.get_center(), m2.get_center())\n        \n        # Create the tree (all at once to save time)\n        self.play(\n            Create(root), Write(root_label),\n            Create(p1), Write(p1_label),\n            Create(p2), Write(p2_label),\n            Create(m1), Write(m1_label),\n            Create(m2), Write(m2_label),\n            Create(line1), Create(line2),\n            Create(line3), Create(line4)\n        )\n        self.wait(1)\n        \n        # Explanation\n        explanation = Text(\"Chains of Prime Ideals\", font_size=24).next_to(title, DOWN)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Highlight path 1 and show equation\n        highlight_line1 = Line(root.get_center(), p1.get_center(), color=YELLOW, stroke_width=5)\n        highlight_line2 = Line(p1.get_center(), m1.get_center(), color=YELLOW, stroke_width=5)\n        self.play(Create(highlight_line1), Create(highlight_line2))\n        \n        # Simple chain equation \n        chain_eq = Text(\"P0 \u2282 P1 \u2282 ... \u2282 Pn\", font_size=24).next_to(explanation, DOWN)\n        self.play(Write(chain_eq))\n        self.wait(1)\n        \n        # Noetherian condition in simple text\n        self.play(FadeOut(chain_eq))\n        noetherian = Text(\"In Noetherian rings, all chains are finite\", font_size=24).next_to(explanation, DOWN)\n        self.play(Write(noetherian))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(explanation), FadeOut(noetherian), FadeOut(highlight_line1), FadeOut(highlight_line2))\n        conclusion = Text(\"Trees visualize prime ideal relationships\", font_size=24).next_to(title, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the concept of a \"tree of prime ideals\" help visualize the relationships outlined by the Hauptidealsatz in a Noetherian ring?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the concept of a \"tree of prime ideals\" help visualize the relationships outlined by the hauptidealsatz in a noetherian ring?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PrimeIdealTree(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Tree of Prime Ideals in Noetherian Rings\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple tree with just 3 levels\n        # Root (zero ideal)\n        root = Circle(radius=0.3, color=BLUE).shift(DOWN * 2)\n        root_label = Text(\"(0)\", font_size=20).next_to(root, DOWN)\n        \n        # Level 1 (two prime ideals)\n        p1 = Circle(radius=0.3, color=GREEN).shift(DOWN * 0.5 + LEFT * 2)\n        p2 = Circle(radius=0.3, color=GREEN).shift(DOWN * 0.5 + RIGHT * 2)\n        p1_label = Text(\"P1\", font_size=20).next_to(p1, DOWN)\n        p2_label = Text(\"P2\", font_size=20).next_to(p2, DOWN)\n        \n        # Level 2 (maximal ideals)\n        m1 = Circle(radius=0.3, color=RED).shift(UP * 1 + LEFT * 2)\n        m2 = Circle(radius=0.3, color=RED).shift(UP * 1 + RIGHT * 2)\n        m1_label = Text(\"M1\", font_size=20).next_to(m1, UP)\n        m2_label = Text(\"M2\", font_size=20).next_to(m2, UP)\n        \n        # Connect with lines\n        line1 = Line(root.get_center(), p1.get_center())\n        line2 = Line(root.get_center(), p2.get_center())\n        line3 = Line(p1.get_center(), m1.get_center())\n        line4 = Line(p2.get_center(), m2.get_center())\n        \n        # Create the tree (all at once to save time)\n        self.play(\n            Create(root), Write(root_label),\n            Create(p1), Write(p1_label),\n            Create(p2), Write(p2_label),\n            Create(m1), Write(m1_label),\n            Create(m2), Write(m2_label),\n            Create(line1), Create(line2),\n            Create(line3), Create(line4)\n        )\n        self.wait(1)\n        \n        # Explanation\n        explanation = Text(\"Chains of Prime Ideals\", font_size=24).next_to(title, DOWN)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Highlight path 1 and show equation\n        highlight_line1 = Line(root.get_center(), p1.get_center(), color=YELLOW, stroke_width=5)\n        highlight_line2 = Line(p1.get_center(), m1.get_center(), color=YELLOW, stroke_width=5)\n        self.play(Create(highlight_line1), Create(highlight_line2))\n        \n        # Simple chain equation \n        chain_eq = Text(\"P0 \u2282 P1 \u2282 ... \u2282 Pn\", font_size=24).next_to(explanation, DOWN)\n        self.play(Write(chain_eq))\n        self.wait(1)\n        \n        # Noetherian condition in simple text\n        self.play(FadeOut(chain_eq))\n        noetherian = Text(\"In Noetherian rings, all chains are finite\", font_size=24).next_to(explanation, DOWN)\n        self.play(Write(noetherian))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(explanation), FadeOut(noetherian), FadeOut(highlight_line1), FadeOut(highlight_line2))\n        conclusion = Text(\"Trees visualize prime ideal relationships\", font_size=24).next_to(title, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the concept of a \"tree of prime ideals\" help visualize the relationships outlined by the Hauptidealsatz in a Noetherian ring?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that visibly explains the steps to calculate the definite integral of the function 3x^2 from 0 to 2, complete with the integration process, simplifying the result, and presenting the final answer?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image),\n            Convolutional2DLayer(1, 6, 1, padding=1),\n            Convolutional2DLayer(3, 6, 3),\n            FeedForwardLayer(3),\n            FeedForwardLayer(1),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=6,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=6,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        self.add(nn)\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=20)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visibly explains the steps to calculate the definite integral of the function 3x^2 from 0 to 2, complete with the integration process, simplifying the result, and presenting the final answer?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that visibly explains the steps to calculate the definite integral of the function 3x^2 from 0 to 2, complete with the integration process, simplifying the result, and presenting the final answer?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers.image import ImageLayer\nimport numpy as np\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nROOT_DIR = Path(__file__).parents[2]\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make nn\n        nn = NeuralNetwork([\n            ImageLayer(numpy_image),\n            Convolutional2DLayer(1, 6, 1, padding=1),\n            Convolutional2DLayer(3, 6, 3),\n            FeedForwardLayer(3),\n            FeedForwardLayer(1),\n        ])\n        # Play animation\n        self.play(nn.make_forward_pass_animation()) \n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(ROOT_DIR / \"assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(\n                    num_feature_maps=1,\n                    feature_map_size=6,\n                    padding=1,\n                    padding_dashed=True,\n                ),\n                Convolutional2DLayer(\n                    num_feature_maps=3,\n                    feature_map_size=6,\n                    filter_size=3,\n                    padding=0,\n                    padding_dashed=False,\n                ),\n                FeedForwardLayer(3),\n                FeedForwardLayer(1),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        self.add(nn)\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=20)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visibly explains the steps to calculate the definite integral of the function 3x^2 from 0 to 2, complete with the integration process, simplifying the result, and presenting the final answer?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a large blue square with red edges, featuring four smaller shapes cut out from it: a triangle in the lower right, a small square in the upper right, a pentagon in the lower left, and a hexagon in the upper left. The cutouts create transparent holes in the larger square, revealing the background."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CutoutExample(Scene):\n    def construct(self):\n        s1 = Square().scale(2.5)\n        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\n        s3 = Square().shift(UP + RIGHT).scale(0.5)\n        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\n        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\n        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\n        self.play(Write(c), run_time=4)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large blue square with red edges, featuring four smaller shapes cut out from it: a triangle in the lower right, a small square in the upper right, a pentagon in the lower left, and a hexagon in the upper left. The cutouts create transparent holes in the larger square, revealing the background."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a large blue square with red edges, featuring four smaller shapes cut out from it: a triangle in the lower right, a small square in the upper right, a pentagon in the lower left, and a hexagon in the upper left. the cutouts create transparent holes in the larger square, revealing the background."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CutoutExample(Scene):\n    def construct(self):\n        s1 = Square().scale(2.5)\n        s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\n        s3 = Square().shift(UP + RIGHT).scale(0.5)\n        s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\n        s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\n        c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\n        self.play(Write(c), run_time=4)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large blue square with red edges, featuring four smaller shapes cut out from it: a triangle in the lower right, a small square in the upper right, a pentagon in the lower left, and a hexagon in the upper left. The cutouts create transparent holes in the larger square, revealing the background."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n2 & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith each entry individually colored:  \n- 2 in blue  \n- 3 in green  \n- 1 in yellow  \n- 5 in red  \n\nThe matrix appears on screen without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n2 & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith each entry individually colored:  \n- 2 in blue  \n- 3 in green  \n- 1 in yellow  \n- 5 in red  \n\nThe matrix appears on screen without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n2 & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith each entry individually colored:  \n- 2 in blue  \n- 3 in green  \n- 1 in yellow  \n- 5 in red  \n\nthe matrix appears on screen without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetEntriesExample(Scene):\n    def construct(self):\n        m0 = Matrix([[2, 3], [1, 5]])\n        ent = m0.get_entries()\n        colors = [BLUE, GREEN, YELLOW, RED]\n        for k in range(len(colors)):\n            ent[k].set_color(colors[k])\n        self.add(m0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 matrix  \n\\[\n\\begin{bmatrix}\n2 & 3 \\\\\n1 & 5\n\\end{bmatrix}\n\\]  \nwith each entry individually colored:  \n- 2 in blue  \n- 3 in green  \n- 1 in yellow  \n- 5 in red  \n\nThe matrix appears on screen without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually demonstrates the process of solving a double integral in polar coordinates, specifically the integral from 0 to 2\u03c0 of the integral from 0 to 1 of r^2 with respect to r and theta? Start by showing the integral problem on the screen, then explain and animate the solution of the inner integral with respect to r, followed by solving the outer integral with respect to theta, and conclude by showing the final area calculation result."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"AnimatedBoundary\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            animated_boundary = AnimatedBoundary(circle, cycle_rate=3, colors=[RED, GREEN, BLUE])\n            self.add(circle, animated_boundary)\n            self.wait(2)\n            self.remove(circle, animated_boundary)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually demonstrates the process of solving a double integral in polar coordinates, specifically the integral from 0 to 2\u03c0 of the integral from 0 to 1 of r^2 with respect to r and theta? Start by showing the integral problem on the screen, then explain and animate the solution of the inner integral with respect to r, followed by solving the outer integral with respect to theta, and conclude by showing the final area calculation result."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually demonstrates the process of solving a double integral in polar coordinates, specifically the integral from 0 to 2\u03c0 of the integral from 0 to 1 of r^2 with respect to r and theta? start by showing the integral problem on the screen, then explain and animate the solution of the inner integral with respect to r, followed by solving the outer integral with respect to theta, and conclude by showing the final area calculation result."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"AnimatedBoundary\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            animated_boundary = AnimatedBoundary(circle, cycle_rate=3, colors=[RED, GREEN, BLUE])\n            self.add(circle, animated_boundary)\n            self.wait(2)\n            self.remove(circle, animated_boundary)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually demonstrates the process of solving a double integral in polar coordinates, specifically the integral from 0 to 2\u03c0 of the integral from 0 to 1 of r^2 with respect to r and theta? Start by showing the integral problem on the screen, then explain and animate the solution of the inner integral with respect to r, followed by solving the outer integral with respect to theta, and conclude by showing the final area calculation result."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what way does de Rham cohomology illustrate the relationship between algebraic varieties and smooth manifolds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DeRhamCohomology(Scene):\n    def construct(self):\n        # Title sequence\n        title = Text(\"Unlocking Hidden Dimensions\", font_size=36)\n        subtitle = Text(\"De Rham Cohomology in Algebraic Geometry\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Element 1: Show bridge between algebraic geometry and topology\n        alg_geom = Text(\"Algebraic Geometry\", font_size=30).to_edge(LEFT)\n        topology = Text(\"Topology\", font_size=30).to_edge(RIGHT)\n        \n        self.play(Write(alg_geom), Write(topology))\n        \n        # Create connecting bridge labeled \"Cohomology\"\n        bridge = Line(alg_geom.get_right() + RIGHT*0.2, \n                     topology.get_left() + LEFT*0.2, \n                     color=YELLOW)\n        cohomology = Text(\"Cohomology\", font_size=24).next_to(bridge, UP)\n        \n        self.play(Create(bridge))\n        self.play(Write(cohomology))\n        self.wait(1)\n        \n        # Clear screen for next element\n        self.play(FadeOut(alg_geom), FadeOut(topology), \n                 FadeOut(cohomology), FadeOut(bridge))\n        \n        # Element 2: Visualize a simple algebraic variety (using a circle for simplicity)\n        variety = Circle(radius=2, color=BLUE)\n        variety_label = Text(\"Algebraic Variety\", font_size=30).next_to(variety, DOWN)\n        \n        self.play(Create(variety))\n        self.play(Write(variety_label))\n        self.wait(1)\n        \n        # Element 3: Show smooth manifold overlaying the algebraic variety\n        manifold = Circle(radius=2.2, color=GREEN)\n        manifold_label = Text(\"Smooth Manifold\", font_size=30).next_to(manifold, UP)\n        \n        self.play(Create(manifold))\n        self.play(Write(manifold_label))\n        \n        # Add arrows representing differentials on the manifold\n        arrow1 = Arrow(UP*2.2, UP*2.7, color=YELLOW)\n        arrow2 = Arrow(DOWN*2.2, DOWN*2.7, color=YELLOW)\n        \n        self.play(Create(arrow1), Create(arrow2))\n        diff_label = Text(\"Differentials\", font_size=24).next_to(arrow1, RIGHT)\n        self.play(Write(diff_label))\n        self.wait(1)\n        \n        # Clear screen for next element\n        self.play(\n            FadeOut(variety), FadeOut(variety_label),\n            FadeOut(manifold), FadeOut(manifold_label),\n            FadeOut(diff_label), FadeOut(arrow1), FadeOut(arrow2)\n        )\n        \n        # Element 4: Show key equation from de Rham cohomology\n        equation = MathTex(r\"\\int_M \\omega = \\int_{\\partial M} \\eta\")\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation up to make room for final element\n        self.play(equation.animate.to_edge(UP))\n        \n        # Element 5: Visualize the connection between algebraic and topological structures\n        alg_box = Square(side_length=2, color=BLUE).shift(LEFT*3)\n        top_box = Square(side_length=2, color=GREEN).shift(RIGHT*3)\n        \n        alg_text = Text(\"Algebraic\", font_size=24).move_to(alg_box)\n        top_text = Text(\"Topological\", font_size=24).move_to(top_box)\n        \n        connection = Arrow(alg_box.get_right(), top_box.get_left(), color=GOLD)\n        connect_text = Text(\"De Rham Cohomology\", font_size=20).next_to(connection, UP)\n        \n        self.play(Create(alg_box), Create(top_box))\n        self.play(Write(alg_text), Write(top_text))\n        self.play(Create(connection))\n        self.play(Write(connect_text))\n        self.wait(1)\n        \n        # Clear screen for conclusion\n        self.play(\n            FadeOut(alg_box), FadeOut(top_box),\n            FadeOut(alg_text), FadeOut(top_text),\n            FadeOut(connection), FadeOut(connect_text),\n            FadeOut(equation)\n        )\n        \n        # Conclusion statement\n        conclusion = Text(\"De Rham cohomology connects\\nalgebraic varieties and smooth manifolds\", \n                         font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way does de Rham cohomology illustrate the relationship between algebraic varieties and smooth manifolds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what way does de rham cohomology illustrate the relationship between algebraic varieties and smooth manifolds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DeRhamCohomology(Scene):\n    def construct(self):\n        # Title sequence\n        title = Text(\"Unlocking Hidden Dimensions\", font_size=36)\n        subtitle = Text(\"De Rham Cohomology in Algebraic Geometry\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Element 1: Show bridge between algebraic geometry and topology\n        alg_geom = Text(\"Algebraic Geometry\", font_size=30).to_edge(LEFT)\n        topology = Text(\"Topology\", font_size=30).to_edge(RIGHT)\n        \n        self.play(Write(alg_geom), Write(topology))\n        \n        # Create connecting bridge labeled \"Cohomology\"\n        bridge = Line(alg_geom.get_right() + RIGHT*0.2, \n                     topology.get_left() + LEFT*0.2, \n                     color=YELLOW)\n        cohomology = Text(\"Cohomology\", font_size=24).next_to(bridge, UP)\n        \n        self.play(Create(bridge))\n        self.play(Write(cohomology))\n        self.wait(1)\n        \n        # Clear screen for next element\n        self.play(FadeOut(alg_geom), FadeOut(topology), \n                 FadeOut(cohomology), FadeOut(bridge))\n        \n        # Element 2: Visualize a simple algebraic variety (using a circle for simplicity)\n        variety = Circle(radius=2, color=BLUE)\n        variety_label = Text(\"Algebraic Variety\", font_size=30).next_to(variety, DOWN)\n        \n        self.play(Create(variety))\n        self.play(Write(variety_label))\n        self.wait(1)\n        \n        # Element 3: Show smooth manifold overlaying the algebraic variety\n        manifold = Circle(radius=2.2, color=GREEN)\n        manifold_label = Text(\"Smooth Manifold\", font_size=30).next_to(manifold, UP)\n        \n        self.play(Create(manifold))\n        self.play(Write(manifold_label))\n        \n        # Add arrows representing differentials on the manifold\n        arrow1 = Arrow(UP*2.2, UP*2.7, color=YELLOW)\n        arrow2 = Arrow(DOWN*2.2, DOWN*2.7, color=YELLOW)\n        \n        self.play(Create(arrow1), Create(arrow2))\n        diff_label = Text(\"Differentials\", font_size=24).next_to(arrow1, RIGHT)\n        self.play(Write(diff_label))\n        self.wait(1)\n        \n        # Clear screen for next element\n        self.play(\n            FadeOut(variety), FadeOut(variety_label),\n            FadeOut(manifold), FadeOut(manifold_label),\n            FadeOut(diff_label), FadeOut(arrow1), FadeOut(arrow2)\n        )\n        \n        # Element 4: Show key equation from de Rham cohomology\n        equation = MathTex(r\"\\int_M \\omega = \\int_{\\partial M} \\eta\")\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation up to make room for final element\n        self.play(equation.animate.to_edge(UP))\n        \n        # Element 5: Visualize the connection between algebraic and topological structures\n        alg_box = Square(side_length=2, color=BLUE).shift(LEFT*3)\n        top_box = Square(side_length=2, color=GREEN).shift(RIGHT*3)\n        \n        alg_text = Text(\"Algebraic\", font_size=24).move_to(alg_box)\n        top_text = Text(\"Topological\", font_size=24).move_to(top_box)\n        \n        connection = Arrow(alg_box.get_right(), top_box.get_left(), color=GOLD)\n        connect_text = Text(\"De Rham Cohomology\", font_size=20).next_to(connection, UP)\n        \n        self.play(Create(alg_box), Create(top_box))\n        self.play(Write(alg_text), Write(top_text))\n        self.play(Create(connection))\n        self.play(Write(connect_text))\n        self.wait(1)\n        \n        # Clear screen for conclusion\n        self.play(\n            FadeOut(alg_box), FadeOut(top_box),\n            FadeOut(alg_text), FadeOut(top_text),\n            FadeOut(connection), FadeOut(connect_text),\n            FadeOut(equation)\n        )\n        \n        # Conclusion statement\n        conclusion = Text(\"De Rham cohomology connects\\nalgebraic varieties and smooth manifolds\", \n                         font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way does de Rham cohomology illustrate the relationship between algebraic varieties and smooth manifolds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a mathematical formula centered on screen:  \n$$\\int_a^b f'(x)\\, dx = f(b) - f(a)$$  \nThis represents the Fundamental Theorem of Calculus, showing the relationship between a function\u2019s derivative and its definite integral."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Formula(Scene):\n    def construct(self):\n        t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n        self.add(t)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a mathematical formula centered on screen:  \n$$\\int_a^b f'(x)\\, dx = f(b) - f(a)$$  \nThis represents the Fundamental Theorem of Calculus, showing the relationship between a function\u2019s derivative and its definite integral."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a mathematical formula centered on screen:  \n$$\\int_a^b f'(x)\\, dx = f(b) - f(a)$$  \nthis represents the fundamental theorem of calculus, showing the relationship between a function\u2019s derivative and its definite integral."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Formula(Scene):\n    def construct(self):\n        t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n        self.add(t)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a mathematical formula centered on screen:  \n$$\\int_a^b f'(x)\\, dx = f(b) - f(a)$$  \nThis represents the Fundamental Theorem of Calculus, showing the relationship between a function\u2019s derivative and its definite integral."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation using simple geometric shapes that starts with a text message moving upwards, then a circle appearing on the screen, which transforms into a red square that moves downwards and to the right, then the square shifts right, rotates slightly, and finally reverts back to a circle in its original position? Also, can you make sure that there's a brief pause after the circle appears and again after it rotates, with the entire sequence of events happening quickly?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport pkg_resources\n\nversion_num = \"0.1.1\"\n\n\nclass Ball(LabeledDot):\n    CONFIG = {\"radius\": 0.4, \"fill_opacity\": 1, \"color\": BLUE}\n\n    def __init__(self, lable=r\"\\alpha\", **kwargs):\n        LabeledDot.__init__(self, lable, **kwargs)\n        self.velocity = np.array((2, 1.5, 0))\n\n    def get_top(self):\n        return self.get_center()[1] + self.radius\n\n    def get_bottom(self):\n        return self.get_center()[1] - self.radius\n\n    def get_right_edge(self):\n        return self.get_center()[0] + self.radius\n\n    def get_left_edge(self):\n        return self.get_center()[0] - self.radius\n\n\nclass Box(Rectangle):\n    def __init__(self, **kwargs):\n        Rectangle.__init__(self, height=6, width=8, color=GREEN_C, **kwargs)  # Edges\n        self.top = 0.5 * self.height\n        self.bottom = -0.5 * self.height\n        self.right_edge = 0.5 * self.width\n        self.left_edge = -0.5 * self.width\n\n\nclass TwitterScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        version = Tex(f\"v{version_num}\").to_corner(UR).set_color(BLACK)\n        self.add(version)\n\n        box = Box()\n        ball = Ball(lable=Text(\"v0.1.1\").scale(0.3))\n        self.add(box)\n        self.play(Write(ball))\n\n        def update_ball(ball, dt):\n            ball.acceleration = np.array((0, -5, 0))\n            ball.velocity = ball.velocity + ball.acceleration * dt\n            ball.shift(ball.velocity * dt)  # Bounce off ground and roof\n            if ball.get_bottom() <= box.bottom or ball.get_top() >= box.top:\n                ball.velocity[1] = -ball.velocity[1]\n            # Bounce off walls\n            if (\n                ball.get_left_edge() <= box.left_edge\n                or ball.get_right_edge() >= box.right_edge\n            ):\n                ball.velocity[0] = -ball.velocity[0]\n\n        ball.add_updater(update_ball)\n        self.add(ball)\n\n        ball2 = Ball(lable=r\"\\Psi\")\n        self.play(Write(ball2))\n        ball2.add_updater(update_ball)\n\n        ball3 = Ball(lable=r\"\\alpha\")\n        self.play(Write(ball3))\n        ball3.add_updater(update_ball)\n\n        ball4 = Ball(lable=r\"\\lambda\")\n        self.play(Write(ball4))\n        ball4.add_updater(update_ball)\n\n        self.wait(3)\n        cu1 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu1)\n        cu1_small = cu1.copy().scale(0.3).to_edge(RIGHT).shift(2 * UP)\n        self.play(Transform(cu1, cu1_small))\n\n        cu2 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu2)\n        cu2_small = cu2.copy().scale(0.3).to_edge(RIGHT)\n        self.play(Transform(cu2, cu2_small))\n\n        self.wait()\n        #\n        banner = ManimBanner(dark_theme=False).scale(0.3).to_corner(DR)\n        self.play(*[FadeOut(x) for x in self.mobjects], FadeIn(banner), run_time=2.5)\n        self.play(banner.expand())\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation using simple geometric shapes that starts with a text message moving upwards, then a circle appearing on the screen, which transforms into a red square that moves downwards and to the right, then the square shifts right, rotates slightly, and finally reverts back to a circle in its original position? Also, can you make sure that there's a brief pause after the circle appears and again after it rotates, with the entire sequence of events happening quickly?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation using simple geometric shapes that starts with a text message moving upwards, then a circle appearing on the screen, which transforms into a red square that moves downwards and to the right, then the square shifts right, rotates slightly, and finally reverts back to a circle in its original position? also, can you make sure that there's a brief pause after the circle appears and again after it rotates, with the entire sequence of events happening quickly?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport pkg_resources\n\nversion_num = \"0.1.1\"\n\n\nclass Ball(LabeledDot):\n    CONFIG = {\"radius\": 0.4, \"fill_opacity\": 1, \"color\": BLUE}\n\n    def __init__(self, lable=r\"\\alpha\", **kwargs):\n        LabeledDot.__init__(self, lable, **kwargs)\n        self.velocity = np.array((2, 1.5, 0))\n\n    def get_top(self):\n        return self.get_center()[1] + self.radius\n\n    def get_bottom(self):\n        return self.get_center()[1] - self.radius\n\n    def get_right_edge(self):\n        return self.get_center()[0] + self.radius\n\n    def get_left_edge(self):\n        return self.get_center()[0] - self.radius\n\n\nclass Box(Rectangle):\n    def __init__(self, **kwargs):\n        Rectangle.__init__(self, height=6, width=8, color=GREEN_C, **kwargs)  # Edges\n        self.top = 0.5 * self.height\n        self.bottom = -0.5 * self.height\n        self.right_edge = 0.5 * self.width\n        self.left_edge = -0.5 * self.width\n\n\nclass TwitterScene(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        version = Tex(f\"v{version_num}\").to_corner(UR).set_color(BLACK)\n        self.add(version)\n\n        box = Box()\n        ball = Ball(lable=Text(\"v0.1.1\").scale(0.3))\n        self.add(box)\n        self.play(Write(ball))\n\n        def update_ball(ball, dt):\n            ball.acceleration = np.array((0, -5, 0))\n            ball.velocity = ball.velocity + ball.acceleration * dt\n            ball.shift(ball.velocity * dt)  # Bounce off ground and roof\n            if ball.get_bottom() <= box.bottom or ball.get_top() >= box.top:\n                ball.velocity[1] = -ball.velocity[1]\n            # Bounce off walls\n            if (\n                ball.get_left_edge() <= box.left_edge\n                or ball.get_right_edge() >= box.right_edge\n            ):\n                ball.velocity[0] = -ball.velocity[0]\n\n        ball.add_updater(update_ball)\n        self.add(ball)\n\n        ball2 = Ball(lable=r\"\\Psi\")\n        self.play(Write(ball2))\n        ball2.add_updater(update_ball)\n\n        ball3 = Ball(lable=r\"\\alpha\")\n        self.play(Write(ball3))\n        ball3.add_updater(update_ball)\n\n        ball4 = Ball(lable=r\"\\lambda\")\n        self.play(Write(ball4))\n        ball4.add_updater(update_ball)\n\n        self.wait(3)\n        cu1 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu1)\n        cu1_small = cu1.copy().scale(0.3).to_edge(RIGHT).shift(2 * UP)\n        self.play(Transform(cu1, cu1_small))\n\n        cu2 = Cutout(\n            box,\n            ball,\n            ball2,\n            ball3,\n            ball4,\n            fill_opacity=0.2,\n            color=GREY,\n            stroke_color=RED,\n        )\n        self.add(cu2)\n        cu2_small = cu2.copy().scale(0.3).to_edge(RIGHT)\n        self.play(Transform(cu2, cu2_small))\n\n        self.wait()\n        #\n        banner = ManimBanner(dark_theme=False).scale(0.3).to_corner(DR)\n        self.play(*[FadeOut(x) for x in self.mobjects], FadeIn(banner), run_time=2.5)\n        self.play(banner.expand())\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation using simple geometric shapes that starts with a text message moving upwards, then a circle appearing on the screen, which transforms into a red square that moves downwards and to the right, then the square shifts right, rotates slightly, and finally reverts back to a circle in its original position? Also, can you make sure that there's a brief pause after the circle appears and again after it rotates, with the entire sequence of events happening quickly?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you please create an educational animation for me that shows the area under the curve y = x^2, from x=0 to x=2, using a blue and green gradient to fill the area? Also, include a set of axes with blue lines, label the curve and the area, and have the elements fade out at the end. I'd like a step-by-step animation where the axes and the curve are drawn first, followed by the labels, then the area filled in, and finally everything fades out."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass HamiltonianCycle(Scene):\n    def construct(self):\n        dots = [Dot(z_index=30) for _ in range(20)]\n        for ind, dot in enumerate(dots[:5]):\n            dot.move_to(\n                3.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[5:10]):\n            dot.move_to(\n                2.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[10:15]):\n            dot.move_to(\n                1.5\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[15:]):\n            dot.move_to(\n                0.75\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        lines = (\n            [\n                Line(dots[k].get_center(), dots[(k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n            + [Line(dots[k].get_center(), dots[5 + k].get_center()) for k in range(5)]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 2) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 3) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[10 + k].get_center(), dots[15 + k].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[15 + k].get_center(), dots[15 + (k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n        )\n        vgroup = VGroup(*lines, *dots)\n        vgroup.move_to(ORIGIN)\n        self.play(*[ShowCreation(dot) for dot in dots])\n        self.play(*[ShowCreation(line) for line in lines])\n        self.wait(1)\n        cycle_ind = [\n            0,\n            1,\n            2,\n            7,\n            14,\n            6,\n            13,\n            5,\n            12,\n            9,\n            11,\n            16,\n            17,\n            18,\n            19,\n            15,\n            10,\n            8,\n            3,\n            4,\n        ]\n        cycle_lines = []\n        for k in range(len(cycle_ind)):\n            self.play(\n                dots[cycle_ind[k]].set_color, RED, run_time=0.3, rate_function=linear\n            )\n            new_line = Line(\n                dots[cycle_ind[k]].get_center(),\n                dots[cycle_ind[(k + 1) % len(cycle_ind)]].get_center(),\n                color=RED,\n                stroke_width=5,\n            )\n            cycle_lines.append(new_line)\n            self.play(ShowCreation(new_line), run_time=0.65)\n        self.wait(1)\n        self.play(VGroup(vgroup, *cycle_lines).shift, 3 * LEFT)\n        t1 = Tex(\"The graph\")\n        t1.next_to(vgroup, RIGHT)\n        self.play(Write(t1))\n        self.play(\n            ApplyFunction(\n                lambda obj: obj.scale(0.2).next_to(t1, RIGHT).shift(0.4 * UP),\n                VGroup(*lines, *dots).copy(),\n            )\n        )\n        t2 = Tex(\"has a Hamiltonian cycle.\")\n        t2.next_to(t1, DOWN)\n        t2.align_to(t1, LEFT)\n        self.play(Write(t2))\n        self.wait(1)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you please create an educational animation for me that shows the area under the curve y = x^2, from x=0 to x=2, using a blue and green gradient to fill the area? Also, include a set of axes with blue lines, label the curve and the area, and have the elements fade out at the end. I'd like a step-by-step animation where the axes and the curve are drawn first, followed by the labels, then the area filled in, and finally everything fades out."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you please create an educational animation for me that shows the area under the curve y = x^2, from x=0 to x=2, using a blue and green gradient to fill the area? also, include a set of axes with blue lines, label the curve and the area, and have the elements fade out at the end. i'd like a step-by-step animation where the axes and the curve are drawn first, followed by the labels, then the area filled in, and finally everything fades out."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass HamiltonianCycle(Scene):\n    def construct(self):\n        dots = [Dot(z_index=30) for _ in range(20)]\n        for ind, dot in enumerate(dots[:5]):\n            dot.move_to(\n                3.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[5:10]):\n            dot.move_to(\n                2.75\n                * (\n                    np.cos(ind / 5 * TAU + TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU + TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[10:15]):\n            dot.move_to(\n                1.5\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        for ind, dot in enumerate(dots[15:]):\n            dot.move_to(\n                0.75\n                * (\n                    np.cos(ind / 5 * TAU - TAU / 4) * RIGHT\n                    + np.sin(ind / 5 * TAU - TAU / 4) * UP\n                )\n            )\n        lines = (\n            [\n                Line(dots[k].get_center(), dots[(k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n            + [Line(dots[k].get_center(), dots[5 + k].get_center()) for k in range(5)]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 2) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[5 + k].get_center(), dots[10 + (k + 3) % 5].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[10 + k].get_center(), dots[15 + k].get_center())\n                for k in range(5)\n            ]\n            + [\n                Line(dots[15 + k].get_center(), dots[15 + (k + 1) % 5].get_center())\n                for k in range(5)\n            ]\n        )\n        vgroup = VGroup(*lines, *dots)\n        vgroup.move_to(ORIGIN)\n        self.play(*[ShowCreation(dot) for dot in dots])\n        self.play(*[ShowCreation(line) for line in lines])\n        self.wait(1)\n        cycle_ind = [\n            0,\n            1,\n            2,\n            7,\n            14,\n            6,\n            13,\n            5,\n            12,\n            9,\n            11,\n            16,\n            17,\n            18,\n            19,\n            15,\n            10,\n            8,\n            3,\n            4,\n        ]\n        cycle_lines = []\n        for k in range(len(cycle_ind)):\n            self.play(\n                dots[cycle_ind[k]].set_color, RED, run_time=0.3, rate_function=linear\n            )\n            new_line = Line(\n                dots[cycle_ind[k]].get_center(),\n                dots[cycle_ind[(k + 1) % len(cycle_ind)]].get_center(),\n                color=RED,\n                stroke_width=5,\n            )\n            cycle_lines.append(new_line)\n            self.play(ShowCreation(new_line), run_time=0.65)\n        self.wait(1)\n        self.play(VGroup(vgroup, *cycle_lines).shift, 3 * LEFT)\n        t1 = Tex(\"The graph\")\n        t1.next_to(vgroup, RIGHT)\n        self.play(Write(t1))\n        self.play(\n            ApplyFunction(\n                lambda obj: obj.scale(0.2).next_to(t1, RIGHT).shift(0.4 * UP),\n                VGroup(*lines, *dots).copy(),\n            )\n        )\n        t2 = Tex(\"has a Hamiltonian cycle.\")\n        t2.next_to(t1, DOWN)\n        t2.align_to(t1, LEFT)\n        self.play(Write(t2))\n        self.wait(1)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you please create an educational animation for me that shows the area under the curve y = x^2, from x=0 to x=2, using a blue and green gradient to fill the area? Also, include a set of axes with blue lines, label the curve and the area, and have the elements fade out at the end. I'd like a step-by-step animation where the axes and the curve are drawn first, followed by the labels, then the area filled in, and finally everything fades out."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 2\u00d72 table with row and column labels. The row heading text is colored red-blue gradient, the first column\u2019s text is colored green, others are white, making each section visually distinct."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SetColumnColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(table)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 table with row and column labels. The row heading text is colored red-blue gradient, the first column\u2019s text is colored green, others are white, making each section visually distinct."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 2\u00d72 table with row and column labels. the row heading text is colored red-blue gradient, the first column\u2019s text is colored green, others are white, making each section visually distinct."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SetColumnColorsExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")]\n        ).set_column_colors([RED,BLUE], GREEN)\n        self.add(table)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 table with row and column labels. The row heading text is colored red-blue gradient, the first column\u2019s text is colored green, others are white, making each section visually distinct."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a graph with six labeled nodes arranged randomly across the screen. The nodes are connected by a mix of sequential and cross-linking edges, forming a dense and irregular network. The layout emphasizes randomness, resulting in a visually scattered but fully connected structure."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with six labeled nodes arranged randomly across the screen. The nodes are connected by a mix of sequential and cross-linking edges, forming a dense and irregular network. The layout emphasizes randomness, resulting in a visually scattered but fully connected structure."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a graph with six labeled nodes arranged randomly across the screen. the nodes are connected by a mix of sequential and cross-linking edges, forming a dense and irregular network. the layout emphasizes randomness, resulting in a visually scattered but fully connected structure."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RandomLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"random\",\n            labels=True\n        )\n        self.add(graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with six labeled nodes arranged randomly across the screen. The nodes are connected by a mix of sequential and cross-linking edges, forming a dense and irregular network. The layout emphasizes randomness, resulting in a visually scattered but fully connected structure."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_camera_move.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass NeuralNetworkScene(ThreeDScene):\n    \"\"\"Test Scene for the Neural Network\"\"\"\n\n    def play_camera_follow_forward_pass(self, neural_network, buffer=0.1):\n        per_layer_animations = neural_network.make_forward_pass_animation(\n            return_per_layer_animations=True\n        )\n        all_layers = neural_network.all_layers\n        # Compute the width and height of the frame\n        max_width = 0\n        max_height = 0\n        for layer_index in range(1, len(all_layers) - 1):\n            prev_layer = all_layers[layer_index - 1]\n            current_layer = all_layers[layer_index]\n            next_layer = all_layers[layer_index + 1]\n            group = Group(prev_layer, current_layer, next_layer)\n\n            max_width = max(max_width, group.width)\n            max_height = max(max_height, group.height)\n\n        frame_width = max_width * (1 + buffer)\n        frame_height = max_height * (1 + buffer)\n        # Go through each animation\n        for layer_index in range(1, len(all_layers)):\n            layer_animation = per_layer_animations[layer_index]\n\n    def construct(self):\n        # Make the Layer object\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        nn.move_to(ORIGIN)\n        # Make Animation\n        self.add(nn)\n        # self.play(Create(nn))\n        self.play_camera_follow_forward_pass(nn)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_camera_move.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_camera_move.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nfrom PIL import Image\nimport numpy as np\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass NeuralNetworkScene(ThreeDScene):\n    \"\"\"Test Scene for the Neural Network\"\"\"\n\n    def play_camera_follow_forward_pass(self, neural_network, buffer=0.1):\n        per_layer_animations = neural_network.make_forward_pass_animation(\n            return_per_layer_animations=True\n        )\n        all_layers = neural_network.all_layers\n        # Compute the width and height of the frame\n        max_width = 0\n        max_height = 0\n        for layer_index in range(1, len(all_layers) - 1):\n            prev_layer = all_layers[layer_index - 1]\n            current_layer = all_layers[layer_index]\n            next_layer = all_layers[layer_index + 1]\n            group = Group(prev_layer, current_layer, next_layer)\n\n            max_width = max(max_width, group.width)\n            max_height = max(max_height, group.height)\n\n        frame_width = max_width * (1 + buffer)\n        frame_height = max_height * (1 + buffer)\n        # Go through each animation\n        for layer_index in range(1, len(all_layers)):\n            layer_animation = per_layer_animations[layer_index]\n\n    def construct(self):\n        # Make the Layer object\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        nn.move_to(ORIGIN)\n        # Make Animation\n        self.add(nn)\n        # self.play(Create(nn))\n        self.play_camera_follow_forward_pass(nn)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_camera_move.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What are the visual similarities and differences between stationary distributions in finite and infinite Markov Chains?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MarkovChainsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Understanding Markov Chains: Finite vs. Infinite\", font_size=30)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"Markov Chains depend only on the present state\", font_size=24)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Finite Markov Chain (Left Side)\n        finite_title = Text(\"Finite Markov Chain\", font_size=24).to_edge(UP).shift(LEFT*3)\n        self.play(Write(finite_title))\n        \n        # Create states as circles with labels\n        states = VGroup(\n            Circle(radius=0.5, color=BLUE, fill_opacity=0.5).shift(LEFT*3 + UP),\n            Circle(radius=0.5, color=BLUE, fill_opacity=0.5).shift(LEFT*3),\n            Circle(radius=0.5, color=BLUE, fill_opacity=0.5).shift(LEFT*3 + DOWN),\n        )\n        \n        # Add labels to states\n        state_labels = VGroup(\n            Text(\"A\").move_to(states[0]),\n            Text(\"B\").move_to(states[1]),\n            Text(\"C\").move_to(states[2]),\n        )\n        \n        # Arrows connecting states (representing transitions)\n        arrows = VGroup(\n            Arrow(states[0].get_bottom(), states[1].get_top(), color=WHITE),\n            Arrow(states[1].get_bottom(), states[2].get_top(), color=WHITE),\n            Arrow(states[2].get_right(), states[0].get_right() + DOWN*2, color=WHITE, path_arc=-2),\n        )\n        \n        # Display finite chain elements\n        self.play(Create(states), Write(state_labels))\n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Stationary Distribution equation for finite case\n        finite_eq = Text(\"\u03c0 = \u03c0P\", font_size=24).next_to(states, DOWN, buff=0.8)\n        self.play(Write(finite_eq))\n        self.wait(1)\n        \n        # Infinite Markov Chain (Right Side)\n        infinite_title = Text(\"Infinite Markov Chain\", font_size=24).to_edge(UP).shift(RIGHT*3)\n        self.play(Write(infinite_title))\n        \n        # Create a line to represent continuous state space\n        line = Line(RIGHT*2, RIGHT*4, color=WHITE)\n        \n        # Create a simple curve to represent probability density function\n        curve = Arc(radius=1, start_angle=PI, angle=PI, color=PURPLE)\n        curve.shift(RIGHT*3 + UP*0.5)\n        \n        # Display infinite chain elements\n        self.play(Create(line))\n        self.play(Create(curve))\n        self.wait(1)\n        \n        # Equation for infinite case - integral formula\n        infinite_eq = Text(\"\u222b f(x)dx = 1\", font_size=24).next_to(line, DOWN, buff=0.8)\n        self.play(Write(infinite_eq))\n        self.wait(1)\n        \n        # Show comparison between finite and infinite chains\n        comparison = Text(\"Both share mathematical stability\", font_size=24).to_edge(DOWN)\n        self.play(Write(comparison))\n        self.wait(2)\n        \n        # Collect all objects to fade them out\n        all_objects = VGroup(\n            finite_title, states, state_labels, arrows, finite_eq,\n            infinite_title, line, curve, infinite_eq, comparison\n        )\n        \n        # Fade everything out for conclusion\n        self.play(FadeOut(all_objects))\n        \n        # Final message\n        conclusion = Text(\"Markov Chains: Finite vs. Infinite\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the visual similarities and differences between stationary distributions in finite and infinite Markov Chains?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what are the visual similarities and differences between stationary distributions in finite and infinite markov chains?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MarkovChainsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Understanding Markov Chains: Finite vs. Infinite\", font_size=30)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"Markov Chains depend only on the present state\", font_size=24)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Finite Markov Chain (Left Side)\n        finite_title = Text(\"Finite Markov Chain\", font_size=24).to_edge(UP).shift(LEFT*3)\n        self.play(Write(finite_title))\n        \n        # Create states as circles with labels\n        states = VGroup(\n            Circle(radius=0.5, color=BLUE, fill_opacity=0.5).shift(LEFT*3 + UP),\n            Circle(radius=0.5, color=BLUE, fill_opacity=0.5).shift(LEFT*3),\n            Circle(radius=0.5, color=BLUE, fill_opacity=0.5).shift(LEFT*3 + DOWN),\n        )\n        \n        # Add labels to states\n        state_labels = VGroup(\n            Text(\"A\").move_to(states[0]),\n            Text(\"B\").move_to(states[1]),\n            Text(\"C\").move_to(states[2]),\n        )\n        \n        # Arrows connecting states (representing transitions)\n        arrows = VGroup(\n            Arrow(states[0].get_bottom(), states[1].get_top(), color=WHITE),\n            Arrow(states[1].get_bottom(), states[2].get_top(), color=WHITE),\n            Arrow(states[2].get_right(), states[0].get_right() + DOWN*2, color=WHITE, path_arc=-2),\n        )\n        \n        # Display finite chain elements\n        self.play(Create(states), Write(state_labels))\n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Stationary Distribution equation for finite case\n        finite_eq = Text(\"\u03c0 = \u03c0P\", font_size=24).next_to(states, DOWN, buff=0.8)\n        self.play(Write(finite_eq))\n        self.wait(1)\n        \n        # Infinite Markov Chain (Right Side)\n        infinite_title = Text(\"Infinite Markov Chain\", font_size=24).to_edge(UP).shift(RIGHT*3)\n        self.play(Write(infinite_title))\n        \n        # Create a line to represent continuous state space\n        line = Line(RIGHT*2, RIGHT*4, color=WHITE)\n        \n        # Create a simple curve to represent probability density function\n        curve = Arc(radius=1, start_angle=PI, angle=PI, color=PURPLE)\n        curve.shift(RIGHT*3 + UP*0.5)\n        \n        # Display infinite chain elements\n        self.play(Create(line))\n        self.play(Create(curve))\n        self.wait(1)\n        \n        # Equation for infinite case - integral formula\n        infinite_eq = Text(\"\u222b f(x)dx = 1\", font_size=24).next_to(line, DOWN, buff=0.8)\n        self.play(Write(infinite_eq))\n        self.wait(1)\n        \n        # Show comparison between finite and infinite chains\n        comparison = Text(\"Both share mathematical stability\", font_size=24).to_edge(DOWN)\n        self.play(Write(comparison))\n        self.wait(2)\n        \n        # Collect all objects to fade them out\n        all_objects = VGroup(\n            finite_title, states, state_labels, arrows, finite_eq,\n            infinite_title, line, curve, infinite_eq, comparison\n        )\n        \n        # Fade everything out for conclusion\n        self.play(FadeOut(all_objects))\n        \n        # Final message\n        conclusion = Text(\"Markov Chains: Finite vs. Infinite\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the visual similarities and differences between stationary distributions in finite and infinite Markov Chains?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_residual_connection.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, ImageLayer\n\nfrom PIL import Image\nimport numpy as np\n\n__module_test__ = \"residual\"\n\n\n@frames_comparison\ndef test_ResidualConnectionScene(scene):\n    \"\"\"Tests the appearance of a residual connection\"\"\"\n    nn = NeuralNetwork(\n        {\n            \"layer1\": FeedForwardLayer(3),\n            \"layer2\": FeedForwardLayer(5),\n            \"layer3\": FeedForwardLayer(3),\n        }\n    )\n\n    scene.add(nn)\n\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass FeedForwardScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork(\n            {\n                \"layer1\": FeedForwardLayer(4),\n                \"layer2\": FeedForwardLayer(4),\n                \"layer3\": FeedForwardLayer(4),\n            },\n            layer_spacing=0.45,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_residual_connection.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_residual_connection.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, ImageLayer\n\nfrom PIL import Image\nimport numpy as np\n\n__module_test__ = \"residual\"\n\n\n@frames_comparison\ndef test_ResidualConnectionScene(scene):\n    \"\"\"Tests the appearance of a residual connection\"\"\"\n    nn = NeuralNetwork(\n        {\n            \"layer1\": FeedForwardLayer(3),\n            \"layer2\": FeedForwardLayer(5),\n            \"layer3\": FeedForwardLayer(3),\n        }\n    )\n\n    scene.add(nn)\n\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass FeedForwardScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork(\n            {\n                \"layer1\": FeedForwardLayer(4),\n                \"layer2\": FeedForwardLayer(4),\n                \"layer3\": FeedForwardLayer(4),\n            },\n            layer_spacing=0.45,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_residual_connection.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a graph with six labeled nodes arranged using the spring layout, which simulates physical forces to position nodes in a way that minimizes edge crossings and evenly distributes them. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and organically spaced network that balances visual clarity and connectivity."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with six labeled nodes arranged using the spring layout, which simulates physical forces to position nodes in a way that minimizes edge crossings and evenly distributes them. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and organically spaced network that balances visual clarity and connectivity."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a graph with six labeled nodes arranged using the spring layout, which simulates physical forces to position nodes in a way that minimizes edge crossings and evenly distributes them. the nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and organically spaced network that balances visual clarity and connectivity."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpringLayout(Scene):\n    def construct(self):\n        graph = Graph(\n            [1, 2, 3, 4, 5, 6],\n            [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n            layout=\"spring\",\n            labels=True\n        )\n        self.add(graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with six labeled nodes arranged using the spring layout, which simulates physical forces to position nodes in a way that minimizes edge crossings and evenly distributes them. The nodes are connected in a loop with additional cross-links between non-adjacent nodes, forming a dense and organically spaced network that balances visual clarity and connectivity."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_mcmc.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.diffusion.mcmc import (\n    MCMCAxes,\n    MultidimensionalGaussianPosterior,\n    metropolis_hastings_sampler,\n)\nfrom manim_ml.utils.mobjects.plotting import convert_matplotlib_figure_to_image_mobject\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib\nplt.style.use('dark_background')\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1200\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\ndef test_metropolis_hastings_sampler(iterations=100):\n    samples, _, candidates = metropolis_hastings_sampler(iterations=iterations)\n    assert samples.shape == (iterations, 2)\n\ndef plot_hexbin_gaussian_on_image_mobject(\n    sample_func, \n    xlim=(-4, 4),\n    ylim=(-4, 4)\n):\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n    n = 100_000\n    samples = []\n    for i in range(n):\n        samples.append(sample_func())\n    samples = np.array(samples)\n\n    x = samples[:, 0]\n    y = samples[:, 1]\n    \n    fig, ax0 = plt.subplots(1, figsize=(5, 5))\n\n    hb = ax0.hexbin(x, y, gridsize=50, cmap='gist_heat')\n\n    ax0.set(xlim=xlim, ylim=ylim)\n\n    return convert_matplotlib_figure_to_image_mobject(fig)\n\nclass MCMCTest(Scene):\n\n    def construct(\n        self, \n        mu=np.array([0.0, 0.0]), \n        var=np.array([[1.0, 1.0]])\n    ):\n\n        def gaussian_sample_func():\n            vals = np.random.multivariate_normal(\n                mu, \n                np.eye(2) * var, \n                1\n            )[0]\n\n            return vals\n\n        image_mobject = plot_hexbin_gaussian_on_image_mobject(\n            gaussian_sample_func\n        )\n        self.add(image_mobject)\n        self.play(FadeOut(image_mobject))\n\n        axes = MCMCAxes(\n            x_range=[-4, 4],\n            y_range=[-4, 4],\n        )\n        self.play(\n            Create(axes)\n        )\n\n        gaussian_posterior = MultidimensionalGaussianPosterior(\n            mu=np.array([0.0, 0.0]), \n            var=np.array([1.0, 1.0])\n        )\n\n        chain_sampling_animation, lines = axes.visualize_metropolis_hastings_chain_sampling(\n            log_prob_fn=gaussian_posterior, \n            sampling_kwargs={\"iterations\": 500},\n        )\n\n        self.play(\n            chain_sampling_animation,\n            run_time=3.5\n        )\n        self.play(\n            FadeOut(lines)\n        )\n        self.wait(1)\n        self.play(\n            FadeIn(image_mobject)\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_mcmc.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_mcmc.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.diffusion.mcmc import (\n    MCMCAxes,\n    MultidimensionalGaussianPosterior,\n    metropolis_hastings_sampler,\n)\nfrom manim_ml.utils.mobjects.plotting import convert_matplotlib_figure_to_image_mobject\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib\nplt.style.use('dark_background')\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1200\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\ndef test_metropolis_hastings_sampler(iterations=100):\n    samples, _, candidates = metropolis_hastings_sampler(iterations=iterations)\n    assert samples.shape == (iterations, 2)\n\ndef plot_hexbin_gaussian_on_image_mobject(\n    sample_func, \n    xlim=(-4, 4),\n    ylim=(-4, 4)\n):\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n    n = 100_000\n    samples = []\n    for i in range(n):\n        samples.append(sample_func())\n    samples = np.array(samples)\n\n    x = samples[:, 0]\n    y = samples[:, 1]\n    \n    fig, ax0 = plt.subplots(1, figsize=(5, 5))\n\n    hb = ax0.hexbin(x, y, gridsize=50, cmap='gist_heat')\n\n    ax0.set(xlim=xlim, ylim=ylim)\n\n    return convert_matplotlib_figure_to_image_mobject(fig)\n\nclass MCMCTest(Scene):\n\n    def construct(\n        self, \n        mu=np.array([0.0, 0.0]), \n        var=np.array([[1.0, 1.0]])\n    ):\n\n        def gaussian_sample_func():\n            vals = np.random.multivariate_normal(\n                mu, \n                np.eye(2) * var, \n                1\n            )[0]\n\n            return vals\n\n        image_mobject = plot_hexbin_gaussian_on_image_mobject(\n            gaussian_sample_func\n        )\n        self.add(image_mobject)\n        self.play(FadeOut(image_mobject))\n\n        axes = MCMCAxes(\n            x_range=[-4, 4],\n            y_range=[-4, 4],\n        )\n        self.play(\n            Create(axes)\n        )\n\n        gaussian_posterior = MultidimensionalGaussianPosterior(\n            mu=np.array([0.0, 0.0]), \n            var=np.array([1.0, 1.0])\n        )\n\n        chain_sampling_animation, lines = axes.visualize_metropolis_hastings_chain_sampling(\n            log_prob_fn=gaussian_posterior, \n            sampling_kwargs={\"iterations\": 500},\n        )\n\n        self.play(\n            chain_sampling_animation,\n            run_time=3.5\n        )\n        self.play(\n            FadeOut(lines)\n        )\n        self.wait(1)\n        self.play(\n            FadeIn(image_mobject)\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_mcmc.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the flow of a Hamiltonian vector field preserve the symplectic form on a manifold?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SymplecticGeometry(Scene):\n    def construct(self):\n        # Scene setup and introduction\n        title = Text(\"The Flow of Symplectic Harmony\", font_size=36)\n        subtitle = Text(\"Hamiltonian Vector Fields Unveiled\", font_size=24, color=BLUE)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a simple representation of a symplectic manifold\n        circle = Circle(radius=3, color=BLUE_E)\n        \n        # Create a grid of dots inside the circle\n        manifold = VGroup()\n        for r in np.linspace(0.5, 2.5, 5):\n            for theta in np.linspace(0, 2*PI, 8, endpoint=False):\n                x, y = r * np.cos(theta), r * np.sin(theta)\n                dot = Dot(point=[x, y, 0], color=RED)\n                manifold.add(dot)\n        \n        manifold_text = Text(\"Symplectic Manifold\", font_size=24)\n        manifold_text.to_edge(UP)\n        \n        self.play(Write(manifold_text))\n        self.play(Create(circle), Create(manifold))\n        self.wait(1)\n        \n        # Show the symplectic form as a grid pattern\n        symplectic_grid = VGroup()\n        \n        # Create concentric circles to represent the symplectic form\n        for r in np.linspace(1, 3, 3):\n            circle_arc = Circle(radius=r, color=BLUE_C, stroke_width=1)\n            symplectic_grid.add(circle_arc)\n        \n        # Add radial lines\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            x, y = 3 * np.cos(angle), 3 * np.sin(angle)\n            line = Line(start=[0, 0, 0], end=[x, y, 0], color=BLUE_C, stroke_width=1)\n            symplectic_grid.add(line)\n        \n        symplectic_text = Text(\"Symplectic Form\", font_size=24)\n        symplectic_text.next_to(manifold_text, DOWN)\n        \n        self.play(Write(symplectic_text))\n        self.play(Create(symplectic_grid))\n        self.wait(1)\n        \n        # Show Hamiltonian vector field as arrows\n        arrows = VGroup()\n        for dot in manifold:\n            position = dot.get_center()\n            r = np.sqrt(position[0]**2 + position[1]**2)\n            if r > 0.1:  # Avoid division by zero near the origin\n                direction = [-position[1]/r, position[0]/r, 0]\n                arrow = Arrow(start=position, end=np.array(position) + 0.5 * np.array(direction), color=YELLOW)\n                arrows.add(arrow)\n        \n        hamiltonian_text = Text(\"Hamiltonian Vector Field\", font_size=24)\n        hamiltonian_text.next_to(symplectic_text, DOWN)\n        \n        self.play(Write(hamiltonian_text))\n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Show the Lie derivative equation\n        lie_derivative = Text(\"L_X_H \u03c9 = 0\", font_size=24)\n        lie_derivative.next_to(hamiltonian_text, DOWN, buff=0.5)\n        \n        self.play(Write(lie_derivative))\n        self.wait(1)\n        \n        # Animate flow along the Hamiltonian vector field\n        self.play(Rotate(manifold, angle=PI/4), run_time=2)\n        \n        # Update the arrows after rotation\n        self.play(FadeOut(arrows))\n        new_arrows = VGroup()\n        for dot in manifold:\n            position = dot.get_center()\n            r = np.sqrt(position[0]**2 + position[1]**2)\n            if r > 0.1:\n                direction = [-position[1]/r, position[0]/r, 0]\n                arrow = Arrow(start=position, end=np.array(position) + 0.5 * np.array(direction), color=YELLOW)\n                new_arrows.add(arrow)\n        \n        self.play(Create(new_arrows))\n        \n        # Highlight preservation of symplectic form\n        preserved_text = Text(\"Symplectic Form Preserved\", font_size=24, color=GREEN)\n        preserved_text.next_to(lie_derivative, DOWN, buff=0.5)\n        \n        self.play(Write(preserved_text))\n        self.wait(1)\n        \n        # Show the symplectic form equation\n        symplectic_form = Text(\"\u03c9(dq \u2227 dp)\", font_size=24)\n        symplectic_form.next_to(preserved_text, DOWN, buff=0.5)\n        \n        self.play(Write(symplectic_form))\n        self.wait(1)\n        \n        # Final message\n        conclusion = Text(\"Embracing the eternal rhythm of symplectic harmony\", font_size=24)\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects]\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the flow of a Hamiltonian vector field preserve the symplectic form on a manifold?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the flow of a hamiltonian vector field preserve the symplectic form on a manifold?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SymplecticGeometry(Scene):\n    def construct(self):\n        # Scene setup and introduction\n        title = Text(\"The Flow of Symplectic Harmony\", font_size=36)\n        subtitle = Text(\"Hamiltonian Vector Fields Unveiled\", font_size=24, color=BLUE)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a simple representation of a symplectic manifold\n        circle = Circle(radius=3, color=BLUE_E)\n        \n        # Create a grid of dots inside the circle\n        manifold = VGroup()\n        for r in np.linspace(0.5, 2.5, 5):\n            for theta in np.linspace(0, 2*PI, 8, endpoint=False):\n                x, y = r * np.cos(theta), r * np.sin(theta)\n                dot = Dot(point=[x, y, 0], color=RED)\n                manifold.add(dot)\n        \n        manifold_text = Text(\"Symplectic Manifold\", font_size=24)\n        manifold_text.to_edge(UP)\n        \n        self.play(Write(manifold_text))\n        self.play(Create(circle), Create(manifold))\n        self.wait(1)\n        \n        # Show the symplectic form as a grid pattern\n        symplectic_grid = VGroup()\n        \n        # Create concentric circles to represent the symplectic form\n        for r in np.linspace(1, 3, 3):\n            circle_arc = Circle(radius=r, color=BLUE_C, stroke_width=1)\n            symplectic_grid.add(circle_arc)\n        \n        # Add radial lines\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            x, y = 3 * np.cos(angle), 3 * np.sin(angle)\n            line = Line(start=[0, 0, 0], end=[x, y, 0], color=BLUE_C, stroke_width=1)\n            symplectic_grid.add(line)\n        \n        symplectic_text = Text(\"Symplectic Form\", font_size=24)\n        symplectic_text.next_to(manifold_text, DOWN)\n        \n        self.play(Write(symplectic_text))\n        self.play(Create(symplectic_grid))\n        self.wait(1)\n        \n        # Show Hamiltonian vector field as arrows\n        arrows = VGroup()\n        for dot in manifold:\n            position = dot.get_center()\n            r = np.sqrt(position[0]**2 + position[1]**2)\n            if r > 0.1:  # Avoid division by zero near the origin\n                direction = [-position[1]/r, position[0]/r, 0]\n                arrow = Arrow(start=position, end=np.array(position) + 0.5 * np.array(direction), color=YELLOW)\n                arrows.add(arrow)\n        \n        hamiltonian_text = Text(\"Hamiltonian Vector Field\", font_size=24)\n        hamiltonian_text.next_to(symplectic_text, DOWN)\n        \n        self.play(Write(hamiltonian_text))\n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Show the Lie derivative equation\n        lie_derivative = Text(\"L_X_H \u03c9 = 0\", font_size=24)\n        lie_derivative.next_to(hamiltonian_text, DOWN, buff=0.5)\n        \n        self.play(Write(lie_derivative))\n        self.wait(1)\n        \n        # Animate flow along the Hamiltonian vector field\n        self.play(Rotate(manifold, angle=PI/4), run_time=2)\n        \n        # Update the arrows after rotation\n        self.play(FadeOut(arrows))\n        new_arrows = VGroup()\n        for dot in manifold:\n            position = dot.get_center()\n            r = np.sqrt(position[0]**2 + position[1]**2)\n            if r > 0.1:\n                direction = [-position[1]/r, position[0]/r, 0]\n                arrow = Arrow(start=position, end=np.array(position) + 0.5 * np.array(direction), color=YELLOW)\n                new_arrows.add(arrow)\n        \n        self.play(Create(new_arrows))\n        \n        # Highlight preservation of symplectic form\n        preserved_text = Text(\"Symplectic Form Preserved\", font_size=24, color=GREEN)\n        preserved_text.next_to(lie_derivative, DOWN, buff=0.5)\n        \n        self.play(Write(preserved_text))\n        self.wait(1)\n        \n        # Show the symplectic form equation\n        symplectic_form = Text(\"\u03c9(dq \u2227 dp)\", font_size=24)\n        symplectic_form.next_to(preserved_text, DOWN, buff=0.5)\n        \n        self.play(Write(symplectic_form))\n        self.wait(1)\n        \n        # Final message\n        conclusion = Text(\"Embracing the eternal rhythm of symplectic harmony\", font_size=24)\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects]\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the flow of a Hamiltonian vector field preserve the symplectic form on a manifold?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation that visually explains how to calculate the area under the curve of x squared from x=1 to x=3. The animation should start by displaying the integral formula for the area under the curve. Then it should show a brief introductory text that says \"Calculating the area under the curve\" followed by the animated steps of the integration process. After that, another text should replace the first one stating \"Substitute the upper and lower bounds\" to indicate the evaluation of the integral from the lower to the upper limit. Finally, show the details of the calculation and the final answer, and end with a clear screen that only displays the final numerical result. Can you create such an educational animation without assuming I have any background in programming?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleSinCosScene(Scene):\n    def construct(self):\n        # Problem statement\n        problem = MathTex(r\"\\int \\sin^2(x) - \\cos^2(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show a trigonometric identity\n        identity = Text(\"Apply trig identity\", font_size=24).to_edge(UP)\n        self.play(Write(identity))\n        self.wait(2)\n\n        # Transformation using trig identity\n        identity_step = MathTex(r\"\\int \\cos(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_step))\n        self.wait(1)\n\n        # Explanation for the integral solution\n        explanation = Text(\"Solve the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(identity, explanation))\n        self.wait(2)\n\n        # Solution to the integral\n        solution = MathTex(r\"= \\frac{1}{2}\\sin(2x) + C\")\n        self.play(ReplacementTransform(identity_step, solution))\n        self.wait(1)\n\n        # Clearing everything off the screen\n        self.play(FadeOut(identity), FadeOut(solution))\n        self.wait(1)\n\n        # Displaying the final answer\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that visually explains how to calculate the area under the curve of x squared from x=1 to x=3. The animation should start by displaying the integral formula for the area under the curve. Then it should show a brief introductory text that says \"Calculating the area under the curve\" followed by the animated steps of the integration process. After that, another text should replace the first one stating \"Substitute the upper and lower bounds\" to indicate the evaluation of the integral from the lower to the upper limit. Finally, show the details of the calculation and the final answer, and end with a clear screen that only displays the final numerical result. Can you create such an educational animation without assuming I have any background in programming?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation that visually explains how to calculate the area under the curve of x squared from x=1 to x=3. the animation should start by displaying the integral formula for the area under the curve. then it should show a brief introductory text that says \"calculating the area under the curve\" followed by the animated steps of the integration process. after that, another text should replace the first one stating \"substitute the upper and lower bounds\" to indicate the evaluation of the integral from the lower to the upper limit. finally, show the details of the calculation and the final answer, and end with a clear screen that only displays the final numerical result. can you create such an educational animation without assuming i have any background in programming?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleSinCosScene(Scene):\n    def construct(self):\n        # Problem statement\n        problem = MathTex(r\"\\int \\sin^2(x) - \\cos^2(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Show a trigonometric identity\n        identity = Text(\"Apply trig identity\", font_size=24).to_edge(UP)\n        self.play(Write(identity))\n        self.wait(2)\n\n        # Transformation using trig identity\n        identity_step = MathTex(r\"\\int \\cos(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_step))\n        self.wait(1)\n\n        # Explanation for the integral solution\n        explanation = Text(\"Solve the integral\", font_size=24).to_edge(UP)\n        self.play(Transform(identity, explanation))\n        self.wait(2)\n\n        # Solution to the integral\n        solution = MathTex(r\"= \\frac{1}{2}\\sin(2x) + C\")\n        self.play(ReplacementTransform(identity_step, solution))\n        self.wait(1)\n\n        # Clearing everything off the screen\n        self.play(FadeOut(identity), FadeOut(solution))\n        self.wait(1)\n\n        # Displaying the final answer\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that visually explains how to calculate the area under the curve of x squared from x=1 to x=3. The animation should start by displaying the integral formula for the area under the curve. Then it should show a brief introductory text that says \"Calculating the area under the curve\" followed by the animated steps of the integration process. After that, another text should replace the first one stating \"Substitute the upper and lower bounds\" to indicate the evaluation of the integral from the lower to the upper limit. Finally, show the details of the calculation and the final answer, and end with a clear screen that only displays the final numerical result. Can you create such an educational animation without assuming I have any background in programming?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that visualizes Euler's Formula, where it starts by displaying the title \"Euler's Formula\", then moves it to the top of the screen and introduces the formula \"e^(i\u03b8) = cos(\u03b8) + i*sin(\u03b8)\" in the center? Then, can you show a complex plane and illustrate an angle \u03b8 traced by a line from the origin to the edge of a circle, with a dot marking the end of the line, to demonstrate how as \u03b8 varies, the expression traces out the unit circle in the complex plane? After completing one full rotation, can you then briefly clear the screen and conclude by re-displaying only Euler's Formula at the end? The narration and explanation for each step of the animation would be added later, just provide the visual elements and the sequence of events."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Restore\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            square = Square(fill_opacity=1).set_fill(RED).shift(DOWN+RIGHT)\n            self.play(Create(circle), run_time=0.5)\n            circle.save_state()\n            self.wait(0.5)\n            self.play(Transform(circle,square), run_time=0.3)\n            self.play(circle.animate.shift(RIGHT), run_time=0.3)\n            self.play(circle.animate.rotate(0.5), run_time=0.4)\n            self.wait(0.5)\n            self.play(Restore(circle))\n            self.wait(0.2)\n            self.remove(circle,square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visualizes Euler's Formula, where it starts by displaying the title \"Euler's Formula\", then moves it to the top of the screen and introduces the formula \"e^(i\u03b8) = cos(\u03b8) + i*sin(\u03b8)\" in the center? Then, can you show a complex plane and illustrate an angle \u03b8 traced by a line from the origin to the edge of a circle, with a dot marking the end of the line, to demonstrate how as \u03b8 varies, the expression traces out the unit circle in the complex plane? After completing one full rotation, can you then briefly clear the screen and conclude by re-displaying only Euler's Formula at the end? The narration and explanation for each step of the animation would be added later, just provide the visual elements and the sequence of events."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that visualizes euler's formula, where it starts by displaying the title \"euler's formula\", then moves it to the top of the screen and introduces the formula \"e^(i\u03b8) = cos(\u03b8) + i*sin(\u03b8)\" in the center? then, can you show a complex plane and illustrate an angle \u03b8 traced by a line from the origin to the edge of a circle, with a dot marking the end of the line, to demonstrate how as \u03b8 varies, the expression traces out the unit circle in the complex plane? after completing one full rotation, can you then briefly clear the screen and conclude by re-displaying only euler's formula at the end? the narration and explanation for each step of the animation would be added later, just provide the visual elements and the sequence of events."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Restore\").shift(UP*2.5)), run_time=0.5)\n            circle = Circle()\n            square = Square(fill_opacity=1).set_fill(RED).shift(DOWN+RIGHT)\n            self.play(Create(circle), run_time=0.5)\n            circle.save_state()\n            self.wait(0.5)\n            self.play(Transform(circle,square), run_time=0.3)\n            self.play(circle.animate.shift(RIGHT), run_time=0.3)\n            self.play(circle.animate.rotate(0.5), run_time=0.4)\n            self.wait(0.5)\n            self.play(Restore(circle))\n            self.wait(0.2)\n            self.remove(circle,square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visualizes Euler's Formula, where it starts by displaying the title \"Euler's Formula\", then moves it to the top of the screen and introduces the formula \"e^(i\u03b8) = cos(\u03b8) + i*sin(\u03b8)\" in the center? Then, can you show a complex plane and illustrate an angle \u03b8 traced by a line from the origin to the edge of a circle, with a dot marking the end of the line, to demonstrate how as \u03b8 varies, the expression traces out the unit circle in the complex plane? After completing one full rotation, can you then briefly clear the screen and conclude by re-displaying only Euler's Formula at the end? The narration and explanation for each step of the animation would be added later, just provide the visual elements and the sequence of events."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the effect of strategic player entry and exit on the equilibrium of a congestion game, and how can this be represented graphically?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CongestionGameScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Navigating Equilibria: The Game of Congestion\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create a simple city map with two roads\n        road1 = Line(LEFT * 4, RIGHT * 4, color=BLUE).shift(DOWN * 1)\n        road2 = Line(LEFT * 4, RIGHT * 4, color=BLUE).shift(UP * 1)\n        roads = VGroup(road1, road2)\n        \n        road_label1 = Text(\"Road 1\", font_size=20).next_to(road1, LEFT)\n        road_label2 = Text(\"Road 2\", font_size=20).next_to(road2, LEFT)\n        \n        self.play(Create(roads))\n        self.play(Write(road_label1), Write(road_label2))\n        self.wait(1)\n        \n        # Add initial players as red dots on road1\n        player1 = Dot(LEFT * 3, color=RED).shift(DOWN * 1)\n        player2 = Dot(LEFT * 2, color=RED).shift(DOWN * 1)\n        \n        self.play(Create(player1))\n        self.play(Create(player2))\n        \n        # Text explaining few players\n        few_players_text = Text(\"With few players, traffic flows freely\", font_size=24)\n        few_players_text.to_edge(UP)\n        self.play(Write(few_players_text))\n        \n        # Move players forward quickly to show free flow\n        self.play(player1.animate.move_to(RIGHT * 3 + DOWN * 1), run_time=1)\n        self.play(player2.animate.move_to(RIGHT * 2 + DOWN * 1), run_time=1)\n        self.wait(1)\n        self.play(FadeOut(few_players_text))\n        \n        # Add more players to show congestion\n        player3 = Dot(LEFT * 3, color=RED).shift(DOWN * 1)\n        player4 = Dot(LEFT * 2.5, color=RED).shift(DOWN * 1)\n        player5 = Dot(LEFT * 2, color=RED).shift(DOWN * 1)\n        \n        self.play(Create(player3))\n        self.play(Create(player4))\n        self.play(Create(player5))\n        \n        # Text explaining congestion\n        congestion_text = Text(\"As more players enter, congestion increases\", font_size=24)\n        congestion_text.to_edge(UP)\n        self.play(Write(congestion_text))\n        \n        # Move players forward slowly to show congestion\n        self.play(player3.animate.move_to(RIGHT * 1 + DOWN * 1), run_time=2)\n        self.play(player4.animate.move_to(RIGHT * 0.5 + DOWN * 1), run_time=2)\n        self.play(player5.animate.move_to(RIGHT * 0 + DOWN * 1), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(congestion_text))\n        \n        # Explain equilibria\n        eq_text = Text(\"Equilibrium: No player can improve by changing route\", font_size=24)\n        eq_text.to_edge(UP)\n        self.play(Write(eq_text))\n        \n        # First equation - simplified\n        eq1 = Text(\"P(t) = delay = n/c * (1 + x(t)/K)\", font_size=30)\n        eq1.next_to(eq_text, DOWN, buff=0.5)\n        self.play(Write(eq1))\n        \n        eq1_explain = Text(\"n = players, c = capacity, x(t) = traffic load\", font_size=20)\n        eq1_explain.next_to(eq1, DOWN, buff=0.5)\n        self.play(Write(eq1_explain))\n        self.wait(2)\n        \n        self.play(FadeOut(eq_text), FadeOut(eq1), FadeOut(eq1_explain))\n        \n        # Strategic behavior - some players take alternative route\n        strategic_text = Text(\"Players adjust routes based on congestion\", font_size=24)\n        strategic_text.to_edge(UP)\n        self.play(Write(strategic_text))\n        \n        # Highlight the alternative route\n        self.play(road2.animate.set_color(GREEN))\n        \n        # Some players switch to the alternative route\n        alt_player1 = Dot(LEFT * 3, color=RED).shift(UP * 1)\n        alt_player2 = Dot(LEFT * 2, color=RED).shift(UP * 1)\n        \n        self.play(Create(alt_player1))\n        self.play(Create(alt_player2))\n        \n        # Move alternative route players faster\n        self.play(alt_player1.animate.move_to(RIGHT * 3 + UP * 1), run_time=1)\n        self.play(alt_player2.animate.move_to(RIGHT * 2 + UP * 1), run_time=1)\n        \n        # Second equation - simplified\n        eq2 = Text(\"x(t+1) = \u03b1x(t) + \u03b2(f(x(t)) - x(t))\", font_size=30)\n        eq2.next_to(strategic_text, DOWN, buff=0.5)\n        self.play(Write(eq2))\n        \n        eq2_explain = Text(\"Players enter/exit based on perceived benefit\", font_size=20)\n        eq2_explain.next_to(eq2, DOWN, buff=0.5)\n        self.play(Write(eq2_explain))\n        self.wait(2)\n        \n        self.play(FadeOut(strategic_text), FadeOut(eq2), FadeOut(eq2_explain))\n        \n        # Conclusion\n        conclusion_text = Text(\"Individual strategies create dynamic congestion patterns\", font_size=28)\n        self.play(Write(conclusion_text))\n        self.wait(1)\n        \n        final_text = Text(\"Appreciate the hidden mathematics of your morning commute!\", font_size=24)\n        final_text.next_to(conclusion_text, DOWN, buff=0.5)\n        self.play(Write(final_text))\n        self.wait(2)\n        \n        self.play(FadeOut(conclusion_text), FadeOut(final_text))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the effect of strategic player entry and exit on the equilibrium of a congestion game, and how can this be represented graphically?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the effect of strategic player entry and exit on the equilibrium of a congestion game, and how can this be represented graphically?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CongestionGameScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Navigating Equilibria: The Game of Congestion\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create a simple city map with two roads\n        road1 = Line(LEFT * 4, RIGHT * 4, color=BLUE).shift(DOWN * 1)\n        road2 = Line(LEFT * 4, RIGHT * 4, color=BLUE).shift(UP * 1)\n        roads = VGroup(road1, road2)\n        \n        road_label1 = Text(\"Road 1\", font_size=20).next_to(road1, LEFT)\n        road_label2 = Text(\"Road 2\", font_size=20).next_to(road2, LEFT)\n        \n        self.play(Create(roads))\n        self.play(Write(road_label1), Write(road_label2))\n        self.wait(1)\n        \n        # Add initial players as red dots on road1\n        player1 = Dot(LEFT * 3, color=RED).shift(DOWN * 1)\n        player2 = Dot(LEFT * 2, color=RED).shift(DOWN * 1)\n        \n        self.play(Create(player1))\n        self.play(Create(player2))\n        \n        # Text explaining few players\n        few_players_text = Text(\"With few players, traffic flows freely\", font_size=24)\n        few_players_text.to_edge(UP)\n        self.play(Write(few_players_text))\n        \n        # Move players forward quickly to show free flow\n        self.play(player1.animate.move_to(RIGHT * 3 + DOWN * 1), run_time=1)\n        self.play(player2.animate.move_to(RIGHT * 2 + DOWN * 1), run_time=1)\n        self.wait(1)\n        self.play(FadeOut(few_players_text))\n        \n        # Add more players to show congestion\n        player3 = Dot(LEFT * 3, color=RED).shift(DOWN * 1)\n        player4 = Dot(LEFT * 2.5, color=RED).shift(DOWN * 1)\n        player5 = Dot(LEFT * 2, color=RED).shift(DOWN * 1)\n        \n        self.play(Create(player3))\n        self.play(Create(player4))\n        self.play(Create(player5))\n        \n        # Text explaining congestion\n        congestion_text = Text(\"As more players enter, congestion increases\", font_size=24)\n        congestion_text.to_edge(UP)\n        self.play(Write(congestion_text))\n        \n        # Move players forward slowly to show congestion\n        self.play(player3.animate.move_to(RIGHT * 1 + DOWN * 1), run_time=2)\n        self.play(player4.animate.move_to(RIGHT * 0.5 + DOWN * 1), run_time=2)\n        self.play(player5.animate.move_to(RIGHT * 0 + DOWN * 1), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(congestion_text))\n        \n        # Explain equilibria\n        eq_text = Text(\"Equilibrium: No player can improve by changing route\", font_size=24)\n        eq_text.to_edge(UP)\n        self.play(Write(eq_text))\n        \n        # First equation - simplified\n        eq1 = Text(\"P(t) = delay = n/c * (1 + x(t)/K)\", font_size=30)\n        eq1.next_to(eq_text, DOWN, buff=0.5)\n        self.play(Write(eq1))\n        \n        eq1_explain = Text(\"n = players, c = capacity, x(t) = traffic load\", font_size=20)\n        eq1_explain.next_to(eq1, DOWN, buff=0.5)\n        self.play(Write(eq1_explain))\n        self.wait(2)\n        \n        self.play(FadeOut(eq_text), FadeOut(eq1), FadeOut(eq1_explain))\n        \n        # Strategic behavior - some players take alternative route\n        strategic_text = Text(\"Players adjust routes based on congestion\", font_size=24)\n        strategic_text.to_edge(UP)\n        self.play(Write(strategic_text))\n        \n        # Highlight the alternative route\n        self.play(road2.animate.set_color(GREEN))\n        \n        # Some players switch to the alternative route\n        alt_player1 = Dot(LEFT * 3, color=RED).shift(UP * 1)\n        alt_player2 = Dot(LEFT * 2, color=RED).shift(UP * 1)\n        \n        self.play(Create(alt_player1))\n        self.play(Create(alt_player2))\n        \n        # Move alternative route players faster\n        self.play(alt_player1.animate.move_to(RIGHT * 3 + UP * 1), run_time=1)\n        self.play(alt_player2.animate.move_to(RIGHT * 2 + UP * 1), run_time=1)\n        \n        # Second equation - simplified\n        eq2 = Text(\"x(t+1) = \u03b1x(t) + \u03b2(f(x(t)) - x(t))\", font_size=30)\n        eq2.next_to(strategic_text, DOWN, buff=0.5)\n        self.play(Write(eq2))\n        \n        eq2_explain = Text(\"Players enter/exit based on perceived benefit\", font_size=20)\n        eq2_explain.next_to(eq2, DOWN, buff=0.5)\n        self.play(Write(eq2_explain))\n        self.wait(2)\n        \n        self.play(FadeOut(strategic_text), FadeOut(eq2), FadeOut(eq2_explain))\n        \n        # Conclusion\n        conclusion_text = Text(\"Individual strategies create dynamic congestion patterns\", font_size=28)\n        self.play(Write(conclusion_text))\n        self.wait(1)\n        \n        final_text = Text(\"Appreciate the hidden mathematics of your morning commute!\", font_size=24)\n        final_text.next_to(conclusion_text, DOWN, buff=0.5)\n        self.play(Write(final_text))\n        self.wait(2)\n        \n        self.play(FadeOut(conclusion_text), FadeOut(final_text))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the effect of strategic player entry and exit on the equilibrium of a congestion game, and how can this be represented graphically?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the Inclusion-Exclusion Principle be applied to count the number of 3-digit numbers without the digits 3 and 7?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InclusionExclusionPrinciple(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unlocking Combinatorics\", font_size=40)\n        subtitle = Text(\"Counting with Inclusion-Exclusion\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Problem statement\n        problem = Text(\"How many 3-digit numbers do not contain 3 or 7?\", font_size=32)\n        self.play(Write(problem))\n        self.wait(1)\n        self.play(problem.animate.to_edge(UP))\n        \n        # Key Concept 1: Total count\n        total_text = Text(\"Total 3-digit numbers: 900\", font_size=28, color=BLUE)\n        total_text.shift(UP)\n        \n        self.play(Write(total_text))\n        self.wait(1)\n        \n        # Key Concept 2: Venn Diagram\n        # Create two circles for the Venn diagram\n        circle_a = Circle(radius=1.5, color=BLUE, fill_opacity=0.3)\n        circle_a.shift(LEFT*1.5)\n        label_a = Text(\"Contains 3\", font_size=24, color=BLUE)\n        label_a.next_to(circle_a, UP)\n        \n        circle_b = Circle(radius=1.5, color=GREEN, fill_opacity=0.3)\n        circle_b.shift(RIGHT*1.5)\n        label_b = Text(\"Contains 7\", font_size=24, color=GREEN)\n        label_b.next_to(circle_b, UP)\n        \n        # Create a simple visual for the intersection\n        intersection_label = Text(\"Both\", font_size=20, color=YELLOW)\n        intersection_label.move_to((circle_a.get_center() + circle_b.get_center())/2)\n        \n        self.play(FadeOut(total_text))\n        self.play(Create(circle_a), Write(label_a))\n        self.play(Create(circle_b), Write(label_b))\n        self.play(Write(intersection_label))\n        self.wait(1)\n        \n        # Key Concept 3: Inclusion-Exclusion Formula\n        formula = Text(\"Valid = Total - (Contains 3) - (Contains 7) + (Contains both)\", font_size=26)\n        formula.shift(UP)\n        \n        self.play(\n            FadeOut(circle_a), FadeOut(circle_b),\n            FadeOut(label_a), FadeOut(label_b),\n            FadeOut(intersection_label),\n            Write(formula)\n        )\n        self.wait(1)\n        \n        # Key Insight: Calculation\n        calc_group = VGroup(\n            Text(\"Total: 900\", font_size=26),\n            Text(\"Numbers with 3: 280\", font_size=26),\n            Text(\"Numbers with 7: 280\", font_size=26),\n            Text(\"Numbers with both 3 and 7: 58\", font_size=26),\n        ).arrange(DOWN, aligned_edge=LEFT)\n        calc_group.next_to(formula, DOWN, buff=0.5)\n        \n        for item in calc_group:\n            self.play(Write(item))\n            self.wait(0.5)\n        \n        # Result\n        result = Text(\"Valid = 900 - 280 - 280 + 58 = 398\", font_size=30, color=BLUE)\n        result.next_to(calc_group, DOWN, buff=0.5)\n        self.play(Write(result))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"There are 398 three-digit numbers without 3 and 7\", font_size=30, color=BLUE)\n        conclusion.move_to(ORIGIN)\n        \n        self.play(\n            FadeOut(problem),\n            FadeOut(formula),\n            FadeOut(calc_group),\n            ReplacementTransform(result, conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the Inclusion-Exclusion Principle be applied to count the number of 3-digit numbers without the digits 3 and 7?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the inclusion-exclusion principle be applied to count the number of 3-digit numbers without the digits 3 and 7?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InclusionExclusionPrinciple(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unlocking Combinatorics\", font_size=40)\n        subtitle = Text(\"Counting with Inclusion-Exclusion\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Problem statement\n        problem = Text(\"How many 3-digit numbers do not contain 3 or 7?\", font_size=32)\n        self.play(Write(problem))\n        self.wait(1)\n        self.play(problem.animate.to_edge(UP))\n        \n        # Key Concept 1: Total count\n        total_text = Text(\"Total 3-digit numbers: 900\", font_size=28, color=BLUE)\n        total_text.shift(UP)\n        \n        self.play(Write(total_text))\n        self.wait(1)\n        \n        # Key Concept 2: Venn Diagram\n        # Create two circles for the Venn diagram\n        circle_a = Circle(radius=1.5, color=BLUE, fill_opacity=0.3)\n        circle_a.shift(LEFT*1.5)\n        label_a = Text(\"Contains 3\", font_size=24, color=BLUE)\n        label_a.next_to(circle_a, UP)\n        \n        circle_b = Circle(radius=1.5, color=GREEN, fill_opacity=0.3)\n        circle_b.shift(RIGHT*1.5)\n        label_b = Text(\"Contains 7\", font_size=24, color=GREEN)\n        label_b.next_to(circle_b, UP)\n        \n        # Create a simple visual for the intersection\n        intersection_label = Text(\"Both\", font_size=20, color=YELLOW)\n        intersection_label.move_to((circle_a.get_center() + circle_b.get_center())/2)\n        \n        self.play(FadeOut(total_text))\n        self.play(Create(circle_a), Write(label_a))\n        self.play(Create(circle_b), Write(label_b))\n        self.play(Write(intersection_label))\n        self.wait(1)\n        \n        # Key Concept 3: Inclusion-Exclusion Formula\n        formula = Text(\"Valid = Total - (Contains 3) - (Contains 7) + (Contains both)\", font_size=26)\n        formula.shift(UP)\n        \n        self.play(\n            FadeOut(circle_a), FadeOut(circle_b),\n            FadeOut(label_a), FadeOut(label_b),\n            FadeOut(intersection_label),\n            Write(formula)\n        )\n        self.wait(1)\n        \n        # Key Insight: Calculation\n        calc_group = VGroup(\n            Text(\"Total: 900\", font_size=26),\n            Text(\"Numbers with 3: 280\", font_size=26),\n            Text(\"Numbers with 7: 280\", font_size=26),\n            Text(\"Numbers with both 3 and 7: 58\", font_size=26),\n        ).arrange(DOWN, aligned_edge=LEFT)\n        calc_group.next_to(formula, DOWN, buff=0.5)\n        \n        for item in calc_group:\n            self.play(Write(item))\n            self.wait(0.5)\n        \n        # Result\n        result = Text(\"Valid = 900 - 280 - 280 + 58 = 398\", font_size=30, color=BLUE)\n        result.next_to(calc_group, DOWN, buff=0.5)\n        self.play(Write(result))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"There are 398 three-digit numbers without 3 and 7\", font_size=30, color=BLUE)\n        conclusion.move_to(ORIGIN)\n        \n        self.play(\n            FadeOut(problem),\n            FadeOut(formula),\n            FadeOut(calc_group),\n            ReplacementTransform(result, conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the Inclusion-Exclusion Principle be applied to count the number of 3-digit numbers without the digits 3 and 7?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually explains the process of solving a trigonometric substitution problem in calculus. The animation should start by presenting the integral of 1 over the square root of 1 minus x squared. Then, it should introduce the idea of using a trigonometric substitution to solve the integral. The animation needs to show the substitution of x with the sine of theta and dx with the cosine of theta times d theta. After that, please demonstrate how the integral changes with the substitution and simplify it using the Pythagorean identity. Once the simplified integral is presented, proceed to solve the integral and display the solution. Finally, please show the process of substituting back to express the solution in terms of x and conclude with the final result clearly displayed. The explanations should be paced with waiting moments to allow the audience to follow the content comfortably."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigonometricIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        apply_identity = MathTex(r\"= \\frac{1}{2}\\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, apply_identity))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4}\\cos(2x) + C\")\n        self.play(Write(integration_step.next_to(apply_identity, DOWN)))\n        self.wait(1)\n\n        # Clear the scene and display the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains the process of solving a trigonometric substitution problem in calculus. The animation should start by presenting the integral of 1 over the square root of 1 minus x squared. Then, it should introduce the idea of using a trigonometric substitution to solve the integral. The animation needs to show the substitution of x with the sine of theta and dx with the cosine of theta times d theta. After that, please demonstrate how the integral changes with the substitution and simplify it using the Pythagorean identity. Once the simplified integral is presented, proceed to solve the integral and display the solution. Finally, please show the process of substituting back to express the solution in terms of x and conclude with the final result clearly displayed. The explanations should be paced with waiting moments to allow the audience to follow the content comfortably."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually explains the process of solving a trigonometric substitution problem in calculus. the animation should start by presenting the integral of 1 over the square root of 1 minus x squared. then, it should introduce the idea of using a trigonometric substitution to solve the integral. the animation needs to show the substitution of x with the sine of theta and dx with the cosine of theta times d theta. after that, please demonstrate how the integral changes with the substitution and simplify it using the pythagorean identity. once the simplified integral is presented, proceed to solve the integral and display the solution. finally, please show the process of substituting back to express the solution in terms of x and conclude with the final result clearly displayed. the explanations should be paced with waiting moments to allow the audience to follow the content comfortably."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigonometricIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using trigonometric identities\n        explanation1 = Text(\"Use trigonometric identity: \"\n                            \"sin(2x) = 2sin(x)cos(x)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        apply_identity = MathTex(r\"= \\frac{1}{2}\\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, apply_identity))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= -\\frac{1}{4}\\cos(2x) + C\")\n        self.play(Write(integration_step.next_to(apply_identity, DOWN)))\n        self.wait(1)\n\n        # Clear the scene and display the final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains the process of solving a trigonometric substitution problem in calculus. The animation should start by presenting the integral of 1 over the square root of 1 minus x squared. Then, it should introduce the idea of using a trigonometric substitution to solve the integral. The animation needs to show the substitution of x with the sine of theta and dx with the cosine of theta times d theta. After that, please demonstrate how the integral changes with the substitution and simplify it using the Pythagorean identity. Once the simplified integral is presented, proceed to solve the integral and display the solution. Finally, please show the process of substituting back to express the solution in terms of x and conclude with the final result clearly displayed. The explanations should be paced with waiting moments to allow the audience to follow the content comfortably."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways do the spectra of similar graphs reveal or obscure their isomorphism?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpectralGraphTheory(Scene):\n    def construct(self):\n        # Set background to black (default in manim)\n        # Create title with vibrant color\n        title = Text(\"Unveiling Hidden Patterns: The Spectra of Graphs\", font_size=36, color=BLUE)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction text\n        intro = Text(\"Welcome to the colorful world of spectral graph theory\", font_size=28, color=BLUE)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create two visually distinct graphs side by side\n        # Path graph (3 nodes)\n        g1_nodes = [Dot(point=[-3 + i, 1, 0], color=BLUE, radius=0.15) for i in range(3)]\n        g1_edges = [Line(g1_nodes[i].get_center(), g1_nodes[i+1].get_center(), color=BLUE) \n                   for i in range(2)]\n        g1 = VGroup(*g1_nodes, *g1_edges)\n        g1_label = Text(\"Path Graph\", font_size=24, color=BLUE).next_to(g1, DOWN)\n        \n        # Star graph (3 nodes)\n        g2_nodes = [\n            Dot(point=[3, 1.5, 0], color=GREEN, radius=0.15),\n            Dot(point=[2, 0.5, 0], color=GREEN, radius=0.15),\n            Dot(point=[4, 0.5, 0], color=GREEN, radius=0.15)\n        ]\n        g2_edges = [\n            Line(g2_nodes[0].get_center(), g2_nodes[1].get_center(), color=GREEN),\n            Line(g2_nodes[0].get_center(), g2_nodes[2].get_center(), color=GREEN)\n        ]\n        g2 = VGroup(*g2_nodes, *g2_edges)\n        g2_label = Text(\"Star Graph\", font_size=24, color=GREEN).next_to(g2, DOWN)\n        \n        # Display the graphs\n        self.play(Create(g1), Write(g1_label))\n        self.play(Create(g2), Write(g2_label))\n        self.wait(1)\n        \n        # Introduce adjacency matrices\n        matrix_title = Text(\"Adjacency Matrix\", font_size=28, color=ORANGE).to_edge(UP)\n        self.play(Write(matrix_title))\n        \n        # Adjacency matrix \n        adj_matrix = MathTex(\n            r\"\\mathbf{A} = \\begin{bmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix}\",\n            color=WHITE\n        )\n        adj_matrix.next_to(g1, DOWN, buff=1)\n        \n        self.play(Write(adj_matrix))\n        self.wait(1)\n        \n        # Eigenvalues\n        eigen_title = Text(\"Eigenvalues (Spectrum)\", font_size=28, color=ORANGE).to_edge(UP)\n        self.play(ReplacementTransform(matrix_title, eigen_title))\n        \n        eigenvalues = MathTex(r\"\\lambda_1, \\lambda_2, \\lambda_3\", color=WHITE)\n        eigenvalues.next_to(adj_matrix, DOWN, buff=0.5)\n        \n        self.play(Write(eigenvalues))\n        self.wait(1)\n        \n        # Key insight\n        insight = Text(\"Similar spectra \u2260 Isomorphic graphs\", font_size=28, color=YELLOW)\n        insight.to_edge(DOWN, buff=1)\n        \n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(eigen_title),\n            FadeOut(adj_matrix),\n            FadeOut(eigenvalues),\n            FadeOut(g1),\n            FadeOut(g1_label),\n            FadeOut(g2),\n            FadeOut(g2_label),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"Thank you for exploring spectral graph theory\", font_size=32, color=BLUE)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways do the spectra of similar graphs reveal or obscure their isomorphism?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways do the spectra of similar graphs reveal or obscure their isomorphism?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpectralGraphTheory(Scene):\n    def construct(self):\n        # Set background to black (default in manim)\n        # Create title with vibrant color\n        title = Text(\"Unveiling Hidden Patterns: The Spectra of Graphs\", font_size=36, color=BLUE)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction text\n        intro = Text(\"Welcome to the colorful world of spectral graph theory\", font_size=28, color=BLUE)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create two visually distinct graphs side by side\n        # Path graph (3 nodes)\n        g1_nodes = [Dot(point=[-3 + i, 1, 0], color=BLUE, radius=0.15) for i in range(3)]\n        g1_edges = [Line(g1_nodes[i].get_center(), g1_nodes[i+1].get_center(), color=BLUE) \n                   for i in range(2)]\n        g1 = VGroup(*g1_nodes, *g1_edges)\n        g1_label = Text(\"Path Graph\", font_size=24, color=BLUE).next_to(g1, DOWN)\n        \n        # Star graph (3 nodes)\n        g2_nodes = [\n            Dot(point=[3, 1.5, 0], color=GREEN, radius=0.15),\n            Dot(point=[2, 0.5, 0], color=GREEN, radius=0.15),\n            Dot(point=[4, 0.5, 0], color=GREEN, radius=0.15)\n        ]\n        g2_edges = [\n            Line(g2_nodes[0].get_center(), g2_nodes[1].get_center(), color=GREEN),\n            Line(g2_nodes[0].get_center(), g2_nodes[2].get_center(), color=GREEN)\n        ]\n        g2 = VGroup(*g2_nodes, *g2_edges)\n        g2_label = Text(\"Star Graph\", font_size=24, color=GREEN).next_to(g2, DOWN)\n        \n        # Display the graphs\n        self.play(Create(g1), Write(g1_label))\n        self.play(Create(g2), Write(g2_label))\n        self.wait(1)\n        \n        # Introduce adjacency matrices\n        matrix_title = Text(\"Adjacency Matrix\", font_size=28, color=ORANGE).to_edge(UP)\n        self.play(Write(matrix_title))\n        \n        # Adjacency matrix \n        adj_matrix = MathTex(\n            r\"\\mathbf{A} = \\begin{bmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix}\",\n            color=WHITE\n        )\n        adj_matrix.next_to(g1, DOWN, buff=1)\n        \n        self.play(Write(adj_matrix))\n        self.wait(1)\n        \n        # Eigenvalues\n        eigen_title = Text(\"Eigenvalues (Spectrum)\", font_size=28, color=ORANGE).to_edge(UP)\n        self.play(ReplacementTransform(matrix_title, eigen_title))\n        \n        eigenvalues = MathTex(r\"\\lambda_1, \\lambda_2, \\lambda_3\", color=WHITE)\n        eigenvalues.next_to(adj_matrix, DOWN, buff=0.5)\n        \n        self.play(Write(eigenvalues))\n        self.wait(1)\n        \n        # Key insight\n        insight = Text(\"Similar spectra \u2260 Isomorphic graphs\", font_size=28, color=YELLOW)\n        insight.to_edge(DOWN, buff=1)\n        \n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(eigen_title),\n            FadeOut(adj_matrix),\n            FadeOut(eigenvalues),\n            FadeOut(g1),\n            FadeOut(g1_label),\n            FadeOut(g2),\n            FadeOut(g2_label),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"Thank you for exploring spectral graph theory\", font_size=32, color=BLUE)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways do the spectra of similar graphs reveal or obscure their isomorphism?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation illustrating the steps to solve a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with the limits for r going from 0 to 1 and for theta from 0 to pi/2? It should include the integration first with respect to r, showing the intermediate steps, and then integration with respect to theta, until reaching the final numeric solution. Also, include textual explanations for each step of the process."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaterScene(Scene):\n    def construct(self):\n        # Create water molecule (H2O)\n        oxygen_center = oxygen()\n        hydrogen1 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        hydrogen2 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        \n        hydrogen1.next_to(oxygen_center, UP+LEFT, buff=0)\n        hydrogen2.next_to(oxygen_center, UP+RIGHT, buff=0)\n        \n        water_molecule = VGroup(oxygen_center, hydrogen1, hydrogen2)\n        \n        # Animate creation of the water molecule\n        self.play(Create(water_molecule))\n        self.wait(1)\n        \n        # Rotate water molecule\n        self.play(Rotate(water_molecule, angle=2*PI), run_time=2)\n        self.wait(1)\n        \n        # Dissociation of water molecule\n        self.play(\n            hydrogen1.animate.shift(LEFT*3),\n            hydrogen2.animate.shift(RIGHT*3),\n        )\n        self.wait(1)\n        \n        # Recombination of hydrogen and oxygen to form water\n        self.play(\n            hydrogen1.animate.next_to(oxygen_center, UP+LEFT, buff=0),\n            hydrogen2.animate.next_to(oxygen_center, UP+RIGHT, buff=0)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation illustrating the steps to solve a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with the limits for r going from 0 to 1 and for theta from 0 to pi/2? It should include the integration first with respect to r, showing the intermediate steps, and then integration with respect to theta, until reaching the final numeric solution. Also, include textual explanations for each step of the process."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation illustrating the steps to solve a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with the limits for r going from 0 to 1 and for theta from 0 to pi/2? it should include the integration first with respect to r, showing the intermediate steps, and then integration with respect to theta, until reaching the final numeric solution. also, include textual explanations for each step of the process."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaterScene(Scene):\n    def construct(self):\n        # Create water molecule (H2O)\n        oxygen_center = oxygen()\n        hydrogen1 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        hydrogen2 = circle_with_text(0.1, 'H', color=WHITE, font_size=18, font_color=BLACK, stroke_width=1, fill_color=WHITE)\n        \n        hydrogen1.next_to(oxygen_center, UP+LEFT, buff=0)\n        hydrogen2.next_to(oxygen_center, UP+RIGHT, buff=0)\n        \n        water_molecule = VGroup(oxygen_center, hydrogen1, hydrogen2)\n        \n        # Animate creation of the water molecule\n        self.play(Create(water_molecule))\n        self.wait(1)\n        \n        # Rotate water molecule\n        self.play(Rotate(water_molecule, angle=2*PI), run_time=2)\n        self.wait(1)\n        \n        # Dissociation of water molecule\n        self.play(\n            hydrogen1.animate.shift(LEFT*3),\n            hydrogen2.animate.shift(RIGHT*3),\n        )\n        self.wait(1)\n        \n        # Recombination of hydrogen and oxygen to form water\n        self.play(\n            hydrogen1.animate.next_to(oxygen_center, UP+LEFT, buff=0),\n            hydrogen2.animate.next_to(oxygen_center, UP+RIGHT, buff=0)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation illustrating the steps to solve a double integral in polar coordinates, specifically the integral of r^2 sin(theta) with the limits for r going from 0 to 1 and for theta from 0 to pi/2? It should include the integration first with respect to r, showing the intermediate steps, and then integration with respect to theta, until reaching the final numeric solution. Also, include textual explanations for each step of the process."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_max_pool.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                Convolutional2DLayer(3, 6, 3, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(5, 2, 2, filter_spacing=0.32),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        self.wait(5)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n\n\nclass SmallNetwork(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_max_pool.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_max_pool.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                Convolutional2DLayer(3, 6, 3, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(5, 2, 2, filter_spacing=0.32),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        self.wait(5)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n\n\nclass SmallNetwork(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 8, filter_spacing=0.32),\n                MaxPooling2DLayer(kernel_size=2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_max_pool.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does iteratively applying bilinear transformations lead to patterns or fractals on the complex plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BilinearTransformScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Beautiful Dance of Bilinear Transforms\")\n        title.to_edge(UP)\n        self.play(Write(title))\n        \n        # Create a complex plane\n        plane = ComplexPlane().scale(2)\n        self.play(Create(plane))\n        \n        # Show the bilinear transformation equation\n        eq = MathTex(r\"f(z) = \\frac{az+b}{cz+d}\")\n        eq.next_to(title, DOWN)\n        self.play(Write(eq))\n        \n        # Show fixed point equation\n        fixed_eq = MathTex(r\"f(z) = z\")\n        fixed_eq.next_to(eq, DOWN)\n        self.play(Write(fixed_eq))\n        \n        # Create a fixed point\n        fixed_point = Dot(plane.n2p(complex(0.5, 0.5)), color=RED)\n        label = Text(\"Fixed Point\").scale(0.5).next_to(fixed_point, UP)\n        self.play(Create(fixed_point), Write(label))\n        \n        # Create just three points\n        point1 = Dot(plane.n2p(complex(0.8, 0.8)), color=BLUE)\n        point2 = Dot(plane.n2p(complex(0.3, 0.6)), color=BLUE)\n        point3 = Dot(plane.n2p(complex(0.6, 0.3)), color=BLUE)\n        \n        self.play(Create(point1), Create(point2), Create(point3))\n        \n        # Show attraction with arrows\n        arrow1 = Arrow(point1.get_center(), fixed_point.get_center(), buff=0.1, color=YELLOW)\n        arrow2 = Arrow(point2.get_center(), fixed_point.get_center(), buff=0.1, color=YELLOW)\n        arrow3 = Arrow(point3.get_center(), fixed_point.get_center(), buff=0.1, color=YELLOW)\n        \n        self.play(Create(arrow1), Create(arrow2), Create(arrow3))\n        \n        # Move points toward fixed point\n        self.play(\n            point1.animate.move_to(point1.get_center() + 0.6 * (fixed_point.get_center() - point1.get_center())),\n            point2.animate.move_to(point2.get_center() + 0.6 * (fixed_point.get_center() - point2.get_center())),\n            point3.animate.move_to(point3.get_center() + 0.6 * (fixed_point.get_center() - point3.get_center()))\n        )\n        \n        # Clear the scene\n        self.play(\n            FadeOut(fixed_point), FadeOut(label),\n            FadeOut(point1), FadeOut(point2), FadeOut(point3),\n            FadeOut(arrow1), FadeOut(arrow2), FadeOut(arrow3)\n        )\n        \n        # Show a pattern forming\n        pattern_text = Text(\"Patterns emerge from iterations\").scale(0.6).to_edge(DOWN)\n        self.play(Write(pattern_text))\n        \n        # Create a simple shape of dots\n        dot1 = Dot(plane.n2p(complex(-1, 0)), color=BLUE)\n        dot2 = Dot(plane.n2p(complex(-0.5, 0.5)), color=BLUE)\n        dot3 = Dot(plane.n2p(complex(0, 1)), color=BLUE)\n        dot4 = Dot(plane.n2p(complex(0.5, 0.5)), color=BLUE)\n        dot5 = Dot(plane.n2p(complex(1, 0)), color=BLUE)\n        dot6 = Dot(plane.n2p(complex(0.5, -0.5)), color=BLUE)\n        dot7 = Dot(plane.n2p(complex(0, -1)), color=BLUE)\n        dot8 = Dot(plane.n2p(complex(-0.5, -0.5)), color=BLUE)\n        \n        dots = [dot1, dot2, dot3, dot4, dot5, dot6, dot7, dot8]\n        self.play(*[Create(dot) for dot in dots])\n        \n        # Transform to a new pattern (just a rotated and scaled version)\n        self.play(\n            dot1.animate.move_to(plane.n2p(complex(-0.5, 0))),\n            dot2.animate.move_to(plane.n2p(complex(-0.25, 0.25))),\n            dot3.animate.move_to(plane.n2p(complex(0, 0.5))),\n            dot4.animate.move_to(plane.n2p(complex(0.25, 0.25))),\n            dot5.animate.move_to(plane.n2p(complex(0.5, 0))),\n            dot6.animate.move_to(plane.n2p(complex(0.25, -0.25))),\n            dot7.animate.move_to(plane.n2p(complex(0, -0.5))),\n            dot8.animate.move_to(plane.n2p(complex(-0.25, -0.25)))\n        )\n        \n        # Show attraction basins\n        basin1 = Circle(radius=0.3, color=RED_A, fill_opacity=0.2).move_to(plane.n2p(complex(-0.5, 0)))\n        basin2 = Circle(radius=0.3, color=GREEN_A, fill_opacity=0.2).move_to(plane.n2p(complex(0.5, 0)))\n        \n        self.play(Create(basin1), Create(basin2))\n        \n        # Final note\n        conclusion = Text(\"Fractals emerge from simple transformations\").scale(0.6)\n        conclusion.to_edge(DOWN)\n        self.play(ReplacementTransform(pattern_text, conclusion))\n        \n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does iteratively applying bilinear transformations lead to patterns or fractals on the complex plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does iteratively applying bilinear transformations lead to patterns or fractals on the complex plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BilinearTransformScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Beautiful Dance of Bilinear Transforms\")\n        title.to_edge(UP)\n        self.play(Write(title))\n        \n        # Create a complex plane\n        plane = ComplexPlane().scale(2)\n        self.play(Create(plane))\n        \n        # Show the bilinear transformation equation\n        eq = MathTex(r\"f(z) = \\frac{az+b}{cz+d}\")\n        eq.next_to(title, DOWN)\n        self.play(Write(eq))\n        \n        # Show fixed point equation\n        fixed_eq = MathTex(r\"f(z) = z\")\n        fixed_eq.next_to(eq, DOWN)\n        self.play(Write(fixed_eq))\n        \n        # Create a fixed point\n        fixed_point = Dot(plane.n2p(complex(0.5, 0.5)), color=RED)\n        label = Text(\"Fixed Point\").scale(0.5).next_to(fixed_point, UP)\n        self.play(Create(fixed_point), Write(label))\n        \n        # Create just three points\n        point1 = Dot(plane.n2p(complex(0.8, 0.8)), color=BLUE)\n        point2 = Dot(plane.n2p(complex(0.3, 0.6)), color=BLUE)\n        point3 = Dot(plane.n2p(complex(0.6, 0.3)), color=BLUE)\n        \n        self.play(Create(point1), Create(point2), Create(point3))\n        \n        # Show attraction with arrows\n        arrow1 = Arrow(point1.get_center(), fixed_point.get_center(), buff=0.1, color=YELLOW)\n        arrow2 = Arrow(point2.get_center(), fixed_point.get_center(), buff=0.1, color=YELLOW)\n        arrow3 = Arrow(point3.get_center(), fixed_point.get_center(), buff=0.1, color=YELLOW)\n        \n        self.play(Create(arrow1), Create(arrow2), Create(arrow3))\n        \n        # Move points toward fixed point\n        self.play(\n            point1.animate.move_to(point1.get_center() + 0.6 * (fixed_point.get_center() - point1.get_center())),\n            point2.animate.move_to(point2.get_center() + 0.6 * (fixed_point.get_center() - point2.get_center())),\n            point3.animate.move_to(point3.get_center() + 0.6 * (fixed_point.get_center() - point3.get_center()))\n        )\n        \n        # Clear the scene\n        self.play(\n            FadeOut(fixed_point), FadeOut(label),\n            FadeOut(point1), FadeOut(point2), FadeOut(point3),\n            FadeOut(arrow1), FadeOut(arrow2), FadeOut(arrow3)\n        )\n        \n        # Show a pattern forming\n        pattern_text = Text(\"Patterns emerge from iterations\").scale(0.6).to_edge(DOWN)\n        self.play(Write(pattern_text))\n        \n        # Create a simple shape of dots\n        dot1 = Dot(plane.n2p(complex(-1, 0)), color=BLUE)\n        dot2 = Dot(plane.n2p(complex(-0.5, 0.5)), color=BLUE)\n        dot3 = Dot(plane.n2p(complex(0, 1)), color=BLUE)\n        dot4 = Dot(plane.n2p(complex(0.5, 0.5)), color=BLUE)\n        dot5 = Dot(plane.n2p(complex(1, 0)), color=BLUE)\n        dot6 = Dot(plane.n2p(complex(0.5, -0.5)), color=BLUE)\n        dot7 = Dot(plane.n2p(complex(0, -1)), color=BLUE)\n        dot8 = Dot(plane.n2p(complex(-0.5, -0.5)), color=BLUE)\n        \n        dots = [dot1, dot2, dot3, dot4, dot5, dot6, dot7, dot8]\n        self.play(*[Create(dot) for dot in dots])\n        \n        # Transform to a new pattern (just a rotated and scaled version)\n        self.play(\n            dot1.animate.move_to(plane.n2p(complex(-0.5, 0))),\n            dot2.animate.move_to(plane.n2p(complex(-0.25, 0.25))),\n            dot3.animate.move_to(plane.n2p(complex(0, 0.5))),\n            dot4.animate.move_to(plane.n2p(complex(0.25, 0.25))),\n            dot5.animate.move_to(plane.n2p(complex(0.5, 0))),\n            dot6.animate.move_to(plane.n2p(complex(0.25, -0.25))),\n            dot7.animate.move_to(plane.n2p(complex(0, -0.5))),\n            dot8.animate.move_to(plane.n2p(complex(-0.25, -0.25)))\n        )\n        \n        # Show attraction basins\n        basin1 = Circle(radius=0.3, color=RED_A, fill_opacity=0.2).move_to(plane.n2p(complex(-0.5, 0)))\n        basin2 = Circle(radius=0.3, color=GREEN_A, fill_opacity=0.2).move_to(plane.n2p(complex(0.5, 0)))\n        \n        self.play(Create(basin1), Create(basin2))\n        \n        # Final note\n        conclusion = Text(\"Fractals emerge from simple transformations\").scale(0.6)\n        conclusion.to_edge(DOWN)\n        self.play(ReplacementTransform(pattern_text, conclusion))\n        \n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does iteratively applying bilinear transformations lead to patterns or fractals on the complex plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do changes in emission probabilities affect the predicted genomic landscapes when using Hidden Markov Models?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HiddenMarkovModelGenomics(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Uncovering Genomic Secrets with Hidden Markov Models\")\n        title.scale(0.7)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Show a genomic sequence to introduce the concept\n        dna_seq = Text(\"ACGTACGTACGTACGT...\")\n        dna_seq.next_to(title, DOWN, buff=0.5)\n        self.play(Write(dna_seq))\n        self.wait(1)\n\n        # Clear the genomic sequence to make room for the HMM\n        self.play(FadeOut(dna_seq))\n\n        # Create a simple Hidden Markov Model diagram with 2 hidden and 2 observed states\n        # Hidden states (H1, H2)\n        h1 = Circle(radius=0.5, color=BLUE, fill_opacity=0.5)\n        h1.shift(UP * 0.5 + LEFT * 2)\n        h1_label = Text(\"H1\").scale(0.5).move_to(h1)\n        \n        h2 = Circle(radius=0.5, color=BLUE, fill_opacity=0.5)\n        h2.shift(UP * 0.5 + RIGHT * 2)\n        h2_label = Text(\"H2\").scale(0.5).move_to(h2)\n        \n        # Observed states (O1, O2)\n        o1 = Circle(radius=0.5, color=GREEN, fill_opacity=0.5)\n        o1.shift(DOWN * 1.5 + LEFT * 2)\n        o1_label = Text(\"O1\").scale(0.5).move_to(o1)\n        \n        o2 = Circle(radius=0.5, color=GREEN, fill_opacity=0.5)\n        o2.shift(DOWN * 1.5 + RIGHT * 2)\n        o2_label = Text(\"O2\").scale(0.5).move_to(o2)\n\n        # Arrows connecting states\n        # Transition arrow between hidden states\n        h_arrow = Arrow(h1.get_right(), h2.get_left(), color=BLUE, buff=0.1)\n        # Emission arrows from hidden to observed states\n        e_arrow1 = Arrow(h1.get_bottom(), o1.get_top(), color=RED, buff=0.1)\n        e_arrow2 = Arrow(h2.get_bottom(), o2.get_top(), color=RED, buff=0.1)\n\n        # Animate the creation of the HMM diagram\n        # Add hidden states\n        self.play(\n            Create(h1), Create(h2), \n            Write(h1_label), Write(h2_label)\n        )\n        # Add observed states\n        self.play(\n            Create(o1), Create(o2),\n            Write(o1_label), Write(o2_label)\n        )\n        # Add arrows\n        self.play(\n            Create(h_arrow),\n            Create(e_arrow1),\n            Create(e_arrow2)\n        )\n        self.wait(1)\n\n        # Display the key equations\n        # Emission probability equation\n        emission_eq = Text(\"P(x_i | y) = Emission Probability\")\n        emission_eq.scale(0.6)\n        emission_eq.to_edge(DOWN, buff=1)\n        \n        # Model probability equation\n        model_eq = Text(\"P(O | Model) = \u03a3(P(O, Q | Model))\")\n        model_eq.scale(0.6)\n        model_eq.next_to(emission_eq, UP, buff=0.5)\n        \n        # Show the equations\n        self.play(Write(emission_eq))\n        self.play(Write(model_eq))\n        self.wait(1)\n\n        # Highlight emission arrows to emphasize their importance\n        self.play(\n            e_arrow1.animate.set_color(YELLOW).set_stroke(width=6),\n            e_arrow2.animate.set_color(YELLOW).set_stroke(width=6)\n        )\n        self.wait(1)\n\n        # Change the color of observed states to demonstrate the effect of changing emission probabilities\n        self.play(\n            o1.animate.set_fill(YELLOW, opacity=0.8),\n            o2.animate.set_fill(PURPLE, opacity=0.8)\n        )\n        self.wait(1)\n\n        # Display a conclusion about how emission probabilities affect genomic predictions\n        conclusion = Text(\"Changing emission probabilities reshapes genomic predictions\")\n        conclusion.scale(0.5)\n        conclusion.next_to(model_eq, UP, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clean up and show final message\n        self.play(\n            FadeOut(h1), FadeOut(h2), FadeOut(o1), FadeOut(o2),\n            FadeOut(h1_label), FadeOut(h2_label), FadeOut(o1_label), FadeOut(o2_label),\n            FadeOut(h_arrow), FadeOut(e_arrow1), FadeOut(e_arrow2),\n            FadeOut(emission_eq), FadeOut(model_eq),\n            FadeOut(title), FadeOut(conclusion)\n        )\n\n        # Final key insight\n        final_message = Text(\"Different emission settings reveal different hidden patterns\")\n        final_message.scale(0.7)\n        self.play(Write(final_message))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do changes in emission probabilities affect the predicted genomic landscapes when using Hidden Markov Models?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do changes in emission probabilities affect the predicted genomic landscapes when using hidden markov models?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HiddenMarkovModelGenomics(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Uncovering Genomic Secrets with Hidden Markov Models\")\n        title.scale(0.7)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Show a genomic sequence to introduce the concept\n        dna_seq = Text(\"ACGTACGTACGTACGT...\")\n        dna_seq.next_to(title, DOWN, buff=0.5)\n        self.play(Write(dna_seq))\n        self.wait(1)\n\n        # Clear the genomic sequence to make room for the HMM\n        self.play(FadeOut(dna_seq))\n\n        # Create a simple Hidden Markov Model diagram with 2 hidden and 2 observed states\n        # Hidden states (H1, H2)\n        h1 = Circle(radius=0.5, color=BLUE, fill_opacity=0.5)\n        h1.shift(UP * 0.5 + LEFT * 2)\n        h1_label = Text(\"H1\").scale(0.5).move_to(h1)\n        \n        h2 = Circle(radius=0.5, color=BLUE, fill_opacity=0.5)\n        h2.shift(UP * 0.5 + RIGHT * 2)\n        h2_label = Text(\"H2\").scale(0.5).move_to(h2)\n        \n        # Observed states (O1, O2)\n        o1 = Circle(radius=0.5, color=GREEN, fill_opacity=0.5)\n        o1.shift(DOWN * 1.5 + LEFT * 2)\n        o1_label = Text(\"O1\").scale(0.5).move_to(o1)\n        \n        o2 = Circle(radius=0.5, color=GREEN, fill_opacity=0.5)\n        o2.shift(DOWN * 1.5 + RIGHT * 2)\n        o2_label = Text(\"O2\").scale(0.5).move_to(o2)\n\n        # Arrows connecting states\n        # Transition arrow between hidden states\n        h_arrow = Arrow(h1.get_right(), h2.get_left(), color=BLUE, buff=0.1)\n        # Emission arrows from hidden to observed states\n        e_arrow1 = Arrow(h1.get_bottom(), o1.get_top(), color=RED, buff=0.1)\n        e_arrow2 = Arrow(h2.get_bottom(), o2.get_top(), color=RED, buff=0.1)\n\n        # Animate the creation of the HMM diagram\n        # Add hidden states\n        self.play(\n            Create(h1), Create(h2), \n            Write(h1_label), Write(h2_label)\n        )\n        # Add observed states\n        self.play(\n            Create(o1), Create(o2),\n            Write(o1_label), Write(o2_label)\n        )\n        # Add arrows\n        self.play(\n            Create(h_arrow),\n            Create(e_arrow1),\n            Create(e_arrow2)\n        )\n        self.wait(1)\n\n        # Display the key equations\n        # Emission probability equation\n        emission_eq = Text(\"P(x_i | y) = Emission Probability\")\n        emission_eq.scale(0.6)\n        emission_eq.to_edge(DOWN, buff=1)\n        \n        # Model probability equation\n        model_eq = Text(\"P(O | Model) = \u03a3(P(O, Q | Model))\")\n        model_eq.scale(0.6)\n        model_eq.next_to(emission_eq, UP, buff=0.5)\n        \n        # Show the equations\n        self.play(Write(emission_eq))\n        self.play(Write(model_eq))\n        self.wait(1)\n\n        # Highlight emission arrows to emphasize their importance\n        self.play(\n            e_arrow1.animate.set_color(YELLOW).set_stroke(width=6),\n            e_arrow2.animate.set_color(YELLOW).set_stroke(width=6)\n        )\n        self.wait(1)\n\n        # Change the color of observed states to demonstrate the effect of changing emission probabilities\n        self.play(\n            o1.animate.set_fill(YELLOW, opacity=0.8),\n            o2.animate.set_fill(PURPLE, opacity=0.8)\n        )\n        self.wait(1)\n\n        # Display a conclusion about how emission probabilities affect genomic predictions\n        conclusion = Text(\"Changing emission probabilities reshapes genomic predictions\")\n        conclusion.scale(0.5)\n        conclusion.next_to(model_eq, UP, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(2)\n\n        # Clean up and show final message\n        self.play(\n            FadeOut(h1), FadeOut(h2), FadeOut(o1), FadeOut(o2),\n            FadeOut(h1_label), FadeOut(h2_label), FadeOut(o1_label), FadeOut(o2_label),\n            FadeOut(h_arrow), FadeOut(e_arrow1), FadeOut(e_arrow2),\n            FadeOut(emission_eq), FadeOut(model_eq),\n            FadeOut(title), FadeOut(conclusion)\n        )\n\n        # Final key insight\n        final_message = Text(\"Different emission settings reveal different hidden patterns\")\n        final_message.scale(0.7)\n        self.play(Write(final_message))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do changes in emission probabilities affect the predicted genomic landscapes when using Hidden Markov Models?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display ten dots scattered across the screen, each representing a point in 2D space. A blue convex polygon (convex hull) is drawn around the outermost points, enclosing all the dots and illustrating the smallest convex shape that contains them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ConvexHullExample(Scene):\n    def construct(self):\n        points = [\n            [-2.35, -2.25, 0],\n            [1.65, -2.25, 0],\n            [2.65, -0.25, 0],\n            [1.65, 1.75, 0],\n            [-0.35, 2.75, 0],\n            [-2.35, 0.75, 0],\n            [-0.35, -1.25, 0],\n            [0.65, -0.25, 0],\n            [-1.35, 0.25, 0],\n            [0.15, 0.75, 0]\n        ]\n        hull = ConvexHull(*points, color=BLUE)\n        dots = VGroup(*[Dot(point) for point in points])\n        self.add(hull)\n        self.add(dots)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display ten dots scattered across the screen, each representing a point in 2D space. A blue convex polygon (convex hull) is drawn around the outermost points, enclosing all the dots and illustrating the smallest convex shape that contains them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display ten dots scattered across the screen, each representing a point in 2d space. a blue convex polygon (convex hull) is drawn around the outermost points, enclosing all the dots and illustrating the smallest convex shape that contains them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ConvexHullExample(Scene):\n    def construct(self):\n        points = [\n            [-2.35, -2.25, 0],\n            [1.65, -2.25, 0],\n            [2.65, -0.25, 0],\n            [1.65, 1.75, 0],\n            [-0.35, 2.75, 0],\n            [-2.35, 0.75, 0],\n            [-0.35, -1.25, 0],\n            [0.65, -0.25, 0],\n            [-1.35, 0.25, 0],\n            [0.15, 0.75, 0]\n        ]\n        hull = ConvexHull(*points, color=BLUE)\n        dots = VGroup(*[Dot(point) for point in points])\n        self.add(hull)\n        self.add(dots)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display ten dots scattered across the screen, each representing a point in 2D space. A blue convex polygon (convex hull) is drawn around the outermost points, enclosing all the dots and illustrating the smallest convex shape that contains them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Which algorithms provide the most efficient path to predict protein folding kinetics from sequence alone?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ProteinFoldingExplainer(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unfolding Mysteries: Predicting Protein Structures\")\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction\n        intro = Text(\"Proteins fold from linear chains to 3D structures\", font_size=24)\n        intro.next_to(title, DOWN, buff=1)\n        self.play(Write(intro))\n        self.wait(1)\n        \n        # Element 1: Linear chain to folded structure\n        # Create 6 circles in a line representing amino acids\n        circles = VGroup()\n        for i in range(6):\n            circle = Circle(radius=0.2, color=BLUE)\n            circle.move_to([i*0.5 - 1.25, -1, 0])\n            circles.add(circle)\n        \n        self.play(Create(circles))\n        self.wait(1)\n        \n        # Transform to a circular arrangement (folded structure)\n        folded_circles = VGroup()\n        for i in range(6):\n            angle = i * 2 * PI / 6\n            circle = Circle(radius=0.2, color=BLUE)\n            circle.move_to([np.cos(angle), np.sin(angle) - 1, 0])\n            folded_circles.add(circle)\n        \n        self.play(Transform(circles, folded_circles))\n        self.wait(1)\n        \n        # Clear for next section\n        self.play(FadeOut(circles), FadeOut(intro))\n        \n        # Element 2: Folding funnel visualization\n        funnel_title = Text(\"The Folding Funnel\", font_size=24)\n        funnel_title.next_to(title, DOWN, buff=1)\n        self.play(Write(funnel_title))\n        \n        # Simple funnel shape\n        top_line = Line([-2, 0, 0], [2, 0, 0], color=BLUE)\n        left_line = Line([-2, 0, 0], [-0.5, -2, 0], color=BLUE)\n        right_line = Line([2, 0, 0], [0.5, -2, 0], color=BLUE)\n        bottom_line = Line([-0.5, -2, 0], [0.5, -2, 0], color=BLUE)\n        \n        funnel = VGroup(top_line, left_line, right_line, bottom_line)\n        funnel.next_to(funnel_title, DOWN, buff=0.5)\n        \n        self.play(Create(funnel))\n        self.wait(1)\n        \n        # Energy equation\n        energy_eq = MathTex(r\"E_{total} = E_{bond} + E_{angle} + E_{torsion} + E_{non-bond}\")\n        energy_eq.scale(0.7)\n        energy_eq.next_to(funnel, DOWN, buff=0.5)\n        \n        self.play(Write(energy_eq))\n        self.wait(1)\n        \n        # Clear for next section\n        self.play(FadeOut(funnel_title), FadeOut(funnel), FadeOut(energy_eq))\n        \n        # Element 3: Monte Carlo simulations\n        mc_title = Text(\"Monte Carlo Simulations\", font_size=24)\n        mc_title.next_to(title, DOWN, buff=1)\n        self.play(Write(mc_title))\n        \n        # Probability equation\n        prob_eq = MathTex(r\"P_{state} = \\frac{1}{Z}e^{-\\frac{E(state)}{kT}}\")\n        prob_eq.scale(0.7)\n        prob_eq.next_to(mc_title, DOWN, buff=1)\n        \n        self.play(Write(prob_eq))\n        self.wait(1)\n        \n        # Clear for conclusion\n        self.play(FadeOut(mc_title), FadeOut(prob_eq))\n        \n        # Element 4: Conclusion\n        conclusion = Text(\"Advancing Drug Design and Medicine\", font_size=24)\n        conclusion.next_to(title, DOWN, buff=1)\n        self.play(Write(conclusion))\n        \n        # Simple protein and drug visualization\n        protein = Circle(radius=0.8, color=BLUE)\n        protein.move_to(LEFT*2)\n        \n        drug = Square(side_length=0.6, color=GREEN)\n        drug.move_to(RIGHT*2)\n        \n        self.play(Create(protein), Create(drug))\n        self.wait(1)\n        \n        arrow = Arrow(protein.get_right(), drug.get_left(), color=YELLOW)\n        self.play(Create(arrow))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            FadeOut(title),\n            FadeOut(conclusion),\n            FadeOut(protein),\n            FadeOut(drug),\n            FadeOut(arrow)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Which algorithms provide the most efficient path to predict protein folding kinetics from sequence alone?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: which algorithms provide the most efficient path to predict protein folding kinetics from sequence alone?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ProteinFoldingExplainer(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unfolding Mysteries: Predicting Protein Structures\")\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction\n        intro = Text(\"Proteins fold from linear chains to 3D structures\", font_size=24)\n        intro.next_to(title, DOWN, buff=1)\n        self.play(Write(intro))\n        self.wait(1)\n        \n        # Element 1: Linear chain to folded structure\n        # Create 6 circles in a line representing amino acids\n        circles = VGroup()\n        for i in range(6):\n            circle = Circle(radius=0.2, color=BLUE)\n            circle.move_to([i*0.5 - 1.25, -1, 0])\n            circles.add(circle)\n        \n        self.play(Create(circles))\n        self.wait(1)\n        \n        # Transform to a circular arrangement (folded structure)\n        folded_circles = VGroup()\n        for i in range(6):\n            angle = i * 2 * PI / 6\n            circle = Circle(radius=0.2, color=BLUE)\n            circle.move_to([np.cos(angle), np.sin(angle) - 1, 0])\n            folded_circles.add(circle)\n        \n        self.play(Transform(circles, folded_circles))\n        self.wait(1)\n        \n        # Clear for next section\n        self.play(FadeOut(circles), FadeOut(intro))\n        \n        # Element 2: Folding funnel visualization\n        funnel_title = Text(\"The Folding Funnel\", font_size=24)\n        funnel_title.next_to(title, DOWN, buff=1)\n        self.play(Write(funnel_title))\n        \n        # Simple funnel shape\n        top_line = Line([-2, 0, 0], [2, 0, 0], color=BLUE)\n        left_line = Line([-2, 0, 0], [-0.5, -2, 0], color=BLUE)\n        right_line = Line([2, 0, 0], [0.5, -2, 0], color=BLUE)\n        bottom_line = Line([-0.5, -2, 0], [0.5, -2, 0], color=BLUE)\n        \n        funnel = VGroup(top_line, left_line, right_line, bottom_line)\n        funnel.next_to(funnel_title, DOWN, buff=0.5)\n        \n        self.play(Create(funnel))\n        self.wait(1)\n        \n        # Energy equation\n        energy_eq = MathTex(r\"E_{total} = E_{bond} + E_{angle} + E_{torsion} + E_{non-bond}\")\n        energy_eq.scale(0.7)\n        energy_eq.next_to(funnel, DOWN, buff=0.5)\n        \n        self.play(Write(energy_eq))\n        self.wait(1)\n        \n        # Clear for next section\n        self.play(FadeOut(funnel_title), FadeOut(funnel), FadeOut(energy_eq))\n        \n        # Element 3: Monte Carlo simulations\n        mc_title = Text(\"Monte Carlo Simulations\", font_size=24)\n        mc_title.next_to(title, DOWN, buff=1)\n        self.play(Write(mc_title))\n        \n        # Probability equation\n        prob_eq = MathTex(r\"P_{state} = \\frac{1}{Z}e^{-\\frac{E(state)}{kT}}\")\n        prob_eq.scale(0.7)\n        prob_eq.next_to(mc_title, DOWN, buff=1)\n        \n        self.play(Write(prob_eq))\n        self.wait(1)\n        \n        # Clear for conclusion\n        self.play(FadeOut(mc_title), FadeOut(prob_eq))\n        \n        # Element 4: Conclusion\n        conclusion = Text(\"Advancing Drug Design and Medicine\", font_size=24)\n        conclusion.next_to(title, DOWN, buff=1)\n        self.play(Write(conclusion))\n        \n        # Simple protein and drug visualization\n        protein = Circle(radius=0.8, color=BLUE)\n        protein.move_to(LEFT*2)\n        \n        drug = Square(side_length=0.6, color=GREEN)\n        drug.move_to(RIGHT*2)\n        \n        self.play(Create(protein), Create(drug))\n        self.wait(1)\n        \n        arrow = Arrow(protein.get_right(), drug.get_left(), color=YELLOW)\n        self.play(Create(arrow))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            FadeOut(title),\n            FadeOut(conclusion),\n            FadeOut(protein),\n            FadeOut(drug),\n            FadeOut(arrow)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Which algorithms provide the most efficient path to predict protein folding kinetics from sequence alone?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what way can the topology of a Lie group aid in understanding the symmetry of its algebraic structure?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LieGroupTopology(Scene):\n    def construct(self):\n        # Define colors\n        blue = \"#3333FF\"\n        gold = \"#FFD700\"\n        white = \"#FFFFFF\"\n        \n        # Title\n        title = Text(\"The Manifold Symphony\", font_size=40, color=blue)\n        subtitle = Text(\"Understanding Lie Groups Through Topology\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introduction\n        intro_text = Text(\"Welcome to the world of Lie Groups\", font_size=36, color=blue)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Element 1: Rotating circle to demonstrate symmetry\n        circle_text = Text(\"Imagine a perfect circle...\", font_size=30)\n        circle_text.to_edge(UP)\n        circle = Circle(radius=2, color=blue)\n        \n        self.play(Write(circle_text))\n        self.play(Create(circle))\n        \n        # Add arrows to indicate rotation\n        arrow = Arrow(start=RIGHT*1.5, end=RIGHT*1.5+UP*0.5, color=gold)\n        arrow_text = Text(\"Rotation = Symmetry\", font_size=24, color=gold)\n        arrow_text.next_to(arrow, RIGHT)\n        \n        self.play(Create(arrow), Write(arrow_text))\n        self.wait(0.5)\n        \n        # Animate rotation\n        self.play(Rotate(circle, angle=PI, about_point=ORIGIN), \n                 Rotate(arrow, angle=PI, about_point=ORIGIN))\n        self.wait(0.5)\n        self.play(FadeOut(arrow), FadeOut(arrow_text), FadeOut(circle_text))\n        \n        # Element 2: Matrix transformation\n        matrix_text = Text(\"These symmetries can be represented by matrices\", font_size=30)\n        matrix_text.to_edge(UP)\n        \n        matrix_eq = MathTex(r\"\\begin{bmatrix} \\cos(\\theta) & -\\sin(\\theta) \\\\ \\sin(\\theta) & \\cos(\\theta) \\end{bmatrix}\")\n        matrix_eq.next_to(matrix_text, DOWN, buff=1)\n        \n        self.play(Write(matrix_text))\n        self.play(FadeOut(circle), Create(matrix_eq))\n        self.wait(1)\n        \n        # Element 3: Continuous transformations\n        transform_text = Text(\"Lie Groups allow continuous transformations\", font_size=30)\n        transform_text.to_edge(UP)\n        \n        self.play(FadeOut(matrix_text), FadeOut(matrix_eq), Write(transform_text))\n        \n        square = Square(side_length=2, color=blue)\n        self.play(Create(square))\n        \n        # Show transformations\n        self.play(square.animate.scale(1.5).rotate(PI/4))\n        self.play(square.animate.scale(0.8).rotate(-PI/3))\n        \n        # Element 4: Topology ensures continuity\n        self.play(FadeOut(square), FadeOut(transform_text))\n        \n        continuity_text = Text(\"Topology ensures transformations are continuous\", font_size=30)\n        continuity_text.to_edge(UP)\n        \n        # Simple representation of a continuous path - a line that bends into a loop\n        line = Line(start=LEFT*3, end=RIGHT*3, color=blue)\n        self.play(Write(continuity_text))\n        self.play(Create(line))\n        \n        # Transform line into a circle to represent continuity\n        circle2 = Circle(radius=2, color=blue)\n        self.play(Transform(line, circle2))\n        \n        # Add equation\n        continuity_eq = MathTex(r\"\\sigma: G \\to G\")\n        continuity_eq.next_to(continuity_text, DOWN, buff=1)\n        self.play(Create(continuity_eq))\n        self.wait(1)\n        \n        # Element 5: Algebraic symmetry - Key Insight\n        self.play(FadeOut(continuity_text), FadeOut(line), FadeOut(continuity_eq))\n        \n        insight_text = Text(\"Key Insight:\", font_size=36, color=gold)\n        insight_text.to_edge(UP)\n        \n        symmetry_text = Text(\"The topology reveals algebraic symmetries\", font_size=30)\n        symmetry_text.next_to(insight_text, DOWN, buff=0.5)\n        \n        formula = MathTex(r\"\\forall g, h \\in G: g \\cdot h \\in G\")\n        formula.next_to(symmetry_text, DOWN, buff=1)\n        \n        self.play(Write(insight_text))\n        self.play(Write(symmetry_text))\n        self.wait(0.5)\n        self.play(Create(formula))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(insight_text), FadeOut(symmetry_text), FadeOut(formula))\n        \n        conclusion = Text(\"The intertwining of topology and algebra\", font_size=32, color=blue)\n        conclusion2 = Text(\"illuminates the symmetries of Lie Groups\", font_size=32, color=blue)\n        conclusion2.next_to(conclusion, DOWN)\n        \n        self.play(Write(conclusion))\n        self.play(Write(conclusion2))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(conclusion2))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way can the topology of a Lie group aid in understanding the symmetry of its algebraic structure?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what way can the topology of a lie group aid in understanding the symmetry of its algebraic structure?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LieGroupTopology(Scene):\n    def construct(self):\n        # Define colors\n        blue = \"#3333FF\"\n        gold = \"#FFD700\"\n        white = \"#FFFFFF\"\n        \n        # Title\n        title = Text(\"The Manifold Symphony\", font_size=40, color=blue)\n        subtitle = Text(\"Understanding Lie Groups Through Topology\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introduction\n        intro_text = Text(\"Welcome to the world of Lie Groups\", font_size=36, color=blue)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Element 1: Rotating circle to demonstrate symmetry\n        circle_text = Text(\"Imagine a perfect circle...\", font_size=30)\n        circle_text.to_edge(UP)\n        circle = Circle(radius=2, color=blue)\n        \n        self.play(Write(circle_text))\n        self.play(Create(circle))\n        \n        # Add arrows to indicate rotation\n        arrow = Arrow(start=RIGHT*1.5, end=RIGHT*1.5+UP*0.5, color=gold)\n        arrow_text = Text(\"Rotation = Symmetry\", font_size=24, color=gold)\n        arrow_text.next_to(arrow, RIGHT)\n        \n        self.play(Create(arrow), Write(arrow_text))\n        self.wait(0.5)\n        \n        # Animate rotation\n        self.play(Rotate(circle, angle=PI, about_point=ORIGIN), \n                 Rotate(arrow, angle=PI, about_point=ORIGIN))\n        self.wait(0.5)\n        self.play(FadeOut(arrow), FadeOut(arrow_text), FadeOut(circle_text))\n        \n        # Element 2: Matrix transformation\n        matrix_text = Text(\"These symmetries can be represented by matrices\", font_size=30)\n        matrix_text.to_edge(UP)\n        \n        matrix_eq = MathTex(r\"\\begin{bmatrix} \\cos(\\theta) & -\\sin(\\theta) \\\\ \\sin(\\theta) & \\cos(\\theta) \\end{bmatrix}\")\n        matrix_eq.next_to(matrix_text, DOWN, buff=1)\n        \n        self.play(Write(matrix_text))\n        self.play(FadeOut(circle), Create(matrix_eq))\n        self.wait(1)\n        \n        # Element 3: Continuous transformations\n        transform_text = Text(\"Lie Groups allow continuous transformations\", font_size=30)\n        transform_text.to_edge(UP)\n        \n        self.play(FadeOut(matrix_text), FadeOut(matrix_eq), Write(transform_text))\n        \n        square = Square(side_length=2, color=blue)\n        self.play(Create(square))\n        \n        # Show transformations\n        self.play(square.animate.scale(1.5).rotate(PI/4))\n        self.play(square.animate.scale(0.8).rotate(-PI/3))\n        \n        # Element 4: Topology ensures continuity\n        self.play(FadeOut(square), FadeOut(transform_text))\n        \n        continuity_text = Text(\"Topology ensures transformations are continuous\", font_size=30)\n        continuity_text.to_edge(UP)\n        \n        # Simple representation of a continuous path - a line that bends into a loop\n        line = Line(start=LEFT*3, end=RIGHT*3, color=blue)\n        self.play(Write(continuity_text))\n        self.play(Create(line))\n        \n        # Transform line into a circle to represent continuity\n        circle2 = Circle(radius=2, color=blue)\n        self.play(Transform(line, circle2))\n        \n        # Add equation\n        continuity_eq = MathTex(r\"\\sigma: G \\to G\")\n        continuity_eq.next_to(continuity_text, DOWN, buff=1)\n        self.play(Create(continuity_eq))\n        self.wait(1)\n        \n        # Element 5: Algebraic symmetry - Key Insight\n        self.play(FadeOut(continuity_text), FadeOut(line), FadeOut(continuity_eq))\n        \n        insight_text = Text(\"Key Insight:\", font_size=36, color=gold)\n        insight_text.to_edge(UP)\n        \n        symmetry_text = Text(\"The topology reveals algebraic symmetries\", font_size=30)\n        symmetry_text.next_to(insight_text, DOWN, buff=0.5)\n        \n        formula = MathTex(r\"\\forall g, h \\in G: g \\cdot h \\in G\")\n        formula.next_to(symmetry_text, DOWN, buff=1)\n        \n        self.play(Write(insight_text))\n        self.play(Write(symmetry_text))\n        self.wait(0.5)\n        self.play(Create(formula))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(insight_text), FadeOut(symmetry_text), FadeOut(formula))\n        \n        conclusion = Text(\"The intertwining of topology and algebra\", font_size=32, color=blue)\n        conclusion2 = Text(\"illuminates the symmetries of Lie Groups\", font_size=32, color=blue)\n        conclusion2.next_to(conclusion, DOWN)\n        \n        self.play(Write(conclusion))\n        self.play(Write(conclusion2))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(conclusion2))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way can the topology of a Lie group aid in understanding the symmetry of its algebraic structure?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that shows the process of chemical bonding between an oxygen atom and a metal atom. The animation should start by showing the oxygen atom at the top of the screen and the metal atom appearing below it. Then, it should depict a bond forming between the oxygen and the metal atom, followed by a second bond forming from the bottom of the metal atom to the edge of the screen. Once the bonds are formed, the resulting molecule should move to the right and then back to its original position. Lastly, I want to introduce an electron into the scene, have it appear from the center, and then have all the elements and bonds fade away at the end. Can you do this in a simple, visually engaging way that would be suitable for a classroom setting?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        curve_label = MathTex(r\"f(x) = x^2\")\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        # Drawing the curve\n        curve_graph = FunctionGraph(lambda x: x**2, x_range=[-3, 3])\n        self.play(Create(curve_graph))\n        self.wait(2)\n\n        # Indicating the area under the curve\n        area_label = Text(\"Calculate the area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Shading the area\n        area = area = self.get_area(curve_graph, (1, 2), color=[BLUE, GREEN], opacity=0.5)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Integral representation\n        integral = MathTex(r\"\\int_{1}^{2} x^2 \\,dx\")\n        self.play(Transform(area_label, integral))\n        self.wait(2)\n\n        # Calculation\n        calculated_area = MathTex(r\"=\\frac{1}{3}\\left[2^3 - 1^3\\right]\").to_edge(DOWN)\n        self.play(Write(calculated_area))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\frac{1}{3}(8 - 1) = \\frac{7}{3}\")\n        self.play(ReplacementTransform(calculated_area, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that shows the process of chemical bonding between an oxygen atom and a metal atom. The animation should start by showing the oxygen atom at the top of the screen and the metal atom appearing below it. Then, it should depict a bond forming between the oxygen and the metal atom, followed by a second bond forming from the bottom of the metal atom to the edge of the screen. Once the bonds are formed, the resulting molecule should move to the right and then back to its original position. Lastly, I want to introduce an electron into the scene, have it appear from the center, and then have all the elements and bonds fade away at the end. Can you do this in a simple, visually engaging way that would be suitable for a classroom setting?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that shows the process of chemical bonding between an oxygen atom and a metal atom. the animation should start by showing the oxygen atom at the top of the screen and the metal atom appearing below it. then, it should depict a bond forming between the oxygen and the metal atom, followed by a second bond forming from the bottom of the metal atom to the edge of the screen. once the bonds are formed, the resulting molecule should move to the right and then back to its original position. lastly, i want to introduce an electron into the scene, have it appear from the center, and then have all the elements and bonds fade away at the end. can you do this in a simple, visually engaging way that would be suitable for a classroom setting?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function\n        curve_label = MathTex(r\"f(x) = x^2\")\n        self.play(Write(curve_label))\n        self.wait(1)\n\n        # Drawing the curve\n        curve_graph = FunctionGraph(lambda x: x**2, x_range=[-3, 3])\n        self.play(Create(curve_graph))\n        self.wait(2)\n\n        # Indicating the area under the curve\n        area_label = Text(\"Calculate the area under the curve from x=1 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(area_label))\n        self.wait(2)\n\n        # Shading the area\n        area = area = self.get_area(curve_graph, (1, 2), color=[BLUE, GREEN], opacity=0.5)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Integral representation\n        integral = MathTex(r\"\\int_{1}^{2} x^2 \\,dx\")\n        self.play(Transform(area_label, integral))\n        self.wait(2)\n\n        # Calculation\n        calculated_area = MathTex(r\"=\\frac{1}{3}\\left[2^3 - 1^3\\right]\").to_edge(DOWN)\n        self.play(Write(calculated_area))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\frac{1}{3}(8 - 1) = \\frac{7}{3}\")\n        self.play(ReplacementTransform(calculated_area, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that shows the process of chemical bonding between an oxygen atom and a metal atom. The animation should start by showing the oxygen atom at the top of the screen and the metal atom appearing below it. Then, it should depict a bond forming between the oxygen and the metal atom, followed by a second bond forming from the bottom of the metal atom to the edge of the screen. Once the bonds are formed, the resulting molecule should move to the right and then back to its original position. Lastly, I want to introduce an electron into the scene, have it appear from the center, and then have all the elements and bonds fade away at the end. Can you do this in a simple, visually engaging way that would be suitable for a classroom setting?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can Alexander Duality be used to prove the existence of essential loops in the complement of a knot in \u007fR^3\u007f?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AlexanderDualityKnots(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Essential Loops with Alexander Duality\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Introduce a simplified knot (represented as a circle)\n        knot = Circle(radius=1.0, color=WHITE)\n        self.play(Create(knot))\n        \n        knot_label = Text(\"Knot\").next_to(knot, DOWN)\n        self.play(Write(knot_label))\n        \n        # Explain the concept of knot complement\n        complement = Text(\"Knot Complement\").next_to(knot, RIGHT, buff=2)\n        arrow = Arrow(knot.get_right(), complement.get_left())\n        self.play(Write(complement), GrowArrow(arrow))\n        self.wait(1)\n        \n        # Show an essential loop around the knot\n        loop = Circle(radius=1.5, color=YELLOW)\n        self.play(Create(loop))\n        \n        loop_label = Text(\"Essential Loop\", color=YELLOW).next_to(loop, UP)\n        self.play(Write(loop_label))\n        self.wait(1)\n        \n        # Clear some elements to focus on Alexander Duality\n        self.play(\n            FadeOut(knot_label),\n            FadeOut(complement),\n            FadeOut(arrow),\n            FadeOut(loop_label)\n        )\n        \n        # Introduce Alexander Duality\n        duality_text = Text(\"Alexander Duality\").next_to(title, DOWN, buff=1)\n        self.play(Write(duality_text))\n        \n        # Show the Alexander Duality equation\n        equation = MathTex(\"H_n(X^c) \\\\cong \\\\tilde{H}^{n-1}(X)\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Highlight the key insight about essential loops\n        insight = Text(\"This proves essential loops exist!\").next_to(equation, DOWN)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclude the animation\n        self.play(\n            FadeOut(knot),\n            FadeOut(loop),\n            FadeOut(duality_text),\n            FadeOut(equation),\n            FadeOut(insight)\n        )\n        \n        # Show the final summary\n        conclusion = Text(\"Alexander Duality reveals\\nthe topology of knot complements\")\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can Alexander Duality be used to prove the existence of essential loops in the complement of a knot in \u007fR^3\u007f?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can alexander duality be used to prove the existence of essential loops in the complement of a knot in \u007fr^3\u007f?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AlexanderDualityKnots(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Essential Loops with Alexander Duality\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Introduce a simplified knot (represented as a circle)\n        knot = Circle(radius=1.0, color=WHITE)\n        self.play(Create(knot))\n        \n        knot_label = Text(\"Knot\").next_to(knot, DOWN)\n        self.play(Write(knot_label))\n        \n        # Explain the concept of knot complement\n        complement = Text(\"Knot Complement\").next_to(knot, RIGHT, buff=2)\n        arrow = Arrow(knot.get_right(), complement.get_left())\n        self.play(Write(complement), GrowArrow(arrow))\n        self.wait(1)\n        \n        # Show an essential loop around the knot\n        loop = Circle(radius=1.5, color=YELLOW)\n        self.play(Create(loop))\n        \n        loop_label = Text(\"Essential Loop\", color=YELLOW).next_to(loop, UP)\n        self.play(Write(loop_label))\n        self.wait(1)\n        \n        # Clear some elements to focus on Alexander Duality\n        self.play(\n            FadeOut(knot_label),\n            FadeOut(complement),\n            FadeOut(arrow),\n            FadeOut(loop_label)\n        )\n        \n        # Introduce Alexander Duality\n        duality_text = Text(\"Alexander Duality\").next_to(title, DOWN, buff=1)\n        self.play(Write(duality_text))\n        \n        # Show the Alexander Duality equation\n        equation = MathTex(\"H_n(X^c) \\\\cong \\\\tilde{H}^{n-1}(X)\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Highlight the key insight about essential loops\n        insight = Text(\"This proves essential loops exist!\").next_to(equation, DOWN)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclude the animation\n        self.play(\n            FadeOut(knot),\n            FadeOut(loop),\n            FadeOut(duality_text),\n            FadeOut(equation),\n            FadeOut(insight)\n        )\n        \n        # Show the final summary\n        conclusion = Text(\"Alexander Duality reveals\\nthe topology of knot complements\")\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can Alexander Duality be used to prove the existence of essential loops in the complement of a knot in \u007fR^3\u007f?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_embedding_layer.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network.layers.embedding import EmbeddingLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass EmbeddingNNScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer()\n\n        neural_network = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        self.play(Create(neural_network))\n\n        self.play(neural_network.make_forward_pass_animation(run_time=5))\n\n\nclass TripletEmbeddingNNScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer()\n\n        neural_network = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        self.play(Create(neural_network))\n\n        self.play(\n            neural_network.make_forward_pass_animation(\n                layer_args={\n                    embedding_layer: {\n                        \"triplet_args\": {\n                            \"anchor_dist\": {\n                                \"cov\": np.array([[0.3, 0], [0, 0.3]]),\n                                \"mean\": np.array([0.7, 1.4]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": BLUE,\n                            },\n                            \"positive_dist\": {\n                                \"cov\": np.array([[0.2, 0], [0, 0.2]]),\n                                \"mean\": np.array([0.8, -0.4]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": GREEN,\n                            },\n                            \"negative_dist\": {\n                                \"cov\": np.array([[0.4, 0], [0, 0.25]]),\n                                \"mean\": np.array([-1, -1.2]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": RED,\n                            },\n                        }\n                    }\n                },\n                run_time=5,\n            )\n        )\n\n\nclass QueryEmbeddingNNScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer()\n        embedding_layer.paired_query_mode = True\n\n        neural_network = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        self.play(Create(neural_network), run_time=2)\n\n        self.play(\n            neural_network.make_forward_pass_animation(\n                run_time=5,\n                layer_args={\n                    embedding_layer: {\n                        \"positive_dist_args\": {\n                            \"cov\": np.array([[1, 0], [0, 1]]),\n                            \"mean\": np.array([1, 1]),\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": GREEN,\n                        },\n                        \"negative_dist_args\": {\n                            \"cov\": np.array([[1, 0], [0, 1]]),\n                            \"mean\": np.array([-1, -1]),\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": RED,\n                        },\n                    }\n                },\n            )\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_embedding_layer.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_embedding_layer.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network.layers.embedding import EmbeddingLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass EmbeddingNNScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer()\n\n        neural_network = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        self.play(Create(neural_network))\n\n        self.play(neural_network.make_forward_pass_animation(run_time=5))\n\n\nclass TripletEmbeddingNNScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer()\n\n        neural_network = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        self.play(Create(neural_network))\n\n        self.play(\n            neural_network.make_forward_pass_animation(\n                layer_args={\n                    embedding_layer: {\n                        \"triplet_args\": {\n                            \"anchor_dist\": {\n                                \"cov\": np.array([[0.3, 0], [0, 0.3]]),\n                                \"mean\": np.array([0.7, 1.4]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": BLUE,\n                            },\n                            \"positive_dist\": {\n                                \"cov\": np.array([[0.2, 0], [0, 0.2]]),\n                                \"mean\": np.array([0.8, -0.4]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": GREEN,\n                            },\n                            \"negative_dist\": {\n                                \"cov\": np.array([[0.4, 0], [0, 0.25]]),\n                                \"mean\": np.array([-1, -1.2]),\n                                \"dist_theme\": \"ellipse\",\n                                \"color\": RED,\n                            },\n                        }\n                    }\n                },\n                run_time=5,\n            )\n        )\n\n\nclass QueryEmbeddingNNScene(Scene):\n    def construct(self):\n        embedding_layer = EmbeddingLayer()\n        embedding_layer.paired_query_mode = True\n\n        neural_network = NeuralNetwork(\n            [\n                FeedForwardLayer(5),\n                FeedForwardLayer(3),\n                embedding_layer,\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ]\n        )\n\n        self.play(Create(neural_network), run_time=2)\n\n        self.play(\n            neural_network.make_forward_pass_animation(\n                run_time=5,\n                layer_args={\n                    embedding_layer: {\n                        \"positive_dist_args\": {\n                            \"cov\": np.array([[1, 0], [0, 1]]),\n                            \"mean\": np.array([1, 1]),\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": GREEN,\n                        },\n                        \"negative_dist_args\": {\n                            \"cov\": np.array([[1, 0], [0, 1]]),\n                            \"mean\": np.array([-1, -1]),\n                            \"dist_theme\": \"ellipse\",\n                            \"color\": RED,\n                        },\n                    }\n                },\n            )\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_embedding_layer.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the level curves of a harmonic function be used to visualize its behavior and ensure the function remains constant across these curves?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicFunctionsScene(Scene):\n    def construct(self):\n        # Introduction - display the title\n        title = Text(\"Unveiling the Magic of Harmonic Functions\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Key concept 1 - explain what level curves are\n        explanation = Text(\"Level curves: where function values remain constant\", font_size=24)\n        self.play(Write(explanation))\n        self.wait(1.5)\n        self.play(FadeOut(explanation))\n        \n        # Visualization - create concentric circles to represent level curves\n        level_curves = VGroup(\n            Circle(radius=0.5, color=BLUE),\n            Circle(radius=1.0, color=BLUE),\n            Circle(radius=1.5, color=BLUE)\n        )\n        curves_label = Text(\"Level Curves\", font_size=24).to_edge(UP)\n        self.play(Create(level_curves), Write(curves_label))\n        self.wait(1)\n        \n        # Key concept 2 - introduce gradient vectors\n        # Create vectors pointing outward (perpendicular to level curves)\n        gradients = VGroup(\n            Arrow(start=0.5*RIGHT, end=RIGHT, color=RED),\n            Arrow(start=0.5*LEFT, end=LEFT, color=RED),\n            Arrow(start=0.5*UP, end=UP, color=RED),\n            Arrow(start=0.5*DOWN, end=DOWN, color=RED)\n        )\n        grad_label = Text(\"Gradient Vectors\", font_size=24).to_edge(DOWN)\n        self.play(Create(gradients), Write(grad_label))\n        self.wait(1.5)\n        \n        # Key insight - highlight the perpendicular relationship\n        insight = Text(\"Gradients are perpendicular to level curves\", font_size=24)\n        self.play(FadeOut(curves_label), FadeOut(grad_label))\n        self.play(Write(insight))\n        self.wait(1.5)\n        self.play(FadeOut(insight))\n        \n        # Key concept 3 - mathematical formulation\n        # First equation: orthogonality condition\n        equation = MathTex(r\"\\nabla u \\cdot \\nabla v = 0\")\n        eq_label = Text(\"Orthogonality Condition\", font_size=20).next_to(equation, UP)\n        self.play(Write(equation), Write(eq_label))\n        self.wait(1.5)\n        self.play(FadeOut(equation), FadeOut(eq_label))\n        \n        # Second equation: Laplace equation (defines harmonic functions)\n        laplace = MathTex(r\"\\Delta u = 0\")\n        laplace_label = Text(\"Laplace Equation\", font_size=20).next_to(laplace, UP)\n        self.play(Write(laplace), Write(laplace_label))\n        self.wait(1.5)\n        \n        # Conclusion - wrap up the key learning\n        self.play(FadeOut(laplace), FadeOut(laplace_label), \n                 FadeOut(level_curves), FadeOut(gradients))\n        conclusion = Text(\"Level curves help visualize how\\nharmonic functions behave\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the level curves of a harmonic function be used to visualize its behavior and ensure the function remains constant across these curves?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the level curves of a harmonic function be used to visualize its behavior and ensure the function remains constant across these curves?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicFunctionsScene(Scene):\n    def construct(self):\n        # Introduction - display the title\n        title = Text(\"Unveiling the Magic of Harmonic Functions\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Key concept 1 - explain what level curves are\n        explanation = Text(\"Level curves: where function values remain constant\", font_size=24)\n        self.play(Write(explanation))\n        self.wait(1.5)\n        self.play(FadeOut(explanation))\n        \n        # Visualization - create concentric circles to represent level curves\n        level_curves = VGroup(\n            Circle(radius=0.5, color=BLUE),\n            Circle(radius=1.0, color=BLUE),\n            Circle(radius=1.5, color=BLUE)\n        )\n        curves_label = Text(\"Level Curves\", font_size=24).to_edge(UP)\n        self.play(Create(level_curves), Write(curves_label))\n        self.wait(1)\n        \n        # Key concept 2 - introduce gradient vectors\n        # Create vectors pointing outward (perpendicular to level curves)\n        gradients = VGroup(\n            Arrow(start=0.5*RIGHT, end=RIGHT, color=RED),\n            Arrow(start=0.5*LEFT, end=LEFT, color=RED),\n            Arrow(start=0.5*UP, end=UP, color=RED),\n            Arrow(start=0.5*DOWN, end=DOWN, color=RED)\n        )\n        grad_label = Text(\"Gradient Vectors\", font_size=24).to_edge(DOWN)\n        self.play(Create(gradients), Write(grad_label))\n        self.wait(1.5)\n        \n        # Key insight - highlight the perpendicular relationship\n        insight = Text(\"Gradients are perpendicular to level curves\", font_size=24)\n        self.play(FadeOut(curves_label), FadeOut(grad_label))\n        self.play(Write(insight))\n        self.wait(1.5)\n        self.play(FadeOut(insight))\n        \n        # Key concept 3 - mathematical formulation\n        # First equation: orthogonality condition\n        equation = MathTex(r\"\\nabla u \\cdot \\nabla v = 0\")\n        eq_label = Text(\"Orthogonality Condition\", font_size=20).next_to(equation, UP)\n        self.play(Write(equation), Write(eq_label))\n        self.wait(1.5)\n        self.play(FadeOut(equation), FadeOut(eq_label))\n        \n        # Second equation: Laplace equation (defines harmonic functions)\n        laplace = MathTex(r\"\\Delta u = 0\")\n        laplace_label = Text(\"Laplace Equation\", font_size=20).next_to(laplace, UP)\n        self.play(Write(laplace), Write(laplace_label))\n        self.wait(1.5)\n        \n        # Conclusion - wrap up the key learning\n        self.play(FadeOut(laplace), FadeOut(laplace_label), \n                 FadeOut(level_curves), FadeOut(gradients))\n        conclusion = Text(\"Level curves help visualize how\\nharmonic functions behave\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the level curves of a harmonic function be used to visualize its behavior and ensure the function remains constant across these curves?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a set of axes with labels \\(\\Delta Q\\) for the x-axis and \\(T[^\\circ C]\\) for the y-axis. Plot a line graph with points at (0, 20), (8, 0), (38, 0), and (39, -5)."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a set of axes with labels \\(\\Delta Q\\) for the x-axis and \\(T[^\\circ C]\\) for the y-axis. Plot a line graph with points at (0, 20), (8, 0), (38, 0), and (39, -5)."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a set of axes with labels \\(\\delta q\\) for the x-axis and \\(t[^\\circ c]\\) for the y-axis. plot a line graph with points at (0, 20), (8, 0), (38, 0), and (39, -5)."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeatDiagramPlot(Scene):\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 40, 5],\n            y_range=[-8, 32, 5],\n            x_length=9,\n            y_length=6,\n            x_axis_config={\"numbers_to_include\": np.arange(0, 40, 5)},\n            y_axis_config={\"numbers_to_include\": np.arange(-5, 34, 5)},\n            tips=False,\n        )\n        labels = ax.get_axis_labels(\n            x_label=Tex(r\"$\\Delta Q$\"), y_label=Tex(r\"T[$^\\circ C$]\")\n        )\n\n        x_vals = [0, 8, 38, 39]\n        y_vals = [20, 0, 0, -5]\n        graph = ax.plot_line_graph(x_values=x_vals, y_values=y_vals)\n\n        self.add(ax, labels, graph)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a set of axes with labels \\(\\Delta Q\\) for the x-axis and \\(T[^\\circ C]\\) for the y-axis. Plot a line graph with points at (0, 20), (8, 0), (38, 0), and (39, -5)."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the concept of a monopole in a Yang-Mills field be visualized using topology?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MonopoleVisualization(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Visualizing Monopoles: Topology in Yang-Mills Theories\")\n        title.set_color(BLUE_C)\n        title.scale(0.8)\n        \n        # Display title\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction - Field visualization\n        field_intro = Text(\"Topological Defects in Field Theories\")\n        field_intro.set_color(BLUE_D)\n        field_intro.scale(0.7)\n        \n        self.play(FadeIn(field_intro))\n        self.wait(1)\n        self.play(FadeOut(field_intro))\n        \n        # Simple field representation with arrows\n        field = VGroup()\n        # Create a grid of arrows representing a field\n        for x in range(-2, 3):\n            for y in range(-2, 3):\n                # Skip center point\n                if x == 0 and y == 0:\n                    continue\n                # Calculate direction (away from center)\n                start_point = np.array([x, y, 0])\n                direction = start_point / np.sqrt(x**2 + y**2)\n                arrow = Arrow(\n                    start=start_point,\n                    end=start_point + 0.5 * direction,\n                    buff=0,\n                    color=BLUE\n                )\n                field.add(arrow)\n        \n        # Show the field\n        self.play(Create(field))\n        self.wait(1)\n        \n        # Add a sphere (circle in 2D) at the center\n        sphere = Circle(radius=1.0, color=WHITE)\n        sphere.set_fill(WHITE, opacity=0.2)\n        sphere_label = Text(\"Sphere in Field\")\n        sphere_label.set_color(WHITE)\n        sphere_label.scale(0.6)\n        sphere_label.next_to(sphere, UP)\n        \n        self.play(Create(sphere), Write(sphere_label))\n        self.wait(1)\n        \n        # Sphere changes color to represent interaction with field\n        colored_sphere = Circle(radius=1.0, color=GOLD)\n        colored_sphere.set_fill(GOLD, opacity=0.3)\n        \n        self.play(Transform(sphere, colored_sphere))\n        self.wait(1)\n        \n        # Create a monopole visualization (as a point on the sphere)\n        monopole_point = Dot(point=RIGHT * 0.7 + UP * 0.7, color=RED)\n        monopole_label = Text(\"Monopole\")\n        monopole_label.set_color(RED)\n        monopole_label.scale(0.6)\n        monopole_label.next_to(monopole_point, UR)\n        \n        self.play(Create(monopole_point), Write(monopole_label))\n        self.wait(1)\n        \n        # Indicate the topological nature\n        topo_label = Text(\"Non-trivial Topology\")\n        topo_label.set_color(GOLD)\n        topo_label.scale(0.6)\n        topo_label.to_edge(DOWN)\n        \n        self.play(Write(topo_label))\n        self.wait(1)\n        \n        # Clear the current visualization\n        self.play(\n            FadeOut(sphere),\n            FadeOut(sphere_label),\n            FadeOut(monopole_point),\n            FadeOut(monopole_label),\n            FadeOut(topo_label),\n            FadeOut(field)\n        )\n        \n        # Show the key equations - using simplified text format\n        eq1 = Text(\"\u2207 \u00d7 A = B (Magnetic Field)\")\n        eq2 = Text(\"\u03c0\u2082(Group Manifold) = \u2124 (Homotopy Group)\")\n        \n        eq1.scale(0.7)\n        eq2.scale(0.7)\n        \n        eq1.shift(UP * 0.5)\n        eq2.shift(DOWN * 0.5)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        conclusion = Text(\"Topological defects reveal the fabric of reality\")\n        conclusion.set_color(GOLD)\n        conclusion.scale(0.7)\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the concept of a monopole in a Yang-Mills field be visualized using topology?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the concept of a monopole in a yang-mills field be visualized using topology?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MonopoleVisualization(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Visualizing Monopoles: Topology in Yang-Mills Theories\")\n        title.set_color(BLUE_C)\n        title.scale(0.8)\n        \n        # Display title\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction - Field visualization\n        field_intro = Text(\"Topological Defects in Field Theories\")\n        field_intro.set_color(BLUE_D)\n        field_intro.scale(0.7)\n        \n        self.play(FadeIn(field_intro))\n        self.wait(1)\n        self.play(FadeOut(field_intro))\n        \n        # Simple field representation with arrows\n        field = VGroup()\n        # Create a grid of arrows representing a field\n        for x in range(-2, 3):\n            for y in range(-2, 3):\n                # Skip center point\n                if x == 0 and y == 0:\n                    continue\n                # Calculate direction (away from center)\n                start_point = np.array([x, y, 0])\n                direction = start_point / np.sqrt(x**2 + y**2)\n                arrow = Arrow(\n                    start=start_point,\n                    end=start_point + 0.5 * direction,\n                    buff=0,\n                    color=BLUE\n                )\n                field.add(arrow)\n        \n        # Show the field\n        self.play(Create(field))\n        self.wait(1)\n        \n        # Add a sphere (circle in 2D) at the center\n        sphere = Circle(radius=1.0, color=WHITE)\n        sphere.set_fill(WHITE, opacity=0.2)\n        sphere_label = Text(\"Sphere in Field\")\n        sphere_label.set_color(WHITE)\n        sphere_label.scale(0.6)\n        sphere_label.next_to(sphere, UP)\n        \n        self.play(Create(sphere), Write(sphere_label))\n        self.wait(1)\n        \n        # Sphere changes color to represent interaction with field\n        colored_sphere = Circle(radius=1.0, color=GOLD)\n        colored_sphere.set_fill(GOLD, opacity=0.3)\n        \n        self.play(Transform(sphere, colored_sphere))\n        self.wait(1)\n        \n        # Create a monopole visualization (as a point on the sphere)\n        monopole_point = Dot(point=RIGHT * 0.7 + UP * 0.7, color=RED)\n        monopole_label = Text(\"Monopole\")\n        monopole_label.set_color(RED)\n        monopole_label.scale(0.6)\n        monopole_label.next_to(monopole_point, UR)\n        \n        self.play(Create(monopole_point), Write(monopole_label))\n        self.wait(1)\n        \n        # Indicate the topological nature\n        topo_label = Text(\"Non-trivial Topology\")\n        topo_label.set_color(GOLD)\n        topo_label.scale(0.6)\n        topo_label.to_edge(DOWN)\n        \n        self.play(Write(topo_label))\n        self.wait(1)\n        \n        # Clear the current visualization\n        self.play(\n            FadeOut(sphere),\n            FadeOut(sphere_label),\n            FadeOut(monopole_point),\n            FadeOut(monopole_label),\n            FadeOut(topo_label),\n            FadeOut(field)\n        )\n        \n        # Show the key equations - using simplified text format\n        eq1 = Text(\"\u2207 \u00d7 A = B (Magnetic Field)\")\n        eq2 = Text(\"\u03c0\u2082(Group Manifold) = \u2124 (Homotopy Group)\")\n        \n        eq1.scale(0.7)\n        eq2.scale(0.7)\n        \n        eq1.shift(UP * 0.5)\n        eq2.shift(DOWN * 0.5)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        conclusion = Text(\"Topological defects reveal the fabric of reality\")\n        conclusion.set_color(GOLD)\n        conclusion.scale(0.7)\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the concept of a monopole in a Yang-Mills field be visualized using topology?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What visual strategies can highlight the smallest inducing set of nodes needed to reconstruct a unique graph?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphReconstructionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Secrets of Graph Reconstruction\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro_text = Text(\"Welcome to the world of graph theory!\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple graph with 5 nodes in a circular layout\n        graph = VGroup()\n        \n        # Create nodes\n        nodes = []\n        radius = 2\n        for i in range(5):\n            angle = i * 2 * PI / 5\n            point = radius * (np.cos(angle) * RIGHT + np.sin(angle) * UP)\n            node = Dot(point=point, radius=0.2, color=BLUE)\n            nodes.append(node)\n            graph.add(node)\n            \n            # Add node label\n            label = Text(str(i+1), font_size=20).move_to(node.get_center())\n            graph.add(label)\n        \n        # Create edges\n        edges = []\n        for i in range(5):\n            # Connect to adjacent nodes\n            edge = Line(nodes[i].get_center(), nodes[(i+1)%5].get_center(), color=WHITE)\n            edges.append(edge)\n            graph.add(edge)\n            \n            # Add some diagonal connections for a more interesting graph\n            if i % 2 == 0:\n                diag_edge = Line(nodes[i].get_center(), nodes[(i+2)%5].get_center(), color=WHITE)\n                edges.append(diag_edge)\n                graph.add(diag_edge)\n        \n        # Display the graph\n        self.play(Create(graph))\n        self.wait(1)\n        \n        # Key Concept 1\n        concept1 = Text(\"A graph is a tapestry of nodes connected by edges\", font_size=24).to_edge(UP)\n        self.play(Write(concept1))\n        self.wait(1)\n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2 - Highlight minimal inducing set\n        concept2 = Text(\"A few special nodes can determine the entire graph\", font_size=24).to_edge(UP)\n        self.play(Write(concept2))\n        \n        # Highlight nodes 1, 3, and 5 as the minimal inducing set\n        minimal_set = [0, 2, 4]\n        self.play(*[nodes[i].animate.set_color(YELLOW) for i in minimal_set])\n        self.wait(1)\n        self.play(FadeOut(concept2))\n        \n        # Key Concept 3 - Graph reconstruction\n        concept3 = Text(\"These nodes help reconstruct the complete graph\", font_size=24).to_edge(UP)\n        self.play(Write(concept3))\n        \n        # Fade other nodes to show the minimal set's importance\n        other_nodes = [i for i in range(5) if i not in minimal_set]\n        \n        # Instead of changing opacity, we'll make them smaller and change color\n        self.play(\n            *[nodes[i].animate.set_color(GRAY) for i in other_nodes],\n            *[nodes[i].animate.scale(0.6) for i in other_nodes]\n        )\n        self.wait(1)\n        \n        # Bring back other nodes to show reconstruction - like pieces materializing in a puzzle\n        self.play(\n            *[nodes[i].animate.set_color(BLUE) for i in other_nodes],\n            *[nodes[i].animate.scale(1/0.6) for i in other_nodes]\n        )\n        self.wait(1)\n        self.play(FadeOut(concept3))\n        \n        # Key Insight with equation\n        insight = Text(\"Minimal inducing sets reveal the unique structure\", font_size=24).to_edge(UP)\n        \n        # Simplified equation - keeping it basic as requested\n        equation = MathTex(r\"G' = (V', E') \\subseteq G\").next_to(insight, DOWN, buff=0.5)\n        eq2 = MathTex(r\"|V'| < |V|\").next_to(equation, DOWN, buff=0.3)\n        \n        self.play(Write(insight))\n        self.play(Write(equation), Write(eq2))\n        self.wait(1)\n        self.play(FadeOut(insight), FadeOut(equation), FadeOut(eq2))\n        \n        # Conclusion\n        conclusion = Text(\"Graph Reconstruction: The Melody from Few Notes\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Reset node colors\n        self.play(*[nodes[i].animate.set_color(BLUE) for i in minimal_set])\n        self.wait(1)\n        \n        # Fade everything out\n        self.play(FadeOut(graph), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What visual strategies can highlight the smallest inducing set of nodes needed to reconstruct a unique graph?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what visual strategies can highlight the smallest inducing set of nodes needed to reconstruct a unique graph?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphReconstructionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Secrets of Graph Reconstruction\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro_text = Text(\"Welcome to the world of graph theory!\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple graph with 5 nodes in a circular layout\n        graph = VGroup()\n        \n        # Create nodes\n        nodes = []\n        radius = 2\n        for i in range(5):\n            angle = i * 2 * PI / 5\n            point = radius * (np.cos(angle) * RIGHT + np.sin(angle) * UP)\n            node = Dot(point=point, radius=0.2, color=BLUE)\n            nodes.append(node)\n            graph.add(node)\n            \n            # Add node label\n            label = Text(str(i+1), font_size=20).move_to(node.get_center())\n            graph.add(label)\n        \n        # Create edges\n        edges = []\n        for i in range(5):\n            # Connect to adjacent nodes\n            edge = Line(nodes[i].get_center(), nodes[(i+1)%5].get_center(), color=WHITE)\n            edges.append(edge)\n            graph.add(edge)\n            \n            # Add some diagonal connections for a more interesting graph\n            if i % 2 == 0:\n                diag_edge = Line(nodes[i].get_center(), nodes[(i+2)%5].get_center(), color=WHITE)\n                edges.append(diag_edge)\n                graph.add(diag_edge)\n        \n        # Display the graph\n        self.play(Create(graph))\n        self.wait(1)\n        \n        # Key Concept 1\n        concept1 = Text(\"A graph is a tapestry of nodes connected by edges\", font_size=24).to_edge(UP)\n        self.play(Write(concept1))\n        self.wait(1)\n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2 - Highlight minimal inducing set\n        concept2 = Text(\"A few special nodes can determine the entire graph\", font_size=24).to_edge(UP)\n        self.play(Write(concept2))\n        \n        # Highlight nodes 1, 3, and 5 as the minimal inducing set\n        minimal_set = [0, 2, 4]\n        self.play(*[nodes[i].animate.set_color(YELLOW) for i in minimal_set])\n        self.wait(1)\n        self.play(FadeOut(concept2))\n        \n        # Key Concept 3 - Graph reconstruction\n        concept3 = Text(\"These nodes help reconstruct the complete graph\", font_size=24).to_edge(UP)\n        self.play(Write(concept3))\n        \n        # Fade other nodes to show the minimal set's importance\n        other_nodes = [i for i in range(5) if i not in minimal_set]\n        \n        # Instead of changing opacity, we'll make them smaller and change color\n        self.play(\n            *[nodes[i].animate.set_color(GRAY) for i in other_nodes],\n            *[nodes[i].animate.scale(0.6) for i in other_nodes]\n        )\n        self.wait(1)\n        \n        # Bring back other nodes to show reconstruction - like pieces materializing in a puzzle\n        self.play(\n            *[nodes[i].animate.set_color(BLUE) for i in other_nodes],\n            *[nodes[i].animate.scale(1/0.6) for i in other_nodes]\n        )\n        self.wait(1)\n        self.play(FadeOut(concept3))\n        \n        # Key Insight with equation\n        insight = Text(\"Minimal inducing sets reveal the unique structure\", font_size=24).to_edge(UP)\n        \n        # Simplified equation - keeping it basic as requested\n        equation = MathTex(r\"G' = (V', E') \\subseteq G\").next_to(insight, DOWN, buff=0.5)\n        eq2 = MathTex(r\"|V'| < |V|\").next_to(equation, DOWN, buff=0.3)\n        \n        self.play(Write(insight))\n        self.play(Write(equation), Write(eq2))\n        self.wait(1)\n        self.play(FadeOut(insight), FadeOut(equation), FadeOut(eq2))\n        \n        # Conclusion\n        conclusion = Text(\"Graph Reconstruction: The Melody from Few Notes\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Reset node colors\n        self.play(*[nodes[i].animate.set_color(BLUE) for i in minimal_set])\n        self.wait(1)\n        \n        # Fade everything out\n        self.play(FadeOut(graph), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What visual strategies can highlight the smallest inducing set of nodes needed to reconstruct a unique graph?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "scene.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass ManimML3DScene(ThreeDScene):\n    \"\"\"\n    This is a wrapper class for the Manim ThreeDScene\n\n    Note: the primary purpose of this is to make it so\n    that everything inside of a layer\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def play(self):\n        \"\"\" \"\"\"\n        pass\n```"}], "metadata": {"source": "thanks-manim", "original_description": "scene.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that scene.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass ManimML3DScene(ThreeDScene):\n    \"\"\"\n    This is a wrapper class for the Manim ThreeDScene\n\n    Note: the primary purpose of this is to make it so\n    that everything inside of a layer\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def play(self):\n        \"\"\" \"\"\"\n        pass\n```"}], "metadata": {"source": "thanks-manim", "original_description": "scene.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an educational animation that visually introduces and explains the one-dimensional wave equation. Start by displaying the wave equation, then add a text description that says it represents the one-dimensional wave equation. After a short pause, replace this text with another, explaining that solutions to this equation take a specific form, which should then be displayed in a mathematical format. Next, please transition to show that same solution replacing the original equation while updating the text description to talk about initial conditions' influence on the solution. Finally, clear the screen and conclude by displaying just the solution to the wave equation on its own. Can you create an engaging and informative animation that presents the equation and its solution with these explanations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EquivalentFractions(Scene):\n    def construct(self):\n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{2}\", color=BLUE).scale(2),\n            MathTex(r\"\\frac{2}{4}\", color=BLUE).scale(2),\n        ).arrange(RIGHT, buff=2)\n\n        equals_sign = MathTex(r\"=\", color=WHITE).scale(2)\n        equals_sign.next_to(fractions[0], RIGHT)\n\n        fractions.add(equals_sign)\n\n        arrows = VGroup(\n            Arrow(fractions[0].get_bottom() + DOWN, fractions[1].get_bottom() + DOWN, color=GREEN),\n            Arrow(fractions[1].get_bottom() + DOWN, fractions[0].get_bottom() + DOWN, color=GREEN)\n        ).arrange(DOWN, buff=0.3)\n        arrows.next_to(fractions, DOWN, buff=0.5)\n\n        text = VGroup(\n            Tex(r\"Multiplicado por 2\", color=GREEN).scale(0.7),\n            Tex(r\"Dividido por 2\", color=GREEN).scale(0.7)\n        )\n        text[0].next_to(arrows[0], DOWN)\n        text[1].next_to(arrows[1], DOWN)\n\n        self.play(Write(fractions))\n        self.play(GrowFromCenter(arrows[0]), Write(text[0]))\n        self.play(GrowFromCenter(arrows[1]), Write(text[1]))\n        self.wait(2)\n\n        self.play(FadeOut(VGroup(fractions, arrows, text)))\n        self.wait(0.5)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational animation that visually introduces and explains the one-dimensional wave equation. Start by displaying the wave equation, then add a text description that says it represents the one-dimensional wave equation. After a short pause, replace this text with another, explaining that solutions to this equation take a specific form, which should then be displayed in a mathematical format. Next, please transition to show that same solution replacing the original equation while updating the text description to talk about initial conditions' influence on the solution. Finally, clear the screen and conclude by displaying just the solution to the wave equation on its own. Can you create an engaging and informative animation that presents the equation and its solution with these explanations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an educational animation that visually introduces and explains the one-dimensional wave equation. start by displaying the wave equation, then add a text description that says it represents the one-dimensional wave equation. after a short pause, replace this text with another, explaining that solutions to this equation take a specific form, which should then be displayed in a mathematical format. next, please transition to show that same solution replacing the original equation while updating the text description to talk about initial conditions' influence on the solution. finally, clear the screen and conclude by displaying just the solution to the wave equation on its own. can you create an engaging and informative animation that presents the equation and its solution with these explanations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EquivalentFractions(Scene):\n    def construct(self):\n        fractions = VGroup(\n            MathTex(r\"\\frac{1}{2}\", color=BLUE).scale(2),\n            MathTex(r\"\\frac{2}{4}\", color=BLUE).scale(2),\n        ).arrange(RIGHT, buff=2)\n\n        equals_sign = MathTex(r\"=\", color=WHITE).scale(2)\n        equals_sign.next_to(fractions[0], RIGHT)\n\n        fractions.add(equals_sign)\n\n        arrows = VGroup(\n            Arrow(fractions[0].get_bottom() + DOWN, fractions[1].get_bottom() + DOWN, color=GREEN),\n            Arrow(fractions[1].get_bottom() + DOWN, fractions[0].get_bottom() + DOWN, color=GREEN)\n        ).arrange(DOWN, buff=0.3)\n        arrows.next_to(fractions, DOWN, buff=0.5)\n\n        text = VGroup(\n            Tex(r\"Multiplicado por 2\", color=GREEN).scale(0.7),\n            Tex(r\"Dividido por 2\", color=GREEN).scale(0.7)\n        )\n        text[0].next_to(arrows[0], DOWN)\n        text[1].next_to(arrows[1], DOWN)\n\n        self.play(Write(fractions))\n        self.play(GrowFromCenter(arrows[0]), Write(text[0]))\n        self.play(GrowFromCenter(arrows[1]), Write(text[1]))\n        self.wait(2)\n\n        self.play(FadeOut(VGroup(fractions, arrows, text)))\n        self.wait(0.5)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational animation that visually introduces and explains the one-dimensional wave equation. Start by displaying the wave equation, then add a text description that says it represents the one-dimensional wave equation. After a short pause, replace this text with another, explaining that solutions to this equation take a specific form, which should then be displayed in a mathematical format. Next, please transition to show that same solution replacing the original equation while updating the text description to talk about initial conditions' influence on the solution. Finally, clear the screen and conclude by displaying just the solution to the wave equation on its own. Can you create an engaging and informative animation that presents the equation and its solution with these explanations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Please create an educational animation that visually demonstrates a multiplying pattern sequence on a neutral-colored background. I'd like the sequence to start with the number 1 and each subsequent number to be three times the previous one, up to five steps in the sequence. The numbers should appear one after the other with a small animation between them that indicates multiplication by three.\n\nCould you make sure that the animation has a clear title at the beginning saying \"Observe a sequ\u00eancia abaixo:\"? The title and the multiplication sign should be in a light red color, while the numbers should be in a standard text color.\n\nFor the multiplication animation, use arrows that connect each number in the sequence, with the label \"x3\" next to each arrow to emphasize the multiplying action. The arrows should be in a light blue color, alternate between the top and bottom of the sequence, and include an exciting animation behavior when they appear.\n\nAfter showing the sequence up to 243, fade everything out smoothly so that the animation ends on the neutral background."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area under the curve\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n\n        self.play(Create(axes), Create(graph), FadeIn(area), Write(graph_label))\n        self.wait()\n\n        # Display the integral symbol with limits\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Calculation of the integral\n        calculation = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(Transform(integral, calculation))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"=\\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3 = \\frac{8}{3}\")\n        self.play(Transform(integral, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(graph_label), FadeOut(integral))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an educational animation that visually demonstrates a multiplying pattern sequence on a neutral-colored background. I'd like the sequence to start with the number 1 and each subsequent number to be three times the previous one, up to five steps in the sequence. The numbers should appear one after the other with a small animation between them that indicates multiplication by three.\n\nCould you make sure that the animation has a clear title at the beginning saying \"Observe a sequ\u00eancia abaixo:\"? The title and the multiplication sign should be in a light red color, while the numbers should be in a standard text color.\n\nFor the multiplication animation, use arrows that connect each number in the sequence, with the label \"x3\" next to each arrow to emphasize the multiplying action. The arrows should be in a light blue color, alternate between the top and bottom of the sequence, and include an exciting animation behavior when they appear.\n\nAfter showing the sequence up to 243, fade everything out smoothly so that the animation ends on the neutral background."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that please create an educational animation that visually demonstrates a multiplying pattern sequence on a neutral-colored background. i'd like the sequence to start with the number 1 and each subsequent number to be three times the previous one, up to five steps in the sequence. the numbers should appear one after the other with a small animation between them that indicates multiplication by three.\n\ncould you make sure that the animation has a clear title at the beginning saying \"observe a sequ\u00eancia abaixo:\"? the title and the multiplication sign should be in a light red color, while the numbers should be in a standard text color.\n\nfor the multiplication animation, use arrows that connect each number in the sequence, with the label \"x3\" next to each arrow to emphasize the multiplying action. the arrows should be in a light blue color, alternate between the top and bottom of the sequence, and include an exciting animation behavior when they appear.\n\nafter showing the sequence up to 243, fade everything out smoothly so that the animation ends on the neutral background."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the function and the area under the curve\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 6],\n            axis_config={\"color\": BLUE}\n        )\n        graph = axes.plot(lambda x: x**2, color=GREEN)\n        area = axes.get_area(graph, x_range=(0, 2), color=[BLUE, GREEN], opacity=0.5)\n        graph_label = axes.get_graph_label(graph, label='y = x^2')\n\n        self.play(Create(axes), Create(graph), FadeIn(area), Write(graph_label))\n        self.wait()\n\n        # Display the integral symbol with limits\n        integral = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Calculation of the integral\n        calculation = MathTex(r\"=\\left[\\frac{1}{3}x^3\\right]_0^2\")\n        self.play(Transform(integral, calculation))\n        self.wait(1)\n\n        # Show the final result\n        final_result = MathTex(r\"=\\frac{1}{3}(2)^3 - \\frac{1}{3}(0)^3 = \\frac{8}{3}\")\n        self.play(Transform(integral, final_result))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(axes), FadeOut(graph), FadeOut(area), FadeOut(graph_label), FadeOut(integral))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an educational animation that visually demonstrates a multiplying pattern sequence on a neutral-colored background. I'd like the sequence to start with the number 1 and each subsequent number to be three times the previous one, up to five steps in the sequence. The numbers should appear one after the other with a small animation between them that indicates multiplication by three.\n\nCould you make sure that the animation has a clear title at the beginning saying \"Observe a sequ\u00eancia abaixo:\"? The title and the multiplication sign should be in a light red color, while the numbers should be in a standard text color.\n\nFor the multiplication animation, use arrows that connect each number in the sequence, with the label \"x3\" next to each arrow to emphasize the multiplying action. The arrows should be in a light blue color, alternate between the top and bottom of the sequence, and include an exciting animation behavior when they appear.\n\nAfter showing the sequence up to 243, fade everything out smoothly so that the animation ends on the neutral background."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a set of axes. Plot the graph of the function \\( f(x) = \\frac{k}{x} \\) in yellow. Show a blue rectangle with yellow edges that dynamically updates its size based on the value of \\( t \\). Display a dot that moves along the graph, updating its position as \\( t \\) changes."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[\n                    ax.c2p(*i)\n                    for i in self.get_rectangle_corners(\n                        (0, 0), (t.get_value(), k / t.get_value())\n                    )\n                ]\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a set of axes. Plot the graph of the function \\( f(x) = \\frac{k}{x} \\) in yellow. Show a blue rectangle with yellow edges that dynamically updates its size based on the value of \\( t \\). Display a dot that moves along the graph, updating its position as \\( t \\) changes."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a set of axes. plot the graph of the function \\( f(x) = \\frac{k}{x} \\) in yellow. show a blue rectangle with yellow edges that dynamically updates its size based on the value of \\( t \\). display a dot that moves along the graph, updating its position as \\( t \\) changes."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PolygonOnAxes(Scene):\n    def get_rectangle_corners(self, bottom_left, top_right):\n        return [\n            (top_right[0], top_right[1]),\n            (bottom_left[0], top_right[1]),\n            (bottom_left[0], bottom_left[1]),\n            (top_right[0], bottom_left[1]),\n        ]\n\n    def construct(self):\n        ax = Axes(\n            x_range=[0, 10],\n            y_range=[0, 10],\n            x_length=6,\n            y_length=6,\n            axis_config={\"include_tip\": False},\n        )\n\n        t = ValueTracker(5)\n        k = 25\n\n        graph = ax.plot(\n            lambda x: k / x,\n            color=YELLOW_D,\n            x_range=[k / 10, 10.0, 0.01],\n            use_smoothing=False,\n        )\n\n        def get_rectangle():\n            polygon = Polygon(\n                *[\n                    ax.c2p(*i)\n                    for i in self.get_rectangle_corners(\n                        (0, 0), (t.get_value(), k / t.get_value())\n                    )\n                ]\n            )\n            polygon.stroke_width = 1\n            polygon.set_fill(BLUE, opacity=0.5)\n            polygon.set_stroke(YELLOW_B)\n            return polygon\n\n        polygon = always_redraw(get_rectangle)\n\n        dot = Dot()\n        dot.add_updater(lambda x: x.move_to(ax.c2p(t.get_value(), k / t.get_value())))\n        dot.set_z_index(10)\n\n        self.add(ax, graph, dot)\n        self.play(Create(polygon))\n        self.play(t.animate.set_value(10))\n        self.play(t.animate.set_value(k / 10))\n        self.play(t.animate.set_value(5))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a set of axes. Plot the graph of the function \\( f(x) = \\frac{k}{x} \\) in yellow. Show a blue rectangle with yellow edges that dynamically updates its size based on the value of \\( t \\). Display a dot that moves along the graph, updating its position as \\( t \\) changes."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the Banach fixed-point theorem guarantee a solution to contraction mappings, and why is it crucial in proving the existence of solutions to differential equations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BanachFixedPointTheorem(Scene):\n    def construct(self):\n        # Set dark blue background\n        self.camera.background_color = \"#0C1445\"\n        \n        # Title\n        title = Text(\"The Magic of Banach Spaces\", color=GOLD_D)\n        subtitle = Text(\"Unlocking Fixed Points and Solutions\", color=GOLD_C).scale(0.7)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introduction to Banach spaces\n        banach_text = Text(\"A Banach space is a complete metric space\", color=WHITE).scale(0.8)\n        self.play(Write(banach_text))\n        self.wait(1)\n        self.play(FadeOut(banach_text))\n        \n        # Create a coordinate system\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-3, 3],\n            axis_config={\"color\": BLUE}\n        )\n        self.play(Create(axes))\n        \n        # Fixed point\n        fixed_point = Dot([1, 1, 0], color=RED)\n        fixed_label = Text(\"Fixed Point\", color=RED).scale(0.6)\n        fixed_label.next_to(fixed_point, UP)\n        \n        # Starting point\n        start_point = Dot([-2, -2, 0], color=GOLD_D)\n        start_label = Text(\"x\u2080\", color=GOLD_D).scale(0.6)\n        start_label.next_to(start_point, DOWN)\n        \n        self.play(Create(fixed_point), Write(fixed_label))\n        self.play(Create(start_point), Write(start_label))\n        \n        # Show contraction mapping equation\n        contraction_eq = MathTex(r\"|T(x) - T(y)| \\leq q|x-y|, \\quad 0 \\leq q < 1\")\n        contraction_eq.to_edge(DOWN)\n        self.play(Write(contraction_eq))\n        \n        # Iterate towards fixed point\n        # First iteration\n        point1 = Dot([-1, -1, 0], color=GOLD_D)\n        label1 = Text(\"x\u2081\", color=GOLD_D).scale(0.6)\n        label1.next_to(point1, DOWN)\n        arrow1 = Arrow(start_point.get_center(), point1.get_center(), color=BLUE)\n        \n        self.play(Create(arrow1), Create(point1), Write(label1))\n        \n        # Second iteration\n        point2 = Dot([0, 0, 0], color=GOLD_D)\n        label2 = Text(\"x\u2082\", color=GOLD_D).scale(0.6)\n        label2.next_to(point2, DOWN)\n        arrow2 = Arrow(point1.get_center(), point2.get_center(), color=BLUE)\n        \n        self.play(Create(arrow2), Create(point2), Write(label2))\n        \n        # Iteration formula\n        iter_formula = MathTex(r\"x_{n+1} = Tx_n\")\n        iter_formula.next_to(contraction_eq, UP)\n        self.play(Write(iter_formula))\n        \n        # Conclusion\n        conclusion = Text(\"The Banach fixed-point theorem guarantees convergence\", color=GOLD_C).scale(0.6)\n        conclusion.to_edge(UP)\n        self.play(Write(conclusion))\n        \n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Banach fixed-point theorem guarantee a solution to contraction mappings, and why is it crucial in proving the existence of solutions to differential equations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the banach fixed-point theorem guarantee a solution to contraction mappings, and why is it crucial in proving the existence of solutions to differential equations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BanachFixedPointTheorem(Scene):\n    def construct(self):\n        # Set dark blue background\n        self.camera.background_color = \"#0C1445\"\n        \n        # Title\n        title = Text(\"The Magic of Banach Spaces\", color=GOLD_D)\n        subtitle = Text(\"Unlocking Fixed Points and Solutions\", color=GOLD_C).scale(0.7)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introduction to Banach spaces\n        banach_text = Text(\"A Banach space is a complete metric space\", color=WHITE).scale(0.8)\n        self.play(Write(banach_text))\n        self.wait(1)\n        self.play(FadeOut(banach_text))\n        \n        # Create a coordinate system\n        axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-3, 3],\n            axis_config={\"color\": BLUE}\n        )\n        self.play(Create(axes))\n        \n        # Fixed point\n        fixed_point = Dot([1, 1, 0], color=RED)\n        fixed_label = Text(\"Fixed Point\", color=RED).scale(0.6)\n        fixed_label.next_to(fixed_point, UP)\n        \n        # Starting point\n        start_point = Dot([-2, -2, 0], color=GOLD_D)\n        start_label = Text(\"x\u2080\", color=GOLD_D).scale(0.6)\n        start_label.next_to(start_point, DOWN)\n        \n        self.play(Create(fixed_point), Write(fixed_label))\n        self.play(Create(start_point), Write(start_label))\n        \n        # Show contraction mapping equation\n        contraction_eq = MathTex(r\"|T(x) - T(y)| \\leq q|x-y|, \\quad 0 \\leq q < 1\")\n        contraction_eq.to_edge(DOWN)\n        self.play(Write(contraction_eq))\n        \n        # Iterate towards fixed point\n        # First iteration\n        point1 = Dot([-1, -1, 0], color=GOLD_D)\n        label1 = Text(\"x\u2081\", color=GOLD_D).scale(0.6)\n        label1.next_to(point1, DOWN)\n        arrow1 = Arrow(start_point.get_center(), point1.get_center(), color=BLUE)\n        \n        self.play(Create(arrow1), Create(point1), Write(label1))\n        \n        # Second iteration\n        point2 = Dot([0, 0, 0], color=GOLD_D)\n        label2 = Text(\"x\u2082\", color=GOLD_D).scale(0.6)\n        label2.next_to(point2, DOWN)\n        arrow2 = Arrow(point1.get_center(), point2.get_center(), color=BLUE)\n        \n        self.play(Create(arrow2), Create(point2), Write(label2))\n        \n        # Iteration formula\n        iter_formula = MathTex(r\"x_{n+1} = Tx_n\")\n        iter_formula.next_to(contraction_eq, UP)\n        self.play(Write(iter_formula))\n        \n        # Conclusion\n        conclusion = Text(\"The Banach fixed-point theorem guarantees convergence\", color=GOLD_C).scale(0.6)\n        conclusion.to_edge(UP)\n        self.play(Write(conclusion))\n        \n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Banach fixed-point theorem guarantee a solution to contraction mappings, and why is it crucial in proving the existence of solutions to differential equations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what way does queue discipline impact the stability of a queuing system, such as FIFO vs LIFO?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QueueDisciplineScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Queue Discipline: The Hidden Influence on System Stability\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction - FIFO vs LIFO\n        fifo_text = Text(\"FIFO: First In, First Out\", font_size=24, color=BLUE).shift(UP * 1.5)\n        lifo_text = Text(\"LIFO: Last In, First Out\", font_size=24, color=RED).shift(DOWN * 1.5)\n        \n        self.play(Write(fifo_text))\n        self.play(Write(lifo_text))\n        self.wait(1)\n        \n        # Clear for queue visualization\n        self.play(FadeOut(fifo_text), FadeOut(lifo_text))\n        \n        # FIFO Queue visualization\n        fifo_label = Text(\"FIFO Queue\", font_size=24, color=BLUE).shift(UP * 2)\n        self.play(Write(fifo_label))\n        \n        # Create a simple FIFO queue with 3 customers\n        fifo_queue = Rectangle(height=0.5, width=4, color=BLUE).shift(UP * 1)\n        fifo_customers = [Circle(radius=0.2, color=BLUE, fill_opacity=0.8) for _ in range(3)]\n        \n        # Position customers in queue\n        for i, customer in enumerate(fifo_customers):\n            customer.move_to(LEFT + (i-1) * RIGHT + UP * 1)\n        \n        self.play(Create(fifo_queue))\n        self.play(Create(fifo_customers[0]), Create(fifo_customers[1]), Create(fifo_customers[2]))\n        \n        # Show FIFO processing - first customer leaves first\n        arrow = Arrow(start=LEFT * 2, end=LEFT * 3, color=BLUE).shift(UP * 1)\n        self.play(Create(arrow))\n        self.play(fifo_customers[0].animate.move_to(LEFT * 3 + UP * 1))\n        self.play(FadeOut(fifo_customers[0]), FadeOut(arrow))\n        \n        # LIFO Queue visualization\n        lifo_label = Text(\"LIFO Queue\", font_size=24, color=RED).shift(DOWN * 0.5)\n        self.play(Write(lifo_label))\n        \n        # Create a simple LIFO queue with 3 customers\n        lifo_queue = Rectangle(height=0.5, width=4, color=RED).shift(DOWN * 1.5)\n        lifo_customers = [Circle(radius=0.2, color=RED, fill_opacity=0.8) for _ in range(3)]\n        \n        # Position customers in queue\n        for i, customer in enumerate(lifo_customers):\n            customer.move_to(LEFT + (i-1) * RIGHT + DOWN * 1.5)\n        \n        self.play(Create(lifo_queue))\n        self.play(Create(lifo_customers[0]), Create(lifo_customers[1]), Create(lifo_customers[2]))\n        \n        # Show LIFO processing - last customer leaves first\n        arrow = Arrow(start=RIGHT * 1, end=RIGHT * 2, color=RED).shift(DOWN * 1.5)\n        self.play(Create(arrow))\n        self.play(lifo_customers[2].animate.move_to(RIGHT * 2 + DOWN * 1.5))\n        self.play(FadeOut(lifo_customers[2]), FadeOut(arrow))\n        \n        # Clear for next section\n        self.play(\n            FadeOut(fifo_label), FadeOut(lifo_label),\n            FadeOut(fifo_queue), FadeOut(lifo_queue),\n            FadeOut(fifo_customers[1]), FadeOut(fifo_customers[2]),\n            FadeOut(lifo_customers[0]), FadeOut(lifo_customers[1])\n        )\n        \n        # Wait Time Comparison\n        comparison_title = Text(\"Wait Time Comparison\", font_size=28).shift(UP * 2)\n        self.play(Write(comparison_title))\n        \n        # FIFO vs LIFO wait time descriptions\n        fifo_wait = Text(\"FIFO: Consistent wait times\", font_size=24, color=BLUE).shift(UP * 0.5)\n        self.play(Write(fifo_wait))\n        \n        lifo_wait = Text(\"LIFO: Unpredictable wait times\", font_size=24, color=RED).shift(DOWN * 0.5)\n        self.play(Write(lifo_wait))\n        \n        # Equations (\u03bc = service rate, \u03bb = arrival rate)\n        fifo_eq = MathTex(r\"T_{FIFO} = \\frac{1}{\\mu - \\lambda}\").shift(UP * 0.5 + RIGHT * 3)\n        lifo_eq = MathTex(r\"T_{LIFO} \\approx \\frac{1}{\\mu - \\lambda} + f(n)\").shift(DOWN * 0.5 + RIGHT * 3)\n        \n        # Add explanation of symbols\n        eq_note = Text(\"(\u03bc = service rate, \u03bb = arrival rate)\", font_size=16).shift(DOWN * 0)\n        \n        self.play(Write(fifo_eq))\n        self.play(Write(lifo_eq))\n        self.play(Write(eq_note))\n        self.wait(1)\n        \n        # Key insight\n        key_insight = Text(\"FIFO provides more stable systems\", font_size=26).shift(DOWN * 2)\n        self.play(Write(key_insight))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(title), FadeOut(comparison_title),\n            FadeOut(fifo_wait), FadeOut(lifo_wait),\n            FadeOut(fifo_eq), FadeOut(lifo_eq), FadeOut(eq_note),\n            FadeOut(key_insight)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way does queue discipline impact the stability of a queuing system, such as FIFO vs LIFO?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what way does queue discipline impact the stability of a queuing system, such as fifo vs lifo?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QueueDisciplineScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Queue Discipline: The Hidden Influence on System Stability\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction - FIFO vs LIFO\n        fifo_text = Text(\"FIFO: First In, First Out\", font_size=24, color=BLUE).shift(UP * 1.5)\n        lifo_text = Text(\"LIFO: Last In, First Out\", font_size=24, color=RED).shift(DOWN * 1.5)\n        \n        self.play(Write(fifo_text))\n        self.play(Write(lifo_text))\n        self.wait(1)\n        \n        # Clear for queue visualization\n        self.play(FadeOut(fifo_text), FadeOut(lifo_text))\n        \n        # FIFO Queue visualization\n        fifo_label = Text(\"FIFO Queue\", font_size=24, color=BLUE).shift(UP * 2)\n        self.play(Write(fifo_label))\n        \n        # Create a simple FIFO queue with 3 customers\n        fifo_queue = Rectangle(height=0.5, width=4, color=BLUE).shift(UP * 1)\n        fifo_customers = [Circle(radius=0.2, color=BLUE, fill_opacity=0.8) for _ in range(3)]\n        \n        # Position customers in queue\n        for i, customer in enumerate(fifo_customers):\n            customer.move_to(LEFT + (i-1) * RIGHT + UP * 1)\n        \n        self.play(Create(fifo_queue))\n        self.play(Create(fifo_customers[0]), Create(fifo_customers[1]), Create(fifo_customers[2]))\n        \n        # Show FIFO processing - first customer leaves first\n        arrow = Arrow(start=LEFT * 2, end=LEFT * 3, color=BLUE).shift(UP * 1)\n        self.play(Create(arrow))\n        self.play(fifo_customers[0].animate.move_to(LEFT * 3 + UP * 1))\n        self.play(FadeOut(fifo_customers[0]), FadeOut(arrow))\n        \n        # LIFO Queue visualization\n        lifo_label = Text(\"LIFO Queue\", font_size=24, color=RED).shift(DOWN * 0.5)\n        self.play(Write(lifo_label))\n        \n        # Create a simple LIFO queue with 3 customers\n        lifo_queue = Rectangle(height=0.5, width=4, color=RED).shift(DOWN * 1.5)\n        lifo_customers = [Circle(radius=0.2, color=RED, fill_opacity=0.8) for _ in range(3)]\n        \n        # Position customers in queue\n        for i, customer in enumerate(lifo_customers):\n            customer.move_to(LEFT + (i-1) * RIGHT + DOWN * 1.5)\n        \n        self.play(Create(lifo_queue))\n        self.play(Create(lifo_customers[0]), Create(lifo_customers[1]), Create(lifo_customers[2]))\n        \n        # Show LIFO processing - last customer leaves first\n        arrow = Arrow(start=RIGHT * 1, end=RIGHT * 2, color=RED).shift(DOWN * 1.5)\n        self.play(Create(arrow))\n        self.play(lifo_customers[2].animate.move_to(RIGHT * 2 + DOWN * 1.5))\n        self.play(FadeOut(lifo_customers[2]), FadeOut(arrow))\n        \n        # Clear for next section\n        self.play(\n            FadeOut(fifo_label), FadeOut(lifo_label),\n            FadeOut(fifo_queue), FadeOut(lifo_queue),\n            FadeOut(fifo_customers[1]), FadeOut(fifo_customers[2]),\n            FadeOut(lifo_customers[0]), FadeOut(lifo_customers[1])\n        )\n        \n        # Wait Time Comparison\n        comparison_title = Text(\"Wait Time Comparison\", font_size=28).shift(UP * 2)\n        self.play(Write(comparison_title))\n        \n        # FIFO vs LIFO wait time descriptions\n        fifo_wait = Text(\"FIFO: Consistent wait times\", font_size=24, color=BLUE).shift(UP * 0.5)\n        self.play(Write(fifo_wait))\n        \n        lifo_wait = Text(\"LIFO: Unpredictable wait times\", font_size=24, color=RED).shift(DOWN * 0.5)\n        self.play(Write(lifo_wait))\n        \n        # Equations (\u03bc = service rate, \u03bb = arrival rate)\n        fifo_eq = MathTex(r\"T_{FIFO} = \\frac{1}{\\mu - \\lambda}\").shift(UP * 0.5 + RIGHT * 3)\n        lifo_eq = MathTex(r\"T_{LIFO} \\approx \\frac{1}{\\mu - \\lambda} + f(n)\").shift(DOWN * 0.5 + RIGHT * 3)\n        \n        # Add explanation of symbols\n        eq_note = Text(\"(\u03bc = service rate, \u03bb = arrival rate)\", font_size=16).shift(DOWN * 0)\n        \n        self.play(Write(fifo_eq))\n        self.play(Write(lifo_eq))\n        self.play(Write(eq_note))\n        self.wait(1)\n        \n        # Key insight\n        key_insight = Text(\"FIFO provides more stable systems\", font_size=26).shift(DOWN * 2)\n        self.play(Write(key_insight))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(title), FadeOut(comparison_title),\n            FadeOut(fifo_wait), FadeOut(lifo_wait),\n            FadeOut(fifo_eq), FadeOut(lifo_eq), FadeOut(eq_note),\n            FadeOut(key_insight)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way does queue discipline impact the stability of a queuing system, such as FIFO vs LIFO?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually walks through the process of solving the integral of e raised to the power of 2x using u-substitution including explanations at each step?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CubicFunctionApproximation(Scene):\n    def construct(self):\n        axis = Axes(\n            x_range=[-3, 3],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Original function\n        original_function = axis.plot(lambda x: x**3, color=GREEN)\n        original_function_label = axis.get_graph_label(original_function, label='x^3')\n\n        self.play(Create(axis), Create(original_function), Write(original_function_label))\n        self.wait(2)\n\n        # Linear approximation\n        linear_approx = axis.plot(lambda x: 3*x - 2, color=RED)\n        linear_approx_label = axis.get_graph_label(linear_approx, label='3x-2', x_val=-2, direction=UP)\n\n        self.play(Create(linear_approx), Write(linear_approx_label))\n        self.wait(1)\n\n        # Quadratic approximation\n        quadratic_approx = axis.plot(lambda x: x**2 - 2*x + 1, color=ORANGE)\n        quadratic_approx_label = axis.get_graph_label(quadratic_approx, label='x^2-2x+1', x_val=0, direction=UP)\n\n        self.play(ReplacementTransform(linear_approx, quadratic_approx), Transform(linear_approx_label, quadratic_approx_label))\n        self.wait(1)\n\n        # Cubic approximation\n        cubic_approx = axis.plot(lambda x: 0.1*x**3 + 0.2*x**2 - 0.5*x - 1, color=PURPLE)\n        cubic_approx_label = axis.get_graph_label(cubic_approx, label='0.1x^3+0.2x^2-0.5x-1', x_val=-1, direction=UP)\n\n        self.play(ReplacementTransform(quadratic_approx, cubic_approx), Transform(quadratic_approx_label, cubic_approx_label))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with the cubic approximation\n        self.play(Write(cubic_approx), Write(cubic_approx_label))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually walks through the process of solving the integral of e raised to the power of 2x using u-substitution including explanations at each step?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually walks through the process of solving the integral of e raised to the power of 2x using u-substitution including explanations at each step?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CubicFunctionApproximation(Scene):\n    def construct(self):\n        axis = Axes(\n            x_range=[-3, 3],\n            y_range=[-5, 5],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Original function\n        original_function = axis.plot(lambda x: x**3, color=GREEN)\n        original_function_label = axis.get_graph_label(original_function, label='x^3')\n\n        self.play(Create(axis), Create(original_function), Write(original_function_label))\n        self.wait(2)\n\n        # Linear approximation\n        linear_approx = axis.plot(lambda x: 3*x - 2, color=RED)\n        linear_approx_label = axis.get_graph_label(linear_approx, label='3x-2', x_val=-2, direction=UP)\n\n        self.play(Create(linear_approx), Write(linear_approx_label))\n        self.wait(1)\n\n        # Quadratic approximation\n        quadratic_approx = axis.plot(lambda x: x**2 - 2*x + 1, color=ORANGE)\n        quadratic_approx_label = axis.get_graph_label(quadratic_approx, label='x^2-2x+1', x_val=0, direction=UP)\n\n        self.play(ReplacementTransform(linear_approx, quadratic_approx), Transform(linear_approx_label, quadratic_approx_label))\n        self.wait(1)\n\n        # Cubic approximation\n        cubic_approx = axis.plot(lambda x: 0.1*x**3 + 0.2*x**2 - 0.5*x - 1, color=PURPLE)\n        cubic_approx_label = axis.get_graph_label(cubic_approx, label='0.1x^3+0.2x^2-0.5x-1', x_val=-1, direction=UP)\n\n        self.play(ReplacementTransform(quadratic_approx, cubic_approx), Transform(quadratic_approx_label, cubic_approx_label))\n        self.wait(3)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclusion with the cubic approximation\n        self.play(Write(cubic_approx), Write(cubic_approx_label))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually walks through the process of solving the integral of e raised to the power of 2x using u-substitution including explanations at each step?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animation sequence using Manim that illustrates the formation of a molecule from an oxygen molecule and a lithium ion? I would like to see an oxygen molecule at the top of the screen and a lithium ion appearing below it. The lithium ion should then move up to join the oxygen molecule, and the resulting lithium-oxygen compound should grow slightly in size and move to the center of the screen. Please also make sure that the animation includes a final pause so the viewer can see the completed molecule."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeToColor\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.play(FadeToColor(square,color=YELLOW))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation sequence using Manim that illustrates the formation of a molecule from an oxygen molecule and a lithium ion? I would like to see an oxygen molecule at the top of the screen and a lithium ion appearing below it. The lithium ion should then move up to join the oxygen molecule, and the resulting lithium-oxygen compound should grow slightly in size and move to the center of the screen. Please also make sure that the animation includes a final pause so the viewer can see the completed molecule."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animation sequence using manim that illustrates the formation of a molecule from an oxygen molecule and a lithium ion? i would like to see an oxygen molecule at the top of the screen and a lithium ion appearing below it. the lithium ion should then move up to join the oxygen molecule, and the resulting lithium-oxygen compound should grow slightly in size and move to the center of the screen. please also make sure that the animation includes a final pause so the viewer can see the completed molecule."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"FadeToColor\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1).set_fill(RED)\n            self.play(FadeToColor(square,color=YELLOW))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation sequence using Manim that illustrates the formation of a molecule from an oxygen molecule and a lithium ion? I would like to see an oxygen molecule at the top of the screen and a lithium ion appearing below it. The lithium ion should then move up to join the oxygen molecule, and the resulting lithium-oxygen compound should grow slightly in size and move to the center of the screen. Please also make sure that the animation includes a final pause so the viewer can see the completed molecule."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can we illustrate the interplay between the dimension of a linear system and the genus of an algebraic curve?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DivisorsAndLinearSystems(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Curves, Divisors, and Their Dimensional Dance\", color=GOLD)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Show a simple algebraic curve\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-2, 2, 1],\n        )\n        curve = ParametricFunction(\n            lambda t: axes.c2p(2 * np.cos(t), 1.5 * np.sin(t)),\n            t_range=[0, 2 * PI],\n            color=GOLD\n        )\n        curve_label = Text(\"Algebraic Curve\", color=GOLD).scale(0.6).next_to(curve, UP)\n        \n        self.play(Create(axes), Create(curve), Write(curve_label))\n        self.wait(1)\n        \n        # Show points on the curve (for divisor)\n        points = [\n            axes.c2p(2 * np.cos(PI/4), 1.5 * np.sin(PI/4)),\n            axes.c2p(2 * np.cos(3*PI/4), 1.5 * np.sin(3*PI/4)),\n            axes.c2p(2 * np.cos(5*PI/4), 1.5 * np.sin(5*PI/4)),\n            axes.c2p(2 * np.cos(7*PI/4), 1.5 * np.sin(7*PI/4)),\n        ]\n        point_dots = [Dot(point, color=RED) for point in points]\n        \n        # Add points to represent a divisor\n        self.play(*[Create(dot) for dot in point_dots])\n        \n        # Label the points with simple positions\n        point_labels = [\n            Text(f\"P{i+1}\", color=RED).scale(0.4).next_to(point_dots[i], UP)\n            for i in range(len(points))\n        ]\n        self.play(*[Write(label) for label in point_labels])\n        self.wait(1)\n        \n        # Visualize divisor concept\n        divisor_title = Text(\"Understanding Divisors\", color=GOLD).scale(0.7).to_edge(UP)\n        self.play(\n            FadeOut(curve_label),\n            Write(divisor_title)\n        )\n        \n        # Simple divisor equation\n        divisor_eq = Text(\"D = P1 + P2 + P3 + P4\", color=WHITE).scale(0.6)\n        divisor_eq.next_to(divisor_title, DOWN, buff=0.5)\n        \n        self.play(Write(divisor_eq))\n        self.wait(1)\n        \n        # Visualize linear systems\n        self.play(\n            FadeOut(divisor_title),\n            FadeOut(divisor_eq)\n        )\n        \n        linear_system_title = Text(\"Linear Systems and Their Dimensions\", color=GOLD).scale(0.7).to_edge(UP)\n        self.play(Write(linear_system_title))\n        \n        # Simplified linear system equation\n        linear_system_eq = Text(\"L(D) = {f : (f) >= -D}\", color=WHITE).scale(0.6)\n        linear_system_eq.next_to(linear_system_title, DOWN, buff=0.5)\n        \n        self.play(Write(linear_system_eq))\n        self.wait(1)\n        \n        # Visualize concept of linear system as lines around curve\n        lines = [\n            ParametricFunction(\n                lambda t: axes.c2p(2 * np.cos(t) + 0.2*i, 1.5 * np.sin(t) + 0.1*i),\n                t_range=[0, 2 * PI],\n                color=BLUE\n            )\n            for i in range(-1, 2)\n        ]\n        \n        self.play(*[Create(line) for line in lines])\n        self.wait(1)\n        \n        # Key Insight\n        self.play(\n            FadeOut(linear_system_title),\n            FadeOut(linear_system_eq),\n            *[FadeOut(line) for line in lines]\n        )\n        \n        key_insight_title = Text(\"Key Insight\", color=GOLD).scale(0.7).to_edge(UP)\n        key_insight_text = Text(\n            \"Dimension of linear system correlates with genus of curve\",\n            color=WHITE\n        ).scale(0.5)\n        key_insight_text.next_to(key_insight_title, DOWN, buff=0.5)\n        \n        self.play(\n            Write(key_insight_title),\n            Write(key_insight_text)\n        )\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(key_insight_title),\n            FadeOut(key_insight_text),\n            *[FadeOut(dot) for dot in point_dots],\n            *[FadeOut(label) for label in point_labels],\n            FadeOut(curve),\n            FadeOut(axes)\n        )\n        \n        conclusion_title = Text(\"Conclusion\", color=GOLD).scale(0.7).to_edge(UP)\n        conclusion_text = Text(\n            \"The interplay between dimensions and genus\\n\"\n            \"reveals the beauty of algebraic curves\",\n            color=WHITE\n        ).scale(0.5)\n        conclusion_text.next_to(conclusion_title, DOWN, buff=0.5)\n        \n        self.play(\n            Write(conclusion_title),\n            Write(conclusion_text)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we illustrate the interplay between the dimension of a linear system and the genus of an algebraic curve?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can we illustrate the interplay between the dimension of a linear system and the genus of an algebraic curve?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DivisorsAndLinearSystems(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Curves, Divisors, and Their Dimensional Dance\", color=GOLD)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Show a simple algebraic curve\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-2, 2, 1],\n        )\n        curve = ParametricFunction(\n            lambda t: axes.c2p(2 * np.cos(t), 1.5 * np.sin(t)),\n            t_range=[0, 2 * PI],\n            color=GOLD\n        )\n        curve_label = Text(\"Algebraic Curve\", color=GOLD).scale(0.6).next_to(curve, UP)\n        \n        self.play(Create(axes), Create(curve), Write(curve_label))\n        self.wait(1)\n        \n        # Show points on the curve (for divisor)\n        points = [\n            axes.c2p(2 * np.cos(PI/4), 1.5 * np.sin(PI/4)),\n            axes.c2p(2 * np.cos(3*PI/4), 1.5 * np.sin(3*PI/4)),\n            axes.c2p(2 * np.cos(5*PI/4), 1.5 * np.sin(5*PI/4)),\n            axes.c2p(2 * np.cos(7*PI/4), 1.5 * np.sin(7*PI/4)),\n        ]\n        point_dots = [Dot(point, color=RED) for point in points]\n        \n        # Add points to represent a divisor\n        self.play(*[Create(dot) for dot in point_dots])\n        \n        # Label the points with simple positions\n        point_labels = [\n            Text(f\"P{i+1}\", color=RED).scale(0.4).next_to(point_dots[i], UP)\n            for i in range(len(points))\n        ]\n        self.play(*[Write(label) for label in point_labels])\n        self.wait(1)\n        \n        # Visualize divisor concept\n        divisor_title = Text(\"Understanding Divisors\", color=GOLD).scale(0.7).to_edge(UP)\n        self.play(\n            FadeOut(curve_label),\n            Write(divisor_title)\n        )\n        \n        # Simple divisor equation\n        divisor_eq = Text(\"D = P1 + P2 + P3 + P4\", color=WHITE).scale(0.6)\n        divisor_eq.next_to(divisor_title, DOWN, buff=0.5)\n        \n        self.play(Write(divisor_eq))\n        self.wait(1)\n        \n        # Visualize linear systems\n        self.play(\n            FadeOut(divisor_title),\n            FadeOut(divisor_eq)\n        )\n        \n        linear_system_title = Text(\"Linear Systems and Their Dimensions\", color=GOLD).scale(0.7).to_edge(UP)\n        self.play(Write(linear_system_title))\n        \n        # Simplified linear system equation\n        linear_system_eq = Text(\"L(D) = {f : (f) >= -D}\", color=WHITE).scale(0.6)\n        linear_system_eq.next_to(linear_system_title, DOWN, buff=0.5)\n        \n        self.play(Write(linear_system_eq))\n        self.wait(1)\n        \n        # Visualize concept of linear system as lines around curve\n        lines = [\n            ParametricFunction(\n                lambda t: axes.c2p(2 * np.cos(t) + 0.2*i, 1.5 * np.sin(t) + 0.1*i),\n                t_range=[0, 2 * PI],\n                color=BLUE\n            )\n            for i in range(-1, 2)\n        ]\n        \n        self.play(*[Create(line) for line in lines])\n        self.wait(1)\n        \n        # Key Insight\n        self.play(\n            FadeOut(linear_system_title),\n            FadeOut(linear_system_eq),\n            *[FadeOut(line) for line in lines]\n        )\n        \n        key_insight_title = Text(\"Key Insight\", color=GOLD).scale(0.7).to_edge(UP)\n        key_insight_text = Text(\n            \"Dimension of linear system correlates with genus of curve\",\n            color=WHITE\n        ).scale(0.5)\n        key_insight_text.next_to(key_insight_title, DOWN, buff=0.5)\n        \n        self.play(\n            Write(key_insight_title),\n            Write(key_insight_text)\n        )\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(key_insight_title),\n            FadeOut(key_insight_text),\n            *[FadeOut(dot) for dot in point_dots],\n            *[FadeOut(label) for label in point_labels],\n            FadeOut(curve),\n            FadeOut(axes)\n        )\n        \n        conclusion_title = Text(\"Conclusion\", color=GOLD).scale(0.7).to_edge(UP)\n        conclusion_text = Text(\n            \"The interplay between dimensions and genus\\n\"\n            \"reveals the beauty of algebraic curves\",\n            color=WHITE\n        ).scale(0.5)\n        conclusion_text.next_to(conclusion_title, DOWN, buff=0.5)\n        \n        self.play(\n            Write(conclusion_title),\n            Write(conclusion_text)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we illustrate the interplay between the dimension of a linear system and the genus of an algebraic curve?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually represents a neural network with four layers: an input layer with 4 nodes, two hidden layers each with 6 nodes, and an output layer with 2 nodes. Each layer should be labeled appropriately. The animation should also show connections forming between these layers to indicate the flow of information or the neural connections. Can this neural network animation also include an animated sequence where the network and the connections appear one after the other?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Calculate area under the parabola\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Anti-derivative step\n        antid_step = MathTex(r\"\\int x^2 \\,dx = \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(problem.copy(), antid_step))\n        self.wait(1)\n\n        # Explanation for computing the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying the limits\n        limits_step = MathTex(r\"\\Bigg|_0^2 \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(antid_step, limits_step))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\left. \\frac{1}{3}(2)^3 \\right|_0^2 = \\frac{8}{3}\")\n        self.play(ReplacementTransform(limits_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually represents a neural network with four layers: an input layer with 4 nodes, two hidden layers each with 6 nodes, and an output layer with 2 nodes. Each layer should be labeled appropriately. The animation should also show connections forming between these layers to indicate the flow of information or the neural connections. Can this neural network animation also include an animated sequence where the network and the connections appear one after the other?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually represents a neural network with four layers: an input layer with 4 nodes, two hidden layers each with 6 nodes, and an output layer with 2 nodes. each layer should be labeled appropriately. the animation should also show connections forming between these layers to indicate the flow of information or the neural connections. can this neural network animation also include an animated sequence where the network and the connections appear one after the other?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ParabolaAreaExample(Scene):\n    def construct(self):\n        # Display the problem\n        problem = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for setting up the integral\n        explanation1 = Text(\"Calculate area under the parabola\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Anti-derivative step\n        antid_step = MathTex(r\"\\int x^2 \\,dx = \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(problem.copy(), antid_step))\n        self.wait(1)\n\n        # Explanation for computing the definite integral\n        explanation2 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Applying the limits\n        limits_step = MathTex(r\"\\Bigg|_0^2 \\frac{1}{3}x^3\")\n        self.play(ReplacementTransform(antid_step, limits_step))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"=\\left. \\frac{1}{3}(2)^3 \\right|_0^2 = \\frac{8}{3}\")\n        self.play(ReplacementTransform(limits_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually represents a neural network with four layers: an input layer with 4 nodes, two hidden layers each with 6 nodes, and an output layer with 2 nodes. Each layer should be labeled appropriately. The animation should also show connections forming between these layers to indicate the flow of information or the neural connections. Can this neural network animation also include an animated sequence where the network and the connections appear one after the other?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_feed_forward.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\n__module_test__ = \"feed_forward\"\n\n\n@frames_comparison\ndef test_FeedForwardScene(scene):\n    \"\"\"Tests the appearance of a feed forward network\"\"\"\n    nn = NeuralNetwork([FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)])\n\n    scene.add(nn)\n\n\nclass FeedForwardScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork(\n            [FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)]\n        )\n\n        self.add(nn)\n\n        self.play(nn.make_forward_pass_animation())\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_feed_forward.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_feed_forward.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\n\n__module_test__ = \"feed_forward\"\n\n\n@frames_comparison\ndef test_FeedForwardScene(scene):\n    \"\"\"Tests the appearance of a feed forward network\"\"\"\n    nn = NeuralNetwork([FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)])\n\n    scene.add(nn)\n\n\nclass FeedForwardScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork(\n            [FeedForwardLayer(3), FeedForwardLayer(5), FeedForwardLayer(3)]\n        )\n\n        self.add(nn)\n\n        self.play(nn.make_forward_pass_animation())\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_feed_forward.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you help create an animation where the word \"Wiggle\" moves up slightly and wiggles using that cool math animation software?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromCenter\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(GrowFromCenter(triangle))\n            self.remove(triangle)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you help create an animation where the word \"Wiggle\" moves up slightly and wiggles using that cool math animation software?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you help create an animation where the word \"wiggle\" moves up slightly and wiggles using that cool math animation software?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"GrowFromCenter\").shift(UP*2.5)), run_time=0.5)\n            triangle = Triangle()\n            self.play(GrowFromCenter(triangle))\n            self.remove(triangle)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you help create an animation where the word \"Wiggle\" moves up slightly and wiggles using that cool math animation software?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animated video using Manim that introduces the wave equation, describes its components including wave speed, then extends it to three dimensions and ends by showing an example solution involving terms like amplitude, wave number, and angular frequency, with each concept and equation appearing on screen sequentially and concluding by fading everything out?"}, {"from": "assistant", "value": "```python\nimport numpy as np\nfrom manim import *\n\n\nclass ComplexPlaneWithFunctionDots(ComplexPlane):\n    class InputDot(Dot):\n        def __init__(self, plane, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def set_value(self, value):\n            self.move_to(self.plane.n2p(value))\n\n            return self\n\n    class OutputDot(Dot):\n        def __init__(self, plane, input_dot, func, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n            self.input_dot = input_dot\n            self.func = func\n\n            self.update_position()\n            always(self.update_position)\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def update_position(self):\n            self.move_to(self.plane.n2p(self.func(self.input_dot.get_value())))\n\n    def get_function_dots(self, func, *, input_config={}, output_config={}):\n        input_dot = self.InputDot(self, **input_config)\n        output_dot = self.OutputDot(self, input_dot, func, **output_config)\n\n        return input_dot, output_dot\n\n\nclass Euler(Scene):\n    def construct(self):\n        plane = ComplexPlaneWithFunctionDots()\n        plane.add_coordinates(*plane.get_default_coordinate_values())\n        self.add(plane)\n\n        theta_dot, z_dot = plane.get_function_dots(\n            lambda z: np.exp(1j * z),\n            input_config={\"color\": RED},\n            output_config={\"color\": YELLOW, \"z_index\": 1},\n        )\n\n        path = TracedPath(z_dot.get_center, min_distance_to_new_point=0)\n\n        formula = MathTex(\"z\", \"=e^{i\", r\"\\theta}\").move_to(5.5 * LEFT + 2.5 * UP)\n        formula[0].set_color(z_dot.get_color())\n        formula[2].set_color(theta_dot.get_color())\n\n        formula_box = Rectangle(\n            width=formula.get_width() + MED_SMALL_BUFF,\n            height=formula.get_height() + MED_SMALL_BUFF,\n        )\n        formula_box.move_to(formula).set_fill(BLACK, opacity=1).set_stroke(\n            BLUE, opacity=1, width=DEFAULT_STROKE_WIDTH / 2\n        )\n\n        formula_group = VGroup(formula_box, formula)\n\n        self.add(path, formula_group, theta_dot, z_dot)\n        self.play(theta_dot.set_value, TAU, run_time=3)\n\n        indicate_path = Circle(color=PINK)\n        self.play(ShowCreationThenDestruction(indicate_path), run_time=3)\n\n        self.play(theta_dot.set_value, 1j, run_time=3)\n        self.play(Rotating(theta_dot, about_point=ORIGIN), run_time=3)\n        self.play(theta_dot.move_to, plane.n2p(0))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated video using Manim that introduces the wave equation, describes its components including wave speed, then extends it to three dimensions and ends by showing an example solution involving terms like amplitude, wave number, and angular frequency, with each concept and equation appearing on screen sequentially and concluding by fading everything out?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animated video using manim that introduces the wave equation, describes its components including wave speed, then extends it to three dimensions and ends by showing an example solution involving terms like amplitude, wave number, and angular frequency, with each concept and equation appearing on screen sequentially and concluding by fading everything out?"}, {"from": "assistant", "value": "```python\nimport numpy as np\nfrom manim import *\n\n\nclass ComplexPlaneWithFunctionDots(ComplexPlane):\n    class InputDot(Dot):\n        def __init__(self, plane, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def set_value(self, value):\n            self.move_to(self.plane.n2p(value))\n\n            return self\n\n    class OutputDot(Dot):\n        def __init__(self, plane, input_dot, func, **kwargs):\n            super().__init__(**kwargs)\n\n            self.plane = plane\n            self.input_dot = input_dot\n            self.func = func\n\n            self.update_position()\n            always(self.update_position)\n\n        def get_value(self):\n            return self.plane.p2n(self.get_center())\n\n        def update_position(self):\n            self.move_to(self.plane.n2p(self.func(self.input_dot.get_value())))\n\n    def get_function_dots(self, func, *, input_config={}, output_config={}):\n        input_dot = self.InputDot(self, **input_config)\n        output_dot = self.OutputDot(self, input_dot, func, **output_config)\n\n        return input_dot, output_dot\n\n\nclass Euler(Scene):\n    def construct(self):\n        plane = ComplexPlaneWithFunctionDots()\n        plane.add_coordinates(*plane.get_default_coordinate_values())\n        self.add(plane)\n\n        theta_dot, z_dot = plane.get_function_dots(\n            lambda z: np.exp(1j * z),\n            input_config={\"color\": RED},\n            output_config={\"color\": YELLOW, \"z_index\": 1},\n        )\n\n        path = TracedPath(z_dot.get_center, min_distance_to_new_point=0)\n\n        formula = MathTex(\"z\", \"=e^{i\", r\"\\theta}\").move_to(5.5 * LEFT + 2.5 * UP)\n        formula[0].set_color(z_dot.get_color())\n        formula[2].set_color(theta_dot.get_color())\n\n        formula_box = Rectangle(\n            width=formula.get_width() + MED_SMALL_BUFF,\n            height=formula.get_height() + MED_SMALL_BUFF,\n        )\n        formula_box.move_to(formula).set_fill(BLACK, opacity=1).set_stroke(\n            BLUE, opacity=1, width=DEFAULT_STROKE_WIDTH / 2\n        )\n\n        formula_group = VGroup(formula_box, formula)\n\n        self.add(path, formula_group, theta_dot, z_dot)\n        self.play(theta_dot.set_value, TAU, run_time=3)\n\n        indicate_path = Circle(color=PINK)\n        self.play(ShowCreationThenDestruction(indicate_path), run_time=3)\n\n        self.play(theta_dot.set_value, 1j, run_time=3)\n        self.play(Rotating(theta_dot, about_point=ORIGIN), run_time=3)\n        self.play(theta_dot.move_to, plane.n2p(0))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated video using Manim that introduces the wave equation, describes its components including wave speed, then extends it to three dimensions and ends by showing an example solution involving terms like amplitude, wave number, and angular frequency, with each concept and equation appearing on screen sequentially and concluding by fading everything out?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a square using a custom class that overrides the default `FadeIn` animation. Instead of fading in, the square is drawn using the `Create` animation when the scene plays."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a square using a custom class that overrides the default `FadeIn` animation. Instead of fading in, the square is drawn using the `Create` animation when the scene plays."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a square using a custom class that overrides the default `fadein` animation. instead of fading in, the square is drawn using the `create` animation when the scene plays."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MySquare(Square):\n    @override_animation(FadeIn)\n    def _fade_in_override(self, **kwargs):\n        return Create(self, **kwargs)\n\nclass OverrideAnimationExample(Scene):\n    def construct(self):\n        self.play(FadeIn(MySquare()))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a square using a custom class that overrides the default `FadeIn` animation. Instead of fading in, the square is drawn using the `Create` animation when the scene plays."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In psychological games, how can we model the impact of a player's perception of fairness on their strategic decisions within a repeated prisoner's dilemma?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FairnessInPrisonersDilemma(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fair Play: Prisoner's Dilemma with Fairness\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction to Prisoner's Dilemma\n        intro_text = Text(\"Traditional Prisoner's Dilemma\", font_size=36)\n        self.play(Write(intro_text))\n        self.wait(1)\n        \n        # Create simple visualization of two players\n        prisoner1 = Circle(radius=0.5, color=BLUE).shift(LEFT*2)\n        prisoner2 = Circle(radius=0.5, color=RED).shift(RIGHT*2)\n        \n        self.play(Create(prisoner1), Create(prisoner2))\n        self.wait(1)\n        \n        # Fade out introduction elements separately to ensure compatibility\n        self.play(FadeOut(intro_text))\n        self.play(FadeOut(prisoner1), FadeOut(prisoner2))\n        \n        # Simple payoff matrix explanation\n        matrix_title = Text(\"Traditional Payoff Matrix\", font_size=32).to_edge(UP)\n        self.play(Write(matrix_title))\n        \n        # Create simplified payoff matrix with text\n        cc_text = Text(\"(C,C): Both get 3\", font_size=24).shift(UP*1)\n        dd_text = Text(\"(D,D): Both get 1\", font_size=24).shift(DOWN*1)\n        \n        self.play(Write(cc_text))\n        self.play(Write(dd_text))\n        self.wait(1)\n        \n        # Nash equilibrium explanation\n        nash_text = Text(\"Nash Equilibrium: (D,D)\", font_size=28).shift(DOWN*2)\n        self.play(Write(nash_text))\n        self.wait(1)\n        \n        # Transition to fairness concept (fade out elements separately)\n        self.play(FadeOut(matrix_title))\n        self.play(FadeOut(cc_text), FadeOut(dd_text))\n        self.play(FadeOut(nash_text))\n        \n        # Introducing fairness utility\n        fairness_title = Text(\"Adding Fairness to Utility\", font_size=32).to_edge(UP)\n        self.play(Write(fairness_title))\n        \n        # Key equations using Text\n        eq1 = Text(\"u_a = pay_a + fairness_a\", font_size=28).shift(UP*0.5)\n        eq2 = Text(\"u_b = pay_b + fairness_b\", font_size=28).shift(DOWN*0.5)\n        \n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Fairness effect visualization (fade out elements separately)\n        self.play(FadeOut(fairness_title))\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        effect_title = Text(\"Effect of Fairness\", font_size=32).to_edge(UP)\n        self.play(Write(effect_title))\n        \n        # Create two states representing traditional and fairness-enhanced equilibria\n        trad_eq = Circle(radius=0.7, color=RED).shift(LEFT*2)\n        fair_eq = Circle(radius=0.7, color=GREEN).shift(RIGHT*2)\n        \n        trad_label = Text(\"D,D\", font_size=24).move_to(trad_eq)\n        fair_label = Text(\"C,C\", font_size=24).move_to(fair_eq)\n        \n        arrow = Arrow(trad_eq.get_right(), fair_eq.get_left(), buff=0.2)\n        arrow_label = Text(\"Fairness\", font_size=20).next_to(arrow, UP)\n        \n        self.play(Create(trad_eq), Write(trad_label))\n        self.play(Create(fair_eq), Write(fair_label))\n        self.play(GrowArrow(arrow), Write(arrow_label))\n        self.wait(1)\n        \n        # Conclusion (fade out elements in smaller groups)\n        self.play(FadeOut(effect_title))\n        self.play(FadeOut(trad_eq), FadeOut(trad_label))\n        self.play(FadeOut(fair_eq), FadeOut(fair_label))\n        self.play(FadeOut(arrow), FadeOut(arrow_label))\n        \n        conclusion = Text(\"Fairness perception leads to\\nmore cooperative outcomes\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In psychological games, how can we model the impact of a player's perception of fairness on their strategic decisions within a repeated prisoner's dilemma?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in psychological games, how can we model the impact of a player's perception of fairness on their strategic decisions within a repeated prisoner's dilemma?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FairnessInPrisonersDilemma(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fair Play: Prisoner's Dilemma with Fairness\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction to Prisoner's Dilemma\n        intro_text = Text(\"Traditional Prisoner's Dilemma\", font_size=36)\n        self.play(Write(intro_text))\n        self.wait(1)\n        \n        # Create simple visualization of two players\n        prisoner1 = Circle(radius=0.5, color=BLUE).shift(LEFT*2)\n        prisoner2 = Circle(radius=0.5, color=RED).shift(RIGHT*2)\n        \n        self.play(Create(prisoner1), Create(prisoner2))\n        self.wait(1)\n        \n        # Fade out introduction elements separately to ensure compatibility\n        self.play(FadeOut(intro_text))\n        self.play(FadeOut(prisoner1), FadeOut(prisoner2))\n        \n        # Simple payoff matrix explanation\n        matrix_title = Text(\"Traditional Payoff Matrix\", font_size=32).to_edge(UP)\n        self.play(Write(matrix_title))\n        \n        # Create simplified payoff matrix with text\n        cc_text = Text(\"(C,C): Both get 3\", font_size=24).shift(UP*1)\n        dd_text = Text(\"(D,D): Both get 1\", font_size=24).shift(DOWN*1)\n        \n        self.play(Write(cc_text))\n        self.play(Write(dd_text))\n        self.wait(1)\n        \n        # Nash equilibrium explanation\n        nash_text = Text(\"Nash Equilibrium: (D,D)\", font_size=28).shift(DOWN*2)\n        self.play(Write(nash_text))\n        self.wait(1)\n        \n        # Transition to fairness concept (fade out elements separately)\n        self.play(FadeOut(matrix_title))\n        self.play(FadeOut(cc_text), FadeOut(dd_text))\n        self.play(FadeOut(nash_text))\n        \n        # Introducing fairness utility\n        fairness_title = Text(\"Adding Fairness to Utility\", font_size=32).to_edge(UP)\n        self.play(Write(fairness_title))\n        \n        # Key equations using Text\n        eq1 = Text(\"u_a = pay_a + fairness_a\", font_size=28).shift(UP*0.5)\n        eq2 = Text(\"u_b = pay_b + fairness_b\", font_size=28).shift(DOWN*0.5)\n        \n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Fairness effect visualization (fade out elements separately)\n        self.play(FadeOut(fairness_title))\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        effect_title = Text(\"Effect of Fairness\", font_size=32).to_edge(UP)\n        self.play(Write(effect_title))\n        \n        # Create two states representing traditional and fairness-enhanced equilibria\n        trad_eq = Circle(radius=0.7, color=RED).shift(LEFT*2)\n        fair_eq = Circle(radius=0.7, color=GREEN).shift(RIGHT*2)\n        \n        trad_label = Text(\"D,D\", font_size=24).move_to(trad_eq)\n        fair_label = Text(\"C,C\", font_size=24).move_to(fair_eq)\n        \n        arrow = Arrow(trad_eq.get_right(), fair_eq.get_left(), buff=0.2)\n        arrow_label = Text(\"Fairness\", font_size=20).next_to(arrow, UP)\n        \n        self.play(Create(trad_eq), Write(trad_label))\n        self.play(Create(fair_eq), Write(fair_label))\n        self.play(GrowArrow(arrow), Write(arrow_label))\n        self.wait(1)\n        \n        # Conclusion (fade out elements in smaller groups)\n        self.play(FadeOut(effect_title))\n        self.play(FadeOut(trad_eq), FadeOut(trad_label))\n        self.play(FadeOut(fair_eq), FadeOut(fair_label))\n        self.play(FadeOut(arrow), FadeOut(arrow_label))\n        \n        conclusion = Text(\"Fairness perception leads to\\nmore cooperative outcomes\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In psychological games, how can we model the impact of a player's perception of fairness on their strategic decisions within a repeated prisoner's dilemma?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "warmup_mcmc.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nimport scipy.stats\nfrom manim_ml.diffusion.mcmc import MCMCAxes\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('dark_background')\n\n# Make the specific scene\nconfig.pixel_height = 720\nconfig.pixel_width = 720\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\nclass MCMCWarmupScene(Scene):\n\n    def construct(self):\n        # Define the Gaussian Mixture likelihood\n        def gaussian_mm_logpdf(x):\n            \"\"\"Gaussian Mixture Model Log PDF\"\"\"\n            # Choose two arbitrary Gaussians\n            # Big Gaussian\n            big_gaussian_pdf = scipy.stats.multivariate_normal(\n                mean=[-0.5, -0.5],\n                cov=[1.0, 1.0]\n            ).pdf(x)\n            # Little Gaussian\n            little_gaussian_pdf = scipy.stats.multivariate_normal(\n                mean=[2.3, 1.9],\n                cov=[0.3, 0.3]\n            ).pdf(x)\n            # Sum their likelihoods and take the log\n            logpdf = np.log(big_gaussian_pdf + little_gaussian_pdf)\n\n            return logpdf\n\n        # Generate a bunch of true samples\n        true_samples = []\n        # Generate samples for little gaussian\n        little_gaussian_samples = np.random.multivariate_normal(\n            mean=[2.3, 1.9],\n            cov=[[0.3, 0.0], [0.0, 0.3]],\n            size=(10000)\n        )\n        big_gaussian_samples = np.random.multivariate_normal(\n            mean=[-0.5, -0.5],\n            cov=[[1.0, 0.0], [0.0, 1.0]],\n            size=(10000)\n        )\n        true_samples = np.concatenate((little_gaussian_samples, big_gaussian_samples))\n        # Make the MCMC axes\n        axes = MCMCAxes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            x_length=7.0,\n            y_length=7.0\n        )\n        axes.move_to(ORIGIN)\n        self.play(\n            Create(axes)\n        )\n        # Make the chain sampling animation \n        chain_sampling_animation = axes.visualize_metropolis_hastings_chain_sampling(\n            log_prob_fn=gaussian_mm_logpdf, \n            true_samples=true_samples,\n            sampling_kwargs={\n                \"iterations\": 2000,\n                \"warm_up\": 50,\n                \"initial_location\": np.array([-3.5, 3.5]),\n                \"sampling_seed\": 4\n            },\n        )\n        self.play(chain_sampling_animation)\n        self.wait(3)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "warmup_mcmc.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that warmup_mcmc.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nimport scipy.stats\nfrom manim_ml.diffusion.mcmc import MCMCAxes\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nplt.style.use('dark_background')\n\n# Make the specific scene\nconfig.pixel_height = 720\nconfig.pixel_width = 720\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\nclass MCMCWarmupScene(Scene):\n\n    def construct(self):\n        # Define the Gaussian Mixture likelihood\n        def gaussian_mm_logpdf(x):\n            \"\"\"Gaussian Mixture Model Log PDF\"\"\"\n            # Choose two arbitrary Gaussians\n            # Big Gaussian\n            big_gaussian_pdf = scipy.stats.multivariate_normal(\n                mean=[-0.5, -0.5],\n                cov=[1.0, 1.0]\n            ).pdf(x)\n            # Little Gaussian\n            little_gaussian_pdf = scipy.stats.multivariate_normal(\n                mean=[2.3, 1.9],\n                cov=[0.3, 0.3]\n            ).pdf(x)\n            # Sum their likelihoods and take the log\n            logpdf = np.log(big_gaussian_pdf + little_gaussian_pdf)\n\n            return logpdf\n\n        # Generate a bunch of true samples\n        true_samples = []\n        # Generate samples for little gaussian\n        little_gaussian_samples = np.random.multivariate_normal(\n            mean=[2.3, 1.9],\n            cov=[[0.3, 0.0], [0.0, 0.3]],\n            size=(10000)\n        )\n        big_gaussian_samples = np.random.multivariate_normal(\n            mean=[-0.5, -0.5],\n            cov=[[1.0, 0.0], [0.0, 1.0]],\n            size=(10000)\n        )\n        true_samples = np.concatenate((little_gaussian_samples, big_gaussian_samples))\n        # Make the MCMC axes\n        axes = MCMCAxes(\n            x_range=[-5, 5],\n            y_range=[-5, 5],\n            x_length=7.0,\n            y_length=7.0\n        )\n        axes.move_to(ORIGIN)\n        self.play(\n            Create(axes)\n        )\n        # Make the chain sampling animation \n        chain_sampling_animation = axes.visualize_metropolis_hastings_chain_sampling(\n            log_prob_fn=gaussian_mm_logpdf, \n            true_samples=true_samples,\n            sampling_kwargs={\n                \"iterations\": 2000,\n                \"warm_up\": 50,\n                \"initial_location\": np.array([-3.5, 3.5]),\n                \"sampling_seed\": 4\n            },\n        )\n        self.play(chain_sampling_animation)\n        self.wait(3)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "warmup_mcmc.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways does Gaussian noise alter the signal-to-noise ratio in communication systems, and how can these changes be illustrated graphically?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass GaussianNoiseAnimation(Scene):\n    def construct(self):\n        # Colors\n        signal_color = \"#3498db\"  # Cool blue for signal\n        noise_color = \"#7f8c8d\"   # Muted gray for noise\n        \n        # Title\n        title = Text(\"Illuminating Signals Through Gaussian Noise\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Element 1: Create axes and clean sine wave\n        axes = Axes(\n            x_range=[0, 6, 1],\n            y_range=[-2, 2, 1],\n        ).scale(0.8)\n        axes.move_to(ORIGIN)\n        \n        # Original clean signal\n        def clean_signal(x):\n            return np.sin(x)\n        \n        clean_graph = axes.plot(clean_signal, color=signal_color)\n        clean_label = Text(\"Clean Signal\", font_size=24, color=signal_color).next_to(axes, UP)\n        \n        self.play(Create(axes))\n        self.play(Create(clean_graph))\n        self.play(Write(clean_label))\n        self.wait(1)\n        \n        # Element 2: Add Gaussian noise\n        x_vals = np.linspace(0, 6, 25)\n        y_vals = [clean_signal(x) + np.random.normal(0, 0.5) for x in x_vals]\n        noisy_dots = VGroup()\n        \n        for i in range(len(x_vals)):\n            dot = Dot(point=axes.c2p(x_vals[i], y_vals[i]), color=noise_color, radius=0.05)\n            noisy_dots.add(dot)\n        \n        noise_label = Text(\"Signal with Gaussian Noise\", font_size=24, color=noise_color).next_to(axes, UP)\n        \n        self.play(FadeOut(clean_label))\n        self.play(Write(noise_label))\n        self.play(Create(noisy_dots))\n        self.wait(1)\n        \n        # Element 3: Show signal and noise equation\n        equation = MathTex(\"y(t) = x(t) + n(t)\")\n        equation.next_to(axes, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Element 4: Show SNR equation\n        snr_eq = MathTex(\"SNR = \\\\frac{P_{signal}}{P_{noise}}\")\n        snr_eq.next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(snr_eq))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(\n            FadeOut(axes),\n            FadeOut(clean_graph),\n            FadeOut(noisy_dots),\n            FadeOut(noise_label),\n            FadeOut(equation),\n            FadeOut(snr_eq)\n        )\n        \n        # Element 5: Show Gaussian distribution\n        gaussian_axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[0, 0.5, 0.1],\n        ).scale(0.8)\n        \n        # Gaussian function\n        def gaussian(x, mu=0, sigma=1):\n            return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mu) / sigma) ** 2)\n        \n        gaussian_graph = gaussian_axes.plot(lambda x: gaussian(x), color=noise_color)\n        gaussian_label = Text(\"Gaussian Noise Distribution\", font_size=24).next_to(gaussian_axes, UP)\n        \n        self.play(Create(gaussian_axes))\n        self.play(Create(gaussian_graph))\n        self.play(Write(gaussian_label))\n        self.wait(1)\n        \n        # Show Gaussian distribution equation\n        gaussian_eq = MathTex(\"n(t) \\\\sim \\\\mathcal{N}(0, \\\\sigma^2)\")\n        gaussian_eq.next_to(gaussian_axes, DOWN, buff=0.5)\n        \n        self.play(Write(gaussian_eq))\n        self.wait(1)\n        \n        # Element 6: Conclusion\n        self.play(\n            FadeOut(gaussian_axes),\n            FadeOut(gaussian_graph),\n            FadeOut(gaussian_label),\n            FadeOut(gaussian_eq)\n        )\n        \n        conclusion = Text(\"As noise variance increases, SNR decreases\", font_size=28)\n        conclusion.next_to(title, DOWN, buff=1)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(Group(*self.mobjects)))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways does Gaussian noise alter the signal-to-noise ratio in communication systems, and how can these changes be illustrated graphically?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways does gaussian noise alter the signal-to-noise ratio in communication systems, and how can these changes be illustrated graphically?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass GaussianNoiseAnimation(Scene):\n    def construct(self):\n        # Colors\n        signal_color = \"#3498db\"  # Cool blue for signal\n        noise_color = \"#7f8c8d\"   # Muted gray for noise\n        \n        # Title\n        title = Text(\"Illuminating Signals Through Gaussian Noise\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Element 1: Create axes and clean sine wave\n        axes = Axes(\n            x_range=[0, 6, 1],\n            y_range=[-2, 2, 1],\n        ).scale(0.8)\n        axes.move_to(ORIGIN)\n        \n        # Original clean signal\n        def clean_signal(x):\n            return np.sin(x)\n        \n        clean_graph = axes.plot(clean_signal, color=signal_color)\n        clean_label = Text(\"Clean Signal\", font_size=24, color=signal_color).next_to(axes, UP)\n        \n        self.play(Create(axes))\n        self.play(Create(clean_graph))\n        self.play(Write(clean_label))\n        self.wait(1)\n        \n        # Element 2: Add Gaussian noise\n        x_vals = np.linspace(0, 6, 25)\n        y_vals = [clean_signal(x) + np.random.normal(0, 0.5) for x in x_vals]\n        noisy_dots = VGroup()\n        \n        for i in range(len(x_vals)):\n            dot = Dot(point=axes.c2p(x_vals[i], y_vals[i]), color=noise_color, radius=0.05)\n            noisy_dots.add(dot)\n        \n        noise_label = Text(\"Signal with Gaussian Noise\", font_size=24, color=noise_color).next_to(axes, UP)\n        \n        self.play(FadeOut(clean_label))\n        self.play(Write(noise_label))\n        self.play(Create(noisy_dots))\n        self.wait(1)\n        \n        # Element 3: Show signal and noise equation\n        equation = MathTex(\"y(t) = x(t) + n(t)\")\n        equation.next_to(axes, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Element 4: Show SNR equation\n        snr_eq = MathTex(\"SNR = \\\\frac{P_{signal}}{P_{noise}}\")\n        snr_eq.next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(snr_eq))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(\n            FadeOut(axes),\n            FadeOut(clean_graph),\n            FadeOut(noisy_dots),\n            FadeOut(noise_label),\n            FadeOut(equation),\n            FadeOut(snr_eq)\n        )\n        \n        # Element 5: Show Gaussian distribution\n        gaussian_axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[0, 0.5, 0.1],\n        ).scale(0.8)\n        \n        # Gaussian function\n        def gaussian(x, mu=0, sigma=1):\n            return (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-0.5 * ((x - mu) / sigma) ** 2)\n        \n        gaussian_graph = gaussian_axes.plot(lambda x: gaussian(x), color=noise_color)\n        gaussian_label = Text(\"Gaussian Noise Distribution\", font_size=24).next_to(gaussian_axes, UP)\n        \n        self.play(Create(gaussian_axes))\n        self.play(Create(gaussian_graph))\n        self.play(Write(gaussian_label))\n        self.wait(1)\n        \n        # Show Gaussian distribution equation\n        gaussian_eq = MathTex(\"n(t) \\\\sim \\\\mathcal{N}(0, \\\\sigma^2)\")\n        gaussian_eq.next_to(gaussian_axes, DOWN, buff=0.5)\n        \n        self.play(Write(gaussian_eq))\n        self.wait(1)\n        \n        # Element 6: Conclusion\n        self.play(\n            FadeOut(gaussian_axes),\n            FadeOut(gaussian_graph),\n            FadeOut(gaussian_label),\n            FadeOut(gaussian_eq)\n        )\n        \n        conclusion = Text(\"As noise variance increases, SNR decreases\", font_size=28)\n        conclusion.next_to(title, DOWN, buff=1)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(Group(*self.mobjects)))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways does Gaussian noise alter the signal-to-noise ratio in communication systems, and how can these changes be illustrated graphically?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways does the construction of higher Chow groups depict the connection between algebraic cycles and homotopy theory, specifically in a visual model?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AlgebraicCyclesAndHomotopy(Scene):\n    def construct(self):\n        # Title slide\n        title = Text(\"The Geometry of Algebraic Cycles and Homotopy Paths\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Element 1: Create a projective plane (represented as a simple grid)\n        grid = NumberPlane(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n            background_line_style={\n                \"stroke_color\": BLUE_E,\n                \"stroke_width\": 2,\n                \"stroke_opacity\": 0.6\n            }\n        )\n        \n        grid_label = Text(\"Projective Plane\", font_size=24).to_edge(UP)\n        \n        self.play(Create(grid), Write(grid_label))\n        self.wait(1)\n        \n        # Element 2: Create algebraic cycles (represented as geometric shapes)\n        # Using a triangle and circle to represent different dimensional cycles\n        triangle = Polygon([-2, -2, 0], [0, 2, 0], [2, -1, 0], color=YELLOW)\n        circle = Circle(radius=1.5, color=BLUE).shift(RIGHT * 1.5)\n        \n        cycles_label = Text(\"Algebraic Cycles\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, cycles_label),\n            Create(triangle),\n            Create(circle)\n        )\n        self.wait(1)\n        \n        # Element 3: Higher Chow groups (represented by connections between cycles)\n        # Line connecting different cycles to show their relationships\n        line = Line(triangle.get_center(), circle.get_center(), color=YELLOW)\n        \n        chow_label = Text(\"Higher Chow Groups\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, chow_label),\n            Create(line)\n        )\n        self.wait(1)\n        \n        # Element 4: Homotopic paths (represented by an arc)\n        # This arc represents a continuous deformation pathway\n        arc = Arc(radius=2, start_angle=0, angle=PI, color=VIOLET).shift(UP * 0.5)\n        \n        homotopy_label = Text(\"Homotopic Paths\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, homotopy_label),\n            Create(arc)\n        )\n        self.wait(1)\n        \n        # Element 5: First equation - algebraic cycle formula\n        eq1 = MathTex(r\"\\sum_{i=1}^{n} (-1)^i [x_0, ..., \\hat{x}_i, ..., x_n]\").shift(DOWN * 2)\n        \n        equation_label = Text(\"Mathematical Representation\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, equation_label),\n            Write(eq1)\n        )\n        self.wait(1)\n        \n        # Element 6: Second equation - homology sequence\n        eq2 = MathTex(r\"H_*(X) \\to H_*(Y, X) \\to H_*(Y) \\to H_{*-1}(X)\").next_to(eq1, DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(2)\n        \n        # Conclusion summarizing the connection\n        conclusion = Text(\"Connection between algebraic cycles and homotopy theory\", font_size=30)\n        \n        self.play(\n            FadeOut(VGroup(grid, triangle, circle, line, arc, grid_label, eq1, eq2)),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways does the construction of higher Chow groups depict the connection between algebraic cycles and homotopy theory, specifically in a visual model?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways does the construction of higher chow groups depict the connection between algebraic cycles and homotopy theory, specifically in a visual model?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AlgebraicCyclesAndHomotopy(Scene):\n    def construct(self):\n        # Title slide\n        title = Text(\"The Geometry of Algebraic Cycles and Homotopy Paths\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Element 1: Create a projective plane (represented as a simple grid)\n        grid = NumberPlane(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n            background_line_style={\n                \"stroke_color\": BLUE_E,\n                \"stroke_width\": 2,\n                \"stroke_opacity\": 0.6\n            }\n        )\n        \n        grid_label = Text(\"Projective Plane\", font_size=24).to_edge(UP)\n        \n        self.play(Create(grid), Write(grid_label))\n        self.wait(1)\n        \n        # Element 2: Create algebraic cycles (represented as geometric shapes)\n        # Using a triangle and circle to represent different dimensional cycles\n        triangle = Polygon([-2, -2, 0], [0, 2, 0], [2, -1, 0], color=YELLOW)\n        circle = Circle(radius=1.5, color=BLUE).shift(RIGHT * 1.5)\n        \n        cycles_label = Text(\"Algebraic Cycles\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, cycles_label),\n            Create(triangle),\n            Create(circle)\n        )\n        self.wait(1)\n        \n        # Element 3: Higher Chow groups (represented by connections between cycles)\n        # Line connecting different cycles to show their relationships\n        line = Line(triangle.get_center(), circle.get_center(), color=YELLOW)\n        \n        chow_label = Text(\"Higher Chow Groups\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, chow_label),\n            Create(line)\n        )\n        self.wait(1)\n        \n        # Element 4: Homotopic paths (represented by an arc)\n        # This arc represents a continuous deformation pathway\n        arc = Arc(radius=2, start_angle=0, angle=PI, color=VIOLET).shift(UP * 0.5)\n        \n        homotopy_label = Text(\"Homotopic Paths\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, homotopy_label),\n            Create(arc)\n        )\n        self.wait(1)\n        \n        # Element 5: First equation - algebraic cycle formula\n        eq1 = MathTex(r\"\\sum_{i=1}^{n} (-1)^i [x_0, ..., \\hat{x}_i, ..., x_n]\").shift(DOWN * 2)\n        \n        equation_label = Text(\"Mathematical Representation\", font_size=24).to_edge(UP)\n        \n        self.play(\n            Transform(grid_label, equation_label),\n            Write(eq1)\n        )\n        self.wait(1)\n        \n        # Element 6: Second equation - homology sequence\n        eq2 = MathTex(r\"H_*(X) \\to H_*(Y, X) \\to H_*(Y) \\to H_{*-1}(X)\").next_to(eq1, DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(2)\n        \n        # Conclusion summarizing the connection\n        conclusion = Text(\"Connection between algebraic cycles and homotopy theory\", font_size=30)\n        \n        self.play(\n            FadeOut(VGroup(grid, triangle, circle, line, arc, grid_label, eq1, eq2)),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways does the construction of higher Chow groups depict the connection between algebraic cycles and homotopy theory, specifically in a visual model?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "max_pooling.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass MaxPoolingScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 8),\n                Convolutional2DLayer(3, 6, 3),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(5, 2, 2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "max_pooling.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that max_pooling.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.max_pooling_2d import MaxPooling2DLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass MaxPoolingScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 8),\n                Convolutional2DLayer(3, 6, 3),\n                MaxPooling2DLayer(kernel_size=2),\n                Convolutional2DLayer(5, 2, 2),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "max_pooling.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the word \"Colors\" in large font, with each letter randomly assigned a different bright color."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IterateColor(Scene):\n    def construct(self):\n        text = Text(\"Colors\", font_size=96)\n        for letter in text:\n            letter.set_color(random_bright_color())\n        self.add(text)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \"Colors\" in large font, with each letter randomly assigned a different bright color."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the word \"colors\" in large font, with each letter randomly assigned a different bright color."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IterateColor(Scene):\n    def construct(self):\n        text = Text(\"Colors\", font_size=96)\n        for letter in text:\n            letter.set_color(random_bright_color())\n        self.add(text)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \"Colors\" in large font, with each letter randomly assigned a different bright color."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a circle positioned in the upper-right corner of the screen. A LaTeX-style text reading \u201cTo the corner!\u201d is placed in the lower-left corner with no buffer space, and a mathematical expression \u201c\\(x^3\\)\u201d is positioned in the upper-left corner with extra spacing from the edges. All three elements appear simultaneously."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ToCornerExample(Scene):\n    def construct(self):\n        c = Circle()\n        c.to_corner(UR)\n        t = Tex(\"To the corner!\")\n        t2 = MathTex(\"x^3\").shift(DOWN)\n        self.add(c,t,t2)\n        t.to_corner(DL, buff=0)\n        t2.to_corner(UL, buff=1.5)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a circle positioned in the upper-right corner of the screen. A LaTeX-style text reading \u201cTo the corner!\u201d is placed in the lower-left corner with no buffer space, and a mathematical expression \u201c\\(x^3\\)\u201d is positioned in the upper-left corner with extra spacing from the edges. All three elements appear simultaneously."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a circle positioned in the upper-right corner of the screen. a latex-style text reading \u201cto the corner!\u201d is placed in the lower-left corner with no buffer space, and a mathematical expression \u201c\\(x^3\\)\u201d is positioned in the upper-left corner with extra spacing from the edges. all three elements appear simultaneously."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ToCornerExample(Scene):\n    def construct(self):\n        c = Circle()\n        c.to_corner(UR)\n        t = Tex(\"To the corner!\")\n        t2 = MathTex(\"x^3\").shift(DOWN)\n        self.add(c,t,t2)\n        t.to_corner(DL, buff=0)\n        t2.to_corner(UL, buff=1.5)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a circle positioned in the upper-right corner of the screen. A LaTeX-style text reading \u201cTo the corner!\u201d is placed in the lower-left corner with no buffer space, and a mathematical expression \u201c\\(x^3\\)\u201d is positioned in the upper-left corner with extra spacing from the edges. All three elements appear simultaneously."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In an entangled chain of circles, how can an animation clarify the effect of a crossing change on the linking number?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LinkingNumberDemo(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling the Power of a Knot: Exploring Linking Numbers\", font_size=32)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.scale(0.5).to_edge(UP))\n        \n        # Create two linked circles\n        circle1 = Circle(radius=1.2, color=BLUE_C).shift(LEFT * 0.5)\n        circle2 = Circle(radius=1.2, color=GREEN_C).shift(RIGHT * 0.5)\n        \n        self.play(Create(circle1), Create(circle2))\n        self.wait()\n        \n        # Highlight crossing points\n        crossing1 = Dot(UP * 0.3, color=YELLOW)\n        crossing2 = Dot(DOWN * 0.3, color=YELLOW)\n        \n        self.play(FadeIn(crossing1), FadeIn(crossing2))\n        self.wait()\n        \n        # Show linking number formula\n        formula = MathTex(r\"L = \\frac{1}{2} \\sum_{i,j} \\text{sgn}(C_i,C_j)\")\n        formula.to_edge(DOWN, buff=1.5)\n        \n        # Show current linking number\n        linking_text = Text(\"Linking Number = 2\", font_size=28)\n        linking_text.next_to(formula, DOWN)\n        \n        self.play(Write(formula), Write(linking_text))\n        self.wait()\n        \n        # Focus on crossing to change\n        highlight = SurroundingRectangle(crossing1, color=RED)\n        change_text = Text(\"Change Crossing\", font_size=24, color=RED)\n        change_text.next_to(highlight, RIGHT)\n        \n        self.play(Create(highlight), Write(change_text))\n        self.wait()\n        \n        # Show crossing change\n        cross_flip = Arrow(UP * 0.5, DOWN * 0.5, color=RED)\n        cross_flip.next_to(crossing1, LEFT)\n        \n        self.play(Create(cross_flip))\n        self.wait()\n        \n        # Show linking number change\n        change_eq = MathTex(r\"\\text{Linking Number Change} = \\pm 2\")\n        change_eq.next_to(formula, UP)\n        \n        self.play(Write(change_eq))\n        self.wait()\n        \n        # Show new linking number\n        new_linking = Text(\"Linking Number = 0\", font_size=28, color=RED)\n        new_linking.move_to(linking_text)\n        \n        self.play(Transform(linking_text, new_linking))\n        self.wait()\n        \n        # Conclusion\n        conclusion = Text(\"A single crossing change affects the linking number by \u00b12\", font_size=28)\n        conclusion.to_edge(DOWN, buff=0.5)\n        \n        self.play(\n            FadeOut(formula),\n            FadeOut(linking_text),\n            FadeOut(change_eq),\n            FadeOut(highlight),\n            FadeOut(change_text),\n            FadeOut(cross_flip),\n            FadeIn(conclusion)\n        )\n        \n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In an entangled chain of circles, how can an animation clarify the effect of a crossing change on the linking number?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in an entangled chain of circles, how can an animation clarify the effect of a crossing change on the linking number?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LinkingNumberDemo(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling the Power of a Knot: Exploring Linking Numbers\", font_size=32)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.scale(0.5).to_edge(UP))\n        \n        # Create two linked circles\n        circle1 = Circle(radius=1.2, color=BLUE_C).shift(LEFT * 0.5)\n        circle2 = Circle(radius=1.2, color=GREEN_C).shift(RIGHT * 0.5)\n        \n        self.play(Create(circle1), Create(circle2))\n        self.wait()\n        \n        # Highlight crossing points\n        crossing1 = Dot(UP * 0.3, color=YELLOW)\n        crossing2 = Dot(DOWN * 0.3, color=YELLOW)\n        \n        self.play(FadeIn(crossing1), FadeIn(crossing2))\n        self.wait()\n        \n        # Show linking number formula\n        formula = MathTex(r\"L = \\frac{1}{2} \\sum_{i,j} \\text{sgn}(C_i,C_j)\")\n        formula.to_edge(DOWN, buff=1.5)\n        \n        # Show current linking number\n        linking_text = Text(\"Linking Number = 2\", font_size=28)\n        linking_text.next_to(formula, DOWN)\n        \n        self.play(Write(formula), Write(linking_text))\n        self.wait()\n        \n        # Focus on crossing to change\n        highlight = SurroundingRectangle(crossing1, color=RED)\n        change_text = Text(\"Change Crossing\", font_size=24, color=RED)\n        change_text.next_to(highlight, RIGHT)\n        \n        self.play(Create(highlight), Write(change_text))\n        self.wait()\n        \n        # Show crossing change\n        cross_flip = Arrow(UP * 0.5, DOWN * 0.5, color=RED)\n        cross_flip.next_to(crossing1, LEFT)\n        \n        self.play(Create(cross_flip))\n        self.wait()\n        \n        # Show linking number change\n        change_eq = MathTex(r\"\\text{Linking Number Change} = \\pm 2\")\n        change_eq.next_to(formula, UP)\n        \n        self.play(Write(change_eq))\n        self.wait()\n        \n        # Show new linking number\n        new_linking = Text(\"Linking Number = 0\", font_size=28, color=RED)\n        new_linking.move_to(linking_text)\n        \n        self.play(Transform(linking_text, new_linking))\n        self.wait()\n        \n        # Conclusion\n        conclusion = Text(\"A single crossing change affects the linking number by \u00b12\", font_size=28)\n        conclusion.to_edge(DOWN, buff=0.5)\n        \n        self.play(\n            FadeOut(formula),\n            FadeOut(linking_text),\n            FadeOut(change_eq),\n            FadeOut(highlight),\n            FadeOut(change_text),\n            FadeOut(cross_flip),\n            FadeIn(conclusion)\n        )\n        \n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In an entangled chain of circles, how can an animation clarify the effect of a crossing change on the linking number?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation that shows a 3D spherical-like object with a rippling effect on its surface, rotate the camera around it to get a better view, and make the animation last for about 8 seconds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass StreamLinePlot(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        stream_lines = StreamLines(\n            lambda p: np.array([p[1], -p[0], 0]), \n            stroke_width=3,\n            max_anchors_per_line=30,\n        )\n        self.add(plane)\n        self.add(stream_lines)\n        self.play(stream_lines.create())  # Uses the StreamLines Animation\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation that shows a 3D spherical-like object with a rippling effect on its surface, rotate the camera around it to get a better view, and make the animation last for about 8 seconds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation that shows a 3d spherical-like object with a rippling effect on its surface, rotate the camera around it to get a better view, and make the animation last for about 8 seconds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass StreamLinePlot(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        stream_lines = StreamLines(\n            lambda p: np.array([p[1], -p[0], 0]), \n            stroke_width=3,\n            max_anchors_per_line=30,\n        )\n        self.add(plane)\n        self.add(stream_lines)\n        self.play(stream_lines.create())  # Uses the StreamLines Animation\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation that shows a 3D spherical-like object with a rippling effect on its surface, rotate the camera around it to get a better view, and make the animation last for about 8 seconds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animated representation of a neural network using 5 sigmoid neurons in one layer connected to a single output neuron, where each neuron and the connections between them light up sequentially to illustrate the process of activation in a neural network?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        green_square = Square(color=GREEN, fill_opacity=0.5)\n        self.play(DrawBorderThenFill(green_square))\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.play(ReplacementTransform(green_square, blue_circle))\n        self.play(Indicate(blue_circle))\n        self.play(FadeOut(blue_circle))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated representation of a neural network using 5 sigmoid neurons in one layer connected to a single output neuron, where each neuron and the connections between them light up sequentially to illustrate the process of activation in a neural network?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animated representation of a neural network using 5 sigmoid neurons in one layer connected to a single output neuron, where each neuron and the connections between them light up sequentially to illustrate the process of activation in a neural network?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        green_square = Square(color=GREEN, fill_opacity=0.5)\n        self.play(DrawBorderThenFill(green_square))\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        self.play(ReplacementTransform(green_square, blue_circle))\n        self.play(Indicate(blue_circle))\n        self.play(FadeOut(blue_circle))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated representation of a neural network using 5 sigmoid neurons in one layer connected to a single output neuron, where each neuron and the connections between them light up sequentially to illustrate the process of activation in a neural network?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that explains how to calculate the area under the curve of the function f(x) = x^2 from x = 0 to x = 2? I would like to see the following steps visualized: first, display the function and the integral expression for the area we are looking for. Next, add a note to clarify that we are finding the area under the curve between x = 0 and x = 2. Then, show the graph of the function with the area under the curve highlighted. After that, visually depict the actual calculation of the integral, and present the final numeric answer. It would be nice to have the final answer stand out, maybe by enclosing it within a colored box. Finally, clear everything else away and leave only the final answer displayed."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ParametricFunctionExample(Scene):\n    def construct(self):\n        # Display the parametric function\n        param_func_text = MathTex(r'\\vec{r}(t) = \\langle \\cos(t), \\sin(t) \\rangle')\n        self.play(Write(param_func_text))\n        self.wait(1)\n\n        # Explain the parametric curve representation\n        explanation1 = Text(\"This parametric function represents a circle\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The parametric curve\n        circle = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), 0]),\n            t_range=[0, TAU]\n        )\n        self.play(ShowCreation(circle))\n        self.wait(2)\n\n        # Label point moving along the curve\n        dot = Dot(radius=0.08)\n        dot.move_to(circle.get_start())\n        dot_label = MathTex(r'\\vec{r}(t)', color=BLUE).next_to(dot, RIGHT)\n        self.play(FadeIn(dot), FadeIn(dot_label))\n        self.wait(1)\n\n        # Animate the point moving along the curve\n        self.play(MoveAlongPath(dot, circle), rate_func=linear, run_time=5)\n        self.wait(1)\n\n        # Explanation for the parametric curve evolution\n        explanation2 = Text(\"As t varies from 0 to 2\u03c0, the point traces the circle\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        final_message = Text(\"Parametric curves can represent complex shapes\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that explains how to calculate the area under the curve of the function f(x) = x^2 from x = 0 to x = 2? I would like to see the following steps visualized: first, display the function and the integral expression for the area we are looking for. Next, add a note to clarify that we are finding the area under the curve between x = 0 and x = 2. Then, show the graph of the function with the area under the curve highlighted. After that, visually depict the actual calculation of the integral, and present the final numeric answer. It would be nice to have the final answer stand out, maybe by enclosing it within a colored box. Finally, clear everything else away and leave only the final answer displayed."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that explains how to calculate the area under the curve of the function f(x) = x^2 from x = 0 to x = 2? i would like to see the following steps visualized: first, display the function and the integral expression for the area we are looking for. next, add a note to clarify that we are finding the area under the curve between x = 0 and x = 2. then, show the graph of the function with the area under the curve highlighted. after that, visually depict the actual calculation of the integral, and present the final numeric answer. it would be nice to have the final answer stand out, maybe by enclosing it within a colored box. finally, clear everything else away and leave only the final answer displayed."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ParametricFunctionExample(Scene):\n    def construct(self):\n        # Display the parametric function\n        param_func_text = MathTex(r'\\vec{r}(t) = \\langle \\cos(t), \\sin(t) \\rangle')\n        self.play(Write(param_func_text))\n        self.wait(1)\n\n        # Explain the parametric curve representation\n        explanation1 = Text(\"This parametric function represents a circle\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The parametric curve\n        circle = ParametricFunction(\n            lambda t: np.array([np.cos(t), np.sin(t), 0]),\n            t_range=[0, TAU]\n        )\n        self.play(ShowCreation(circle))\n        self.wait(2)\n\n        # Label point moving along the curve\n        dot = Dot(radius=0.08)\n        dot.move_to(circle.get_start())\n        dot_label = MathTex(r'\\vec{r}(t)', color=BLUE).next_to(dot, RIGHT)\n        self.play(FadeIn(dot), FadeIn(dot_label))\n        self.wait(1)\n\n        # Animate the point moving along the curve\n        self.play(MoveAlongPath(dot, circle), rate_func=linear, run_time=5)\n        self.wait(1)\n\n        # Explanation for the parametric curve evolution\n        explanation2 = Text(\"As t varies from 0 to 2\u03c0, the point traces the circle\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        final_message = Text(\"Parametric curves can represent complex shapes\", font_size=24)\n        self.play(Write(final_message))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that explains how to calculate the area under the curve of the function f(x) = x^2 from x = 0 to x = 2? I would like to see the following steps visualized: first, display the function and the integral expression for the area we are looking for. Next, add a note to clarify that we are finding the area under the curve between x = 0 and x = 2. Then, show the graph of the function with the area under the curve highlighted. After that, visually depict the actual calculation of the integral, and present the final numeric answer. It would be nice to have the final answer stand out, maybe by enclosing it within a colored box. Finally, clear everything else away and leave only the final answer displayed."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What are the implications of using Poisson processes to model the arrival times of customers in a queue, and how can this be visually represented?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PoissonProcessScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Randomness: Poisson Processes in Queue Theory\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction - bank queue visualization\n        bank = Square(side_length=2, color=BLUE).shift(RIGHT*3)\n        \n        # Create a simple queue of customers\n        customers = VGroup()\n        for i in range(4):\n            customer = Circle(radius=0.3, color=GREEN).shift(LEFT*(i+1))\n            customers.add(customer)\n        \n        self.play(Create(bank), Create(customers))\n        self.wait(1)\n        self.play(FadeOut(bank), FadeOut(customers))\n        \n        # Timeline showing arrival times\n        timeline = Line(LEFT*4, RIGHT*4)\n        time_label = Text(\"Time\", font_size=24).next_to(timeline, DOWN)\n        \n        self.play(Create(timeline), Write(time_label))\n        \n        # Add arrival points as dots on timeline\n        dots = VGroup()\n        positions = [0.1, 0.3, 0.45, 0.7, 0.9]\n        \n        for pos in positions:\n            dot = Dot(color=BLUE).move_to(timeline.point_from_proportion(pos))\n            dots.add(dot)\n            self.play(Create(dot))\n        \n        arrival_label = Text(\"Customer arrivals\", font_size=24).next_to(timeline, UP)\n        self.play(Write(arrival_label))\n        self.wait(1)\n        \n        # Transition to Poisson equation\n        self.play(\n            FadeOut(dots), FadeOut(timeline),\n            FadeOut(time_label), FadeOut(arrival_label)\n        )\n        \n        # Display Poisson distribution equation\n        poisson_eq = MathTex(r\"P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}\")\n        eq_label = Text(\"Poisson Distribution\", font_size=24).next_to(poisson_eq, UP)\n        \n        self.play(Write(poisson_eq), Write(eq_label))\n        self.wait(1)\n        \n        # Explanation\n        explanation = Text(\"Modeling random arrivals in queue systems\", font_size=24)\n        explanation.next_to(poisson_eq, DOWN)\n        \n        self.play(Write(explanation))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            FadeOut(title), FadeOut(poisson_eq), \n            FadeOut(eq_label), FadeOut(explanation)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the implications of using Poisson processes to model the arrival times of customers in a queue, and how can this be visually represented?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what are the implications of using poisson processes to model the arrival times of customers in a queue, and how can this be visually represented?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PoissonProcessScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Randomness: Poisson Processes in Queue Theory\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction - bank queue visualization\n        bank = Square(side_length=2, color=BLUE).shift(RIGHT*3)\n        \n        # Create a simple queue of customers\n        customers = VGroup()\n        for i in range(4):\n            customer = Circle(radius=0.3, color=GREEN).shift(LEFT*(i+1))\n            customers.add(customer)\n        \n        self.play(Create(bank), Create(customers))\n        self.wait(1)\n        self.play(FadeOut(bank), FadeOut(customers))\n        \n        # Timeline showing arrival times\n        timeline = Line(LEFT*4, RIGHT*4)\n        time_label = Text(\"Time\", font_size=24).next_to(timeline, DOWN)\n        \n        self.play(Create(timeline), Write(time_label))\n        \n        # Add arrival points as dots on timeline\n        dots = VGroup()\n        positions = [0.1, 0.3, 0.45, 0.7, 0.9]\n        \n        for pos in positions:\n            dot = Dot(color=BLUE).move_to(timeline.point_from_proportion(pos))\n            dots.add(dot)\n            self.play(Create(dot))\n        \n        arrival_label = Text(\"Customer arrivals\", font_size=24).next_to(timeline, UP)\n        self.play(Write(arrival_label))\n        self.wait(1)\n        \n        # Transition to Poisson equation\n        self.play(\n            FadeOut(dots), FadeOut(timeline),\n            FadeOut(time_label), FadeOut(arrival_label)\n        )\n        \n        # Display Poisson distribution equation\n        poisson_eq = MathTex(r\"P(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}\")\n        eq_label = Text(\"Poisson Distribution\", font_size=24).next_to(poisson_eq, UP)\n        \n        self.play(Write(poisson_eq), Write(eq_label))\n        self.wait(1)\n        \n        # Explanation\n        explanation = Text(\"Modeling random arrivals in queue systems\", font_size=24)\n        explanation.next_to(poisson_eq, DOWN)\n        \n        self.play(Write(explanation))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            FadeOut(title), FadeOut(poisson_eq), \n            FadeOut(eq_label), FadeOut(explanation)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the implications of using Poisson processes to model the arrival times of customers in a queue, and how can this be visually represented?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Why does the infinite complete graph always contain a monochromatic complete subgraph of a given size in any edge coloring?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RamseyTheoryExplanation(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Infinite Palette\", font_size=36)\n        subtitle = Text(\"Monochromatic Subgraphs in Infinite Graphs\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create 5 vertices in a pentagon formation\n        vertices = VGroup(*[Dot(radius=0.15) for _ in range(5)])\n        \n        # Position vertices in a pentagon\n        for i, vertex in enumerate(vertices):\n            angle = i * 2 * PI / 5\n            vertex.move_to([2 * np.cos(angle), 2 * np.sin(angle), 0])\n        \n        self.play(Create(vertices))\n        self.wait(0.5)\n        \n        # Create and store all edges\n        edges = VGroup()\n        \n        # Define which edges will be red (forming a triangle)\n        red_pairs = [(0, 2), (0, 4), (2, 4)]\n        \n        for i in range(5):\n            for j in range(i+1, 5):\n                edge = Line(\n                    vertices[i].get_center(),\n                    vertices[j].get_center(),\n                    stroke_width=3\n                )\n                \n                # Color edges - red for our triangle, blue for others\n                color = RED if (i, j) in red_pairs else BLUE\n                edge.set_color(color)\n                edges.add(edge)\n        \n        self.play(Create(edges))\n        self.wait(1)\n        \n        # Explanation text\n        explanation = Text(\"In any coloring of edges in an infinite graph...\", font_size=28)\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Highlight the red triangle\n        red_triangle_vertices = [0, 2, 4]  # Vertices forming red triangle\n        \n        # Calculate center of the triangle\n        triangle_center = np.mean([vertices[i].get_center() for i in red_triangle_vertices], axis=0)\n        highlight_circle = Circle(radius=2.2, color=YELLOW).move_to(triangle_center)\n        \n        self.play(Create(highlight_circle))\n        self.wait(0.5)\n        \n        # Get the red edges (simpler approach)\n        red_edges = [edge for edge in edges if edge.get_color() == RED]\n        \n        # Highlight the red edges\n        self.play(*[edge.animate.set_stroke(width=6) for edge in red_edges])\n        self.wait(1)\n        \n        # Update explanation\n        self.play(FadeOut(explanation))\n        explanation2 = Text(\"...we always find a monochromatic subgraph\", font_size=28)\n        explanation2.to_edge(UP)\n        self.play(Write(explanation2))\n        self.wait(1)\n        \n        # Show equation\n        equation = MathTex(r\"c: \\infty \\rightarrow \\text{color}\")\n        equation.next_to(explanation2, DOWN, buff=0.5)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(explanation2),\n            FadeOut(equation),\n            FadeOut(highlight_circle),\n            *[edge.animate.set_stroke(width=3) for edge in red_edges]\n        )\n        \n        conclusion = Text(\"The infinite pigeonhole principle guarantees this!\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(vertices), FadeOut(edges))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why does the infinite complete graph always contain a monochromatic complete subgraph of a given size in any edge coloring?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: why does the infinite complete graph always contain a monochromatic complete subgraph of a given size in any edge coloring?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RamseyTheoryExplanation(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Infinite Palette\", font_size=36)\n        subtitle = Text(\"Monochromatic Subgraphs in Infinite Graphs\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create 5 vertices in a pentagon formation\n        vertices = VGroup(*[Dot(radius=0.15) for _ in range(5)])\n        \n        # Position vertices in a pentagon\n        for i, vertex in enumerate(vertices):\n            angle = i * 2 * PI / 5\n            vertex.move_to([2 * np.cos(angle), 2 * np.sin(angle), 0])\n        \n        self.play(Create(vertices))\n        self.wait(0.5)\n        \n        # Create and store all edges\n        edges = VGroup()\n        \n        # Define which edges will be red (forming a triangle)\n        red_pairs = [(0, 2), (0, 4), (2, 4)]\n        \n        for i in range(5):\n            for j in range(i+1, 5):\n                edge = Line(\n                    vertices[i].get_center(),\n                    vertices[j].get_center(),\n                    stroke_width=3\n                )\n                \n                # Color edges - red for our triangle, blue for others\n                color = RED if (i, j) in red_pairs else BLUE\n                edge.set_color(color)\n                edges.add(edge)\n        \n        self.play(Create(edges))\n        self.wait(1)\n        \n        # Explanation text\n        explanation = Text(\"In any coloring of edges in an infinite graph...\", font_size=28)\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Highlight the red triangle\n        red_triangle_vertices = [0, 2, 4]  # Vertices forming red triangle\n        \n        # Calculate center of the triangle\n        triangle_center = np.mean([vertices[i].get_center() for i in red_triangle_vertices], axis=0)\n        highlight_circle = Circle(radius=2.2, color=YELLOW).move_to(triangle_center)\n        \n        self.play(Create(highlight_circle))\n        self.wait(0.5)\n        \n        # Get the red edges (simpler approach)\n        red_edges = [edge for edge in edges if edge.get_color() == RED]\n        \n        # Highlight the red edges\n        self.play(*[edge.animate.set_stroke(width=6) for edge in red_edges])\n        self.wait(1)\n        \n        # Update explanation\n        self.play(FadeOut(explanation))\n        explanation2 = Text(\"...we always find a monochromatic subgraph\", font_size=28)\n        explanation2.to_edge(UP)\n        self.play(Write(explanation2))\n        self.wait(1)\n        \n        # Show equation\n        equation = MathTex(r\"c: \\infty \\rightarrow \\text{color}\")\n        equation.next_to(explanation2, DOWN, buff=0.5)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(explanation2),\n            FadeOut(equation),\n            FadeOut(highlight_circle),\n            *[edge.animate.set_stroke(width=3) for edge in red_edges]\n        )\n        \n        conclusion = Text(\"The infinite pigeonhole principle guarantees this!\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(vertices), FadeOut(edges))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why does the infinite complete graph always contain a monochromatic complete subgraph of a given size in any edge coloring?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the distribution of a sum of independent random variables approach a normal distribution, and what factors affect this convergence?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass NormalDistributionFromRandomSums(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Normal: The Magic of Random Sums\", color=BLUE).scale(0.7)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Single die representation\n        dice = Square(side_length=1).set_fill(BLUE, opacity=0.5)\n        single_die_text = Text(\"Single Random Variable\", color=BLUE).scale(0.6)\n        single_die_text.next_to(dice, UP)\n        \n        # Simple uniform distribution representation\n        uniform_bars = VGroup()\n        for i in range(6):\n            bar = Rectangle(width=0.4, height=0.5, fill_opacity=0.8, fill_color=BLUE)\n            bar.move_to(np.array([-2.5 + i*1, -1, 0]))\n            uniform_bars.add(bar)\n        \n        uniform_label = Text(\"Uniform Distribution\", color=BLUE).scale(0.5)\n        uniform_label.next_to(uniform_bars, DOWN)\n        \n        self.play(Create(dice), Write(single_die_text))\n        self.play(Create(uniform_bars), Write(uniform_label))\n        self.wait(1)\n        \n        # Two dice\n        two_dice = VGroup(\n            Square(side_length=1).set_fill(BLUE, opacity=0.5),\n            Square(side_length=1).set_fill(ORANGE, opacity=0.5)\n        ).arrange(RIGHT, buff=0.5)\n        \n        two_dice_text = Text(\"Sum of Two Random Variables\", color=ORANGE).scale(0.6)\n        two_dice_text.next_to(two_dice, UP)\n        \n        # Simple triangular distribution\n        triangular_bars = VGroup()\n        heights = [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]\n        for i, h in enumerate(heights):\n            bar = Rectangle(width=0.4, height=h*0.1, fill_opacity=0.8, fill_color=ORANGE)\n            bar.move_to(np.array([-3 + i*0.6, -1, 0]))\n            triangular_bars.add(bar)\n        \n        triangular_label = Text(\"Triangular Distribution\", color=ORANGE).scale(0.5)\n        triangular_label.next_to(triangular_bars, DOWN)\n        \n        self.play(\n            FadeOut(dice),\n            FadeOut(single_die_text),\n            FadeOut(uniform_bars),\n            FadeOut(uniform_label)\n        )\n        \n        self.play(Create(two_dice), Write(two_dice_text))\n        self.play(Create(triangular_bars), Write(triangular_label))\n        self.wait(1)\n        \n        # Multiple random variables\n        many_dice = VGroup(*[Square(side_length=0.6).set_fill(BLUE, opacity=0.5) for _ in range(5)])\n        many_dice.arrange(RIGHT, buff=0.2)\n        \n        many_dice_text = Text(\"Sum of Many Random Variables\", color=RED).scale(0.6)\n        many_dice_text.next_to(many_dice, UP)\n        \n        # Simple normal curve\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[0, 1, 0.2],\n            axis_config={\"include_tip\": False, \"color\": RED},\n        ).scale(0.7)\n        \n        normal_curve = axes.plot(\n            lambda x: 0.8 * np.exp(-x**2 / 2),\n            color=RED\n        )\n        \n        normal_label = Text(\"Normal Distribution\", color=RED).scale(0.5)\n        normal_label.next_to(axes, DOWN)\n        \n        self.play(\n            FadeOut(two_dice),\n            FadeOut(two_dice_text),\n            FadeOut(triangular_bars),\n            FadeOut(triangular_label)\n        )\n        \n        self.play(Create(many_dice), Write(many_dice_text))\n        self.play(Create(axes), Create(normal_curve), Write(normal_label))\n        self.wait(1)\n        \n        # Central Limit Theorem\n        clt_text = Text(\"Central Limit Theorem\", color=YELLOW).scale(0.7)\n        equation = MathTex(\n            r\"X_1 + X_2 + \\cdots + X_n \\sim N\\left( \\mu_n, \\frac{\\sigma^2}{n} \\right)\",\n            color=YELLOW\n        ).scale(0.7)\n        \n        equation.next_to(clt_text, DOWN)\n        \n        self.play(\n            FadeOut(many_dice),\n            FadeOut(many_dice_text),\n            FadeOut(axes),\n            FadeOut(normal_curve),\n            FadeOut(normal_label),\n            Write(clt_text)\n        )\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The Sum marries randomness with predictability\", color=GREEN).scale(0.6)\n        \n        self.play(\n            FadeOut(clt_text),\n            FadeOut(equation),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the distribution of a sum of independent random variables approach a normal distribution, and what factors affect this convergence?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the distribution of a sum of independent random variables approach a normal distribution, and what factors affect this convergence?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass NormalDistributionFromRandomSums(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Normal: The Magic of Random Sums\", color=BLUE).scale(0.7)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Single die representation\n        dice = Square(side_length=1).set_fill(BLUE, opacity=0.5)\n        single_die_text = Text(\"Single Random Variable\", color=BLUE).scale(0.6)\n        single_die_text.next_to(dice, UP)\n        \n        # Simple uniform distribution representation\n        uniform_bars = VGroup()\n        for i in range(6):\n            bar = Rectangle(width=0.4, height=0.5, fill_opacity=0.8, fill_color=BLUE)\n            bar.move_to(np.array([-2.5 + i*1, -1, 0]))\n            uniform_bars.add(bar)\n        \n        uniform_label = Text(\"Uniform Distribution\", color=BLUE).scale(0.5)\n        uniform_label.next_to(uniform_bars, DOWN)\n        \n        self.play(Create(dice), Write(single_die_text))\n        self.play(Create(uniform_bars), Write(uniform_label))\n        self.wait(1)\n        \n        # Two dice\n        two_dice = VGroup(\n            Square(side_length=1).set_fill(BLUE, opacity=0.5),\n            Square(side_length=1).set_fill(ORANGE, opacity=0.5)\n        ).arrange(RIGHT, buff=0.5)\n        \n        two_dice_text = Text(\"Sum of Two Random Variables\", color=ORANGE).scale(0.6)\n        two_dice_text.next_to(two_dice, UP)\n        \n        # Simple triangular distribution\n        triangular_bars = VGroup()\n        heights = [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]\n        for i, h in enumerate(heights):\n            bar = Rectangle(width=0.4, height=h*0.1, fill_opacity=0.8, fill_color=ORANGE)\n            bar.move_to(np.array([-3 + i*0.6, -1, 0]))\n            triangular_bars.add(bar)\n        \n        triangular_label = Text(\"Triangular Distribution\", color=ORANGE).scale(0.5)\n        triangular_label.next_to(triangular_bars, DOWN)\n        \n        self.play(\n            FadeOut(dice),\n            FadeOut(single_die_text),\n            FadeOut(uniform_bars),\n            FadeOut(uniform_label)\n        )\n        \n        self.play(Create(two_dice), Write(two_dice_text))\n        self.play(Create(triangular_bars), Write(triangular_label))\n        self.wait(1)\n        \n        # Multiple random variables\n        many_dice = VGroup(*[Square(side_length=0.6).set_fill(BLUE, opacity=0.5) for _ in range(5)])\n        many_dice.arrange(RIGHT, buff=0.2)\n        \n        many_dice_text = Text(\"Sum of Many Random Variables\", color=RED).scale(0.6)\n        many_dice_text.next_to(many_dice, UP)\n        \n        # Simple normal curve\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[0, 1, 0.2],\n            axis_config={\"include_tip\": False, \"color\": RED},\n        ).scale(0.7)\n        \n        normal_curve = axes.plot(\n            lambda x: 0.8 * np.exp(-x**2 / 2),\n            color=RED\n        )\n        \n        normal_label = Text(\"Normal Distribution\", color=RED).scale(0.5)\n        normal_label.next_to(axes, DOWN)\n        \n        self.play(\n            FadeOut(two_dice),\n            FadeOut(two_dice_text),\n            FadeOut(triangular_bars),\n            FadeOut(triangular_label)\n        )\n        \n        self.play(Create(many_dice), Write(many_dice_text))\n        self.play(Create(axes), Create(normal_curve), Write(normal_label))\n        self.wait(1)\n        \n        # Central Limit Theorem\n        clt_text = Text(\"Central Limit Theorem\", color=YELLOW).scale(0.7)\n        equation = MathTex(\n            r\"X_1 + X_2 + \\cdots + X_n \\sim N\\left( \\mu_n, \\frac{\\sigma^2}{n} \\right)\",\n            color=YELLOW\n        ).scale(0.7)\n        \n        equation.next_to(clt_text, DOWN)\n        \n        self.play(\n            FadeOut(many_dice),\n            FadeOut(many_dice_text),\n            FadeOut(axes),\n            FadeOut(normal_curve),\n            FadeOut(normal_label),\n            Write(clt_text)\n        )\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The Sum marries randomness with predictability\", color=GREEN).scale(0.6)\n        \n        self.play(\n            FadeOut(clt_text),\n            FadeOut(equation),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the distribution of a sum of independent random variables approach a normal distribution, and what factors affect this convergence?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the interplay between matrix sparsity and preconditioners be optimized to enhance computational efficiency in large systems?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PreconditionedConjugateGradientScene(Scene):\n    def construct(self):\n        # Set background color to dark blue\n        self.camera.background_color = \"#0C1445\"\n        \n        # Title\n        title = Text(\"Mastering Sparsity: Preconditioning the Conjugate Gradient Dance\", \n                    font_size=28, color=WHITE).to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Element 1: Show a sparse matrix with a grid and a few dots\n        matrix_border = Square(side_length=4, color=WHITE)\n        \n        # Create dots at fixed positions to represent non-zero elements\n        dots = VGroup()\n        positions = [\n            [-1.5, 1.5, 0], [0, 1.5, 0], [1.5, 1.5, 0],\n            [-1.5, 0, 0], [0, 0, 0], [1.5, 0, 0],\n            [-1.5, -1.5, 0], [0, -1.5, 0], [1.5, -1.5, 0]\n        ]\n        \n        # Only use a few of the positions to show sparsity\n        sparse_positions = [positions[0], positions[4], positions[8], positions[2], positions[6]]\n        for pos in sparse_positions:\n            dot = Dot(point=pos, radius=0.1, color=WHITE)\n            dots.add(dot)\n        \n        sparse_matrix = VGroup(matrix_border, dots)\n        \n        # Label\n        matrix_label = Text(\"Sparse Matrix\", font_size=24, color=YELLOW)\n        matrix_label.next_to(sparse_matrix, DOWN, buff=0.5)\n        \n        self.play(Create(matrix_border), FadeIn(dots), Write(matrix_label))\n        self.wait(1)\n        \n        # Element 2: Show basic equation Ax = b\n        self.play(FadeOut(sparse_matrix, matrix_label))\n        \n        eq1 = Text(\"Ax = b\", color=WHITE).scale(1.5)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Element 3: Transform to preconditioned equation\n        eq2 = Text(\"PAx = Pb\", color=GREEN).scale(1.5)\n        self.play(Transform(eq1, eq2))\n        self.wait(1)\n        \n        # Element 4: Simple convergence comparison\n        self.play(FadeOut(eq1))\n        \n        # Create a simple horizontal line representing iterations\n        line = Line(LEFT * 3, RIGHT * 3, color=WHITE)\n        iter_text = Text(\"Iterations\", font_size=20, color=WHITE)\n        iter_text.next_to(line, DOWN, buff=0.3)\n        \n        # Standard CG convergence - several steps\n        dot1 = Dot(point=LEFT * 3, color=RED)\n        dot2 = Dot(point=LEFT * 1.5, color=RED)\n        dot3 = Dot(point=ORIGIN, color=RED)\n        dot4 = Dot(point=RIGHT * 1.5, color=RED)\n        dot5 = Dot(point=RIGHT * 3, color=RED)\n        \n        std_dots = VGroup(dot1, dot2, dot3, dot4, dot5)\n        \n        # Connect the dots with lines\n        std_lines = VGroup()\n        for i in range(4):\n            line = Line(std_dots[i].get_center(), std_dots[i+1].get_center(), color=RED)\n            std_lines.add(line)\n        \n        # Preconditioned CG - fewer steps\n        dot6 = Dot(point=LEFT * 3, color=GREEN)\n        dot7 = Dot(point=LEFT * 0, color=GREEN)\n        dot8 = Dot(point=RIGHT * 3, color=GREEN)\n        \n        precond_dots = VGroup(dot6, dot7, dot8)\n        \n        # Connect the dots with lines\n        precond_lines = VGroup()\n        for i in range(2):\n            line = Line(precond_dots[i].get_center(), precond_dots[i+1].get_center(), color=GREEN)\n            precond_lines.add(line)\n        \n        # Labels\n        std_label = Text(\"Standard CG\", font_size=20, color=RED)\n        std_label.move_to(UP * 1 + LEFT * 2)\n        \n        precond_label = Text(\"Preconditioned CG\", font_size=20, color=GREEN)\n        precond_label.move_to(DOWN * 1 + LEFT * 1.5)\n        \n        # Display the convergence comparison\n        self.play(Create(line), Write(iter_text))\n        self.play(Create(std_dots), Create(std_lines), Write(std_label))\n        self.play(Create(precond_dots), Create(precond_lines), Write(precond_label))\n        self.wait(1)\n        \n        # Element 5: Conclusion\n        self.play(FadeOut(VGroup(line, iter_text, std_dots, std_lines, precond_dots, precond_lines, std_label, precond_label)))\n        \n        conclusion = Text(\"Matrix sparsity + Effective preconditioning\", font_size=28, color=YELLOW)\n        conclusion2 = Text(\"= Computational efficiency\", font_size=28, color=YELLOW)\n        \n        conclusion.move_to(UP * 0.5)\n        conclusion2.move_to(DOWN * 0.5)\n        \n        self.play(Write(conclusion))\n        self.play(Write(conclusion2))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the interplay between matrix sparsity and preconditioners be optimized to enhance computational efficiency in large systems?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the interplay between matrix sparsity and preconditioners be optimized to enhance computational efficiency in large systems?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PreconditionedConjugateGradientScene(Scene):\n    def construct(self):\n        # Set background color to dark blue\n        self.camera.background_color = \"#0C1445\"\n        \n        # Title\n        title = Text(\"Mastering Sparsity: Preconditioning the Conjugate Gradient Dance\", \n                    font_size=28, color=WHITE).to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Element 1: Show a sparse matrix with a grid and a few dots\n        matrix_border = Square(side_length=4, color=WHITE)\n        \n        # Create dots at fixed positions to represent non-zero elements\n        dots = VGroup()\n        positions = [\n            [-1.5, 1.5, 0], [0, 1.5, 0], [1.5, 1.5, 0],\n            [-1.5, 0, 0], [0, 0, 0], [1.5, 0, 0],\n            [-1.5, -1.5, 0], [0, -1.5, 0], [1.5, -1.5, 0]\n        ]\n        \n        # Only use a few of the positions to show sparsity\n        sparse_positions = [positions[0], positions[4], positions[8], positions[2], positions[6]]\n        for pos in sparse_positions:\n            dot = Dot(point=pos, radius=0.1, color=WHITE)\n            dots.add(dot)\n        \n        sparse_matrix = VGroup(matrix_border, dots)\n        \n        # Label\n        matrix_label = Text(\"Sparse Matrix\", font_size=24, color=YELLOW)\n        matrix_label.next_to(sparse_matrix, DOWN, buff=0.5)\n        \n        self.play(Create(matrix_border), FadeIn(dots), Write(matrix_label))\n        self.wait(1)\n        \n        # Element 2: Show basic equation Ax = b\n        self.play(FadeOut(sparse_matrix, matrix_label))\n        \n        eq1 = Text(\"Ax = b\", color=WHITE).scale(1.5)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Element 3: Transform to preconditioned equation\n        eq2 = Text(\"PAx = Pb\", color=GREEN).scale(1.5)\n        self.play(Transform(eq1, eq2))\n        self.wait(1)\n        \n        # Element 4: Simple convergence comparison\n        self.play(FadeOut(eq1))\n        \n        # Create a simple horizontal line representing iterations\n        line = Line(LEFT * 3, RIGHT * 3, color=WHITE)\n        iter_text = Text(\"Iterations\", font_size=20, color=WHITE)\n        iter_text.next_to(line, DOWN, buff=0.3)\n        \n        # Standard CG convergence - several steps\n        dot1 = Dot(point=LEFT * 3, color=RED)\n        dot2 = Dot(point=LEFT * 1.5, color=RED)\n        dot3 = Dot(point=ORIGIN, color=RED)\n        dot4 = Dot(point=RIGHT * 1.5, color=RED)\n        dot5 = Dot(point=RIGHT * 3, color=RED)\n        \n        std_dots = VGroup(dot1, dot2, dot3, dot4, dot5)\n        \n        # Connect the dots with lines\n        std_lines = VGroup()\n        for i in range(4):\n            line = Line(std_dots[i].get_center(), std_dots[i+1].get_center(), color=RED)\n            std_lines.add(line)\n        \n        # Preconditioned CG - fewer steps\n        dot6 = Dot(point=LEFT * 3, color=GREEN)\n        dot7 = Dot(point=LEFT * 0, color=GREEN)\n        dot8 = Dot(point=RIGHT * 3, color=GREEN)\n        \n        precond_dots = VGroup(dot6, dot7, dot8)\n        \n        # Connect the dots with lines\n        precond_lines = VGroup()\n        for i in range(2):\n            line = Line(precond_dots[i].get_center(), precond_dots[i+1].get_center(), color=GREEN)\n            precond_lines.add(line)\n        \n        # Labels\n        std_label = Text(\"Standard CG\", font_size=20, color=RED)\n        std_label.move_to(UP * 1 + LEFT * 2)\n        \n        precond_label = Text(\"Preconditioned CG\", font_size=20, color=GREEN)\n        precond_label.move_to(DOWN * 1 + LEFT * 1.5)\n        \n        # Display the convergence comparison\n        self.play(Create(line), Write(iter_text))\n        self.play(Create(std_dots), Create(std_lines), Write(std_label))\n        self.play(Create(precond_dots), Create(precond_lines), Write(precond_label))\n        self.wait(1)\n        \n        # Element 5: Conclusion\n        self.play(FadeOut(VGroup(line, iter_text, std_dots, std_lines, precond_dots, precond_lines, std_label, precond_label)))\n        \n        conclusion = Text(\"Matrix sparsity + Effective preconditioning\", font_size=28, color=YELLOW)\n        conclusion2 = Text(\"= Computational efficiency\", font_size=28, color=YELLOW)\n        \n        conclusion.move_to(UP * 0.5)\n        conclusion2.move_to(DOWN * 0.5)\n        \n        self.play(Write(conclusion))\n        self.play(Write(conclusion2))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the interplay between matrix sparsity and preconditioners be optimized to enhance computational efficiency in large systems?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four sets of two intersecting lines forming right angles, each with a different style of right angle marker:\n\n1. The first uses the default size and position.\n2. The second has a smaller marker placed in a different quadrant.\n3. The third has a slightly larger marker with a thicker stroke in another quadrant.\n4. The fourth features the largest marker, colored red, positioned in a different quadrant.\n\nAll four sets are arranged horizontally with space between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RightAngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT, RIGHT )\n        line2 = Line( DOWN, UP )\n        rightangles = [\n            RightAngle(line1, line2),\n            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\n            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\n            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\n        ]\n        plots = VGroup()\n        for rightangle in rightangles:\n            plot=VGroup(line1.copy(),line2.copy(), rightangle)\n            plots.add(plot)\n        plots.arrange(buff=1.5)\n        self.add(plots)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four sets of two intersecting lines forming right angles, each with a different style of right angle marker:\n\n1. The first uses the default size and position.\n2. The second has a smaller marker placed in a different quadrant.\n3. The third has a slightly larger marker with a thicker stroke in another quadrant.\n4. The fourth features the largest marker, colored red, positioned in a different quadrant.\n\nAll four sets are arranged horizontally with space between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four sets of two intersecting lines forming right angles, each with a different style of right angle marker:\n\n1. the first uses the default size and position.\n2. the second has a smaller marker placed in a different quadrant.\n3. the third has a slightly larger marker with a thicker stroke in another quadrant.\n4. the fourth features the largest marker, colored red, positioned in a different quadrant.\n\nall four sets are arranged horizontally with space between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RightAngleExample(Scene):\n    def construct(self):\n        line1 = Line( LEFT, RIGHT )\n        line2 = Line( DOWN, UP )\n        rightangles = [\n            RightAngle(line1, line2),\n            RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\n            RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\n            RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\n        ]\n        plots = VGroup()\n        for rightangle in rightangles:\n            plot=VGroup(line1.copy(),line2.copy(), rightangle)\n            plots.add(plot)\n        plots.arrange(buff=1.5)\n        self.add(plots)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four sets of two intersecting lines forming right angles, each with a different style of right angle marker:\n\n1. The first uses the default size and position.\n2. The second has a smaller marker placed in a different quadrant.\n3. The third has a slightly larger marker with a thicker stroke in another quadrant.\n4. The fourth features the largest marker, colored red, positioned in a different quadrant.\n\nAll four sets are arranged horizontally with space between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways does the spin-orbit coupling affect the calculation of magic numbers in nuclei, and how can these be visualized effectively?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpinOrbitCoupling(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Magic: Spin-Orbit Coupling in Nuclear Shell Models\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Introduction to magic numbers\n        magic_intro = Text(\"Magic Numbers: 2, 8, 20, 28, 50, 82, 126\", font_size=24)\n        self.play(Write(magic_intro))\n        self.wait(1)\n        self.play(FadeOut(magic_intro))\n        \n        # Create nucleus and nucleon with orbit\n        nucleus = Circle(radius=1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        orbit = Circle(radius=2, color=WHITE)\n        nucleon = Dot(color=RED).move_to(RIGHT * 2)\n        \n        self.play(Create(nucleus), Create(orbit))\n        self.play(Create(nucleon))\n        \n        # Add spin to nucleon\n        spin = Arrow(start=nucleon.get_center(), end=nucleon.get_center() + UP * 0.5, color=YELLOW)\n        self.play(Create(spin))\n        \n        # First equation - spin-orbit coupling\n        eq1 = Text(\"E_so = l\u00b7s\", font_size=24).next_to(nucleus, DOWN, buff=1)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Clear first part\n        first_group = VGroup(nucleus, orbit, nucleon, spin, eq1)\n        self.play(FadeOut(first_group))\n        \n        # Energy levels before and after coupling\n        before = VGroup()\n        after = VGroup()\n        \n        # Create energy levels without coupling\n        for i in range(4):\n            line = Line(LEFT, RIGHT, color=WHITE)\n            line.move_to(LEFT * 2 + UP * (i - 1.5))\n            label = Text(f\"n={i}\", font_size=16).next_to(line, LEFT)\n            before.add(line, label)\n        \n        before_title = Text(\"Without Coupling\", font_size=20).next_to(before, UP)\n        \n        # Create split energy levels with coupling\n        positions = [-1.7, -1.3, -0.5, -0.1, 0.7, 1.1, 1.9]\n        for i, pos in enumerate(positions):\n            line = Line(LEFT, RIGHT, color=BLUE if i % 2 == 0 else RED)\n            line.move_to(RIGHT * 2 + UP * pos)\n            after.add(line)\n        \n        after_title = Text(\"With Coupling\", font_size=20).next_to(after, UP)\n        \n        # Show energy levels \n        self.play(Create(before), Write(before_title))\n        self.play(Create(after), Write(after_title))\n        \n        # Second equation - energy calculation\n        eq2 = Text(\"\u0394E = \u0127\u03c9/2 (2n + l + 3/2 - \u03ba\u00b7l\u00b7s)\", font_size=20).to_edge(DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Clear second part\n        second_group = VGroup(before, before_title, after, after_title, eq2)\n        self.play(FadeOut(second_group))\n        \n        # Conclusion\n        conclusion = Text(\"Spin-orbit coupling explains magic numbers\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways does the spin-orbit coupling affect the calculation of magic numbers in nuclei, and how can these be visualized effectively?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways does the spin-orbit coupling affect the calculation of magic numbers in nuclei, and how can these be visualized effectively?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpinOrbitCoupling(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Magic: Spin-Orbit Coupling in Nuclear Shell Models\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Introduction to magic numbers\n        magic_intro = Text(\"Magic Numbers: 2, 8, 20, 28, 50, 82, 126\", font_size=24)\n        self.play(Write(magic_intro))\n        self.wait(1)\n        self.play(FadeOut(magic_intro))\n        \n        # Create nucleus and nucleon with orbit\n        nucleus = Circle(radius=1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        orbit = Circle(radius=2, color=WHITE)\n        nucleon = Dot(color=RED).move_to(RIGHT * 2)\n        \n        self.play(Create(nucleus), Create(orbit))\n        self.play(Create(nucleon))\n        \n        # Add spin to nucleon\n        spin = Arrow(start=nucleon.get_center(), end=nucleon.get_center() + UP * 0.5, color=YELLOW)\n        self.play(Create(spin))\n        \n        # First equation - spin-orbit coupling\n        eq1 = Text(\"E_so = l\u00b7s\", font_size=24).next_to(nucleus, DOWN, buff=1)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Clear first part\n        first_group = VGroup(nucleus, orbit, nucleon, spin, eq1)\n        self.play(FadeOut(first_group))\n        \n        # Energy levels before and after coupling\n        before = VGroup()\n        after = VGroup()\n        \n        # Create energy levels without coupling\n        for i in range(4):\n            line = Line(LEFT, RIGHT, color=WHITE)\n            line.move_to(LEFT * 2 + UP * (i - 1.5))\n            label = Text(f\"n={i}\", font_size=16).next_to(line, LEFT)\n            before.add(line, label)\n        \n        before_title = Text(\"Without Coupling\", font_size=20).next_to(before, UP)\n        \n        # Create split energy levels with coupling\n        positions = [-1.7, -1.3, -0.5, -0.1, 0.7, 1.1, 1.9]\n        for i, pos in enumerate(positions):\n            line = Line(LEFT, RIGHT, color=BLUE if i % 2 == 0 else RED)\n            line.move_to(RIGHT * 2 + UP * pos)\n            after.add(line)\n        \n        after_title = Text(\"With Coupling\", font_size=20).next_to(after, UP)\n        \n        # Show energy levels \n        self.play(Create(before), Write(before_title))\n        self.play(Create(after), Write(after_title))\n        \n        # Second equation - energy calculation\n        eq2 = Text(\"\u0394E = \u0127\u03c9/2 (2n + l + 3/2 - \u03ba\u00b7l\u00b7s)\", font_size=20).to_edge(DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Clear second part\n        second_group = VGroup(before, before_title, after, after_title, eq2)\n        self.play(FadeOut(second_group))\n        \n        # Conclusion\n        conclusion = Text(\"Spin-orbit coupling explains magic numbers\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways does the spin-orbit coupling affect the calculation of magic numbers in nuclei, and how can these be visualized effectively?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 3D scene with a coordinate axis system and a colorful surface representing the function \\( z = \\sin(x) \\cos(y) \\) over a square domain. The surface is fully opaque and shaded using a color gradient: red for lower values, yellow for mid-range, and green for higher values along the vertical (z) axis. The camera is angled from above and behind to highlight the surface's undulating shape."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FillByValueExample(ThreeDScene):\n    def construct(self):\n        resolution_fa = 8\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\n        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\n        def param_surface(u, v):\n            x = u\n            y = v\n            z = np.sin(x) * np.cos(y)\n            return z\n        surface_plane = Surface(\n            lambda u, v: axes.c2p(u, v, param_surface(u, v)),\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[0, 5],\n            u_range=[0, 5],\n            )\n        surface_plane.set_style(fill_opacity=1)\n        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\n        self.add(axes, surface_plane)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D scene with a coordinate axis system and a colorful surface representing the function \\( z = \\sin(x) \\cos(y) \\) over a square domain. The surface is fully opaque and shaded using a color gradient: red for lower values, yellow for mid-range, and green for higher values along the vertical (z) axis. The camera is angled from above and behind to highlight the surface's undulating shape."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 3d scene with a coordinate axis system and a colorful surface representing the function \\( z = \\sin(x) \\cos(y) \\) over a square domain. the surface is fully opaque and shaded using a color gradient: red for lower values, yellow for mid-range, and green for higher values along the vertical (z) axis. the camera is angled from above and behind to highlight the surface's undulating shape."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FillByValueExample(ThreeDScene):\n    def construct(self):\n        resolution_fa = 8\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\n        axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\n        def param_surface(u, v):\n            x = u\n            y = v\n            z = np.sin(x) * np.cos(y)\n            return z\n        surface_plane = Surface(\n            lambda u, v: axes.c2p(u, v, param_surface(u, v)),\n            resolution=(resolution_fa, resolution_fa),\n            v_range=[0, 5],\n            u_range=[0, 5],\n            )\n        surface_plane.set_style(fill_opacity=1)\n        surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\n        self.add(axes, surface_plane)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D scene with a coordinate axis system and a colorful surface representing the function \\( z = \\sin(x) \\cos(y) \\) over a square domain. The surface is fully opaque and shaded using a color gradient: red for lower values, yellow for mid-range, and green for higher values along the vertical (z) axis. The camera is angled from above and behind to highlight the surface's undulating shape."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the text \u201cFocusing on the dot below:\u201d at the top of the screen with a yellow dot positioned below it. Then animate a spotlight effect that highlights and draws attention to the dot."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \u201cFocusing on the dot below:\u201d at the top of the screen with a yellow dot positioned below it. Then animate a spotlight effect that highlights and draws attention to the dot."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the text \u201cfocusing on the dot below:\u201d at the top of the screen with a yellow dot positioned below it. then animate a spotlight effect that highlights and draws attention to the dot."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UsingFocusOn(Scene):\n    def construct(self):\n        dot = Dot(color=YELLOW).shift(DOWN)\n        self.add(Tex(\"Focusing on the dot below:\"), dot)\n        self.play(FocusOn(dot))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \u201cFocusing on the dot below:\u201d at the top of the screen with a yellow dot positioned below it. Then animate a spotlight effect that highlights and draws attention to the dot."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a mathematical expression representing the Taylor series expansion of \\( e^x \\). All instances of the variable \\( x \\) in the equation are colored yellow."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IncorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a mathematical expression representing the Taylor series expansion of \\( e^x \\). All instances of the variable \\( x \\) in the equation are colored yellow."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a mathematical expression representing the taylor series expansion of \\( e^x \\). all instances of the variable \\( x \\) in the equation are colored yellow."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IncorrectLaTeXSubstringColoring(Scene):\n    def construct(self):\n        equation = MathTex(\n            r\"e^x = x^0 + x^1 + \\frac{1}{2} x^2 + \\frac{1}{6} x^3 + \\cdots + \\frac{1}{n!} x^n + \\cdots\"\n        )\n        equation.set_color_by_tex(\"x\", YELLOW)\n        self.add(equation)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a mathematical expression representing the Taylor series expansion of \\( e^x \\). All instances of the variable \\( x \\) in the equation are colored yellow."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation that starts with a vertical arrangement of geometric shapes, specifically three sets of rectangles, displayed on a light beige background. The first and third sets should have a black rectangle on each side with a red-filled rectangle in the middle. For the second set, both rectangles should be red-filled. On the second stage, numbers from 1 to 6 should be displayed sequentially on top of the corresponding red rectangles, followed by a fraction appearing to the right, showing 6 over 10 with the numerator in red. After that, I'd like the numbers to fade away and a new set of numbers, from 1 to 10, to appear on each rectangle, regardless of the color. The remaining part of the fraction should also be shown, and then all the numbers fade out. The animation should conclude by moving everything offscreen to the left."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Atom(VMobject):\n    def __init__(self, label, radius=0.2, color=BLUE, label_color=WHITE, **kwargs):\n        super().__init__(**kwargs)\n        self.circle = Circle(radius=radius, color=color)\n        self.label = Tex(label, color=label_color).scale(0.5)\n        self.add(self.circle, self.label)\n\n    def set_label(self, new_label):\n        self.label.become(Tex(new_label).scale(0.5))\n        return self\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        grid = VGroup()\n        for x in range(-5, 6):\n            for y in range(-3, 4):\n                atom = Atom(label=\"H\", radius=0.3, color=RED)\n                atom.move_to(x*0.6*RIGHT + y*0.6*UP)\n                grid.add(atom)\n\n        self.play(Create(grid))\n        self.wait()\n\n        # Animate the change of all atoms labels to \"He\"\n        for atom in grid:\n            self.play(atom.set_label(\"He\"), run_time=0.1)\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that starts with a vertical arrangement of geometric shapes, specifically three sets of rectangles, displayed on a light beige background. The first and third sets should have a black rectangle on each side with a red-filled rectangle in the middle. For the second set, both rectangles should be red-filled. On the second stage, numbers from 1 to 6 should be displayed sequentially on top of the corresponding red rectangles, followed by a fraction appearing to the right, showing 6 over 10 with the numerator in red. After that, I'd like the numbers to fade away and a new set of numbers, from 1 to 10, to appear on each rectangle, regardless of the color. The remaining part of the fraction should also be shown, and then all the numbers fade out. The animation should conclude by moving everything offscreen to the left."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation that starts with a vertical arrangement of geometric shapes, specifically three sets of rectangles, displayed on a light beige background. the first and third sets should have a black rectangle on each side with a red-filled rectangle in the middle. for the second set, both rectangles should be red-filled. on the second stage, numbers from 1 to 6 should be displayed sequentially on top of the corresponding red rectangles, followed by a fraction appearing to the right, showing 6 over 10 with the numerator in red. after that, i'd like the numbers to fade away and a new set of numbers, from 1 to 10, to appear on each rectangle, regardless of the color. the remaining part of the fraction should also be shown, and then all the numbers fade out. the animation should conclude by moving everything offscreen to the left."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Atom(VMobject):\n    def __init__(self, label, radius=0.2, color=BLUE, label_color=WHITE, **kwargs):\n        super().__init__(**kwargs)\n        self.circle = Circle(radius=radius, color=color)\n        self.label = Tex(label, color=label_color).scale(0.5)\n        self.add(self.circle, self.label)\n\n    def set_label(self, new_label):\n        self.label.become(Tex(new_label).scale(0.5))\n        return self\n\nclass AtomScene(Scene):\n    def construct(self):\n        # Create a grid of atoms\n        grid = VGroup()\n        for x in range(-5, 6):\n            for y in range(-3, 4):\n                atom = Atom(label=\"H\", radius=0.3, color=RED)\n                atom.move_to(x*0.6*RIGHT + y*0.6*UP)\n                grid.add(atom)\n\n        self.play(Create(grid))\n        self.wait()\n\n        # Animate the change of all atoms labels to \"He\"\n        for atom in grid:\n            self.play(atom.set_label(\"He\"), run_time=0.1)\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that starts with a vertical arrangement of geometric shapes, specifically three sets of rectangles, displayed on a light beige background. The first and third sets should have a black rectangle on each side with a red-filled rectangle in the middle. For the second set, both rectangles should be red-filled. On the second stage, numbers from 1 to 6 should be displayed sequentially on top of the corresponding red rectangles, followed by a fraction appearing to the right, showing 6 over 10 with the numerator in red. After that, I'd like the numbers to fade away and a new set of numbers, from 1 to 10, to appear on each rectangle, regardless of the color. The remaining part of the fraction should also be shown, and then all the numbers fade out. The animation should conclude by moving everything offscreen to the left."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do adaptive landscapes illustrate the evolution of strategy populations within an 'Evolutionary Stable Strategy (ESS)' framework?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EvolutionaryGameDynamics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating Strategic Peaks\", font_size=32, color=BLUE_C)\n        subtitle = Text(\"Evolutionary Game Dynamics\", font_size=24, color=GREEN_C)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a simple landscape with axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[0, 4, 1],\n            x_length=6,\n            y_length=4,\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Create a curve with two peaks (simplified adaptive landscape)\n        curve = axes.plot(\n            lambda x: 2 + np.exp(-x**2) + 0.5 * np.exp(-(x-1.5)**2),\n            color=BLUE_B\n        )\n        \n        landscape = VGroup(axes, curve)\n        landscape_label = Text(\"Adaptive Landscape\", font_size=24, color=PURPLE_A).to_edge(UP)\n        \n        self.play(Create(landscape))\n        self.play(Write(landscape_label))\n        \n        # Mark peaks (ESS points)\n        peak1 = Dot(axes.c2p(0, 3), color=PURPLE_B)\n        peak2 = Dot(axes.c2p(1.5, 2.5), color=PURPLE_B)\n        \n        ess_label = Text(\"Evolutionary Stable Strategies\", font_size=24, color=PURPLE_B)\n        ess_label.next_to(landscape, DOWN)\n        \n        self.play(Create(peak1), Create(peak2))\n        self.play(Write(ess_label))\n        \n        # Show strategies as dots moving towards peaks\n        strategy1 = Dot(axes.c2p(-2, 2), color=GREEN_C)\n        strategy2 = Dot(axes.c2p(3, 2), color=GREEN_C)\n        \n        strat_label = Text(\"Evolving Strategies\", font_size=20, color=GREEN_C)\n        strat_label.next_to(ess_label, DOWN)\n        \n        self.play(Create(strategy1), Create(strategy2))\n        self.play(Write(strat_label))\n        \n        # Move strategies towards peaks\n        self.play(\n            strategy1.animate.move_to(peak1.get_center()),\n            strategy2.animate.move_to(peak2.get_center()),\n            run_time=2\n        )\n        self.wait(1)\n        \n        # Clear screen for equations\n        self.play(\n            FadeOut(landscape),\n            FadeOut(landscape_label),\n            FadeOut(peak1), FadeOut(peak2),\n            FadeOut(strategy1), FadeOut(strategy2),\n            FadeOut(ess_label),\n            FadeOut(strat_label)\n        )\n        \n        # Show the ESS equation\n        ess_eq = MathTex(r\"\\mathrm{ESS} \\Leftrightarrow \\exists \\left( \\sigma, \\sigma' \\right), \\quad \\text{if} \\quad \\sigma \\cdot \\sigma \\geq \\sigma' \\cdot \\sigma\")\n        eq_label = Text(\"ESS Definition\", font_size=24, color=BLUE_C).next_to(ess_eq, UP)\n        \n        self.play(Write(eq_label))\n        self.play(Write(ess_eq))\n        self.wait(2)\n        \n        # Show the fitness function equation\n        self.play(FadeOut(ess_eq), FadeOut(eq_label))\n        \n        fitness_eq = MathTex(r\"f(x) = \\sum {\\text{payoff}(x)} \\quad \\& \\quad \\nabla f(x) \\rightarrow \\text{gradients}\")\n        fitness_label = Text(\"Fitness Function\", font_size=24, color=BLUE_C).next_to(fitness_eq, UP)\n        \n        self.play(Write(fitness_label))\n        self.play(Write(fitness_eq))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(fitness_eq), FadeOut(fitness_label))\n        \n        conclusion = Text(\"Strategies evolve towards stable equilibria\", font_size=28, color=GREEN_C)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do adaptive landscapes illustrate the evolution of strategy populations within an 'Evolutionary Stable Strategy (ESS)' framework?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do adaptive landscapes illustrate the evolution of strategy populations within an 'evolutionary stable strategy (ess)' framework?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EvolutionaryGameDynamics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating Strategic Peaks\", font_size=32, color=BLUE_C)\n        subtitle = Text(\"Evolutionary Game Dynamics\", font_size=24, color=GREEN_C)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a simple landscape with axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[0, 4, 1],\n            x_length=6,\n            y_length=4,\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Create a curve with two peaks (simplified adaptive landscape)\n        curve = axes.plot(\n            lambda x: 2 + np.exp(-x**2) + 0.5 * np.exp(-(x-1.5)**2),\n            color=BLUE_B\n        )\n        \n        landscape = VGroup(axes, curve)\n        landscape_label = Text(\"Adaptive Landscape\", font_size=24, color=PURPLE_A).to_edge(UP)\n        \n        self.play(Create(landscape))\n        self.play(Write(landscape_label))\n        \n        # Mark peaks (ESS points)\n        peak1 = Dot(axes.c2p(0, 3), color=PURPLE_B)\n        peak2 = Dot(axes.c2p(1.5, 2.5), color=PURPLE_B)\n        \n        ess_label = Text(\"Evolutionary Stable Strategies\", font_size=24, color=PURPLE_B)\n        ess_label.next_to(landscape, DOWN)\n        \n        self.play(Create(peak1), Create(peak2))\n        self.play(Write(ess_label))\n        \n        # Show strategies as dots moving towards peaks\n        strategy1 = Dot(axes.c2p(-2, 2), color=GREEN_C)\n        strategy2 = Dot(axes.c2p(3, 2), color=GREEN_C)\n        \n        strat_label = Text(\"Evolving Strategies\", font_size=20, color=GREEN_C)\n        strat_label.next_to(ess_label, DOWN)\n        \n        self.play(Create(strategy1), Create(strategy2))\n        self.play(Write(strat_label))\n        \n        # Move strategies towards peaks\n        self.play(\n            strategy1.animate.move_to(peak1.get_center()),\n            strategy2.animate.move_to(peak2.get_center()),\n            run_time=2\n        )\n        self.wait(1)\n        \n        # Clear screen for equations\n        self.play(\n            FadeOut(landscape),\n            FadeOut(landscape_label),\n            FadeOut(peak1), FadeOut(peak2),\n            FadeOut(strategy1), FadeOut(strategy2),\n            FadeOut(ess_label),\n            FadeOut(strat_label)\n        )\n        \n        # Show the ESS equation\n        ess_eq = MathTex(r\"\\mathrm{ESS} \\Leftrightarrow \\exists \\left( \\sigma, \\sigma' \\right), \\quad \\text{if} \\quad \\sigma \\cdot \\sigma \\geq \\sigma' \\cdot \\sigma\")\n        eq_label = Text(\"ESS Definition\", font_size=24, color=BLUE_C).next_to(ess_eq, UP)\n        \n        self.play(Write(eq_label))\n        self.play(Write(ess_eq))\n        self.wait(2)\n        \n        # Show the fitness function equation\n        self.play(FadeOut(ess_eq), FadeOut(eq_label))\n        \n        fitness_eq = MathTex(r\"f(x) = \\sum {\\text{payoff}(x)} \\quad \\& \\quad \\nabla f(x) \\rightarrow \\text{gradients}\")\n        fitness_label = Text(\"Fitness Function\", font_size=24, color=BLUE_C).next_to(fitness_eq, UP)\n        \n        self.play(Write(fitness_label))\n        self.play(Write(fitness_eq))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(fitness_eq), FadeOut(fitness_label))\n        \n        conclusion = Text(\"Strategies evolve towards stable equilibria\", font_size=28, color=GREEN_C)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do adaptive landscapes illustrate the evolution of strategy populations within an 'Evolutionary Stable Strategy (ESS)' framework?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_plotting.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib\nplt.style.use('dark_background')\n\nfrom manim_ml.utils.mobjects.plotting import convert_matplotlib_figure_to_image_mobject\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\n__module_test__ = \"plotting\"\n\n@frames_comparison\ndef test_matplotlib_to_image_mobject(scene):\n    # libraries & dataset\n    df = sns.load_dataset('iris')\n    # Custom the color, add shade and bandwidth\n    matplotlib.use('Agg')\n    plt.figure(figsize=(10,10), dpi=100)\n    displot = sns.displot(\n        x=df.sepal_width, \n        y=df.sepal_length, \n        cmap=\"Reds\", \n        kind=\"kde\",\n    )\n    plt.axis('off')\n    fig = displot.fig\n    image_mobject = convert_matplotlib_figure_to_image_mobject(fig)\n    # Display the image mobject\n    scene.add(image_mobject)\n\nclass TestMatplotlibToImageMobject(Scene):\n\n    def construct(self):\n        # Make a matplotlib plot\n        # libraries & dataset\n        df = sns.load_dataset('iris')\n        # Custom the color, add shade and bandwidth\n        matplotlib.use('Agg')\n        plt.figure(figsize=(10,10), dpi=100)\n        displot = sns.displot(\n            x=df.sepal_width, \n            y=df.sepal_length, \n            cmap=\"Reds\", \n            kind=\"kde\",\n        )\n        plt.axis('off')\n        fig = displot.fig\n        image_mobject = convert_matplotlib_figure_to_image_mobject(fig)\n        # Display the image mobject\n        self.add(image_mobject)\n\n\nclass HexabinScene(Scene):\n\n    def construct(self):\n        # Fixing random state for reproducibility\n        np.random.seed(19680801)\n        n = 100_000\n        x = np.random.standard_normal(n)\n        y = x + 1.0 * np.random.standard_normal(n)\n        xlim = -4, 4\n        ylim = -4, 4\n\n        fig, ax0 = plt.subplots(1, figsize=(5, 5))\n\n        hb = ax0.hexbin(x, y, gridsize=50, cmap='inferno')\n        ax0.set(xlim=xlim, ylim=ylim)\n\n        self.add(convert_matplotlib_figure_to_image_mobject(fig))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_plotting.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_plotting.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib\nplt.style.use('dark_background')\n\nfrom manim_ml.utils.mobjects.plotting import convert_matplotlib_figure_to_image_mobject\nfrom manim_ml.utils.testing.frames_comparison import frames_comparison\n\n__module_test__ = \"plotting\"\n\n@frames_comparison\ndef test_matplotlib_to_image_mobject(scene):\n    # libraries & dataset\n    df = sns.load_dataset('iris')\n    # Custom the color, add shade and bandwidth\n    matplotlib.use('Agg')\n    plt.figure(figsize=(10,10), dpi=100)\n    displot = sns.displot(\n        x=df.sepal_width, \n        y=df.sepal_length, \n        cmap=\"Reds\", \n        kind=\"kde\",\n    )\n    plt.axis('off')\n    fig = displot.fig\n    image_mobject = convert_matplotlib_figure_to_image_mobject(fig)\n    # Display the image mobject\n    scene.add(image_mobject)\n\nclass TestMatplotlibToImageMobject(Scene):\n\n    def construct(self):\n        # Make a matplotlib plot\n        # libraries & dataset\n        df = sns.load_dataset('iris')\n        # Custom the color, add shade and bandwidth\n        matplotlib.use('Agg')\n        plt.figure(figsize=(10,10), dpi=100)\n        displot = sns.displot(\n            x=df.sepal_width, \n            y=df.sepal_length, \n            cmap=\"Reds\", \n            kind=\"kde\",\n        )\n        plt.axis('off')\n        fig = displot.fig\n        image_mobject = convert_matplotlib_figure_to_image_mobject(fig)\n        # Display the image mobject\n        self.add(image_mobject)\n\n\nclass HexabinScene(Scene):\n\n    def construct(self):\n        # Fixing random state for reproducibility\n        np.random.seed(19680801)\n        n = 100_000\n        x = np.random.standard_normal(n)\n        y = x + 1.0 * np.random.standard_normal(n)\n        xlim = -4, 4\n        ylim = -4, 4\n\n        fig, ax0 = plt.subplots(1, figsize=(5, 5))\n\n        hb = ax0.hexbin(x, y, gridsize=50, cmap='inferno')\n        ax0.set(xlim=xlim, ylim=ylim)\n\n        self.add(convert_matplotlib_figure_to_image_mobject(fig))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_plotting.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Please create an animation that shows a blue, semi-transparent ball bouncing across the floor, making a total of four bounces before it comes to a stop and everything fades away. The floor should be a simple line, and the ball should start above the ground on the left side of the screen. Each bounce should be smaller than the last, and the ball should move slightly to the right with each bounce. Also ensure that the ball appears to descend and ascend at an angle as it bounces rather than straight up and down. After the final bounce, the ball should rest for a moment before the entire scene fades out."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_1^3 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Showing the general solution\n        general_solution = MathTex(r\"= \\left[ \\frac{3x^{2+1}}{2+1} \\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), general_solution))\n        self.wait(2)\n        \n        # Evaluation step 1\n        evaluation1 = MathTex(r\"= \\left[ x^3 \\right]_1^3\")\n        self.play(ReplacementTransform(general_solution, evaluation1))\n        self.wait(2)\n        \n        # Evaluation from the upper bound to the lower bound\n        evaluation2 = MathTex(r\"= 3^3 - 1^3\")\n        self.play(ReplacementTransform(evaluation1, evaluation2))\n        self.wait(1)\n\n        # Final value after calculation\n        final_value = MathTex(r\"= 27 - 1 = 26\")\n        self.play(ReplacementTransform(evaluation2, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final answer\n        self.play(Write(final_value))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an animation that shows a blue, semi-transparent ball bouncing across the floor, making a total of four bounces before it comes to a stop and everything fades away. The floor should be a simple line, and the ball should start above the ground on the left side of the screen. Each bounce should be smaller than the last, and the ball should move slightly to the right with each bounce. Also ensure that the ball appears to descend and ascend at an angle as it bounces rather than straight up and down. After the final bounce, the ball should rest for a moment before the entire scene fades out."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that please create an animation that shows a blue, semi-transparent ball bouncing across the floor, making a total of four bounces before it comes to a stop and everything fades away. the floor should be a simple line, and the ball should start above the ground on the left side of the screen. each bounce should be smaller than the last, and the ball should move slightly to the right with each bounce. also ensure that the ball appears to descend and ascend at an angle as it bounces rather than straight up and down. after the final bounce, the ball should rest for a moment before the entire scene fades out."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Setting up the problem\n        problem = MathTex(r\"\\int_1^3 3x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Showing the general solution\n        general_solution = MathTex(r\"= \\left[ \\frac{3x^{2+1}}{2+1} \\right]_1^3\")\n        self.play(ReplacementTransform(problem.copy(), general_solution))\n        self.wait(2)\n        \n        # Evaluation step 1\n        evaluation1 = MathTex(r\"= \\left[ x^3 \\right]_1^3\")\n        self.play(ReplacementTransform(general_solution, evaluation1))\n        self.wait(2)\n        \n        # Evaluation from the upper bound to the lower bound\n        evaluation2 = MathTex(r\"= 3^3 - 1^3\")\n        self.play(ReplacementTransform(evaluation1, evaluation2))\n        self.wait(1)\n\n        # Final value after calculation\n        final_value = MathTex(r\"= 27 - 1 = 26\")\n        self.play(ReplacementTransform(evaluation2, final_value))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Display the final answer\n        self.play(Write(final_value))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an animation that shows a blue, semi-transparent ball bouncing across the floor, making a total of four bounces before it comes to a stop and everything fades away. The floor should be a simple line, and the ball should start above the ground on the left side of the screen. Each bounce should be smaller than the last, and the ball should move slightly to the right with each bounce. Also ensure that the ball appears to descend and ascend at an angle as it bounces rather than straight up and down. After the final bounce, the ball should rest for a moment before the entire scene fades out."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What role does the Sasaki Metric play in establishing contact metric structures on manifolds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SasakiMetricScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Sasaki Metric\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple manifold representation (a circle)\n        manifold = Circle(radius=2, color=BLUE).set_fill(BLUE_E, opacity=0.3)\n        manifold_label = Text(\"Manifold\", font_size=30).next_to(manifold, DOWN)\n        \n        self.play(Create(manifold), Write(manifold_label))\n        self.wait(1)\n        \n        # Add contact structures (represented by radial lines)\n        contact_lines = VGroup()\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            line = Line(\n                manifold.get_center(),\n                manifold.point_at_angle(angle),\n                color=YELLOW\n            )\n            contact_lines.add(line)\n        \n        contact_label = Text(\"Contact Structure\", font_size=30).next_to(manifold, UP)\n        \n        self.play(Create(contact_lines), Write(contact_label))\n        self.wait(1)\n        \n        # Group all elements related to the manifold\n        manifold_group = VGroup(manifold, contact_lines, manifold_label, contact_label)\n        \n        # Move the manifold to the left to make room for the equation\n        self.play(\n            manifold_group.animate.scale(0.7).to_edge(LEFT)\n        )\n        \n        # Show the Sasaki Metric equation\n        sasaki_eq = MathTex(r\"g_{Sasaki}=\\pi^*g + g^v\").scale(1.3)\n        sasaki_label = Text(\"Sasaki Metric\", font_size=30).next_to(sasaki_eq, UP)\n        \n        eq_group = VGroup(sasaki_eq, sasaki_label).to_edge(RIGHT)\n        \n        self.play(Write(eq_group))\n        self.wait(1)\n        \n        # Show how the Sasaki Metric connects contact and Riemannian geometry\n        arrow = Arrow(manifold.get_right(), sasaki_eq.get_left(), color=GREEN)\n        bridge_text = Text(\"Bridges\", font_size=28).next_to(arrow, UP)\n        \n        self.play(Create(arrow), Write(bridge_text))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The Sasaki Metric connects\\ncontact and Riemannian geometry\", \n                          font_size=32).to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(VGroup(\n                manifold_group, eq_group, arrow, bridge_text, conclusion, title\n            ))\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What role does the Sasaki Metric play in establishing contact metric structures on manifolds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what role does the sasaki metric play in establishing contact metric structures on manifolds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SasakiMetricScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Sasaki Metric\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple manifold representation (a circle)\n        manifold = Circle(radius=2, color=BLUE).set_fill(BLUE_E, opacity=0.3)\n        manifold_label = Text(\"Manifold\", font_size=30).next_to(manifold, DOWN)\n        \n        self.play(Create(manifold), Write(manifold_label))\n        self.wait(1)\n        \n        # Add contact structures (represented by radial lines)\n        contact_lines = VGroup()\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            line = Line(\n                manifold.get_center(),\n                manifold.point_at_angle(angle),\n                color=YELLOW\n            )\n            contact_lines.add(line)\n        \n        contact_label = Text(\"Contact Structure\", font_size=30).next_to(manifold, UP)\n        \n        self.play(Create(contact_lines), Write(contact_label))\n        self.wait(1)\n        \n        # Group all elements related to the manifold\n        manifold_group = VGroup(manifold, contact_lines, manifold_label, contact_label)\n        \n        # Move the manifold to the left to make room for the equation\n        self.play(\n            manifold_group.animate.scale(0.7).to_edge(LEFT)\n        )\n        \n        # Show the Sasaki Metric equation\n        sasaki_eq = MathTex(r\"g_{Sasaki}=\\pi^*g + g^v\").scale(1.3)\n        sasaki_label = Text(\"Sasaki Metric\", font_size=30).next_to(sasaki_eq, UP)\n        \n        eq_group = VGroup(sasaki_eq, sasaki_label).to_edge(RIGHT)\n        \n        self.play(Write(eq_group))\n        self.wait(1)\n        \n        # Show how the Sasaki Metric connects contact and Riemannian geometry\n        arrow = Arrow(manifold.get_right(), sasaki_eq.get_left(), color=GREEN)\n        bridge_text = Text(\"Bridges\", font_size=28).next_to(arrow, UP)\n        \n        self.play(Create(arrow), Write(bridge_text))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The Sasaki Metric connects\\ncontact and Riemannian geometry\", \n                          font_size=32).to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(VGroup(\n                manifold_group, eq_group, arrow, bridge_text, conclusion, title\n            ))\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What role does the Sasaki Metric play in establishing contact metric structures on manifolds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that illustrates and explains the heat equation, including how it represents the distribution of heat over time, provides an example of a specific solution, discusses the importance of initial and boundary conditions, and shows what a steady-state solution looks like?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the example\n        title = Text(\"Fourier Series Example\", font_size=36)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(FadeOut(title))\n        \n        # Displaying Fourier Series Definition\n        fourier_series_def = MathTex(\n            r\"f(x) = a_0\",\n            r\"+ \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\"\n        )\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Coefficients explanation\n        coefficients_explanation = Text(\n            \"Coefficients are calculated based on function's periodicity\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Write(coefficients_explanation))\n        self.wait(3)\n        \n        # Transition to specific example\n        specific_example = Text(\n            \"For a square wave, coefficients have distinct values\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Transform(coefficients_explanation, specific_example))\n        self.wait(3)\n\n        # Displaying the square wave's Fourier Series\n        square_wave_fs = MathTex(\n            r\"f(x) = \\frac{4}{\\pi}\",\n            r\"\\sum_{n=1,3,5}^{\\infty} \\frac{(-1)^{(n-1)/2}}{n} \\sin(nx)\"\n        )\n\n        self.play(ReplacementTransform(fourier_series_def, square_wave_fs))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(square_wave_fs), FadeOut(specific_example))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates and explains the heat equation, including how it represents the distribution of heat over time, provides an example of a specific solution, discusses the importance of initial and boundary conditions, and shows what a steady-state solution looks like?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that illustrates and explains the heat equation, including how it represents the distribution of heat over time, provides an example of a specific solution, discusses the importance of initial and boundary conditions, and shows what a steady-state solution looks like?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FourierSeriesExample(Scene):\n    def construct(self):\n        # Title of the example\n        title = Text(\"Fourier Series Example\", font_size=36)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(FadeOut(title))\n        \n        # Displaying Fourier Series Definition\n        fourier_series_def = MathTex(\n            r\"f(x) = a_0\",\n            r\"+ \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))\"\n        )\n        self.play(Write(fourier_series_def))\n        self.wait(2)\n\n        # Coefficients explanation\n        coefficients_explanation = Text(\n            \"Coefficients are calculated based on function's periodicity\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Write(coefficients_explanation))\n        self.wait(3)\n        \n        # Transition to specific example\n        specific_example = Text(\n            \"For a square wave, coefficients have distinct values\",\n            font_size=24\n        ).to_edge(DOWN)\n        self.play(Transform(coefficients_explanation, specific_example))\n        self.wait(3)\n\n        # Displaying the square wave's Fourier Series\n        square_wave_fs = MathTex(\n            r\"f(x) = \\frac{4}{\\pi}\",\n            r\"\\sum_{n=1,3,5}^{\\infty} \\frac{(-1)^{(n-1)/2}}{n} \\sin(nx)\"\n        )\n\n        self.play(ReplacementTransform(fourier_series_def, square_wave_fs))\n        self.wait(2)\n\n        # Clear the scene\n        self.play(FadeOut(square_wave_fs), FadeOut(specific_example))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates and explains the heat equation, including how it represents the distribution of heat over time, provides an example of a specific solution, discusses the importance of initial and boundary conditions, and shows what a steady-state solution looks like?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that explains the process of solving a simple first-order differential equation. The content should begin by showing the differential equation y' - y = 0, and then proceed to explain how to form its characteristic equation. After forming the characteristic equation, r - 1 = 0, it should demonstrate how to find the roots of this equation. Once we have the root r = 1, the animation should then present the general solution to the differential equation which is y = C e^x, where C is an arbitrary constant. Throughout the animation, it would be helpful to have written explanations that appear at the top of the screen guiding viewers through each step of the process. Lastly, the entire solution process should conclude with the final general solution displayed clearly on the screen. Can this be visualized in an animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.background_color = \"#faf4e1\"\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = it.cycle([\n            \"#f55e61\",\n            \"#408ef5\",\n            \"#e3883d\",\n            \"#a346eb\",\n            \"#0dc786\"\n        ])\n\n        fib_numbers = [0, 1]\n        for _ in range(7):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n        \n        squares = VGroup()\n        for index, number in enumerate(fib_numbers[2:]):\n            color = next(colors)\n            square = Square(side_length=number).set_stroke(color, width=3).set_fill(color, opacity=0.5)\n            squares.add(square)\n        \n        squares.arrange_in_grid(buf=0)\n        center_of_spiral = squares.get_center()\n        \n        self.play(AnimationGroup(*[FadeIn(square, shift=0.5*UP) for square in squares], lag_ratio=0.2))\n        self.wait()\n        \n        arcs = VGroup()\n        for s1, s2 in zip(squares[:-1], squares[1:]):\n            angle = 90 * DEGREES if s2.get_y() < s1.get_y() else -90 * DEGREES\n            radius = abs(s1.get_width() - s2.get_width()) / 2\n            arc = Arc(radius=radius, angle=angle, arc_center=s1.get_center())\n            arc.move_arc_center_to(s1.get_center())\n            arcs.add(arc)\n        \n        arcs.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE)\n        self.play(AnimationGroup(*[ShowCreation(arc) for arc in arcs], lag_ratio=0.4))\n        self.wait()\n\n        last_square = squares[-1]\n        circles = VGroup()\n        for n in fib_numbers[2:]:\n            circle = Circle(radius=n/2).set_stroke(BLACK, width=3)\n            circle.move_to(last_square)\n            last_square = circle\n            circles.add(circle)\n        \n        self.play(AnimationGroup(*[FadeIn(circle) for circle in circles], lag_ratio=0.7))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that explains the process of solving a simple first-order differential equation. The content should begin by showing the differential equation y' - y = 0, and then proceed to explain how to form its characteristic equation. After forming the characteristic equation, r - 1 = 0, it should demonstrate how to find the roots of this equation. Once we have the root r = 1, the animation should then present the general solution to the differential equation which is y = C e^x, where C is an arbitrary constant. Throughout the animation, it would be helpful to have written explanations that appear at the top of the screen guiding viewers through each step of the process. Lastly, the entire solution process should conclude with the final general solution displayed clearly on the screen. Can this be visualized in an animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that explains the process of solving a simple first-order differential equation. the content should begin by showing the differential equation y' - y = 0, and then proceed to explain how to form its characteristic equation. after forming the characteristic equation, r - 1 = 0, it should demonstrate how to find the roots of this equation. once we have the root r = 1, the animation should then present the general solution to the differential equation which is y = c e^x, where c is an arbitrary constant. throughout the animation, it would be helpful to have written explanations that appear at the top of the screen guiding viewers through each step of the process. lastly, the entire solution process should conclude with the final general solution displayed clearly on the screen. can this be visualized in an animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.background_color = \"#faf4e1\"\n\nclass FibonacciSpiral(Scene):\n    def construct(self):\n        colors = it.cycle([\n            \"#f55e61\",\n            \"#408ef5\",\n            \"#e3883d\",\n            \"#a346eb\",\n            \"#0dc786\"\n        ])\n\n        fib_numbers = [0, 1]\n        for _ in range(7):\n            fib_numbers.append(fib_numbers[-1] + fib_numbers[-2])\n        \n        squares = VGroup()\n        for index, number in enumerate(fib_numbers[2:]):\n            color = next(colors)\n            square = Square(side_length=number).set_stroke(color, width=3).set_fill(color, opacity=0.5)\n            squares.add(square)\n        \n        squares.arrange_in_grid(buf=0)\n        center_of_spiral = squares.get_center()\n        \n        self.play(AnimationGroup(*[FadeIn(square, shift=0.5*UP) for square in squares], lag_ratio=0.2))\n        self.wait()\n        \n        arcs = VGroup()\n        for s1, s2 in zip(squares[:-1], squares[1:]):\n            angle = 90 * DEGREES if s2.get_y() < s1.get_y() else -90 * DEGREES\n            radius = abs(s1.get_width() - s2.get_width()) / 2\n            arc = Arc(radius=radius, angle=angle, arc_center=s1.get_center())\n            arc.move_arc_center_to(s1.get_center())\n            arcs.add(arc)\n        \n        arcs.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE, PURPLE)\n        self.play(AnimationGroup(*[ShowCreation(arc) for arc in arcs], lag_ratio=0.4))\n        self.wait()\n\n        last_square = squares[-1]\n        circles = VGroup()\n        for n in fib_numbers[2:]:\n            circle = Circle(radius=n/2).set_stroke(BLACK, width=3)\n            circle.move_to(last_square)\n            last_square = circle\n            circles.add(circle)\n        \n        self.play(AnimationGroup(*[FadeIn(circle) for circle in circles], lag_ratio=0.7))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that explains the process of solving a simple first-order differential equation. The content should begin by showing the differential equation y' - y = 0, and then proceed to explain how to form its characteristic equation. After forming the characteristic equation, r - 1 = 0, it should demonstrate how to find the roots of this equation. Once we have the root r = 1, the animation should then present the general solution to the differential equation which is y = C e^x, where C is an arbitrary constant. Throughout the animation, it would be helpful to have written explanations that appear at the top of the screen guiding viewers through each step of the process. Lastly, the entire solution process should conclude with the final general solution displayed clearly on the screen. Can this be visualized in an animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the solutions to the Pell's Equation be visualized geometrically on a coordinate grid?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PellsEquationGeometric(Scene):\n    def construct(self):\n        # INTRODUCTION\n        title = Text(\"Symmetric Patterns of Pell's Equation\", font_size=36)\n        subtitle = Text(\"A Geometric Exploration\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        \n        # Display Pell's equation with D=2\n        equation = MathTex(\"x^2 - 2y^2 = 1\")\n        equation.move_to(ORIGIN)\n        \n        self.play(FadeOut(title), FadeOut(subtitle))\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation to corner\n        self.play(equation.animate.to_corner(UR))\n        \n        # Create coordinate grid\n        grid = NumberPlane(\n            x_range=[-5, 5, 1],\n            y_range=[-5, 5, 1],\n        )\n        \n        self.play(Create(grid))\n        self.wait(1)\n        \n        # Plot solution points for D=2\n        # These solutions satisfy x^2 - 2y^2 = 1\n        solutions = [(1, 0), (3, 2)]\n        \n        # Create dots for solutions\n        dots = VGroup()\n        for x, y in solutions:\n            dot = Dot(grid.c2p(x, y), color=BLUE)\n            dots.add(dot)\n            \n            # Add symmetric solutions\n            dots.add(Dot(grid.c2p(x, -y), color=BLUE))\n            dots.add(Dot(grid.c2p(-x, y), color=BLUE))\n            dots.add(Dot(grid.c2p(-x, -y), color=BLUE))\n        \n        self.play(Create(dots))\n        self.wait(1)\n        \n        # Draw diagonal line through solutions\n        diagonal = Line(grid.c2p(-5, -3.5), grid.c2p(5, 3.5), color=YELLOW)\n        self.play(Create(diagonal))\n        self.wait(1)\n        \n        # Connect solution points\n        connections = VGroup(\n            Line(grid.c2p(1, 0), grid.c2p(3, 2), color=GREEN),\n            Line(grid.c2p(1, 0), grid.c2p(3, -2), color=GREEN),\n            Line(grid.c2p(-1, 0), grid.c2p(-3, 2), color=GREEN),\n            Line(grid.c2p(-1, 0), grid.c2p(-3, -2), color=GREEN)\n        )\n        \n        self.play(Create(connections))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Pell's Equation connects algebra and geometry\", font_size=32)\n        \n        self.play(FadeOut(grid), FadeOut(equation), FadeOut(dots), \n                  FadeOut(diagonal), FadeOut(connections))\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n\n# Run with: manim -pql -o video.mp4 script_name.py PellsEquationGeometric\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the solutions to the Pell's Equation be visualized geometrically on a coordinate grid?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the solutions to the pell's equation be visualized geometrically on a coordinate grid?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PellsEquationGeometric(Scene):\n    def construct(self):\n        # INTRODUCTION\n        title = Text(\"Symmetric Patterns of Pell's Equation\", font_size=36)\n        subtitle = Text(\"A Geometric Exploration\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        \n        # Display Pell's equation with D=2\n        equation = MathTex(\"x^2 - 2y^2 = 1\")\n        equation.move_to(ORIGIN)\n        \n        self.play(FadeOut(title), FadeOut(subtitle))\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation to corner\n        self.play(equation.animate.to_corner(UR))\n        \n        # Create coordinate grid\n        grid = NumberPlane(\n            x_range=[-5, 5, 1],\n            y_range=[-5, 5, 1],\n        )\n        \n        self.play(Create(grid))\n        self.wait(1)\n        \n        # Plot solution points for D=2\n        # These solutions satisfy x^2 - 2y^2 = 1\n        solutions = [(1, 0), (3, 2)]\n        \n        # Create dots for solutions\n        dots = VGroup()\n        for x, y in solutions:\n            dot = Dot(grid.c2p(x, y), color=BLUE)\n            dots.add(dot)\n            \n            # Add symmetric solutions\n            dots.add(Dot(grid.c2p(x, -y), color=BLUE))\n            dots.add(Dot(grid.c2p(-x, y), color=BLUE))\n            dots.add(Dot(grid.c2p(-x, -y), color=BLUE))\n        \n        self.play(Create(dots))\n        self.wait(1)\n        \n        # Draw diagonal line through solutions\n        diagonal = Line(grid.c2p(-5, -3.5), grid.c2p(5, 3.5), color=YELLOW)\n        self.play(Create(diagonal))\n        self.wait(1)\n        \n        # Connect solution points\n        connections = VGroup(\n            Line(grid.c2p(1, 0), grid.c2p(3, 2), color=GREEN),\n            Line(grid.c2p(1, 0), grid.c2p(3, -2), color=GREEN),\n            Line(grid.c2p(-1, 0), grid.c2p(-3, 2), color=GREEN),\n            Line(grid.c2p(-1, 0), grid.c2p(-3, -2), color=GREEN)\n        )\n        \n        self.play(Create(connections))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Pell's Equation connects algebra and geometry\", font_size=32)\n        \n        self.play(FadeOut(grid), FadeOut(equation), FadeOut(dots), \n                  FadeOut(diagonal), FadeOut(connections))\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n\n# Run with: manim -pql -o video.mp4 script_name.py PellsEquationGeometric\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the solutions to the Pell's Equation be visualized geometrically on a coordinate grid?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the use of quasi-random sequences in Monte Carlo simulations enhance accuracy over purely random sampling?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MonteCarloQuasiRandomSequences(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Enhancing Monte Carlo Simulations\", font_size=32)\n        subtitle = Text(\"with Quasi-Random Sequences\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Visual of pond with random pebbles\n        pond = Circle(radius=2, color=BLUE)\n        pond.set_fill(BLUE, opacity=0.5)\n        pond_label = Text(\"Irregular Pond\", font_size=24)\n        pond_label.to_edge(UP)\n        \n        self.play(Create(pond), Write(pond_label))\n        \n        # Add random dots (pebbles)\n        dots = VGroup()\n        inside_dots = VGroup()\n        outside_dots = VGroup()\n        \n        # Use a seed for reproducibility\n        np.random.seed(42)\n        \n        for _ in range(25):\n            x = np.random.uniform(-3, 3)\n            y = np.random.uniform(-3, 3)\n            dot = Dot(point=[x, y, 0], color=YELLOW)\n            dots.add(dot)\n            \n            # Check if dot is inside pond\n            if x**2 + y**2 <= 4:  # radius squared\n                inside_dots.add(dot)\n            else:\n                outside_dots.add(dot)\n        \n        self.play(Create(dots, run_time=2))\n        self.wait(0.5)\n        \n        # Highlight dots inside vs outside\n        self.play(\n            inside_dots.animate.set_color(GREEN),\n            outside_dots.animate.set_color(RED)\n        )\n        \n        # Formula for area approximation\n        formula = MathTex(r\"A_{approx} = \\frac{N_{inside}}{N_{total}} \\cdot A_{total}\")\n        formula.to_edge(DOWN)\n        \n        self.play(Write(formula))\n        self.wait(1)\n        \n        self.play(FadeOut(pond), FadeOut(dots), FadeOut(pond_label), FadeOut(formula))\n        \n        # Side-by-side comparison of sampling methods\n        comparison_title = Text(\"Random vs. Quasi-Random\", font_size=28)\n        comparison_title.to_edge(UP)\n        \n        self.play(Write(comparison_title))\n        \n        # Create demonstration squares\n        square_left = Square(side_length=3).shift(LEFT*3)\n        square_right = Square(side_length=3).shift(RIGHT*3)\n        \n        random_label = Text(\"Random\", font_size=20).next_to(square_left, DOWN)\n        quasi_label = Text(\"Quasi-Random\", font_size=20).next_to(square_right, DOWN)\n        \n        self.play(\n            Create(square_left), Create(square_right),\n            Write(random_label), Write(quasi_label)\n        )\n        \n        # Random dots for left square\n        random_dots = VGroup()\n        np.random.seed(42)  # For reproducibility\n        for _ in range(25):\n            x = -3 + np.random.uniform(0, 3)\n            y = np.random.uniform(-1.5, 1.5)\n            dot = Dot(point=[x, y, 0], color=RED)\n            random_dots.add(dot)\n        \n        # Grid-like quasi-random dots for right square\n        quasi_dots = VGroup()\n        for i in range(5):\n            for j in range(5):\n                # Add small random variation to make it look like quasi-random\n                x = 3 - 1.5 + j*0.75 + np.random.uniform(-0.05, 0.05)\n                y = -1.5 + i*0.75 + np.random.uniform(-0.05, 0.05)\n                dot = Dot(point=[x, y, 0], color=GREEN)\n                quasi_dots.add(dot)\n        \n        self.play(Create(random_dots), Create(quasi_dots))\n        self.wait(1)\n        \n        # Highlight the difference in distribution\n        distribution_text = Text(\"More uniform distribution\", font_size=18)\n        distribution_text.next_to(square_right, UP)\n        \n        self.play(Write(distribution_text))\n        self.wait(1)\n        \n        # Error equation\n        error_eq = MathTex(r\"A_{error} \\approx O(\\frac{1}{N})\")\n        error_eq.to_edge(DOWN)\n        \n        self.play(Write(error_eq))\n        self.wait(2)\n        \n        self.play(\n            FadeOut(comparison_title), \n            FadeOut(square_left), FadeOut(square_right),\n            FadeOut(random_label), FadeOut(quasi_label),\n            FadeOut(random_dots), FadeOut(quasi_dots),\n            FadeOut(distribution_text), FadeOut(error_eq)\n        )\n        \n        # Conclusion\n        conclusion = Text(\n            \"Quasi-random sequences provide more uniform coverage,\\n\"\n            \"leading to faster convergence and greater accuracy.\",\n            font_size=24\n        )\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the use of quasi-random sequences in Monte Carlo simulations enhance accuracy over purely random sampling?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the use of quasi-random sequences in monte carlo simulations enhance accuracy over purely random sampling?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MonteCarloQuasiRandomSequences(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Enhancing Monte Carlo Simulations\", font_size=32)\n        subtitle = Text(\"with Quasi-Random Sequences\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Visual of pond with random pebbles\n        pond = Circle(radius=2, color=BLUE)\n        pond.set_fill(BLUE, opacity=0.5)\n        pond_label = Text(\"Irregular Pond\", font_size=24)\n        pond_label.to_edge(UP)\n        \n        self.play(Create(pond), Write(pond_label))\n        \n        # Add random dots (pebbles)\n        dots = VGroup()\n        inside_dots = VGroup()\n        outside_dots = VGroup()\n        \n        # Use a seed for reproducibility\n        np.random.seed(42)\n        \n        for _ in range(25):\n            x = np.random.uniform(-3, 3)\n            y = np.random.uniform(-3, 3)\n            dot = Dot(point=[x, y, 0], color=YELLOW)\n            dots.add(dot)\n            \n            # Check if dot is inside pond\n            if x**2 + y**2 <= 4:  # radius squared\n                inside_dots.add(dot)\n            else:\n                outside_dots.add(dot)\n        \n        self.play(Create(dots, run_time=2))\n        self.wait(0.5)\n        \n        # Highlight dots inside vs outside\n        self.play(\n            inside_dots.animate.set_color(GREEN),\n            outside_dots.animate.set_color(RED)\n        )\n        \n        # Formula for area approximation\n        formula = MathTex(r\"A_{approx} = \\frac{N_{inside}}{N_{total}} \\cdot A_{total}\")\n        formula.to_edge(DOWN)\n        \n        self.play(Write(formula))\n        self.wait(1)\n        \n        self.play(FadeOut(pond), FadeOut(dots), FadeOut(pond_label), FadeOut(formula))\n        \n        # Side-by-side comparison of sampling methods\n        comparison_title = Text(\"Random vs. Quasi-Random\", font_size=28)\n        comparison_title.to_edge(UP)\n        \n        self.play(Write(comparison_title))\n        \n        # Create demonstration squares\n        square_left = Square(side_length=3).shift(LEFT*3)\n        square_right = Square(side_length=3).shift(RIGHT*3)\n        \n        random_label = Text(\"Random\", font_size=20).next_to(square_left, DOWN)\n        quasi_label = Text(\"Quasi-Random\", font_size=20).next_to(square_right, DOWN)\n        \n        self.play(\n            Create(square_left), Create(square_right),\n            Write(random_label), Write(quasi_label)\n        )\n        \n        # Random dots for left square\n        random_dots = VGroup()\n        np.random.seed(42)  # For reproducibility\n        for _ in range(25):\n            x = -3 + np.random.uniform(0, 3)\n            y = np.random.uniform(-1.5, 1.5)\n            dot = Dot(point=[x, y, 0], color=RED)\n            random_dots.add(dot)\n        \n        # Grid-like quasi-random dots for right square\n        quasi_dots = VGroup()\n        for i in range(5):\n            for j in range(5):\n                # Add small random variation to make it look like quasi-random\n                x = 3 - 1.5 + j*0.75 + np.random.uniform(-0.05, 0.05)\n                y = -1.5 + i*0.75 + np.random.uniform(-0.05, 0.05)\n                dot = Dot(point=[x, y, 0], color=GREEN)\n                quasi_dots.add(dot)\n        \n        self.play(Create(random_dots), Create(quasi_dots))\n        self.wait(1)\n        \n        # Highlight the difference in distribution\n        distribution_text = Text(\"More uniform distribution\", font_size=18)\n        distribution_text.next_to(square_right, UP)\n        \n        self.play(Write(distribution_text))\n        self.wait(1)\n        \n        # Error equation\n        error_eq = MathTex(r\"A_{error} \\approx O(\\frac{1}{N})\")\n        error_eq.to_edge(DOWN)\n        \n        self.play(Write(error_eq))\n        self.wait(2)\n        \n        self.play(\n            FadeOut(comparison_title), \n            FadeOut(square_left), FadeOut(square_right),\n            FadeOut(random_label), FadeOut(quasi_label),\n            FadeOut(random_dots), FadeOut(quasi_dots),\n            FadeOut(distribution_text), FadeOut(error_eq)\n        )\n        \n        # Conclusion\n        conclusion = Text(\n            \"Quasi-random sequences provide more uniform coverage,\\n\"\n            \"leading to faster convergence and greater accuracy.\",\n            font_size=24\n        )\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the use of quasi-random sequences in Monte Carlo simulations enhance accuracy over purely random sampling?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four identical squares arranged in a horizontal row with equal spacing between them, all centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Example(Scene):\n    def construct(self):\n        s1 = Square()\n        s2 = Square()\n        s3 = Square()\n        s4 = Square()\n        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n        self.add(x)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four identical squares arranged in a horizontal row with equal spacing between them, all centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four identical squares arranged in a horizontal row with equal spacing between them, all centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Example(Scene):\n    def construct(self):\n        s1 = Square()\n        s2 = Square()\n        s3 = Square()\n        s4 = Square()\n        x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n        self.add(x)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four identical squares arranged in a horizontal row with equal spacing between them, all centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Is it possible to characterize the entire class of graphs that can be homomorphically mapped into a given target graph? If so, how?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphHomomorphism(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Mapping Graphs: Unveiling Homomorphisms\", font_size=36)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction to graph homomorphisms\n        intro_text = Text(\"A graph homomorphism maps one graph to another\\nwhile preserving connections\", \n                          font_size=28)\n        self.play(FadeIn(intro_text))\n        self.wait(2)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple source graph G\n        g_label = Text(\"Graph G\", font_size=24)\n        g_label.to_edge(LEFT).shift(UP * 2)\n        \n        # Create nodes for G\n        g_nodes = []\n        g_positions = [[-4, 0, 0], [-3, 1, 0], [-3, -1, 0], [-2, 0, 0]]\n        for i, pos in enumerate(g_positions):\n            node = Circle(radius=0.3, color=BLUE).move_to(pos)\n            node_label = Text(str(i+1), font_size=18).move_to(pos)\n            g_nodes.append(VGroup(node, node_label))\n        \n        g_graph = VGroup(*g_nodes)\n        \n        # Create edges for G\n        g_edges = []\n        edge_pairs = [(0, 1), (0, 2), (1, 3), (2, 3)]\n        for u, v in edge_pairs:\n            edge = Line(g_positions[u], g_positions[v], color=BLUE)\n            g_edges.append(edge)\n        \n        g_edges_group = VGroup(*g_edges)\n        \n        # Create a target graph H\n        h_label = Text(\"Graph H\", font_size=24)\n        h_label.to_edge(RIGHT).shift(UP * 2)\n        \n        # Create nodes for H\n        h_nodes = []\n        h_positions = [[2, 0, 0], [4, 0, 0]]\n        for i, pos in enumerate(h_positions):\n            node = Circle(radius=0.3, color=GREEN).move_to(pos)\n            node_label = Text(chr(65+i), font_size=18).move_to(pos)\n            h_nodes.append(VGroup(node, node_label))\n        \n        h_graph = VGroup(*h_nodes)\n        \n        # Create edge for H\n        h_edge = Line(h_positions[0], h_positions[1], color=GREEN)\n        \n        # Animate the graphs\n        self.play(\n            FadeIn(g_label),\n            Create(g_graph),\n            Create(g_edges_group)\n        )\n        self.wait()\n        \n        self.play(\n            FadeIn(h_label),\n            Create(h_graph),\n            Create(h_edge)\n        )\n        self.wait()\n        \n        # Homomorphism definition\n        hom_def = Text(\"f: V(G) \u2192 V(H) such that if {u,v} in E(G),\\nthen {f(u),f(v)} in E(H)\", font_size=24)\n        hom_def.next_to(title, DOWN, buff=0.5)\n        self.play(Write(hom_def))\n        self.wait(2)\n        \n        # Animate the homomorphism mapping\n        mapping_text = Text(\"Mapping example:\", font_size=24).to_edge(DOWN, buff=1)\n        self.play(FadeIn(mapping_text))\n        \n        # Define the mapping\n        arrows = []\n        mappings = [(0, 0), (1, 0), (2, 1), (3, 1)]  # (g_node_index, h_node_index)\n        \n        for g_idx, h_idx in mappings:\n            arrow = Arrow(\n                g_positions[g_idx] + RIGHT * 0.5,\n                h_positions[h_idx] + LEFT * 0.5,\n                color=YELLOW,\n                buff=0.1\n            )\n            arrows.append(arrow)\n        \n        arrows_group = VGroup(*arrows)\n        \n        for arrow in arrows:\n            self.play(Create(arrow), run_time=0.5)\n        self.wait()\n        \n        # Properties preservation\n        self.play(FadeOut(mapping_text))\n        \n        property_text = Text(\"Key Properties:\", font_size=28)\n        property_text.next_to(hom_def, DOWN, buff=0.5)\n        self.play(FadeIn(property_text))\n        \n        chromatic_property = Text(\"\u03c7(G) \u2264 \u03c7(H)\", font_size=24)\n        chromatic_property.next_to(property_text, DOWN, buff=0.3)\n        self.play(Write(chromatic_property))\n        self.wait()\n        \n        cycle_property = Text(\"Cycles in G map to cycles in H\", font_size=24)\n        cycle_property.next_to(chromatic_property, DOWN, buff=0.3)\n        self.play(Write(cycle_property))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"Characterizing graphs that map to a target\\ndepends on these core properties\", \n                         font_size=28)\n        conclusion.to_edge(DOWN, buff=1)\n        self.play(FadeIn(conclusion))\n        self.wait(2)\n        \n        final_text = Text(\"Where mathematics and art unite,\\nrevealing endless possibilities\", \n                         font_size=24)\n        \n        # Fade out all elements except title\n        all_elements = VGroup(\n            g_label, g_graph, g_edges_group, \n            h_label, h_graph, h_edge,\n            arrows_group,\n            hom_def, property_text, chromatic_property, \n            cycle_property, conclusion\n        )\n        \n        self.play(\n            FadeOut(all_elements),\n            FadeIn(final_text)\n        )\n        self.wait(3)\n        \n        # Fade everything out\n        self.play(FadeOut(title, final_text))\n        self.wait()\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Is it possible to characterize the entire class of graphs that can be homomorphically mapped into a given target graph? If so, how?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: is it possible to characterize the entire class of graphs that can be homomorphically mapped into a given target graph? if so, how?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphHomomorphism(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Mapping Graphs: Unveiling Homomorphisms\", font_size=36)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction to graph homomorphisms\n        intro_text = Text(\"A graph homomorphism maps one graph to another\\nwhile preserving connections\", \n                          font_size=28)\n        self.play(FadeIn(intro_text))\n        self.wait(2)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple source graph G\n        g_label = Text(\"Graph G\", font_size=24)\n        g_label.to_edge(LEFT).shift(UP * 2)\n        \n        # Create nodes for G\n        g_nodes = []\n        g_positions = [[-4, 0, 0], [-3, 1, 0], [-3, -1, 0], [-2, 0, 0]]\n        for i, pos in enumerate(g_positions):\n            node = Circle(radius=0.3, color=BLUE).move_to(pos)\n            node_label = Text(str(i+1), font_size=18).move_to(pos)\n            g_nodes.append(VGroup(node, node_label))\n        \n        g_graph = VGroup(*g_nodes)\n        \n        # Create edges for G\n        g_edges = []\n        edge_pairs = [(0, 1), (0, 2), (1, 3), (2, 3)]\n        for u, v in edge_pairs:\n            edge = Line(g_positions[u], g_positions[v], color=BLUE)\n            g_edges.append(edge)\n        \n        g_edges_group = VGroup(*g_edges)\n        \n        # Create a target graph H\n        h_label = Text(\"Graph H\", font_size=24)\n        h_label.to_edge(RIGHT).shift(UP * 2)\n        \n        # Create nodes for H\n        h_nodes = []\n        h_positions = [[2, 0, 0], [4, 0, 0]]\n        for i, pos in enumerate(h_positions):\n            node = Circle(radius=0.3, color=GREEN).move_to(pos)\n            node_label = Text(chr(65+i), font_size=18).move_to(pos)\n            h_nodes.append(VGroup(node, node_label))\n        \n        h_graph = VGroup(*h_nodes)\n        \n        # Create edge for H\n        h_edge = Line(h_positions[0], h_positions[1], color=GREEN)\n        \n        # Animate the graphs\n        self.play(\n            FadeIn(g_label),\n            Create(g_graph),\n            Create(g_edges_group)\n        )\n        self.wait()\n        \n        self.play(\n            FadeIn(h_label),\n            Create(h_graph),\n            Create(h_edge)\n        )\n        self.wait()\n        \n        # Homomorphism definition\n        hom_def = Text(\"f: V(G) \u2192 V(H) such that if {u,v} in E(G),\\nthen {f(u),f(v)} in E(H)\", font_size=24)\n        hom_def.next_to(title, DOWN, buff=0.5)\n        self.play(Write(hom_def))\n        self.wait(2)\n        \n        # Animate the homomorphism mapping\n        mapping_text = Text(\"Mapping example:\", font_size=24).to_edge(DOWN, buff=1)\n        self.play(FadeIn(mapping_text))\n        \n        # Define the mapping\n        arrows = []\n        mappings = [(0, 0), (1, 0), (2, 1), (3, 1)]  # (g_node_index, h_node_index)\n        \n        for g_idx, h_idx in mappings:\n            arrow = Arrow(\n                g_positions[g_idx] + RIGHT * 0.5,\n                h_positions[h_idx] + LEFT * 0.5,\n                color=YELLOW,\n                buff=0.1\n            )\n            arrows.append(arrow)\n        \n        arrows_group = VGroup(*arrows)\n        \n        for arrow in arrows:\n            self.play(Create(arrow), run_time=0.5)\n        self.wait()\n        \n        # Properties preservation\n        self.play(FadeOut(mapping_text))\n        \n        property_text = Text(\"Key Properties:\", font_size=28)\n        property_text.next_to(hom_def, DOWN, buff=0.5)\n        self.play(FadeIn(property_text))\n        \n        chromatic_property = Text(\"\u03c7(G) \u2264 \u03c7(H)\", font_size=24)\n        chromatic_property.next_to(property_text, DOWN, buff=0.3)\n        self.play(Write(chromatic_property))\n        self.wait()\n        \n        cycle_property = Text(\"Cycles in G map to cycles in H\", font_size=24)\n        cycle_property.next_to(chromatic_property, DOWN, buff=0.3)\n        self.play(Write(cycle_property))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"Characterizing graphs that map to a target\\ndepends on these core properties\", \n                         font_size=28)\n        conclusion.to_edge(DOWN, buff=1)\n        self.play(FadeIn(conclusion))\n        self.wait(2)\n        \n        final_text = Text(\"Where mathematics and art unite,\\nrevealing endless possibilities\", \n                         font_size=24)\n        \n        # Fade out all elements except title\n        all_elements = VGroup(\n            g_label, g_graph, g_edges_group, \n            h_label, h_graph, h_edge,\n            arrows_group,\n            hom_def, property_text, chromatic_property, \n            cycle_property, conclusion\n        )\n        \n        self.play(\n            FadeOut(all_elements),\n            FadeIn(final_text)\n        )\n        self.wait(3)\n        \n        # Fade everything out\n        self.play(FadeOut(title, final_text))\n        self.wait()\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Is it possible to characterize the entire class of graphs that can be homomorphically mapped into a given target graph? If so, how?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can we use animated graphs to depict the dynamic process of finding maximal cliques in a changing friendship network?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CliqueAnimation(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling Maximal Cliques: The Social Network Puzzle\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"Imagine a party with people making friends\", font_size=20)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create nodes (people)\n        nodes = VGroup()\n        for i in range(5):\n            angle = i * 2 * PI / 5\n            node = Circle(radius=0.3, color=BLUE, fill_opacity=0.8)\n            node.move_to([2 * np.cos(angle), 2 * np.sin(angle), 0])\n            nodes.add(node)\n        \n        # Add simple labels\n        labels = VGroup()\n        for i, node in enumerate(nodes):\n            label = Text(f\"{i+1}\", font_size=20).move_to(node.get_center())\n            labels.add(label)\n        \n        # Show nodes (people)\n        self.play(Create(nodes), Write(labels))\n        \n        # Key Concept 1: Initial network\n        concept1 = Text(\"A network of individuals with friendship connections\", font_size=20)\n        concept1.to_edge(UP)\n        self.play(Write(concept1))\n        \n        # Create initial connections\n        edges = VGroup()\n        for i in range(5):\n            next_i = (i + 1) % 5\n            edge = Line(nodes[i].get_center(), nodes[next_i].get_center(), color=GREEN)\n            edges.add(edge)\n        \n        self.play(Create(edges))\n        self.wait(1)\n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2: Form a clique\n        concept2 = Text(\"As people become acquainted, more connections form\", font_size=20)\n        concept2.to_edge(UP)\n        self.play(Write(concept2))\n        \n        # Add a diagonal to form a triangle (clique of 3)\n        clique_edge = Line(nodes[0].get_center(), nodes[2].get_center(), color=YELLOW)\n        self.play(Create(clique_edge))\n        \n        # Highlight the clique\n        self.play(nodes[0].animate.set_color(YELLOW), \n                  nodes[1].animate.set_color(YELLOW), \n                  nodes[2].animate.set_color(YELLOW))\n        \n        clique_text = Text(\"Maximal Clique\", font_size=18, color=YELLOW)\n        clique_text.next_to(nodes[1], UP)\n        self.play(Write(clique_text))\n        \n        self.wait(1)\n        self.play(FadeOut(concept2), FadeOut(clique_text))\n        \n        # Key Concept 3: Changing friendships\n        concept3 = Text(\"But friendships can fade, changing the clique structure\", font_size=20)\n        concept3.to_edge(UP)\n        self.play(Write(concept3))\n        \n        # Reset node colors\n        self.play(nodes.animate.set_color(BLUE))\n        \n        # Remove an edge (friendship dissolves)\n        self.play(FadeOut(edges[1]))\n        \n        # Form a new clique\n        new_edge = Line(nodes[2].get_center(), nodes[4].get_center(), color=RED)\n        self.play(Create(new_edge))\n        \n        # Highlight the new clique\n        self.play(nodes[2].animate.set_color(RED), \n                  nodes[3].animate.set_color(RED), \n                  nodes[4].animate.set_color(RED))\n        \n        new_clique_text = Text(\"New Maximal Clique\", font_size=18, color=RED)\n        new_clique_text.next_to(nodes[3], DOWN)\n        self.play(Write(new_clique_text))\n        \n        self.wait(1)\n        self.play(FadeOut(concept3), FadeOut(new_clique_text))\n        \n        # Key Insight with simple equation\n        insight = Text(\"Visualizing evolving cliques reveals network dynamics\", font_size=20)\n        insight.to_edge(UP)\n        self.play(Write(insight))\n        \n        eq1 = MathTex(r\"K_{n} = \\binom{n}{2}\")\n        eq1.next_to(insight, DOWN, buff=0.5)\n        self.play(Write(eq1))\n        \n        eq2 = MathTex(r\"\\Delta(G) \\leq \\frac{n}{2}\")\n        eq2.next_to(eq1, DOWN, buff=0.5)\n        self.play(Write(eq2))\n        \n        self.wait(1)\n        self.play(FadeOut(insight), FadeOut(eq1), FadeOut(eq2))\n        \n        # Conclusion\n        conclusion = Text(\"Your circle of friends might be a fascinating mathematical model\", font_size=20)\n        conclusion.to_edge(UP)\n        self.play(Write(conclusion))\n        \n        final_title = Text(\"The Social Network Puzzle\", font_size=24)\n        final_title.to_edge(DOWN)\n        self.play(Write(final_title))\n        \n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            FadeOut(nodes), FadeOut(labels), FadeOut(edges), \n            FadeOut(clique_edge), FadeOut(new_edge),\n            FadeOut(conclusion), FadeOut(final_title)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we use animated graphs to depict the dynamic process of finding maximal cliques in a changing friendship network?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can we use animated graphs to depict the dynamic process of finding maximal cliques in a changing friendship network?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CliqueAnimation(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling Maximal Cliques: The Social Network Puzzle\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"Imagine a party with people making friends\", font_size=20)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create nodes (people)\n        nodes = VGroup()\n        for i in range(5):\n            angle = i * 2 * PI / 5\n            node = Circle(radius=0.3, color=BLUE, fill_opacity=0.8)\n            node.move_to([2 * np.cos(angle), 2 * np.sin(angle), 0])\n            nodes.add(node)\n        \n        # Add simple labels\n        labels = VGroup()\n        for i, node in enumerate(nodes):\n            label = Text(f\"{i+1}\", font_size=20).move_to(node.get_center())\n            labels.add(label)\n        \n        # Show nodes (people)\n        self.play(Create(nodes), Write(labels))\n        \n        # Key Concept 1: Initial network\n        concept1 = Text(\"A network of individuals with friendship connections\", font_size=20)\n        concept1.to_edge(UP)\n        self.play(Write(concept1))\n        \n        # Create initial connections\n        edges = VGroup()\n        for i in range(5):\n            next_i = (i + 1) % 5\n            edge = Line(nodes[i].get_center(), nodes[next_i].get_center(), color=GREEN)\n            edges.add(edge)\n        \n        self.play(Create(edges))\n        self.wait(1)\n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2: Form a clique\n        concept2 = Text(\"As people become acquainted, more connections form\", font_size=20)\n        concept2.to_edge(UP)\n        self.play(Write(concept2))\n        \n        # Add a diagonal to form a triangle (clique of 3)\n        clique_edge = Line(nodes[0].get_center(), nodes[2].get_center(), color=YELLOW)\n        self.play(Create(clique_edge))\n        \n        # Highlight the clique\n        self.play(nodes[0].animate.set_color(YELLOW), \n                  nodes[1].animate.set_color(YELLOW), \n                  nodes[2].animate.set_color(YELLOW))\n        \n        clique_text = Text(\"Maximal Clique\", font_size=18, color=YELLOW)\n        clique_text.next_to(nodes[1], UP)\n        self.play(Write(clique_text))\n        \n        self.wait(1)\n        self.play(FadeOut(concept2), FadeOut(clique_text))\n        \n        # Key Concept 3: Changing friendships\n        concept3 = Text(\"But friendships can fade, changing the clique structure\", font_size=20)\n        concept3.to_edge(UP)\n        self.play(Write(concept3))\n        \n        # Reset node colors\n        self.play(nodes.animate.set_color(BLUE))\n        \n        # Remove an edge (friendship dissolves)\n        self.play(FadeOut(edges[1]))\n        \n        # Form a new clique\n        new_edge = Line(nodes[2].get_center(), nodes[4].get_center(), color=RED)\n        self.play(Create(new_edge))\n        \n        # Highlight the new clique\n        self.play(nodes[2].animate.set_color(RED), \n                  nodes[3].animate.set_color(RED), \n                  nodes[4].animate.set_color(RED))\n        \n        new_clique_text = Text(\"New Maximal Clique\", font_size=18, color=RED)\n        new_clique_text.next_to(nodes[3], DOWN)\n        self.play(Write(new_clique_text))\n        \n        self.wait(1)\n        self.play(FadeOut(concept3), FadeOut(new_clique_text))\n        \n        # Key Insight with simple equation\n        insight = Text(\"Visualizing evolving cliques reveals network dynamics\", font_size=20)\n        insight.to_edge(UP)\n        self.play(Write(insight))\n        \n        eq1 = MathTex(r\"K_{n} = \\binom{n}{2}\")\n        eq1.next_to(insight, DOWN, buff=0.5)\n        self.play(Write(eq1))\n        \n        eq2 = MathTex(r\"\\Delta(G) \\leq \\frac{n}{2}\")\n        eq2.next_to(eq1, DOWN, buff=0.5)\n        self.play(Write(eq2))\n        \n        self.wait(1)\n        self.play(FadeOut(insight), FadeOut(eq1), FadeOut(eq2))\n        \n        # Conclusion\n        conclusion = Text(\"Your circle of friends might be a fascinating mathematical model\", font_size=20)\n        conclusion.to_edge(UP)\n        self.play(Write(conclusion))\n        \n        final_title = Text(\"The Social Network Puzzle\", font_size=24)\n        final_title.to_edge(DOWN)\n        self.play(Write(final_title))\n        \n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            FadeOut(nodes), FadeOut(labels), FadeOut(edges), \n            FadeOut(clique_edge), FadeOut(new_edge),\n            FadeOut(conclusion), FadeOut(final_title)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we use animated graphs to depict the dynamic process of finding maximal cliques in a changing friendship network?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do holomorphic 1-forms facilitate the classification of Riemann surfaces?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HolomorphicFormsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Surfing the Waves of Holomorphic Forms\", color=BLUE_D)\n        title.scale(0.8)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction to Riemann surfaces\n        intro = Text(\"Riemann surfaces are complex manifolds\", color=BLUE)\n        intro.scale(0.6).next_to(title, DOWN, buff=0.5)\n        self.play(FadeIn(intro))\n        self.wait(1)\n        \n        # Represent a Riemann surface with a simple circle\n        surface = Circle(radius=1.5, color=PURPLE).move_to(ORIGIN)\n        surface_label = Text(\"Riemann Surface\", color=PURPLE).scale(0.5).next_to(surface, UP, buff=0.2)\n        \n        self.play(Create(surface), Write(surface_label))\n        self.wait(1)\n        \n        # Remove the introduction text\n        self.play(FadeOut(intro))\n        \n        # Explain holomorphic 1-forms\n        form_text = Text(\"Holomorphic 1-forms are like waves on the surface\", color=PURPLE_A)\n        form_text.scale(0.6).next_to(title, DOWN, buff=0.5)\n        self.play(Write(form_text))\n        self.wait(1)\n        \n        # Show the formula for a holomorphic 1-form\n        omega_eq = MathTex(r\"\\omega = f(z)\\,dz\", color=WHITE)\n        omega_eq.next_to(form_text, DOWN, buff=0.5)\n        self.play(Write(omega_eq))\n        self.wait(1)\n        \n        # Illustrate a zero of the form\n        zero_point = Dot(color=RED).move_to(surface.get_center() + LEFT*0.5)\n        zero_label = Text(\"Zero\", color=RED).scale(0.4).next_to(zero_point, DOWN, buff=0.1)\n        \n        self.play(Create(zero_point), Write(zero_label))\n        self.wait(1)\n        \n        # Show an integration loop\n        loop = Circle(radius=0.7, color=GREEN_B).move_to(surface.get_center())\n        loop_label = Text(\"Loop\", color=GREEN_B).scale(0.4).next_to(loop, RIGHT, buff=0.2)\n        \n        self.play(Create(loop), Write(loop_label))\n        self.wait(1)\n        \n        # Show the period formula (simplified to avoid LaTeX issues)\n        period_eq = MathTex(r\"\\oint_C \\omega = 2\\pi i \\sum\", color=WHITE)\n        period_eq.next_to(omega_eq, DOWN, buff=0.5)\n        self.play(Write(period_eq))\n        self.wait(1)\n        \n        # Classification explanation\n        self.play(\n            FadeOut(form_text), FadeOut(omega_eq), FadeOut(period_eq),\n            FadeOut(zero_point), FadeOut(zero_label), FadeOut(loop), FadeOut(loop_label)\n        )\n        \n        classify_text = Text(\"Holomorphic forms help classify Riemann surfaces by genus\", color=YELLOW)\n        classify_text.scale(0.5).next_to(title, DOWN, buff=0.5)\n        \n        self.play(Write(classify_text))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The topology is revealed through zeros and periods\", color=BLUE)\n        conclusion.scale(0.5).next_to(classify_text, DOWN, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fadeout\n        self.play(\n            FadeOut(title), FadeOut(surface), FadeOut(surface_label),\n            FadeOut(classify_text), FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do holomorphic 1-forms facilitate the classification of Riemann surfaces?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do holomorphic 1-forms facilitate the classification of riemann surfaces?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HolomorphicFormsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Surfing the Waves of Holomorphic Forms\", color=BLUE_D)\n        title.scale(0.8)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction to Riemann surfaces\n        intro = Text(\"Riemann surfaces are complex manifolds\", color=BLUE)\n        intro.scale(0.6).next_to(title, DOWN, buff=0.5)\n        self.play(FadeIn(intro))\n        self.wait(1)\n        \n        # Represent a Riemann surface with a simple circle\n        surface = Circle(radius=1.5, color=PURPLE).move_to(ORIGIN)\n        surface_label = Text(\"Riemann Surface\", color=PURPLE).scale(0.5).next_to(surface, UP, buff=0.2)\n        \n        self.play(Create(surface), Write(surface_label))\n        self.wait(1)\n        \n        # Remove the introduction text\n        self.play(FadeOut(intro))\n        \n        # Explain holomorphic 1-forms\n        form_text = Text(\"Holomorphic 1-forms are like waves on the surface\", color=PURPLE_A)\n        form_text.scale(0.6).next_to(title, DOWN, buff=0.5)\n        self.play(Write(form_text))\n        self.wait(1)\n        \n        # Show the formula for a holomorphic 1-form\n        omega_eq = MathTex(r\"\\omega = f(z)\\,dz\", color=WHITE)\n        omega_eq.next_to(form_text, DOWN, buff=0.5)\n        self.play(Write(omega_eq))\n        self.wait(1)\n        \n        # Illustrate a zero of the form\n        zero_point = Dot(color=RED).move_to(surface.get_center() + LEFT*0.5)\n        zero_label = Text(\"Zero\", color=RED).scale(0.4).next_to(zero_point, DOWN, buff=0.1)\n        \n        self.play(Create(zero_point), Write(zero_label))\n        self.wait(1)\n        \n        # Show an integration loop\n        loop = Circle(radius=0.7, color=GREEN_B).move_to(surface.get_center())\n        loop_label = Text(\"Loop\", color=GREEN_B).scale(0.4).next_to(loop, RIGHT, buff=0.2)\n        \n        self.play(Create(loop), Write(loop_label))\n        self.wait(1)\n        \n        # Show the period formula (simplified to avoid LaTeX issues)\n        period_eq = MathTex(r\"\\oint_C \\omega = 2\\pi i \\sum\", color=WHITE)\n        period_eq.next_to(omega_eq, DOWN, buff=0.5)\n        self.play(Write(period_eq))\n        self.wait(1)\n        \n        # Classification explanation\n        self.play(\n            FadeOut(form_text), FadeOut(omega_eq), FadeOut(period_eq),\n            FadeOut(zero_point), FadeOut(zero_label), FadeOut(loop), FadeOut(loop_label)\n        )\n        \n        classify_text = Text(\"Holomorphic forms help classify Riemann surfaces by genus\", color=YELLOW)\n        classify_text.scale(0.5).next_to(title, DOWN, buff=0.5)\n        \n        self.play(Write(classify_text))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The topology is revealed through zeros and periods\", color=BLUE)\n        conclusion.scale(0.5).next_to(classify_text, DOWN, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fadeout\n        self.play(\n            FadeOut(title), FadeOut(surface), FadeOut(surface_label),\n            FadeOut(classify_text), FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do holomorphic 1-forms facilitate the classification of Riemann surfaces?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Under what conditions does fictitious play fail to reach a consistent strategy profile in a non-zero-sum game?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FictitiousPlayAnimation(Scene):\n    def construct(self):\n        # Set a more vibrant background color\n        self.camera.background_color = \"#1A1A2E\"\n        \n        # Introduction\n        title = Text(\"The Dance of Strategy: Fictitious Play\", font_size=32, color=BLUE_B)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Key Concept 1: Fictitious Play Explanation\n        concept1 = Text(\"Fictitious Play\", font_size=28, color=YELLOW).next_to(title, DOWN)\n        self.play(Write(concept1))\n        \n        # Players and game board with more vibrant colors\n        player1 = Circle(radius=0.3, color=GREEN_C).shift(LEFT*2 + DOWN)\n        player2 = Circle(radius=0.3, color=ORANGE).shift(RIGHT*2 + DOWN)\n        player1_label = Text(\"P1\", font_size=18, color=GREEN_C).next_to(player1, DOWN)\n        player2_label = Text(\"P2\", font_size=18, color=ORANGE).next_to(player2, DOWN)\n        game_board = Square(side_length=3, color=BLUE_D).set_opacity(0.3).shift(DOWN)\n        \n        self.play(\n            Create(player1), \n            Create(player2),\n            Create(game_board),\n            Write(player1_label),\n            Write(player2_label)\n        )\n        \n        # Strategy averaging equation\n        strategy_eq = MathTex(\n            r\"\\text{AverageStrategy}_i(t) = \\frac{1}{t} \\sum_{s=1}^{t} S_i(s)\",\n            font_size=24\n        ).to_edge(DOWN, buff=1.2)\n        \n        self.play(Write(strategy_eq))\n        self.wait(1)\n        \n        # Clear for next concept\n        self.play(\n            FadeOut(concept1),\n            FadeOut(player1), \n            FadeOut(player2), \n            FadeOut(player1_label),\n            FadeOut(player2_label),\n            FadeOut(game_board),\n            FadeOut(strategy_eq)\n        )\n        \n        # Key Concept 2: Convergence in some games\n        concept2 = Text(\"Convergence in Zero-Sum Games\", font_size=24, color=GREEN_B).next_to(title, DOWN)\n        self.play(Write(concept2))\n        \n        # Simple convergence visualization\n        arrow = Arrow(start=UP+LEFT*2, end=DOWN+RIGHT*2, color=GREEN_C)\n        end_dot = Dot(DOWN+RIGHT*2, color=BLUE_B)\n        \n        self.play(Create(arrow))\n        self.play(Create(end_dot))\n        self.wait(1)\n        \n        # Clear for next concept\n        self.play(\n            FadeOut(concept2),\n            FadeOut(arrow),\n            FadeOut(end_dot)\n        )\n        \n        # Key Concept 3: Cyclical responses\n        concept3 = Text(\"Cyclical Responses in Non-Zero-Sum Games\", font_size=24, color=RED_B).next_to(title, DOWN)\n        self.play(Write(concept3))\n        \n        # Best response equation\n        response_eq = MathTex(\n            r\"\\text{BestResponse}_i(\\bar{S}_{-i})\",\n            font_size=24\n        ).to_edge(DOWN, buff=1.2)\n        \n        self.play(Write(response_eq))\n        \n        # Simple cycle visualization\n        cycle = Circle(radius=1.2, color=RED_C).shift(DOWN*0.2)\n        dots = VGroup(*[\n            Dot(cycle.point_at_angle(angle), color=YELLOW) \n            for angle in [0, PI/2, PI, 3*PI/2]\n        ])\n        \n        self.play(Create(cycle))\n        self.play(Create(dots))\n        self.wait(1)\n        \n        # Key Insight\n        insight = Text(\"Strategies may never reach equilibrium\", font_size=20, color=YELLOW)\n        insight.next_to(cycle, DOWN, buff=0.8)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(concept3),\n            FadeOut(response_eq),\n            FadeOut(cycle),\n            FadeOut(dots),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"Some games remain perpetually dynamic\", font_size=24, color=TEAL_B).next_to(title, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(title),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Under what conditions does fictitious play fail to reach a consistent strategy profile in a non-zero-sum game?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: under what conditions does fictitious play fail to reach a consistent strategy profile in a non-zero-sum game?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FictitiousPlayAnimation(Scene):\n    def construct(self):\n        # Set a more vibrant background color\n        self.camera.background_color = \"#1A1A2E\"\n        \n        # Introduction\n        title = Text(\"The Dance of Strategy: Fictitious Play\", font_size=32, color=BLUE_B)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Key Concept 1: Fictitious Play Explanation\n        concept1 = Text(\"Fictitious Play\", font_size=28, color=YELLOW).next_to(title, DOWN)\n        self.play(Write(concept1))\n        \n        # Players and game board with more vibrant colors\n        player1 = Circle(radius=0.3, color=GREEN_C).shift(LEFT*2 + DOWN)\n        player2 = Circle(radius=0.3, color=ORANGE).shift(RIGHT*2 + DOWN)\n        player1_label = Text(\"P1\", font_size=18, color=GREEN_C).next_to(player1, DOWN)\n        player2_label = Text(\"P2\", font_size=18, color=ORANGE).next_to(player2, DOWN)\n        game_board = Square(side_length=3, color=BLUE_D).set_opacity(0.3).shift(DOWN)\n        \n        self.play(\n            Create(player1), \n            Create(player2),\n            Create(game_board),\n            Write(player1_label),\n            Write(player2_label)\n        )\n        \n        # Strategy averaging equation\n        strategy_eq = MathTex(\n            r\"\\text{AverageStrategy}_i(t) = \\frac{1}{t} \\sum_{s=1}^{t} S_i(s)\",\n            font_size=24\n        ).to_edge(DOWN, buff=1.2)\n        \n        self.play(Write(strategy_eq))\n        self.wait(1)\n        \n        # Clear for next concept\n        self.play(\n            FadeOut(concept1),\n            FadeOut(player1), \n            FadeOut(player2), \n            FadeOut(player1_label),\n            FadeOut(player2_label),\n            FadeOut(game_board),\n            FadeOut(strategy_eq)\n        )\n        \n        # Key Concept 2: Convergence in some games\n        concept2 = Text(\"Convergence in Zero-Sum Games\", font_size=24, color=GREEN_B).next_to(title, DOWN)\n        self.play(Write(concept2))\n        \n        # Simple convergence visualization\n        arrow = Arrow(start=UP+LEFT*2, end=DOWN+RIGHT*2, color=GREEN_C)\n        end_dot = Dot(DOWN+RIGHT*2, color=BLUE_B)\n        \n        self.play(Create(arrow))\n        self.play(Create(end_dot))\n        self.wait(1)\n        \n        # Clear for next concept\n        self.play(\n            FadeOut(concept2),\n            FadeOut(arrow),\n            FadeOut(end_dot)\n        )\n        \n        # Key Concept 3: Cyclical responses\n        concept3 = Text(\"Cyclical Responses in Non-Zero-Sum Games\", font_size=24, color=RED_B).next_to(title, DOWN)\n        self.play(Write(concept3))\n        \n        # Best response equation\n        response_eq = MathTex(\n            r\"\\text{BestResponse}_i(\\bar{S}_{-i})\",\n            font_size=24\n        ).to_edge(DOWN, buff=1.2)\n        \n        self.play(Write(response_eq))\n        \n        # Simple cycle visualization\n        cycle = Circle(radius=1.2, color=RED_C).shift(DOWN*0.2)\n        dots = VGroup(*[\n            Dot(cycle.point_at_angle(angle), color=YELLOW) \n            for angle in [0, PI/2, PI, 3*PI/2]\n        ])\n        \n        self.play(Create(cycle))\n        self.play(Create(dots))\n        self.wait(1)\n        \n        # Key Insight\n        insight = Text(\"Strategies may never reach equilibrium\", font_size=20, color=YELLOW)\n        insight.next_to(cycle, DOWN, buff=0.8)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(concept3),\n            FadeOut(response_eq),\n            FadeOut(cycle),\n            FadeOut(dots),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"Some games remain perpetually dynamic\", font_size=24, color=TEAL_B).next_to(title, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(title),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Under what conditions does fictitious play fail to reach a consistent strategy profile in a non-zero-sum game?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 2\u00d72 integer matrix:  \n\\[\n\\left(\n\\begin{array}{cc}\n3.7 & 2 \\\\\n42.2 & 12 \\\\\n\\end{array}\n\\right)\n\\]  \nAlthough the matrix is created using `IntegerMatrix`, it includes decimal values like 3.7 and 42.2. The matrix is enclosed in parentheses and appears on screen without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IntegerMatrixExample(Scene):\n    def construct(self):\n        m0 = IntegerMatrix(\n            [[3.7, 2], [42.2, 12]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        self.add(m0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 integer matrix:  \n\\[\n\\left(\n\\begin{array}{cc}\n3.7 & 2 \\\\\n42.2 & 12 \\\\\n\\end{array}\n\\right)\n\\]  \nAlthough the matrix is created using `IntegerMatrix`, it includes decimal values like 3.7 and 42.2. The matrix is enclosed in parentheses and appears on screen without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 2\u00d72 integer matrix:  \n\\[\n\\left(\n\\begin{array}{cc}\n3.7 & 2 \\\\\n42.2 & 12 \\\\\n\\end{array}\n\\right)\n\\]  \nalthough the matrix is created using `integermatrix`, it includes decimal values like 3.7 and 42.2. the matrix is enclosed in parentheses and appears on screen without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IntegerMatrixExample(Scene):\n    def construct(self):\n        m0 = IntegerMatrix(\n            [[3.7, 2], [42.2, 12]],\n            left_bracket=\"(\",\n            right_bracket=\")\")\n        self.add(m0)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 integer matrix:  \n\\[\n\\left(\n\\begin{array}{cc}\n3.7 & 2 \\\\\n42.2 & 12 \\\\\n\\end{array}\n\\right)\n\\]  \nAlthough the matrix is created using `IntegerMatrix`, it includes decimal values like 3.7 and 42.2. The matrix is enclosed in parentheses and appears on screen without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animated math tutorial video that explains how to differentiate the function f(x) = x^2 + 2x + 1 step by step using the power rule and show that the derivative is a linear function?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{1}^{3} 2x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x \\,dx = \\frac{x^{2}}{2} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= 2 \\cdot \\frac{x^{2}}{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the limits\n        evaluated_at_limits = MathTex(r\"= x^{2} \\Big|_1^3\")\n        self.play(ReplacementTransform(solution1, evaluated_at_limits))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 3^{2} - 1^{2}\")\n        self.play(ReplacementTransform(evaluated_at_limits, final_solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9 - 1\")\n        self.play(Write(final_value))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(final_value, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated math tutorial video that explains how to differentiate the function f(x) = x^2 + 2x + 1 step by step using the power rule and show that the derivative is a linear function?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animated math tutorial video that explains how to differentiate the function f(x) = x^2 + 2x + 1 step by step using the power rule and show that the derivative is a linear function?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{1}^{3} 2x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x \\,dx = \\frac{x^{2}}{2} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        solution1 = MathTex(r\"= 2 \\cdot \\frac{x^{2}}{2}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate from 1 to 3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the limits\n        evaluated_at_limits = MathTex(r\"= x^{2} \\Big|_1^3\")\n        self.play(ReplacementTransform(solution1, evaluated_at_limits))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= 3^{2} - 1^{2}\")\n        self.play(ReplacementTransform(evaluated_at_limits, final_solution))\n        self.wait(1)\n\n        final_value = MathTex(r\"= 9 - 1\")\n        self.play(Write(final_value))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(final_value, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated math tutorial video that explains how to differentiate the function f(x) = x^2 + 2x + 1 step by step using the power rule and show that the derivative is a linear function?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display two dots on opposite sides of the screen\u2014one on the far left and one on the far right. They move toward each other simultaneously, crossing paths. During their motion, the speed of the animation dynamically changes: it starts at normal speed, slows down significantly in the middle portion, then returns to normal speed by the end, creating a noticeable slow-motion effect during the center of the movement."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        )\n```"}], "metadata": {"source": "manimbench", "original_description": "Display two dots on opposite sides of the screen\u2014one on the far left and one on the far right. They move toward each other simultaneously, crossing paths. During their motion, the speed of the animation dynamically changes: it starts at normal speed, slows down significantly in the middle portion, then returns to normal speed by the end, creating a noticeable slow-motion effect during the center of the movement."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display two dots on opposite sides of the screen\u2014one on the far left and one on the far right. they move toward each other simultaneously, crossing paths. during their motion, the speed of the animation dynamically changes: it starts at normal speed, slows down significantly in the middle portion, then returns to normal speed by the end, creating a noticeable slow-motion effect during the center of the movement."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpeedModifierExample(Scene):\n    def construct(self):\n        a = Dot().shift(LEFT * 4)\n        b = Dot().shift(RIGHT * 4)\n        self.add(a, b)\n        self.play(\n            ChangeSpeed(\n                AnimationGroup(\n                    a.animate(run_time=1).shift(RIGHT * 8),\n                    b.animate(run_time=1).shift(LEFT * 8),\n                ),\n                speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                rate_func=linear,\n            )\n        )\n```"}], "metadata": {"source": "manimbench", "original_description": "Display two dots on opposite sides of the screen\u2014one on the far left and one on the far right. They move toward each other simultaneously, crossing paths. During their motion, the speed of the animation dynamically changes: it starts at normal speed, slows down significantly in the middle portion, then returns to normal speed by the end, creating a noticeable slow-motion effect during the center of the movement."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does Koebe's Quarter Theorem interact with the notion of extremal mappings in complex analysis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass KoebeQuarterTheoremScene(Scene):\n    def construct(self):\n        # Define colors for a clean, minimalistic style with pastel palette\n        purple = \"#9370DB\"  # Pastel purple\n        blue = \"#87CEEB\"    # Pastel blue\n        \n        # Introduction\n        title = Text(\"Exploring Koebe's Quarter Theorem\", color=purple, font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a complex plane representation\n        grid = NumberPlane(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            background_line_style={\n                \"stroke_color\": blue,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.3\n            }\n        )\n        grid.scale(0.7)  # Make grid a bit smaller\n        self.play(Create(grid))\n        \n        intro_text = Text(\"Complex Analysis and Mappings\", color=purple, font_size=28)\n        intro_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro_text))\n        self.wait(1)\n        \n        # Clear intro text for the first key concept\n        self.play(FadeOut(intro_text))\n        \n        # Key Concept 1: Univalent Functions\n        concept1 = Text(\"Univalent Functions\", color=purple, font_size=28)\n        concept1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept1))\n        \n        # Show a simple transformation\n        circle = Circle(radius=1, color=blue)\n        circle.move_to(LEFT * 2)\n        self.play(Create(circle))\n        \n        # Transform to a stretched shape (keeping uniqueness)\n        ellipse = circle.copy().stretch(2, 0)\n        ellipse.move_to(RIGHT * 2)\n        arrow = Arrow(LEFT, RIGHT, color=purple).move_to(ORIGIN)\n        \n        self.play(Create(arrow))\n        self.play(TransformFromCopy(circle, ellipse))\n        self.wait(1)\n        \n        # Clear for next concept\n        self.play(FadeOut(circle), FadeOut(ellipse), FadeOut(arrow), FadeOut(concept1))\n        \n        # Key Concept 2: Extremal Mappings\n        concept2 = Text(\"Extremal Mappings\", color=purple, font_size=28)\n        concept2.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept2))\n        \n        # Show extremal mapping pushing boundaries\n        orig_shape = Circle(radius=1, color=blue, fill_opacity=0.3)\n        orig_shape.move_to(LEFT * 2)\n        self.play(Create(orig_shape))\n        \n        # Create a stretching effect to show pushing boundaries\n        stretched_shape = orig_shape.copy().stretch(3, 0)\n        stretched_shape.move_to(RIGHT * 2)\n        self.play(TransformFromCopy(orig_shape, stretched_shape))\n        self.wait(1)\n        \n        # Clear for Koebe's Quarter Theorem\n        self.play(FadeOut(orig_shape), FadeOut(stretched_shape), FadeOut(concept2))\n        \n        # Key Concept 3: Koebe's Quarter Theorem\n        concept3 = Text(\"Koebe's Quarter Theorem\", color=purple, font_size=28)\n        concept3.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept3))\n        \n        # Create a unit disk\n        unit_disk = Circle(radius=2, color=blue)\n        unit_disk.move_to(ORIGIN)\n        self.play(Create(unit_disk))\n        \n        # Show quarter disk to illustrate the theorem\n        quarter_disk = Sector(\n            radius=0.5,\n            angle=PI/2,\n            color=purple,\n            fill_opacity=0.5,\n            start_angle=0\n        )\n        quarter_disk.move_to(ORIGIN)\n        \n        self.play(Create(quarter_disk))\n        self.wait(1)\n        \n        # Show the theorem equation\n        theorem_eq = MathTex(r\"F(D_r) \\subseteq D_{\\frac{r}{4}} (0)\", color=purple)\n        theorem_eq.next_to(unit_disk, DOWN, buff=1)\n        self.play(Write(theorem_eq))\n        self.wait(1)\n        \n        # Show Koebe function\n        koebe_eq = MathTex(r\"f(z) = z + \\sum_{n=2}^{\\infty} a_n z^n\", color=purple)\n        koebe_eq.next_to(theorem_eq, DOWN, buff=0.5)\n        self.play(Write(koebe_eq))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(concept3),\n            FadeOut(unit_disk),\n            FadeOut(quarter_disk),\n            FadeOut(theorem_eq),\n            FadeOut(koebe_eq),\n            FadeOut(grid)\n        )\n        \n        conclusion = Text(\"Extremal mappings show the beauty and\\nlimits of complex transformations\", color=purple, font_size=28)\n        conclusion.move_to(ORIGIN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Koebe's Quarter Theorem interact with the notion of extremal mappings in complex analysis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does koebe's quarter theorem interact with the notion of extremal mappings in complex analysis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass KoebeQuarterTheoremScene(Scene):\n    def construct(self):\n        # Define colors for a clean, minimalistic style with pastel palette\n        purple = \"#9370DB\"  # Pastel purple\n        blue = \"#87CEEB\"    # Pastel blue\n        \n        # Introduction\n        title = Text(\"Exploring Koebe's Quarter Theorem\", color=purple, font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a complex plane representation\n        grid = NumberPlane(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            background_line_style={\n                \"stroke_color\": blue,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.3\n            }\n        )\n        grid.scale(0.7)  # Make grid a bit smaller\n        self.play(Create(grid))\n        \n        intro_text = Text(\"Complex Analysis and Mappings\", color=purple, font_size=28)\n        intro_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro_text))\n        self.wait(1)\n        \n        # Clear intro text for the first key concept\n        self.play(FadeOut(intro_text))\n        \n        # Key Concept 1: Univalent Functions\n        concept1 = Text(\"Univalent Functions\", color=purple, font_size=28)\n        concept1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept1))\n        \n        # Show a simple transformation\n        circle = Circle(radius=1, color=blue)\n        circle.move_to(LEFT * 2)\n        self.play(Create(circle))\n        \n        # Transform to a stretched shape (keeping uniqueness)\n        ellipse = circle.copy().stretch(2, 0)\n        ellipse.move_to(RIGHT * 2)\n        arrow = Arrow(LEFT, RIGHT, color=purple).move_to(ORIGIN)\n        \n        self.play(Create(arrow))\n        self.play(TransformFromCopy(circle, ellipse))\n        self.wait(1)\n        \n        # Clear for next concept\n        self.play(FadeOut(circle), FadeOut(ellipse), FadeOut(arrow), FadeOut(concept1))\n        \n        # Key Concept 2: Extremal Mappings\n        concept2 = Text(\"Extremal Mappings\", color=purple, font_size=28)\n        concept2.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept2))\n        \n        # Show extremal mapping pushing boundaries\n        orig_shape = Circle(radius=1, color=blue, fill_opacity=0.3)\n        orig_shape.move_to(LEFT * 2)\n        self.play(Create(orig_shape))\n        \n        # Create a stretching effect to show pushing boundaries\n        stretched_shape = orig_shape.copy().stretch(3, 0)\n        stretched_shape.move_to(RIGHT * 2)\n        self.play(TransformFromCopy(orig_shape, stretched_shape))\n        self.wait(1)\n        \n        # Clear for Koebe's Quarter Theorem\n        self.play(FadeOut(orig_shape), FadeOut(stretched_shape), FadeOut(concept2))\n        \n        # Key Concept 3: Koebe's Quarter Theorem\n        concept3 = Text(\"Koebe's Quarter Theorem\", color=purple, font_size=28)\n        concept3.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept3))\n        \n        # Create a unit disk\n        unit_disk = Circle(radius=2, color=blue)\n        unit_disk.move_to(ORIGIN)\n        self.play(Create(unit_disk))\n        \n        # Show quarter disk to illustrate the theorem\n        quarter_disk = Sector(\n            radius=0.5,\n            angle=PI/2,\n            color=purple,\n            fill_opacity=0.5,\n            start_angle=0\n        )\n        quarter_disk.move_to(ORIGIN)\n        \n        self.play(Create(quarter_disk))\n        self.wait(1)\n        \n        # Show the theorem equation\n        theorem_eq = MathTex(r\"F(D_r) \\subseteq D_{\\frac{r}{4}} (0)\", color=purple)\n        theorem_eq.next_to(unit_disk, DOWN, buff=1)\n        self.play(Write(theorem_eq))\n        self.wait(1)\n        \n        # Show Koebe function\n        koebe_eq = MathTex(r\"f(z) = z + \\sum_{n=2}^{\\infty} a_n z^n\", color=purple)\n        koebe_eq.next_to(theorem_eq, DOWN, buff=0.5)\n        self.play(Write(koebe_eq))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(concept3),\n            FadeOut(unit_disk),\n            FadeOut(quarter_disk),\n            FadeOut(theorem_eq),\n            FadeOut(koebe_eq),\n            FadeOut(grid)\n        )\n        \n        conclusion = Text(\"Extremal mappings show the beauty and\\nlimits of complex transformations\", color=purple, font_size=28)\n        conclusion.move_to(ORIGIN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Koebe's Quarter Theorem interact with the notion of extremal mappings in complex analysis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually explains how image formation works with a concave mirror by showing light rays tracing from an object to the mirror and reflecting according to the rules of ray tracing? The animation should include a representation of a concave mirror with a principal axis, focal point, and center of curvature marked. An upright object in front of the mirror, and its inverted real image formed by the mirror should also be shown. Additionally, the animation should trace three specific light rays: one that travels parallel to the principal axis and then reflects through the focal point, another that travels towards the focal point and reflects parallel to the principal axis, and a third that travels toward the center of curvature and reflects back along the same path. At the end of the animation, all elements should fade out, leaving a blank screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of Wave Equation\n        description = Text(\"This describes the propagation of waves.\", font_size=24).to_edge(DOWN)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying solution formula\n        solution_formula = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, solution_formula))\n        self.wait(2)\n\n        # Explanation of solution components\n        explanation = Text(\"f and g are arbitrary functions representing waveforms.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, explanation))\n        self.wait(2)\n\n        # Displaying a specific example\n        example_solution = MathTex(r\"u(x, t) = A\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(solution_formula, example_solution))\n        self.wait(1)\n\n        # Explanation of specific example\n        example_explanation = Text(\"This is a monochromatic plane wave.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, example_explanation))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(example_solution), FadeOut(description))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually explains how image formation works with a concave mirror by showing light rays tracing from an object to the mirror and reflecting according to the rules of ray tracing? The animation should include a representation of a concave mirror with a principal axis, focal point, and center of curvature marked. An upright object in front of the mirror, and its inverted real image formed by the mirror should also be shown. Additionally, the animation should trace three specific light rays: one that travels parallel to the principal axis and then reflects through the focal point, another that travels towards the focal point and reflects parallel to the principal axis, and a third that travels toward the center of curvature and reflects back along the same path. At the end of the animation, all elements should fade out, leaving a blank screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually explains how image formation works with a concave mirror by showing light rays tracing from an object to the mirror and reflecting according to the rules of ray tracing? the animation should include a representation of a concave mirror with a principal axis, focal point, and center of curvature marked. an upright object in front of the mirror, and its inverted real image formed by the mirror should also be shown. additionally, the animation should trace three specific light rays: one that travels parallel to the principal axis and then reflects through the focal point, another that travels towards the focal point and reflects parallel to the principal axis, and a third that travels toward the center of curvature and reflects back along the same path. at the end of the animation, all elements should fade out, leaving a blank screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of Wave Equation\n        description = Text(\"This describes the propagation of waves.\", font_size=24).to_edge(DOWN)\n        self.play(Write(description))\n        self.wait(2)\n\n        # Displaying solution formula\n        solution_formula = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(ReplacementTransform(wave_eq, solution_formula))\n        self.wait(2)\n\n        # Explanation of solution components\n        explanation = Text(\"f and g are arbitrary functions representing waveforms.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, explanation))\n        self.wait(2)\n\n        # Displaying a specific example\n        example_solution = MathTex(r\"u(x, t) = A\\sin(kx - \\omega t)\")\n        self.play(ReplacementTransform(solution_formula, example_solution))\n        self.wait(1)\n\n        # Explanation of specific example\n        example_explanation = Text(\"This is a monochromatic plane wave.\", font_size=24).to_edge(DOWN)\n        self.play(Transform(description, example_explanation))\n        self.wait(2)\n\n        # Conclusion\n        self.play(FadeOut(example_solution), FadeOut(description))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually explains how image formation works with a concave mirror by showing light rays tracing from an object to the mirror and reflecting according to the rules of ray tracing? The animation should include a representation of a concave mirror with a principal axis, focal point, and center of curvature marked. An upright object in front of the mirror, and its inverted real image formed by the mirror should also be shown. Additionally, the animation should trace three specific light rays: one that travels parallel to the principal axis and then reflects through the focal point, another that travels towards the focal point and reflects parallel to the principal axis, and a third that travels toward the center of curvature and reflects back along the same path. At the end of the animation, all elements should fade out, leaving a blank screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do perturbations in a Hamiltonian system affect the standing patterns on a Poincar\u00e9 section?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PoincareDynamics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dancing Patterns: How Chaos Unfolds on a Poincar\u00e9 Map\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Element 1: Pebble in lake analogy\n        lake = Circle(radius=2, color=BLUE)\n        pebble = Dot(color=WHITE)\n        ripple = Circle(radius=0.5, color=BLUE_A)\n        \n        self.play(Create(lake))\n        self.play(FadeIn(pebble))\n        \n        # Ripple animation\n        self.play(\n            ripple.animate.scale(3),\n            pebble.animate.fade(0.5),\n            run_time=2\n        )\n        self.play(FadeOut(lake), FadeOut(pebble), FadeOut(ripple))\n        \n        # Element 2: Phase space with Poincar\u00e9 section\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            x_length=6,\n            y_length=6,\n            axis_config={\"color\": GREY}\n        )\n        \n        # Trajectories and Poincar\u00e9 section\n        traj1 = Circle(radius=1, color=GOLD)\n        traj2 = Circle(radius=2, color=GOLD)\n        poincare = Line(start=[-3, 0, 0], end=[3, 0, 0], color=RED)\n        poincare_label = Text(\"Poincar\u00e9 Section\", font_size=20, color=RED).next_to(poincare, DOWN)\n        \n        self.play(Create(axes))\n        self.play(Create(traj1), Create(traj2))\n        self.play(Create(poincare), Write(poincare_label))\n        \n        # Intersection points\n        points = [Dot(point=[-1, 0, 0], color=GREEN), Dot(point=[1, 0, 0], color=GREEN)]\n        self.play(*[Create(point) for point in points])\n        \n        # Hamiltonian equations\n        hamiltonian = Text(\"H(q, p) = p\u00b2/2m + V(q)\", font_size=28).to_edge(UP)\n        perturbation = Text(\"\u03b4H = \u03b5q\", font_size=28).next_to(hamiltonian, DOWN)\n        \n        self.play(Write(hamiltonian))\n        self.play(Write(perturbation))\n        self.wait(1)\n        \n        # Apply perturbation\n        self.play(\n            FadeOut(hamiltonian),\n            FadeOut(perturbation)\n        )\n        \n        # Show perturbation effect\n        arrow = Arrow(start=ORIGIN, end=[0.5, 0, 0], color=YELLOW).shift(UP)\n        self.play(Create(arrow))\n        \n        # Move trajectories to show perturbation effect\n        self.play(\n            traj1.animate.shift(RIGHT * 0.5),\n            traj2.animate.shift(RIGHT * 0.3)\n        )\n        \n        # New intersection points\n        new_points = [\n            Dot(point=[-0.5, 0, 0], color=RED), \n            Dot(point=[1.3, 0, 0], color=RED)\n        ]\n        self.play(*[Create(point) for point in new_points])\n        \n        # Key insight\n        insight = Text(\"Small perturbations dramatically alter the patterns\", font_size=24).to_edge(UP)\n        self.play(FadeOut(arrow), Write(insight))\n        self.wait(1.5)\n        \n        # Conclusion\n        self.play(\n            FadeOut(insight),\n            *[FadeOut(obj) for obj in [traj1, traj2, poincare, poincare_label, axes] + points + new_points]\n        )\n        \n        conclusion = Text(\n            \"The beauty of mathematics reveals\\nthe intricate dance of our universe\", \n            font_size=28\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do perturbations in a Hamiltonian system affect the standing patterns on a Poincar\u00e9 section?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do perturbations in a hamiltonian system affect the standing patterns on a poincar\u00e9 section?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PoincareDynamics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dancing Patterns: How Chaos Unfolds on a Poincar\u00e9 Map\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Element 1: Pebble in lake analogy\n        lake = Circle(radius=2, color=BLUE)\n        pebble = Dot(color=WHITE)\n        ripple = Circle(radius=0.5, color=BLUE_A)\n        \n        self.play(Create(lake))\n        self.play(FadeIn(pebble))\n        \n        # Ripple animation\n        self.play(\n            ripple.animate.scale(3),\n            pebble.animate.fade(0.5),\n            run_time=2\n        )\n        self.play(FadeOut(lake), FadeOut(pebble), FadeOut(ripple))\n        \n        # Element 2: Phase space with Poincar\u00e9 section\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            x_length=6,\n            y_length=6,\n            axis_config={\"color\": GREY}\n        )\n        \n        # Trajectories and Poincar\u00e9 section\n        traj1 = Circle(radius=1, color=GOLD)\n        traj2 = Circle(radius=2, color=GOLD)\n        poincare = Line(start=[-3, 0, 0], end=[3, 0, 0], color=RED)\n        poincare_label = Text(\"Poincar\u00e9 Section\", font_size=20, color=RED).next_to(poincare, DOWN)\n        \n        self.play(Create(axes))\n        self.play(Create(traj1), Create(traj2))\n        self.play(Create(poincare), Write(poincare_label))\n        \n        # Intersection points\n        points = [Dot(point=[-1, 0, 0], color=GREEN), Dot(point=[1, 0, 0], color=GREEN)]\n        self.play(*[Create(point) for point in points])\n        \n        # Hamiltonian equations\n        hamiltonian = Text(\"H(q, p) = p\u00b2/2m + V(q)\", font_size=28).to_edge(UP)\n        perturbation = Text(\"\u03b4H = \u03b5q\", font_size=28).next_to(hamiltonian, DOWN)\n        \n        self.play(Write(hamiltonian))\n        self.play(Write(perturbation))\n        self.wait(1)\n        \n        # Apply perturbation\n        self.play(\n            FadeOut(hamiltonian),\n            FadeOut(perturbation)\n        )\n        \n        # Show perturbation effect\n        arrow = Arrow(start=ORIGIN, end=[0.5, 0, 0], color=YELLOW).shift(UP)\n        self.play(Create(arrow))\n        \n        # Move trajectories to show perturbation effect\n        self.play(\n            traj1.animate.shift(RIGHT * 0.5),\n            traj2.animate.shift(RIGHT * 0.3)\n        )\n        \n        # New intersection points\n        new_points = [\n            Dot(point=[-0.5, 0, 0], color=RED), \n            Dot(point=[1.3, 0, 0], color=RED)\n        ]\n        self.play(*[Create(point) for point in new_points])\n        \n        # Key insight\n        insight = Text(\"Small perturbations dramatically alter the patterns\", font_size=24).to_edge(UP)\n        self.play(FadeOut(arrow), Write(insight))\n        self.wait(1.5)\n        \n        # Conclusion\n        self.play(\n            FadeOut(insight),\n            *[FadeOut(obj) for obj in [traj1, traj2, poincare, poincare_label, axes] + points + new_points]\n        )\n        \n        conclusion = Text(\n            \"The beauty of mathematics reveals\\nthe intricate dance of our universe\", \n            font_size=28\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do perturbations in a Hamiltonian system affect the standing patterns on a Poincar\u00e9 section?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Please create an educational animation that visually walks through the steps of solving a double integral in polar coordinates. Start by displaying the double integral of r^2 * sin(theta) with respect to r from 0 to 1 and theta from 0 to pi. Follow that by a step-by-step integration process. First, calculate the inner integral with respect to r and display the intermediate result. Then, explain that the next step is to integrate with respect to theta and show this calculation, leading to the final result. Finally, evaluate the integral and simplify the expression to get the numerical answer. Make sure that each step is clearly written out and that there are brief pauses between steps for viewers to follow along."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CalculateSeries(Scene):\n    def construct(self):\n        # Display the series to be calculated\n        series_problem = MathTex(r\"S = \\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for partial sums\n        explanation1 = Text(\"Use partial sums to approach the series' value\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Partial sum notation\n        partial_sum = MathTex(r\"S_N = \\sum_{n=1}^{N} \\frac{1}{n^2}\")\n        self.play(ReplacementTransform(series_problem, partial_sum))\n        self.wait(1)\n\n        # Representing the series with partial sums\n        partial_sum_example = MathTex(r\"S_5 = 1 + \\frac{1}{4} + \\frac{1}{9} + \\frac{1}{16} + \\frac{1}{25}\")\n        self.play(ReplacementTransform(partial_sum, partial_sum_example))\n        self.wait(2)\n\n        # Explanation for the known limit\n        explanation2 = Text(\"The series converges to a known value\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Series limit is pi squared over 6\n        series_solution = MathTex(r\"S = \\frac{\\pi^2}{6}\")\n        self.play(ReplacementTransform(partial_sum_example, series_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(series_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an educational animation that visually walks through the steps of solving a double integral in polar coordinates. Start by displaying the double integral of r^2 * sin(theta) with respect to r from 0 to 1 and theta from 0 to pi. Follow that by a step-by-step integration process. First, calculate the inner integral with respect to r and display the intermediate result. Then, explain that the next step is to integrate with respect to theta and show this calculation, leading to the final result. Finally, evaluate the integral and simplify the expression to get the numerical answer. Make sure that each step is clearly written out and that there are brief pauses between steps for viewers to follow along."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that please create an educational animation that visually walks through the steps of solving a double integral in polar coordinates. start by displaying the double integral of r^2 * sin(theta) with respect to r from 0 to 1 and theta from 0 to pi. follow that by a step-by-step integration process. first, calculate the inner integral with respect to r and display the intermediate result. then, explain that the next step is to integrate with respect to theta and show this calculation, leading to the final result. finally, evaluate the integral and simplify the expression to get the numerical answer. make sure that each step is clearly written out and that there are brief pauses between steps for viewers to follow along."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CalculateSeries(Scene):\n    def construct(self):\n        # Display the series to be calculated\n        series_problem = MathTex(r\"S = \\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for partial sums\n        explanation1 = Text(\"Use partial sums to approach the series' value\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Partial sum notation\n        partial_sum = MathTex(r\"S_N = \\sum_{n=1}^{N} \\frac{1}{n^2}\")\n        self.play(ReplacementTransform(series_problem, partial_sum))\n        self.wait(1)\n\n        # Representing the series with partial sums\n        partial_sum_example = MathTex(r\"S_5 = 1 + \\frac{1}{4} + \\frac{1}{9} + \\frac{1}{16} + \\frac{1}{25}\")\n        self.play(ReplacementTransform(partial_sum, partial_sum_example))\n        self.wait(2)\n\n        # Explanation for the known limit\n        explanation2 = Text(\"The series converges to a known value\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Series limit is pi squared over 6\n        series_solution = MathTex(r\"S = \\frac{\\pi^2}{6}\")\n        self.play(ReplacementTransform(partial_sum_example, series_solution))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(series_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an educational animation that visually walks through the steps of solving a double integral in polar coordinates. Start by displaying the double integral of r^2 * sin(theta) with respect to r from 0 to 1 and theta from 0 to pi. Follow that by a step-by-step integration process. First, calculate the inner integral with respect to r and display the intermediate result. Then, explain that the next step is to integrate with respect to theta and show this calculation, leading to the final result. Finally, evaluate the integral and simplify the expression to get the numerical answer. Make sure that each step is clearly written out and that there are brief pauses between steps for viewers to follow along."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that illustrates the process of solving an integration by parts problem, specifically integrating the function x times e to the power of x? I would like the animation to first display the problem, then show the steps for setting 'u' and 'dv', followed by an explanation of the integration by parts formula, and finally demonstrate the calculation steps with the final solution including the constant of integration. Each step should be shown clearly and give enough time for the viewer to follow along."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigFunctionExample(Scene):\n    def construct(self):\n        # Displaying the trigonometric function\n        trig_func = MathTex(r\"\\int_0^{\\frac{\\pi}{2}} \\sin(x) \\,dx\")\n        self.play(Write(trig_func))\n        self.wait(1)\n\n        # Explanation for the definite integral\n        explanation1 = Text(\"Definite integral of a trigonometric function\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Calculating the integral\n        integral_calc = MathTex(r\"= [-\\cos(x)]_0^{\\frac{\\pi}{2}}\")\n        self.play(ReplacementTransform(trig_func.copy(), integral_calc))\n        self.wait(1)\n\n        # Explanation for solving the definite integral\n        explanation2 = Text(\"Solve the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 1\")\n        self.play(ReplacementTransform(integral_calc, final_result))\n        self.wait(1)\n\n        # Clear the scene and present final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that illustrates the process of solving an integration by parts problem, specifically integrating the function x times e to the power of x? I would like the animation to first display the problem, then show the steps for setting 'u' and 'dv', followed by an explanation of the integration by parts formula, and finally demonstrate the calculation steps with the final solution including the constant of integration. Each step should be shown clearly and give enough time for the viewer to follow along."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that illustrates the process of solving an integration by parts problem, specifically integrating the function x times e to the power of x? i would like the animation to first display the problem, then show the steps for setting 'u' and 'dv', followed by an explanation of the integration by parts formula, and finally demonstrate the calculation steps with the final solution including the constant of integration. each step should be shown clearly and give enough time for the viewer to follow along."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigFunctionExample(Scene):\n    def construct(self):\n        # Displaying the trigonometric function\n        trig_func = MathTex(r\"\\int_0^{\\frac{\\pi}{2}} \\sin(x) \\,dx\")\n        self.play(Write(trig_func))\n        self.wait(1)\n\n        # Explanation for the definite integral\n        explanation1 = Text(\"Definite integral of a trigonometric function\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Calculating the integral\n        integral_calc = MathTex(r\"= [-\\cos(x)]_0^{\\frac{\\pi}{2}}\")\n        self.play(ReplacementTransform(trig_func.copy(), integral_calc))\n        self.wait(1)\n\n        # Explanation for solving the definite integral\n        explanation2 = Text(\"Solve the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final result\n        final_result = MathTex(r\"= 1\")\n        self.play(ReplacementTransform(integral_calc, final_result))\n        self.wait(1)\n\n        # Clear the scene and present final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_result))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that illustrates the process of solving an integration by parts problem, specifically integrating the function x times e to the power of x? I would like the animation to first display the problem, then show the steps for setting 'u' and 'dv', followed by an explanation of the integration by parts formula, and finally demonstrate the calculation steps with the final solution including the constant of integration. Each step should be shown clearly and give enough time for the viewer to follow along."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the maximal function depict the rate of change as we vary the geometric configuration of the averaging region (e.g., sphere, cube)?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MaximalFunctionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Dance of Shapes: Unraveling the Maximal Function\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Create a grid\n        grid = NumberPlane(\n            x_range=[-5, 5, 1],\n            y_range=[-3, 3, 1],\n            background_line_style={\n                \"stroke_color\": BLUE_D,\n                \"stroke_width\": 0.5,\n                \"stroke_opacity\": 0.3\n            }\n        )\n        self.play(Create(grid))\n        \n        # Create a simple function curve\n        def f(x):\n            return np.exp(-x**2)\n        \n        function_graph = ParametricFunction(\n            lambda t: np.array([t, f(t), 0]),\n            t_range=[-3, 3, 0.01],\n            color=YELLOW\n        )\n        self.play(Create(function_graph))\n        \n        # Explanation text\n        explain_text = Text(\"Maximal function averages over regions\", font_size=24)\n        explain_text.next_to(title, DOWN)\n        self.play(Write(explain_text))\n        self.wait(1)\n        \n        # Create a reference point\n        point = Dot(ORIGIN, color=RED)\n        self.play(Create(point))\n        \n        # First shape: Circle (representing sphere)\n        circle = Circle(radius=0.5, color=RED)\n        circle.move_to(point.get_center())\n        \n        circle_label = Text(\"Sphere average\", font_size=20, color=RED)\n        circle_label.next_to(circle, DOWN)\n        \n        self.play(Create(circle), Write(circle_label))\n        self.wait(1)\n        \n        # Expand the circle\n        circle_expanded = Circle(radius=2, color=RED)\n        circle_expanded.move_to(point.get_center())\n        self.play(Transform(circle, circle_expanded))\n        self.wait(1)\n        \n        # Show the first equation - simplified\n        sphere_eq = Text(\"M(f)(x) = sup average of f over spheres\", font_size=24)\n        sphere_eq.next_to(explain_text, DOWN)\n        self.play(Write(sphere_eq))\n        self.wait(1.5)\n        \n        # Transition to square\n        self.play(FadeOut(circle), FadeOut(circle_label))\n        \n        # Second shape: Square (representing cube)\n        square = Square(side_length=1, color=GREEN)\n        square.move_to(point.get_center())\n        \n        square_label = Text(\"Cube average\", font_size=20, color=GREEN)\n        square_label.next_to(square, DOWN)\n        \n        self.play(Create(square), Write(square_label))\n        self.wait(1)\n        \n        # Expand the square\n        square_expanded = Square(side_length=4, color=GREEN)\n        square_expanded.move_to(point.get_center())\n        self.play(Transform(square, square_expanded))\n        self.wait(1)\n        \n        # Show the second equation - simplified\n        cube_eq = Text(\"M_cube(f)(x) = sup average of f over cubes\", font_size=24)\n        cube_eq.next_to(explain_text, DOWN)\n        self.play(Transform(sphere_eq, cube_eq))\n        self.wait(1.5)\n        \n        # Key insight\n        insight_text = Text(\"Different shapes \u2192 Different rates of change\", font_size=24)\n        insight_text.to_edge(DOWN)\n        self.play(Write(insight_text))\n        self.wait(2)\n        \n        # Clean up everything for conclusion\n        self.play(\n            FadeOut(grid),\n            FadeOut(function_graph),\n            FadeOut(point),\n            FadeOut(square),\n            FadeOut(square_label),\n            FadeOut(sphere_eq),\n            FadeOut(explain_text),\n            FadeOut(insight_text),\n            FadeOut(title)\n        )\n        \n        # Conclusion\n        conclusion = Text(\"The geometry guides the narrative of growth and change\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the maximal function depict the rate of change as we vary the geometric configuration of the averaging region (e.g., sphere, cube)?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the maximal function depict the rate of change as we vary the geometric configuration of the averaging region (e.g., sphere, cube)?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MaximalFunctionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Dance of Shapes: Unraveling the Maximal Function\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Create a grid\n        grid = NumberPlane(\n            x_range=[-5, 5, 1],\n            y_range=[-3, 3, 1],\n            background_line_style={\n                \"stroke_color\": BLUE_D,\n                \"stroke_width\": 0.5,\n                \"stroke_opacity\": 0.3\n            }\n        )\n        self.play(Create(grid))\n        \n        # Create a simple function curve\n        def f(x):\n            return np.exp(-x**2)\n        \n        function_graph = ParametricFunction(\n            lambda t: np.array([t, f(t), 0]),\n            t_range=[-3, 3, 0.01],\n            color=YELLOW\n        )\n        self.play(Create(function_graph))\n        \n        # Explanation text\n        explain_text = Text(\"Maximal function averages over regions\", font_size=24)\n        explain_text.next_to(title, DOWN)\n        self.play(Write(explain_text))\n        self.wait(1)\n        \n        # Create a reference point\n        point = Dot(ORIGIN, color=RED)\n        self.play(Create(point))\n        \n        # First shape: Circle (representing sphere)\n        circle = Circle(radius=0.5, color=RED)\n        circle.move_to(point.get_center())\n        \n        circle_label = Text(\"Sphere average\", font_size=20, color=RED)\n        circle_label.next_to(circle, DOWN)\n        \n        self.play(Create(circle), Write(circle_label))\n        self.wait(1)\n        \n        # Expand the circle\n        circle_expanded = Circle(radius=2, color=RED)\n        circle_expanded.move_to(point.get_center())\n        self.play(Transform(circle, circle_expanded))\n        self.wait(1)\n        \n        # Show the first equation - simplified\n        sphere_eq = Text(\"M(f)(x) = sup average of f over spheres\", font_size=24)\n        sphere_eq.next_to(explain_text, DOWN)\n        self.play(Write(sphere_eq))\n        self.wait(1.5)\n        \n        # Transition to square\n        self.play(FadeOut(circle), FadeOut(circle_label))\n        \n        # Second shape: Square (representing cube)\n        square = Square(side_length=1, color=GREEN)\n        square.move_to(point.get_center())\n        \n        square_label = Text(\"Cube average\", font_size=20, color=GREEN)\n        square_label.next_to(square, DOWN)\n        \n        self.play(Create(square), Write(square_label))\n        self.wait(1)\n        \n        # Expand the square\n        square_expanded = Square(side_length=4, color=GREEN)\n        square_expanded.move_to(point.get_center())\n        self.play(Transform(square, square_expanded))\n        self.wait(1)\n        \n        # Show the second equation - simplified\n        cube_eq = Text(\"M_cube(f)(x) = sup average of f over cubes\", font_size=24)\n        cube_eq.next_to(explain_text, DOWN)\n        self.play(Transform(sphere_eq, cube_eq))\n        self.wait(1.5)\n        \n        # Key insight\n        insight_text = Text(\"Different shapes \u2192 Different rates of change\", font_size=24)\n        insight_text.to_edge(DOWN)\n        self.play(Write(insight_text))\n        self.wait(2)\n        \n        # Clean up everything for conclusion\n        self.play(\n            FadeOut(grid),\n            FadeOut(function_graph),\n            FadeOut(point),\n            FadeOut(square),\n            FadeOut(square_label),\n            FadeOut(sphere_eq),\n            FadeOut(explain_text),\n            FadeOut(insight_text),\n            FadeOut(title)\n        )\n        \n        # Conclusion\n        conclusion = Text(\"The geometry guides the narrative of growth and change\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the maximal function depict the rate of change as we vary the geometric configuration of the averaging region (e.g., sphere, cube)?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animation where a text reading \"SpinInFromNothing\" appears with a spinning effect and is placed at the top of the screen. After the text appears, I want a triangle to spin into existence in the center of the screen and then disappear. The animation should be quick, with the text transformation happening in just half a second. Can you write me a script for this using ManimCE?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Describing the motion\n        motion_eq = MathTex(r\"\\frac{d^2 x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explaining the terms\n        explanation1 = Text(\"This represents a simple harmonic oscillator.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Frequency of the oscillator\n        explanation2 = Text(r\"The term $\\omega$ is the angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution to the motion equation\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(motion_eq, solution))\n        self.wait(1)\n\n        # Describing the amplitude and phase\n        explanation3 = Text(\"Here, A is amplitude and \u03c6 is the phase.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear scene and show conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animation where a text reading \"SpinInFromNothing\" appears with a spinning effect and is placed at the top of the screen. After the text appears, I want a triangle to spin into existence in the center of the screen and then disappear. The animation should be quick, with the text transformation happening in just half a second. Can you write me a script for this using ManimCE?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animation where a text reading \"spininfromnothing\" appears with a spinning effect and is placed at the top of the screen. after the text appears, i want a triangle to spin into existence in the center of the screen and then disappear. the animation should be quick, with the text transformation happening in just half a second. can you write me a script for this using manimce?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Describing the motion\n        motion_eq = MathTex(r\"\\frac{d^2 x}{dt^2} + \\omega^2 x = 0\")\n        self.play(Write(motion_eq))\n        self.wait(1)\n\n        # Explaining the terms\n        explanation1 = Text(\"This represents a simple harmonic oscillator.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1))\n        self.wait(2)\n\n        # Frequency of the oscillator\n        explanation2 = Text(r\"The term $\\omega$ is the angular frequency.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Displaying the solution to the motion equation\n        solution = MathTex(r\"x(t) = A\\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(motion_eq, solution))\n        self.wait(1)\n\n        # Describing the amplitude and phase\n        explanation3 = Text(\"Here, A is amplitude and \u03c6 is the phase.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clear scene and show conclusion\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animation where a text reading \"SpinInFromNothing\" appears with a spinning effect and is placed at the top of the screen. After the text appears, I want a triangle to spin into existence in the center of the screen and then disappear. The animation should be quick, with the text transformation happening in just half a second. Can you write me a script for this using ManimCE?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the Manim logo banner animation on a light beige background:  \n- The banner is drawn on screen using the light theme style.  \n- It then expands in size.  \n- After a brief pause, the banner is smoothly removed with an unwrite animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LightThemeBanner(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner = ManimBanner(dark_theme=False)\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the Manim logo banner animation on a light beige background:  \n- The banner is drawn on screen using the light theme style.  \n- It then expands in size.  \n- After a brief pause, the banner is smoothly removed with an unwrite animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the manim logo banner animation on a light beige background:  \n- the banner is drawn on screen using the light theme style.  \n- it then expands in size.  \n- after a brief pause, the banner is smoothly removed with an unwrite animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LightThemeBanner(Scene):\n    def construct(self):\n        self.camera.background_color = \"#ece6e2\"\n        banner = ManimBanner(dark_theme=False)\n        self.play(banner.create())\n        self.play(banner.expand())\n        self.wait()\n        self.play(Unwrite(banner))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the Manim logo banner animation on a light beige background:  \n- The banner is drawn on screen using the light theme style.  \n- It then expands in size.  \n- After a brief pause, the banner is smoothly removed with an unwrite animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a blue square with partial fill. The square rotates 180 degrees over 2 seconds with a linear motion, then it is highlighted using the `Indicate` animation without changing its color. The default settings for `Rotate` and `Indicate` are temporarily modified for this scene and then reset afterward."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChangeDefaultAnimation(Scene):\n    def construct(self):\n        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n        Indicate.set_default(color=None)\n\n        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n        self.add(S)\n        self.play(Rotate(S, PI))\n        self.play(Indicate(S))\n\n        Rotate.set_default()\n        Indicate.set_default()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue square with partial fill. The square rotates 180 degrees over 2 seconds with a linear motion, then it is highlighted using the `Indicate` animation without changing its color. The default settings for `Rotate` and `Indicate` are temporarily modified for this scene and then reset afterward."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a blue square with partial fill. the square rotates 180 degrees over 2 seconds with a linear motion, then it is highlighted using the `indicate` animation without changing its color. the default settings for `rotate` and `indicate` are temporarily modified for this scene and then reset afterward."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChangeDefaultAnimation(Scene):\n    def construct(self):\n        Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n        Indicate.set_default(color=None)\n\n        S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n        self.add(S)\n        self.play(Rotate(S, PI))\n        self.play(Indicate(S))\n\n        Rotate.set_default()\n        Indicate.set_default()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue square with partial fill. The square rotates 180 degrees over 2 seconds with a linear motion, then it is highlighted using the `Indicate` animation without changing its color. The default settings for `Rotate` and `Indicate` are temporarily modified for this scene and then reset afterward."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What factors determine if a nonlinear system of equations will converge to a unique solution or multiple possible solutions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass NonlinearEquationSystems(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Decoding Convergence: Nonlinear Equations\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"What determines how nonlinear systems converge?\", font_size=28)\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(FadeOut(intro))\n        \n        # Create a simple grid\n        grid = NumberPlane(\n            x_range=(-3, 3, 1),\n            y_range=(-3, 3, 1),\n            background_line_style={\n                \"stroke_color\": BLUE_D,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.5\n            }\n        )\n        self.play(Create(grid))\n        \n        # Key concept 1: Single solution scenario\n        concept1 = Text(\"1. Unique Solution\", font_size=28).to_edge(UP)\n        self.play(Write(concept1))\n        \n        # Show a single solution point\n        solution_point = Dot(point=ORIGIN, color=YELLOW, radius=0.15)\n        self.play(Create(solution_point))\n        \n        # Show Jacobian condition for unique solution\n        jacobian_eq = MathTex(r\"\\det(Jacobian) \\neq 0\", color=WHITE)\n        jacobian_eq.next_to(concept1, DOWN)\n        self.play(Write(jacobian_eq))\n        \n        # Draw arrows converging to the solution\n        arrows = VGroup()\n        for angle in np.linspace(0, 2*PI, 8):\n            start_pos = 2 * np.array([np.cos(angle), np.sin(angle), 0])\n            arrow = Arrow(start=start_pos, end=ORIGIN, color=BLUE)\n            arrows.add(arrow)\n        self.play(Create(arrows))\n        self.wait(2)\n        \n        # Transition\n        self.play(\n            FadeOut(arrows),\n            FadeOut(jacobian_eq),\n            FadeOut(concept1),\n            FadeOut(solution_point)\n        )\n        \n        # Key concept 2: Multiple solutions\n        concept2 = Text(\"2. Multiple Solutions\", font_size=28).to_edge(UP)\n        self.play(Write(concept2))\n        \n        # Show multiple solution points\n        solution1 = Dot(point=np.array([-1.5, -1.5, 0]), color=YELLOW, radius=0.15)\n        solution2 = Dot(point=np.array([1.5, 1.5, 0]), color=YELLOW, radius=0.15)\n        \n        self.play(Create(solution1), Create(solution2))\n        \n        # Nonlinearity equation\n        nonlinear_eq = MathTex(r\"f(x,y) = xy - \\sin(xy)\", color=WHITE)\n        nonlinear_eq.next_to(concept2, DOWN)\n        self.play(Write(nonlinear_eq))\n        self.wait(2)\n        \n        # Transition\n        self.play(\n            FadeOut(nonlinear_eq)\n        )\n        \n        # Key concept 3: Convergence basins\n        concept3 = Text(\"3. Convergence Basins\", font_size=28).to_edge(UP)\n        self.play(\n            FadeOut(concept2),\n            Write(concept3)\n        )\n        \n        # Create basins of attraction\n        basin1 = Circle(radius=1.2, color=RED, fill_opacity=0.3).move_to(solution1.get_center())\n        basin2 = Circle(radius=1.2, color=GREEN, fill_opacity=0.3).move_to(solution2.get_center())\n        \n        self.play(Create(basin1), Create(basin2))\n        \n        # Add explanation\n        basin_text = Text(\"Initial conditions determine which solution is reached\", \n                         font_size=20).to_edge(DOWN)\n        self.play(Write(basin_text))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(grid),\n            FadeOut(solution1),\n            FadeOut(solution2),\n            FadeOut(basin1),\n            FadeOut(basin2),\n            FadeOut(basin_text),\n            FadeOut(concept3)\n        )\n        \n        conclusion = Text(\n            \"Convergence depends on:\\n\u2022 Initial conditions\\n\u2022 Jacobian properties\\n\u2022 Degree of nonlinearity\",\n            font_size=28,\n            line_spacing=1.5\n        )\n        self.play(Write(conclusion))\n        self.wait(3)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What factors determine if a nonlinear system of equations will converge to a unique solution or multiple possible solutions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what factors determine if a nonlinear system of equations will converge to a unique solution or multiple possible solutions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass NonlinearEquationSystems(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Decoding Convergence: Nonlinear Equations\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"What determines how nonlinear systems converge?\", font_size=28)\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(FadeOut(intro))\n        \n        # Create a simple grid\n        grid = NumberPlane(\n            x_range=(-3, 3, 1),\n            y_range=(-3, 3, 1),\n            background_line_style={\n                \"stroke_color\": BLUE_D,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.5\n            }\n        )\n        self.play(Create(grid))\n        \n        # Key concept 1: Single solution scenario\n        concept1 = Text(\"1. Unique Solution\", font_size=28).to_edge(UP)\n        self.play(Write(concept1))\n        \n        # Show a single solution point\n        solution_point = Dot(point=ORIGIN, color=YELLOW, radius=0.15)\n        self.play(Create(solution_point))\n        \n        # Show Jacobian condition for unique solution\n        jacobian_eq = MathTex(r\"\\det(Jacobian) \\neq 0\", color=WHITE)\n        jacobian_eq.next_to(concept1, DOWN)\n        self.play(Write(jacobian_eq))\n        \n        # Draw arrows converging to the solution\n        arrows = VGroup()\n        for angle in np.linspace(0, 2*PI, 8):\n            start_pos = 2 * np.array([np.cos(angle), np.sin(angle), 0])\n            arrow = Arrow(start=start_pos, end=ORIGIN, color=BLUE)\n            arrows.add(arrow)\n        self.play(Create(arrows))\n        self.wait(2)\n        \n        # Transition\n        self.play(\n            FadeOut(arrows),\n            FadeOut(jacobian_eq),\n            FadeOut(concept1),\n            FadeOut(solution_point)\n        )\n        \n        # Key concept 2: Multiple solutions\n        concept2 = Text(\"2. Multiple Solutions\", font_size=28).to_edge(UP)\n        self.play(Write(concept2))\n        \n        # Show multiple solution points\n        solution1 = Dot(point=np.array([-1.5, -1.5, 0]), color=YELLOW, radius=0.15)\n        solution2 = Dot(point=np.array([1.5, 1.5, 0]), color=YELLOW, radius=0.15)\n        \n        self.play(Create(solution1), Create(solution2))\n        \n        # Nonlinearity equation\n        nonlinear_eq = MathTex(r\"f(x,y) = xy - \\sin(xy)\", color=WHITE)\n        nonlinear_eq.next_to(concept2, DOWN)\n        self.play(Write(nonlinear_eq))\n        self.wait(2)\n        \n        # Transition\n        self.play(\n            FadeOut(nonlinear_eq)\n        )\n        \n        # Key concept 3: Convergence basins\n        concept3 = Text(\"3. Convergence Basins\", font_size=28).to_edge(UP)\n        self.play(\n            FadeOut(concept2),\n            Write(concept3)\n        )\n        \n        # Create basins of attraction\n        basin1 = Circle(radius=1.2, color=RED, fill_opacity=0.3).move_to(solution1.get_center())\n        basin2 = Circle(radius=1.2, color=GREEN, fill_opacity=0.3).move_to(solution2.get_center())\n        \n        self.play(Create(basin1), Create(basin2))\n        \n        # Add explanation\n        basin_text = Text(\"Initial conditions determine which solution is reached\", \n                         font_size=20).to_edge(DOWN)\n        self.play(Write(basin_text))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(grid),\n            FadeOut(solution1),\n            FadeOut(solution2),\n            FadeOut(basin1),\n            FadeOut(basin2),\n            FadeOut(basin_text),\n            FadeOut(concept3)\n        )\n        \n        conclusion = Text(\n            \"Convergence depends on:\\n\u2022 Initial conditions\\n\u2022 Jacobian properties\\n\u2022 Degree of nonlinearity\",\n            font_size=28,\n            line_spacing=1.5\n        )\n        self.play(Write(conclusion))\n        self.wait(3)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What factors determine if a nonlinear system of equations will converge to a unique solution or multiple possible solutions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the word \u201cBlinking\u201d in medium-large text on the screen, then animate it blinking three times by briefly disappearing and reappearing."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BlinkingExample(Scene):\n    def construct(self):\n        text = Text(\"Blinking\").scale(1.5)\n        self.add(text)\n        self.play(Blink(text, blinks=3))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \u201cBlinking\u201d in medium-large text on the screen, then animate it blinking three times by briefly disappearing and reappearing."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the word \u201cblinking\u201d in medium-large text on the screen, then animate it blinking three times by briefly disappearing and reappearing."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BlinkingExample(Scene):\n    def construct(self):\n        text = Text(\"Blinking\").scale(1.5)\n        self.add(text)\n        self.play(Blink(text, blinks=3))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \u201cBlinking\u201d in medium-large text on the screen, then animate it blinking three times by briefly disappearing and reappearing."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In a class of 40 students, 25 study Biology, 15 study Chemistry, 10 study both. Using the Inclusion-Exclusion Principle, how many study at least one of the two subjects?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InclusionExclusionPrinciple(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Counting the Overlap: Inclusion-Exclusion in Action\", font_size=32)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction\n        intro = Text(\"In a class of 40 students:\", font_size=28)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(FadeIn(intro))\n        self.wait(1)\n        \n        # Create Venn diagram\n        bio_circle = Circle(radius=1.5, color=GREEN)\n        bio_circle.shift(LEFT * 1.5)\n        chem_circle = Circle(radius=1.5, color=BLUE)\n        chem_circle.shift(RIGHT * 1.5)\n        \n        # Labels for Venn diagram\n        bio_label = Text(\"Biology: 25\", font_size=24, color=GREEN)\n        bio_label.next_to(bio_circle, UP)\n        chem_label = Text(\"Chemistry: 15\", font_size=24, color=BLUE)\n        chem_label.next_to(chem_circle, UP)\n        both_label = Text(\"Both: 10\", font_size=24, color=YELLOW)\n        both_label.move_to((bio_circle.get_center() + chem_circle.get_center()) / 2)\n        \n        # Show Venn diagram\n        self.play(Create(bio_circle), Create(chem_circle))\n        self.play(Write(bio_label), Write(chem_label), Write(both_label))\n        self.wait(1)\n        \n        # Question\n        question = Text(\"How many study at least one subject?\", font_size=24)\n        question.next_to(chem_circle, DOWN, buff=2)\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Formula\n        formula = Text(\"|A \u222a B| = |A| + |B| - |A \u2229 B|\", font_size=28)\n        formula.next_to(question, DOWN, buff=0.5)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Calculation\n        calc = Text(\"25 + 15 - 10 = 30\", font_size=28)\n        calc.next_to(formula, DOWN, buff=0.5)\n        self.play(Write(calc))\n        self.wait(1)\n        \n        # Result\n        result = Text(\"30 students study at least one subject\", font_size=28, color=YELLOW)\n        result.next_to(calc, DOWN, buff=0.5)\n        self.play(FadeIn(result))\n        self.wait(2)\n        \n        # Clean up for final view\n        self.play(\n            FadeOut(question),\n            FadeOut(formula),\n            FadeOut(calc),\n            FadeOut(result),\n            FadeOut(intro),\n            FadeOut(title)\n        )\n        \n        # Final summary\n        final = Text(\"At least one: 30\", font_size=28, color=YELLOW)\n        final.next_to(chem_circle, DOWN, buff=0.5)\n        self.play(FadeIn(final))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In a class of 40 students, 25 study Biology, 15 study Chemistry, 10 study both. Using the Inclusion-Exclusion Principle, how many study at least one of the two subjects?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in a class of 40 students, 25 study biology, 15 study chemistry, 10 study both. using the inclusion-exclusion principle, how many study at least one of the two subjects?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InclusionExclusionPrinciple(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Counting the Overlap: Inclusion-Exclusion in Action\", font_size=32)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction\n        intro = Text(\"In a class of 40 students:\", font_size=28)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(FadeIn(intro))\n        self.wait(1)\n        \n        # Create Venn diagram\n        bio_circle = Circle(radius=1.5, color=GREEN)\n        bio_circle.shift(LEFT * 1.5)\n        chem_circle = Circle(radius=1.5, color=BLUE)\n        chem_circle.shift(RIGHT * 1.5)\n        \n        # Labels for Venn diagram\n        bio_label = Text(\"Biology: 25\", font_size=24, color=GREEN)\n        bio_label.next_to(bio_circle, UP)\n        chem_label = Text(\"Chemistry: 15\", font_size=24, color=BLUE)\n        chem_label.next_to(chem_circle, UP)\n        both_label = Text(\"Both: 10\", font_size=24, color=YELLOW)\n        both_label.move_to((bio_circle.get_center() + chem_circle.get_center()) / 2)\n        \n        # Show Venn diagram\n        self.play(Create(bio_circle), Create(chem_circle))\n        self.play(Write(bio_label), Write(chem_label), Write(both_label))\n        self.wait(1)\n        \n        # Question\n        question = Text(\"How many study at least one subject?\", font_size=24)\n        question.next_to(chem_circle, DOWN, buff=2)\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Formula\n        formula = Text(\"|A \u222a B| = |A| + |B| - |A \u2229 B|\", font_size=28)\n        formula.next_to(question, DOWN, buff=0.5)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Calculation\n        calc = Text(\"25 + 15 - 10 = 30\", font_size=28)\n        calc.next_to(formula, DOWN, buff=0.5)\n        self.play(Write(calc))\n        self.wait(1)\n        \n        # Result\n        result = Text(\"30 students study at least one subject\", font_size=28, color=YELLOW)\n        result.next_to(calc, DOWN, buff=0.5)\n        self.play(FadeIn(result))\n        self.wait(2)\n        \n        # Clean up for final view\n        self.play(\n            FadeOut(question),\n            FadeOut(formula),\n            FadeOut(calc),\n            FadeOut(result),\n            FadeOut(intro),\n            FadeOut(title)\n        )\n        \n        # Final summary\n        final = Text(\"At least one: 30\", font_size=28, color=YELLOW)\n        final.next_to(chem_circle, DOWN, buff=0.5)\n        self.play(FadeIn(final))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In a class of 40 students, 25 study Biology, 15 study Chemistry, 10 study both. Using the Inclusion-Exclusion Principle, how many study at least one of the two subjects?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the geometric interpretation of Farey sequences on the unit circle?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass FareySequenceScene(Scene):\n    def construct(self):\n        # Title slide\n        title = Text(\"Unveiling Chord Patterns: Farey Sequences on the Unit Circle\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction to Farey sequences\n        intro_text = Text(\"The Farey sequence orders rational numbers between 0 and 1\")\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Definition of Farey sequence\n        farey_def = MathTex(r\"F_n = \\{ \\frac{a}{b} : 0 \\leq a \\leq b \\leq n, \\text{gcd}(a, b) = 1 \\}\")\n        self.play(Write(farey_def))\n        self.wait(2)\n        self.play(FadeOut(farey_def))\n        \n        # Create a unit circle\n        circle = Circle(radius=3, color=BLUE)\n        self.play(Create(circle))\n        self.wait(1)\n        \n        # Farey sequence of order 4\n        fractions = [(0, 1), (1, 4), (1, 3), (1, 2), (2, 3), (3, 4), (1, 1)]\n        \n        # Function to convert fraction to point on unit circle\n        def fraction_to_point(a, b):\n            angle = 2 * np.pi * a / b\n            return np.array([3 * np.cos(angle), 3 * np.sin(angle), 0])\n        \n        # Add points for each fraction\n        dots = []\n        labels = []\n        \n        for a, b in fractions:\n            point = fraction_to_point(a, b)\n            dot = Dot(point, color=YELLOW)\n            label = MathTex(f\"{a}/{b}\")\n            label.next_to(dot, direction=point/np.linalg.norm(point), buff=0.3)\n            \n            self.play(Create(dot), Write(label), run_time=0.5)\n            dots.append(dot)\n            labels.append(label)\n        \n        # Show the angle formula\n        angle_formula = MathTex(r\"\\theta = 2\\pi \\frac{a}{b}\")\n        angle_formula.to_corner(UL)\n        self.play(Write(angle_formula))\n        self.wait(1)\n        \n        # Draw chords between sequential fractions\n        chords = []\n        for i in range(len(fractions) - 1):\n            p1 = fraction_to_point(fractions[i][0], fractions[i][1])\n            p2 = fraction_to_point(fractions[i+1][0], fractions[i+1][1])\n            chord = Line(p1, p2, color=RED)\n            self.play(Create(chord), run_time=0.5)\n            chords.append(chord)\n        \n        # Highlight the pattern\n        insight_text = Text(\"Notice the pattern of chords\")\n        insight_text.to_edge(DOWN)\n        self.play(Write(insight_text))\n        self.wait(2)\n        self.play(FadeOut(insight_text))\n        \n        # Conclusion\n        conclusion = Text(\"Farey Sequence \u2013 A Journey Through Arithmetic & Geometry\")\n        conclusion.to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(*[FadeOut(obj) for obj in [*dots, *labels, *chords, angle_formula, conclusion, circle]])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the geometric interpretation of Farey sequences on the unit circle?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the geometric interpretation of farey sequences on the unit circle?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass FareySequenceScene(Scene):\n    def construct(self):\n        # Title slide\n        title = Text(\"Unveiling Chord Patterns: Farey Sequences on the Unit Circle\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction to Farey sequences\n        intro_text = Text(\"The Farey sequence orders rational numbers between 0 and 1\")\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Definition of Farey sequence\n        farey_def = MathTex(r\"F_n = \\{ \\frac{a}{b} : 0 \\leq a \\leq b \\leq n, \\text{gcd}(a, b) = 1 \\}\")\n        self.play(Write(farey_def))\n        self.wait(2)\n        self.play(FadeOut(farey_def))\n        \n        # Create a unit circle\n        circle = Circle(radius=3, color=BLUE)\n        self.play(Create(circle))\n        self.wait(1)\n        \n        # Farey sequence of order 4\n        fractions = [(0, 1), (1, 4), (1, 3), (1, 2), (2, 3), (3, 4), (1, 1)]\n        \n        # Function to convert fraction to point on unit circle\n        def fraction_to_point(a, b):\n            angle = 2 * np.pi * a / b\n            return np.array([3 * np.cos(angle), 3 * np.sin(angle), 0])\n        \n        # Add points for each fraction\n        dots = []\n        labels = []\n        \n        for a, b in fractions:\n            point = fraction_to_point(a, b)\n            dot = Dot(point, color=YELLOW)\n            label = MathTex(f\"{a}/{b}\")\n            label.next_to(dot, direction=point/np.linalg.norm(point), buff=0.3)\n            \n            self.play(Create(dot), Write(label), run_time=0.5)\n            dots.append(dot)\n            labels.append(label)\n        \n        # Show the angle formula\n        angle_formula = MathTex(r\"\\theta = 2\\pi \\frac{a}{b}\")\n        angle_formula.to_corner(UL)\n        self.play(Write(angle_formula))\n        self.wait(1)\n        \n        # Draw chords between sequential fractions\n        chords = []\n        for i in range(len(fractions) - 1):\n            p1 = fraction_to_point(fractions[i][0], fractions[i][1])\n            p2 = fraction_to_point(fractions[i+1][0], fractions[i+1][1])\n            chord = Line(p1, p2, color=RED)\n            self.play(Create(chord), run_time=0.5)\n            chords.append(chord)\n        \n        # Highlight the pattern\n        insight_text = Text(\"Notice the pattern of chords\")\n        insight_text.to_edge(DOWN)\n        self.play(Write(insight_text))\n        self.wait(2)\n        self.play(FadeOut(insight_text))\n        \n        # Conclusion\n        conclusion = Text(\"Farey Sequence \u2013 A Journey Through Arithmetic & Geometry\")\n        conclusion.to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(*[FadeOut(obj) for obj in [*dots, *labels, *chords, angle_formula, conclusion, circle]])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the geometric interpretation of Farey sequences on the unit circle?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can you use the Mellin Transform to analyze the behavior of the Gamma function at infinity?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MellinGammaScene(Scene):\n    def construct(self):\n        # Set background color to deep blue\n        self.camera.background_color = \"#0a0a2c\"  # This works in most versions\n        \n        # Title\n        title = Text(\"Unveiling Infinity\", color=GOLD_A).scale(0.8)\n        subtitle = Text(\"The Mellin Transform & The Gamma Function\", color=BLUE_B).scale(0.6)\n        title_group = VGroup(title, subtitle).arrange(DOWN)\n        \n        # Animation sequence\n        self.play(Write(title_group))\n        self.wait(1)\n        self.play(title_group.animate.to_edge(UP))\n        \n        # Gamma function with visual\n        gamma_text = Text(\"Gamma Function:\", color=GOLD_A).scale(0.7)\n        gamma_eq = MathTex(r\"\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} \\, dt\", color=WHITE)\n        gamma_group = VGroup(gamma_text, gamma_eq).arrange(DOWN).next_to(title_group, DOWN, buff=1)\n        \n        # Simple gamma visual - a curved line\n        gamma_curve = ParametricFunction(\n            lambda t: np.array([t, 0.5*np.exp(-t/2)*np.sin(t), 0]),\n            t_range=[0, 8, 0.1],\n            color=GOLD_A\n        ).scale(0.5).next_to(gamma_group, DOWN, buff=0.5)\n        \n        self.play(Write(gamma_group))\n        self.play(Create(gamma_curve))\n        self.wait(2)\n        \n        # Mellin Transform with visual\n        mellin_text = Text(\"Mellin Transform:\", color=BLUE_B).scale(0.7)\n        mellin_eq = MathTex(r\"\\mathcal{M}\\{\\Gamma(x)\\}(s) = \\int_0^\\infty \\Gamma(t) t^{s-1} \\, dt\", color=WHITE)\n        mellin_group = VGroup(mellin_text, mellin_eq).arrange(DOWN).next_to(title_group, DOWN, buff=1)\n        \n        # Simple mellin visual - a different curve\n        mellin_curve = ParametricFunction(\n            lambda t: np.array([t, 0.3*np.sin(t*2), 0]),\n            t_range=[0, 4, 0.1],\n            color=BLUE_B\n        ).scale(0.5).next_to(mellin_group, DOWN, buff=0.5)\n        \n        self.play(FadeOut(gamma_group, gamma_curve))\n        self.play(Write(mellin_group))\n        self.play(Create(mellin_curve))\n        self.wait(2)\n        \n        # Transformation visualization\n        arrow = Arrow(LEFT*2, RIGHT*2, color=WHITE).next_to(title_group, DOWN, buff=2)\n        gamma_circle = Circle(radius=0.5, color=GOLD_A).next_to(arrow, LEFT, buff=0.5)\n        mellin_circle = Circle(radius=0.5, color=BLUE_B).next_to(arrow, RIGHT, buff=0.5)\n        \n        gamma_label = Text(\"\u0393\", color=GOLD_A).scale(0.6).move_to(gamma_circle)\n        mellin_label = Text(\"M\", color=BLUE_B).scale(0.6).move_to(mellin_circle)\n        \n        transform_group = VGroup(arrow, gamma_circle, mellin_circle, gamma_label, mellin_label)\n        insight = Text(\"Reveals behavior at \u221e\", color=WHITE).scale(0.6).next_to(arrow, DOWN, buff=0.3)\n        \n        self.play(FadeOut(mellin_group, mellin_curve))\n        self.play(Create(transform_group))\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"The elegance of infinity\", color=GOLD_A).scale(0.7)\n        conclusion.move_to(ORIGIN)\n        \n        self.play(FadeOut(transform_group, insight, title_group))\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can you use the Mellin Transform to analyze the behavior of the Gamma function at infinity?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can you use the mellin transform to analyze the behavior of the gamma function at infinity?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MellinGammaScene(Scene):\n    def construct(self):\n        # Set background color to deep blue\n        self.camera.background_color = \"#0a0a2c\"  # This works in most versions\n        \n        # Title\n        title = Text(\"Unveiling Infinity\", color=GOLD_A).scale(0.8)\n        subtitle = Text(\"The Mellin Transform & The Gamma Function\", color=BLUE_B).scale(0.6)\n        title_group = VGroup(title, subtitle).arrange(DOWN)\n        \n        # Animation sequence\n        self.play(Write(title_group))\n        self.wait(1)\n        self.play(title_group.animate.to_edge(UP))\n        \n        # Gamma function with visual\n        gamma_text = Text(\"Gamma Function:\", color=GOLD_A).scale(0.7)\n        gamma_eq = MathTex(r\"\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} \\, dt\", color=WHITE)\n        gamma_group = VGroup(gamma_text, gamma_eq).arrange(DOWN).next_to(title_group, DOWN, buff=1)\n        \n        # Simple gamma visual - a curved line\n        gamma_curve = ParametricFunction(\n            lambda t: np.array([t, 0.5*np.exp(-t/2)*np.sin(t), 0]),\n            t_range=[0, 8, 0.1],\n            color=GOLD_A\n        ).scale(0.5).next_to(gamma_group, DOWN, buff=0.5)\n        \n        self.play(Write(gamma_group))\n        self.play(Create(gamma_curve))\n        self.wait(2)\n        \n        # Mellin Transform with visual\n        mellin_text = Text(\"Mellin Transform:\", color=BLUE_B).scale(0.7)\n        mellin_eq = MathTex(r\"\\mathcal{M}\\{\\Gamma(x)\\}(s) = \\int_0^\\infty \\Gamma(t) t^{s-1} \\, dt\", color=WHITE)\n        mellin_group = VGroup(mellin_text, mellin_eq).arrange(DOWN).next_to(title_group, DOWN, buff=1)\n        \n        # Simple mellin visual - a different curve\n        mellin_curve = ParametricFunction(\n            lambda t: np.array([t, 0.3*np.sin(t*2), 0]),\n            t_range=[0, 4, 0.1],\n            color=BLUE_B\n        ).scale(0.5).next_to(mellin_group, DOWN, buff=0.5)\n        \n        self.play(FadeOut(gamma_group, gamma_curve))\n        self.play(Write(mellin_group))\n        self.play(Create(mellin_curve))\n        self.wait(2)\n        \n        # Transformation visualization\n        arrow = Arrow(LEFT*2, RIGHT*2, color=WHITE).next_to(title_group, DOWN, buff=2)\n        gamma_circle = Circle(radius=0.5, color=GOLD_A).next_to(arrow, LEFT, buff=0.5)\n        mellin_circle = Circle(radius=0.5, color=BLUE_B).next_to(arrow, RIGHT, buff=0.5)\n        \n        gamma_label = Text(\"\u0393\", color=GOLD_A).scale(0.6).move_to(gamma_circle)\n        mellin_label = Text(\"M\", color=BLUE_B).scale(0.6).move_to(mellin_circle)\n        \n        transform_group = VGroup(arrow, gamma_circle, mellin_circle, gamma_label, mellin_label)\n        insight = Text(\"Reveals behavior at \u221e\", color=WHITE).scale(0.6).next_to(arrow, DOWN, buff=0.3)\n        \n        self.play(FadeOut(mellin_group, mellin_curve))\n        self.play(Create(transform_group))\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"The elegance of infinity\", color=GOLD_A).scale(0.7)\n        conclusion.move_to(ORIGIN)\n        \n        self.play(FadeOut(transform_group, insight, title_group))\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can you use the Mellin Transform to analyze the behavior of the Gamma function at infinity?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do generating functions offer a fresh perspective on solving the classic Towers of Hanoi puzzle?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TowersOfHanoiScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unlocking the Towers of Hanoi with Generating Functions\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Element 1: Towers of Hanoi Setup\n        # Create three pegs\n        pegs = VGroup()\n        for i in range(3):\n            peg = Line(start=DOWN, end=2*UP, color=GRAY)\n            peg.move_to((-3 + 3*i) * RIGHT)\n            pegs.add(peg)\n        \n        base = Line(start=(-4)*RIGHT, end=(4)*RIGHT, color=GRAY)\n        base.move_to(DOWN)\n        \n        # Create discs of different sizes\n        discs = VGroup()\n        colors = [BLUE_E, BLUE_D, BLUE_C]\n        for i in range(3):\n            disc = Rectangle(width=2 - 0.3*i, height=0.3, color=colors[i], fill_opacity=1)\n            disc.move_to((-3) * RIGHT + (DOWN - 0.15 - 0.3*i))\n            discs.add(disc)\n        \n        puzzle_label = Text(\"The Towers of Hanoi Puzzle\", font_size=28)\n        puzzle_label.to_edge(UP)\n        \n        self.play(Create(pegs), Create(base))\n        self.play(Write(puzzle_label))\n        self.play(FadeIn(discs))\n        self.wait(1)\n        \n        # Element 2: Movement Rule\n        rule_text = Text(\"No larger disc on a smaller one\", font_size=28)\n        rule_text.to_edge(UP)\n        \n        # Move a disc to demonstrate the rule\n        self.play(FadeOut(puzzle_label))\n        self.play(Write(rule_text))\n        self.play(discs[2].animate.move_to((0) * RIGHT + (DOWN - 0.15)))\n        self.wait(1)\n        \n        # Element 3: Introducing Generating Functions\n        gf_text = Text(\"Generating Functions\", font_size=36)\n        gf_text.to_edge(UP)\n        \n        self.play(FadeOut(rule_text))\n        self.play(Write(gf_text))\n        self.wait(1)\n        \n        # Element 4: Recursive Formula\n        rec_text = Text(\"Recursive Formula\", font_size=28)\n        rec_text.to_edge(UP)\n        \n        eq1 = Text(\"S(n) = 2S(n-1) + 1\", font_size=36)\n        \n        self.play(FadeOut(gf_text))\n        self.play(Write(rec_text))\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Element 5: Generating Function\n        gf_formula_text = Text(\"Generating Function\", font_size=28)\n        gf_formula_text.to_edge(UP)\n        \n        eq2 = Text(\"T(x) = 1/(1-2x)\", font_size=36)\n        \n        self.play(FadeOut(rec_text), FadeOut(eq1))\n        self.play(Write(gf_formula_text))\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Element 6: Conclusion\n        conclusion_text = Text(\"Elegance in Simplicity\", font_size=36)\n        \n        self.play(FadeOut(gf_formula_text), FadeOut(eq2))\n        self.play(FadeOut(discs), FadeOut(pegs), FadeOut(base))\n        self.play(Write(conclusion_text))\n        self.wait(1)\n        \n        # Final display of solved towers\n        pegs_final = VGroup()\n        for i in range(3):\n            peg = Line(start=DOWN, end=2*UP, color=GRAY)\n            peg.move_to((-3 + 3*i) * RIGHT)\n            pegs_final.add(peg)\n        \n        base_final = Line(start=(-4)*RIGHT, end=(4)*RIGHT, color=GRAY)\n        base_final.move_to(DOWN)\n        \n        # Create discs in the solved state\n        discs_final = VGroup()\n        for i in range(3):\n            disc = Rectangle(width=2 - 0.3*i, height=0.3, color=colors[i], fill_opacity=1)\n            disc.move_to((3) * RIGHT + (DOWN - 0.15 - 0.3*i))\n            discs_final.add(disc)\n        \n        self.play(FadeOut(conclusion_text))\n        self.play(Create(pegs_final), Create(base_final))\n        self.play(FadeIn(discs_final))\n        \n        final_title = Text(\"Towers of Hanoi with Generating Functions\", font_size=28)\n        final_title.to_edge(DOWN)\n        self.play(Write(final_title))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do generating functions offer a fresh perspective on solving the classic Towers of Hanoi puzzle?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do generating functions offer a fresh perspective on solving the classic towers of hanoi puzzle?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TowersOfHanoiScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unlocking the Towers of Hanoi with Generating Functions\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Element 1: Towers of Hanoi Setup\n        # Create three pegs\n        pegs = VGroup()\n        for i in range(3):\n            peg = Line(start=DOWN, end=2*UP, color=GRAY)\n            peg.move_to((-3 + 3*i) * RIGHT)\n            pegs.add(peg)\n        \n        base = Line(start=(-4)*RIGHT, end=(4)*RIGHT, color=GRAY)\n        base.move_to(DOWN)\n        \n        # Create discs of different sizes\n        discs = VGroup()\n        colors = [BLUE_E, BLUE_D, BLUE_C]\n        for i in range(3):\n            disc = Rectangle(width=2 - 0.3*i, height=0.3, color=colors[i], fill_opacity=1)\n            disc.move_to((-3) * RIGHT + (DOWN - 0.15 - 0.3*i))\n            discs.add(disc)\n        \n        puzzle_label = Text(\"The Towers of Hanoi Puzzle\", font_size=28)\n        puzzle_label.to_edge(UP)\n        \n        self.play(Create(pegs), Create(base))\n        self.play(Write(puzzle_label))\n        self.play(FadeIn(discs))\n        self.wait(1)\n        \n        # Element 2: Movement Rule\n        rule_text = Text(\"No larger disc on a smaller one\", font_size=28)\n        rule_text.to_edge(UP)\n        \n        # Move a disc to demonstrate the rule\n        self.play(FadeOut(puzzle_label))\n        self.play(Write(rule_text))\n        self.play(discs[2].animate.move_to((0) * RIGHT + (DOWN - 0.15)))\n        self.wait(1)\n        \n        # Element 3: Introducing Generating Functions\n        gf_text = Text(\"Generating Functions\", font_size=36)\n        gf_text.to_edge(UP)\n        \n        self.play(FadeOut(rule_text))\n        self.play(Write(gf_text))\n        self.wait(1)\n        \n        # Element 4: Recursive Formula\n        rec_text = Text(\"Recursive Formula\", font_size=28)\n        rec_text.to_edge(UP)\n        \n        eq1 = Text(\"S(n) = 2S(n-1) + 1\", font_size=36)\n        \n        self.play(FadeOut(gf_text))\n        self.play(Write(rec_text))\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Element 5: Generating Function\n        gf_formula_text = Text(\"Generating Function\", font_size=28)\n        gf_formula_text.to_edge(UP)\n        \n        eq2 = Text(\"T(x) = 1/(1-2x)\", font_size=36)\n        \n        self.play(FadeOut(rec_text), FadeOut(eq1))\n        self.play(Write(gf_formula_text))\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Element 6: Conclusion\n        conclusion_text = Text(\"Elegance in Simplicity\", font_size=36)\n        \n        self.play(FadeOut(gf_formula_text), FadeOut(eq2))\n        self.play(FadeOut(discs), FadeOut(pegs), FadeOut(base))\n        self.play(Write(conclusion_text))\n        self.wait(1)\n        \n        # Final display of solved towers\n        pegs_final = VGroup()\n        for i in range(3):\n            peg = Line(start=DOWN, end=2*UP, color=GRAY)\n            peg.move_to((-3 + 3*i) * RIGHT)\n            pegs_final.add(peg)\n        \n        base_final = Line(start=(-4)*RIGHT, end=(4)*RIGHT, color=GRAY)\n        base_final.move_to(DOWN)\n        \n        # Create discs in the solved state\n        discs_final = VGroup()\n        for i in range(3):\n            disc = Rectangle(width=2 - 0.3*i, height=0.3, color=colors[i], fill_opacity=1)\n            disc.move_to((3) * RIGHT + (DOWN - 0.15 - 0.3*i))\n            discs_final.add(disc)\n        \n        self.play(FadeOut(conclusion_text))\n        self.play(Create(pegs_final), Create(base_final))\n        self.play(FadeIn(discs_final))\n        \n        final_title = Text(\"Towers of Hanoi with Generating Functions\", font_size=28)\n        final_title.to_edge(DOWN)\n        self.play(Write(final_title))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do generating functions offer a fresh perspective on solving the classic Towers of Hanoi puzzle?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational math animation that visually explains the concept of finding the area under a curve using definite integration. The animation should start by displaying the integral of x squared from 0 to 3. Then, there should be a highlight around the x squared function to emphasize it. Following this, I'd like the animation to include a sentence that mentions the definite integral represents the area under the curve. Next, the animation should show the process of integrating x squared from 0 to 3, step by step, and end by calculating the exact area value numerically. After the calculation is complete, clear everything away and just show the final numerical answer. Can this all be done in an animated sequence that's easy to follow and educational?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        diff_eq = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation1 = Text(\"Separate the variables\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Separated equation\n        sep_eq = MathTex(r\"\\frac{dy}{dx} = 3y\")\n        self.play(ReplacementTransform(diff_eq.copy(), sep_eq))\n        self.wait(1)\n\n        # Integrating both sides\n        explanation2 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrated equation\n        integrated_eq = MathTex(r\"\\ln|y| = 3x + C\")\n        self.play(ReplacementTransform(sep_eq, integrated_eq))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"y = C e^{3x}\")\n        self.play(Write(final_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clean up the scene\n        self.play(FadeOut(integrated_eq), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational math animation that visually explains the concept of finding the area under a curve using definite integration. The animation should start by displaying the integral of x squared from 0 to 3. Then, there should be a highlight around the x squared function to emphasize it. Following this, I'd like the animation to include a sentence that mentions the definite integral represents the area under the curve. Next, the animation should show the process of integrating x squared from 0 to 3, step by step, and end by calculating the exact area value numerically. After the calculation is complete, clear everything away and just show the final numerical answer. Can this all be done in an animated sequence that's easy to follow and educational?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational math animation that visually explains the concept of finding the area under a curve using definite integration. the animation should start by displaying the integral of x squared from 0 to 3. then, there should be a highlight around the x squared function to emphasize it. following this, i'd like the animation to include a sentence that mentions the definite integral represents the area under the curve. next, the animation should show the process of integrating x squared from 0 to 3, step by step, and end by calculating the exact area value numerically. after the calculation is complete, clear everything away and just show the final numerical answer. can this all be done in an animated sequence that's easy to follow and educational?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the differential equation\n        diff_eq = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Explanation for separation of variables\n        explanation1 = Text(\"Separate the variables\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Separated equation\n        sep_eq = MathTex(r\"\\frac{dy}{dx} = 3y\")\n        self.play(ReplacementTransform(diff_eq.copy(), sep_eq))\n        self.wait(1)\n\n        # Integrating both sides\n        explanation2 = Text(\"Integrate both sides\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integrated equation\n        integrated_eq = MathTex(r\"\\ln|y| = 3x + C\")\n        self.play(ReplacementTransform(sep_eq, integrated_eq))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"y = C e^{3x}\")\n        self.play(Write(final_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Clean up the scene\n        self.play(FadeOut(integrated_eq), FadeOut(explanation1))\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational math animation that visually explains the concept of finding the area under a curve using definite integration. The animation should start by displaying the integral of x squared from 0 to 3. Then, there should be a highlight around the x squared function to emphasize it. Following this, I'd like the animation to include a sentence that mentions the definite integral represents the area under the curve. Next, the animation should show the process of integrating x squared from 0 to 3, step by step, and end by calculating the exact area value numerically. After the calculation is complete, clear everything away and just show the final numerical answer. Can this all be done in an animated sequence that's easy to follow and educational?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the structure of the Hilbert Scheme of points on a plane, and how does it relate to configurations of those points?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HilbertSchemeExploration(Scene):\n    def construct(self):\n        # Title slide\n        title = Text(\"Exploring the Dance of Points\", font_size=40)\n        subtitle = Text(\"Hilbert Schemes Unveiled\", font_size=32)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a simple coordinate system\n        axes = Axes(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n        )\n        self.play(Create(axes))\n        \n        # Create initial points\n        point1 = Dot(axes.coords_to_point(-1, 1), color=BLUE)\n        point2 = Dot(axes.coords_to_point(1, 1), color=BLUE)\n        point3 = Dot(axes.coords_to_point(0, -1), color=BLUE)\n        \n        # Add points\n        self.play(Create(point1), Create(point2), Create(point3))\n        \n        # Text explanation\n        text1 = Text(\"Points on a plane\", font_size=32)\n        text1.to_edge(UP)\n        self.play(Write(text1))\n        self.wait(1)\n        \n        # Show points merging\n        text2 = Text(\"Points can merge together\", font_size=32)\n        text2.to_edge(UP)\n        self.play(FadeOut(text1))\n        self.play(Write(text2))\n        \n        # Merge two points\n        self.play(\n            point1.animate.move_to(axes.coords_to_point(0, 1)),\n            point2.animate.move_to(axes.coords_to_point(0, 1))\n        )\n        \n        merged_point = Dot(axes.coords_to_point(0, 1), color=RED)\n        self.play(FadeOut(point1), FadeOut(point2))\n        self.play(Create(merged_point))\n        self.wait(1)\n        \n        # Show Hilbert Scheme\n        text3 = Text(\"Hilbert Scheme Structure\", font_size=32)\n        text3.to_edge(UP)\n        self.play(FadeOut(text2))\n        self.play(Write(text3))\n        \n        # Simple equation\n        equation = MathTex(\"H = \\\\{x,y|m_1,m_2,\\\\ldots,m_n\\\\}\")\n        self.play(Write(equation))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(text3), FadeOut(equation), \n                  FadeOut(merged_point), FadeOut(point3), FadeOut(axes))\n        \n        conclusion = Text(\"The Hilbert Scheme reveals the dance of points\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the structure of the Hilbert Scheme of points on a plane, and how does it relate to configurations of those points?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the structure of the hilbert scheme of points on a plane, and how does it relate to configurations of those points?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HilbertSchemeExploration(Scene):\n    def construct(self):\n        # Title slide\n        title = Text(\"Exploring the Dance of Points\", font_size=40)\n        subtitle = Text(\"Hilbert Schemes Unveiled\", font_size=32)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a simple coordinate system\n        axes = Axes(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n        )\n        self.play(Create(axes))\n        \n        # Create initial points\n        point1 = Dot(axes.coords_to_point(-1, 1), color=BLUE)\n        point2 = Dot(axes.coords_to_point(1, 1), color=BLUE)\n        point3 = Dot(axes.coords_to_point(0, -1), color=BLUE)\n        \n        # Add points\n        self.play(Create(point1), Create(point2), Create(point3))\n        \n        # Text explanation\n        text1 = Text(\"Points on a plane\", font_size=32)\n        text1.to_edge(UP)\n        self.play(Write(text1))\n        self.wait(1)\n        \n        # Show points merging\n        text2 = Text(\"Points can merge together\", font_size=32)\n        text2.to_edge(UP)\n        self.play(FadeOut(text1))\n        self.play(Write(text2))\n        \n        # Merge two points\n        self.play(\n            point1.animate.move_to(axes.coords_to_point(0, 1)),\n            point2.animate.move_to(axes.coords_to_point(0, 1))\n        )\n        \n        merged_point = Dot(axes.coords_to_point(0, 1), color=RED)\n        self.play(FadeOut(point1), FadeOut(point2))\n        self.play(Create(merged_point))\n        self.wait(1)\n        \n        # Show Hilbert Scheme\n        text3 = Text(\"Hilbert Scheme Structure\", font_size=32)\n        text3.to_edge(UP)\n        self.play(FadeOut(text2))\n        self.play(Write(text3))\n        \n        # Simple equation\n        equation = MathTex(\"H = \\\\{x,y|m_1,m_2,\\\\ldots,m_n\\\\}\")\n        self.play(Write(equation))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(text3), FadeOut(equation), \n                  FadeOut(merged_point), FadeOut(point3), FadeOut(axes))\n        \n        conclusion = Text(\"The Hilbert Scheme reveals the dance of points\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the structure of the Hilbert Scheme of points on a plane, and how does it relate to configurations of those points?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like to create an animation where a text element transitions into another text that says \"animate.match_width\" and moves upwards, followed by a square changing its width to match the width of a larger circle, with both the square and the circle then disappearing. Can this be done in a simple and visually appealing way, possibly with a quick transition for the text and a smooth transformation for the square?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_0^4 (4 - x^2) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the graph\n        graph = FunctionGraph(lambda x: 4 - x**2, x_range=[0, 4])\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Shade the area under the curve\n        area = graph.get_area(x_range=(0, 4), color=BLUE, opacity=0.3)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Integration to find the area\n        integration_step = MathTex(r\"= [4x - \\frac{x^3}{3}]_0^4\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Explanation for the definite integral\n        explanation2 = Text(\"Evaluate the definite integral for the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= (4 \\cdot 4) - \\frac{4^3}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{32}{3}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer.move_to(ORIGIN)))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animation where a text element transitions into another text that says \"animate.match_width\" and moves upwards, followed by a square changing its width to match the width of a larger circle, with both the square and the circle then disappearing. Can this be done in a simple and visually appealing way, possibly with a quick transition for the text and a smooth transformation for the square?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like to create an animation where a text element transitions into another text that says \"animate.match_width\" and moves upwards, followed by a square changing its width to match the width of a larger circle, with both the square and the circle then disappearing. can this be done in a simple and visually appealing way, possibly with a quick transition for the text and a smooth transformation for the square?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_0^4 (4 - x^2) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the area under the curve\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show the graph\n        graph = FunctionGraph(lambda x: 4 - x**2, x_range=[0, 4])\n        self.play(Create(graph))\n        self.wait(2)\n\n        # Shade the area under the curve\n        area = graph.get_area(x_range=(0, 4), color=BLUE, opacity=0.3)\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Integration to find the area\n        integration_step = MathTex(r\"= [4x - \\frac{x^3}{3}]_0^4\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(2)\n\n        # Explanation for the definite integral\n        explanation2 = Text(\"Evaluate the definite integral for the area\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= (4 \\cdot 4) - \\frac{4^3}{3}\")\n        self.play(ReplacementTransform(integration_step, final_solution))\n        self.wait(1)\n\n        final_answer = MathTex(r\"= \\frac{32}{3}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_answer.move_to(ORIGIN)))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animation where a text element transitions into another text that says \"animate.match_width\" and moves upwards, followed by a square changing its width to match the width of a larger circle, with both the square and the circle then disappearing. Can this be done in a simple and visually appealing way, possibly with a quick transition for the text and a smooth transformation for the square?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an educational math animation that shows the process of finding the area under the curve of the function f(x) = 0.1(x - 3)^2 + 1 from x = 0 to x = 5. The animation should start by displaying the problem, which is the integral of the function from 0 to 5. Then, I want the animation to show the curve and a shaded area beneath it to represent the area we are trying to find. After that, please include text that explains the shaded region is the area under the curve. Next, can you animate step-by-step computations of the integral, showing each step of the antiderivative calculation and evaluation at the bounds, resulting in the final numeric answer? Lastly, clear the screen and display the final result in isolation at the end of the animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ConcentricCirclesScene(Scene):\n    def construct(self):\n        circles = VGroup(*[\n            Circle(radius=i*0.2, stroke_width=15 - i*2, stroke_opacity=0.5).set_color(color=[RED, BLUE])\n            for i in range(1, 15)\n        ])\n        circles.arrange_in_grid(rows=1)\n        self.play(Create(circles), run_time=3)\n        self.wait(1)\n        self.play(circles.animate.shift(UP * 2), run_time=1)\n        self.play(circles.animate.scale(0.5), run_time=1)\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational math animation that shows the process of finding the area under the curve of the function f(x) = 0.1(x - 3)^2 + 1 from x = 0 to x = 5. The animation should start by displaying the problem, which is the integral of the function from 0 to 5. Then, I want the animation to show the curve and a shaded area beneath it to represent the area we are trying to find. After that, please include text that explains the shaded region is the area under the curve. Next, can you animate step-by-step computations of the integral, showing each step of the antiderivative calculation and evaluation at the bounds, resulting in the final numeric answer? Lastly, clear the screen and display the final result in isolation at the end of the animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an educational math animation that shows the process of finding the area under the curve of the function f(x) = 0.1(x - 3)^2 + 1 from x = 0 to x = 5. the animation should start by displaying the problem, which is the integral of the function from 0 to 5. then, i want the animation to show the curve and a shaded area beneath it to represent the area we are trying to find. after that, please include text that explains the shaded region is the area under the curve. next, can you animate step-by-step computations of the integral, showing each step of the antiderivative calculation and evaluation at the bounds, resulting in the final numeric answer? lastly, clear the screen and display the final result in isolation at the end of the animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ConcentricCirclesScene(Scene):\n    def construct(self):\n        circles = VGroup(*[\n            Circle(radius=i*0.2, stroke_width=15 - i*2, stroke_opacity=0.5).set_color(color=[RED, BLUE])\n            for i in range(1, 15)\n        ])\n        circles.arrange_in_grid(rows=1)\n        self.play(Create(circles), run_time=3)\n        self.wait(1)\n        self.play(circles.animate.shift(UP * 2), run_time=1)\n        self.play(circles.animate.scale(0.5), run_time=1)\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an educational math animation that shows the process of finding the area under the curve of the function f(x) = 0.1(x - 3)^2 + 1 from x = 0 to x = 5. The animation should start by displaying the problem, which is the integral of the function from 0 to 5. Then, I want the animation to show the curve and a shaded area beneath it to represent the area we are trying to find. After that, please include text that explains the shaded region is the area under the curve. Next, can you animate step-by-step computations of the integral, showing each step of the antiderivative calculation and evaluation at the bounds, resulting in the final numeric answer? Lastly, clear the screen and display the final result in isolation at the end of the animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation using Manim that explains the basics of Fourier Series to me? Start by showing the mathematical definition of Fourier Series. Then provide a simple text explanation about the concept and how it represents functions with sines and cosines. Next, introduce the coefficients of the series and explain that they're found through integration. After that, mention under what conditions the Fourier Series will converge to the function. Lastly, conclude by displaying a graph of a sample function like a sine wave, then clear everything away to complete the lesson."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE}\n        )\n\n        func_graph = axes.plot(lambda x: x**2, color=GREEN)\n        derivative_graph = axes.plot(lambda x: 2 * x, color=ORANGE)\n\n        tangent_line = always_redraw(\n            lambda: axes.get_tangent_line(\n                x=1, \n                graph=func_graph, \n                length=4, \n                line_color=PURPLE\n            )\n        )\n        \n        self.play(Create(axes), Create(func_graph))\n        self.wait(1)\n\n        self.play(Write(derivative_graph), run_time=2)\n        self.wait(1)\n\n        self.play(Create(tangent_line), run_time=2)\n        self.wait(2)\n\n        explanation = Tex(r\"The tangent line at $x=1$ represents \\\\ the derivative of $x^2$, which is $2x$.\")\n        explanation.next_to(tangent_line, UP)\n        explanation.shift(RIGHT*3)\n\n        self.play(Write(explanation))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation using Manim that explains the basics of Fourier Series to me? Start by showing the mathematical definition of Fourier Series. Then provide a simple text explanation about the concept and how it represents functions with sines and cosines. Next, introduce the coefficients of the series and explain that they're found through integration. After that, mention under what conditions the Fourier Series will converge to the function. Lastly, conclude by displaying a graph of a sample function like a sine wave, then clear everything away to complete the lesson."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation using manim that explains the basics of fourier series to me? start by showing the mathematical definition of fourier series. then provide a simple text explanation about the concept and how it represents functions with sines and cosines. next, introduce the coefficients of the series and explain that they're found through integration. after that, mention under what conditions the fourier series will converge to the function. lastly, conclude by displaying a graph of a sample function like a sine wave, then clear everything away to complete the lesson."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DerivativeConcept(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE}\n        )\n\n        func_graph = axes.plot(lambda x: x**2, color=GREEN)\n        derivative_graph = axes.plot(lambda x: 2 * x, color=ORANGE)\n\n        tangent_line = always_redraw(\n            lambda: axes.get_tangent_line(\n                x=1, \n                graph=func_graph, \n                length=4, \n                line_color=PURPLE\n            )\n        )\n        \n        self.play(Create(axes), Create(func_graph))\n        self.wait(1)\n\n        self.play(Write(derivative_graph), run_time=2)\n        self.wait(1)\n\n        self.play(Create(tangent_line), run_time=2)\n        self.wait(2)\n\n        explanation = Tex(r\"The tangent line at $x=1$ represents \\\\ the derivative of $x^2$, which is $2x$.\")\n        explanation.next_to(tangent_line, UP)\n        explanation.shift(RIGHT*3)\n\n        self.play(Write(explanation))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation using Manim that explains the basics of Fourier Series to me? Start by showing the mathematical definition of Fourier Series. Then provide a simple text explanation about the concept and how it represents functions with sines and cosines. Next, introduce the coefficients of the series and explain that they're found through integration. After that, mention under what conditions the Fourier Series will converge to the function. Lastly, conclude by displaying a graph of a sample function like a sine wave, then clear everything away to complete the lesson."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_convolutional_2d_layer.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass SingleConvolutionalLayerScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        layers = [Convolutional2DLayer(3, 4)]\n        nn = NeuralNetwork(layers)\n        nn.scale(1.3)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        self.set_camera_orientation(\n            phi=280 * DEGREES, theta=-10 * DEGREES, gamma=90 * DEGREES\n        )\n        # self.play(nn.make_forward_pass_animation(run_time=5))\n\n\nclass Simple3DConvScene(ThreeDScene):\n    def construct(self):\n        \"\"\"\n        TODO\n        - [X] Make grid lines for the CNN filters\n        - [ ] Make Scanning filter effect\n        - [ ] Have filter box go accross each input feature map\n        - [ ] Make filter lines effect\n        - [ ] Make flowing animation down filter lines\n        \"\"\"\n        # Make nn\n        layers = [\n            Convolutional2DLayer(num_feature_maps=1, feature_map_size=3, filter_size=3),\n            Convolutional2DLayer(num_feature_maps=1, feature_map_size=3, filter_size=3),\n        ]\n        nn = NeuralNetwork(layers)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        # self.set_camera_orientation(phi=280*DEGREES, theta=-10*DEGREES, gamma=90*DEGREES)\n        self.play(nn.make_forward_pass_animation(run_time=30))\n\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_convolutional_2d_layer.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_convolutional_2d_layer.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n\nclass SingleConvolutionalLayerScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        layers = [Convolutional2DLayer(3, 4)]\n        nn = NeuralNetwork(layers)\n        nn.scale(1.3)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        self.set_camera_orientation(\n            phi=280 * DEGREES, theta=-10 * DEGREES, gamma=90 * DEGREES\n        )\n        # self.play(nn.make_forward_pass_animation(run_time=5))\n\n\nclass Simple3DConvScene(ThreeDScene):\n    def construct(self):\n        \"\"\"\n        TODO\n        - [X] Make grid lines for the CNN filters\n        - [ ] Make Scanning filter effect\n        - [ ] Have filter box go accross each input feature map\n        - [ ] Make filter lines effect\n        - [ ] Make flowing animation down filter lines\n        \"\"\"\n        # Make nn\n        layers = [\n            Convolutional2DLayer(num_feature_maps=1, feature_map_size=3, filter_size=3),\n            Convolutional2DLayer(num_feature_maps=1, feature_map_size=3, filter_size=3),\n        ]\n        nn = NeuralNetwork(layers)\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        # self.set_camera_orientation(phi=280*DEGREES, theta=-10*DEGREES, gamma=90*DEGREES)\n        self.play(nn.make_forward_pass_animation(run_time=30))\n\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_convolutional_2d_layer.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a blue rectangle at the center of the screen with a translucent gray copy behind it for reference. A number is shown at the top edge of the screen, dynamically updating to reflect the rectangle\u2019s height. The rectangle then smoothly grows taller until its height reaches 5 units, while the number updates in real time."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeightExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.height))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(height=5))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue rectangle at the center of the screen with a translucent gray copy behind it for reference. A number is shown at the top edge of the screen, dynamically updating to reflect the rectangle\u2019s height. The rectangle then smoothly grows taller until its height reaches 5 units, while the number updates in real time."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a blue rectangle at the center of the screen with a translucent gray copy behind it for reference. a number is shown at the top edge of the screen, dynamically updating to reflect the rectangle\u2019s height. the rectangle then smoothly grows taller until its height reaches 5 units, while the number updates in real time."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeightExample(Scene):\n    def construct(self):\n        decimal = DecimalNumber().to_edge(UP)\n        rect = Rectangle(color=BLUE)\n        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n        decimal.add_updater(lambda d: d.set_value(rect.height))\n\n        self.add(rect_copy, rect, decimal)\n        self.play(rect.animate.set(height=5))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue rectangle at the center of the screen with a translucent gray copy behind it for reference. A number is shown at the top edge of the screen, dynamically updating to reflect the rectangle\u2019s height. The rectangle then smoothly grows taller until its height reaches 5 units, while the number updates in real time."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can Cauchy's Integral Formula be adapted to elucidate the behavior of multi-valued functions, such as logarithm or power functions, across branch cuts?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BranchCutsExploration(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating Branch Cuts\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction to Cauchy's Integral Formula\n        cauchy_formula = MathTex(r\"f(z) = \\frac{1}{2\\pi i} \\int_\\gamma \\frac{f(\\zeta)}{\\zeta - z} d\\zeta\")\n        self.play(Write(cauchy_formula))\n        self.wait(1)\n        \n        # Create a simple complex plane and clear formula\n        self.play(FadeOut(cauchy_formula))\n        \n        plane = NumberPlane(\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n        ).scale(0.7)\n        \n        plane_label = Text(\"Complex Plane\", font_size=18).next_to(plane, DOWN)\n        \n        self.play(FadeIn(plane), Write(plane_label))\n        \n        # A simple closed contour\n        contour = Circle(radius=1, color=YELLOW).move_to(plane.get_center())\n        contour_label = Text(\"Contour \u03b3\", font_size=18).next_to(contour, UP)\n        \n        self.play(Create(contour), Write(contour_label))\n        self.wait(1)\n        \n        # Introduce multi-valued functions\n        multi_eq1 = MathTex(r\"w = \\log z\")\n        multi_eq2 = MathTex(r\"w = z^n\")\n        \n        multi_group = VGroup(multi_eq1, multi_eq2).arrange(DOWN).to_edge(RIGHT).shift(LEFT * 2)\n        \n        self.play(Write(multi_group))\n        self.wait(1)\n        \n        # Introduce branch cut\n        branch_cut = Line(\n            start=plane.get_center(),\n            end=plane.get_center() + RIGHT * 2,\n            color=PURPLE,\n            stroke_width=4\n        )\n        branch_cut_label = Text(\"Branch Cut\", font_size=18).next_to(branch_cut, DOWN)\n        \n        self.play(Create(branch_cut), Write(branch_cut_label))\n        self.wait(1)\n        \n        # Path crossing branch cut\n        path = Arrow(\n            start=plane.get_center() + LEFT + UP,\n            end=plane.get_center() + RIGHT * 1.5 + DOWN * 0.5,\n            color=GREEN,\n            stroke_width=3\n        )\n        \n        path_label = Text(\"Path crosses branch cut\", font_size=18).to_edge(DOWN)\n        \n        self.play(Create(path), Write(path_label))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(plane), FadeOut(contour), FadeOut(contour_label),\n            FadeOut(branch_cut), FadeOut(branch_cut_label),\n            FadeOut(path), FadeOut(path_label), FadeOut(multi_group),\n            FadeOut(plane_label)\n        )\n        \n        conclusion = Text(\"Branch cuts allow Cauchy's formula to work with multi-valued functions\", font_size=24)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can Cauchy's Integral Formula be adapted to elucidate the behavior of multi-valued functions, such as logarithm or power functions, across branch cuts?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can cauchy's integral formula be adapted to elucidate the behavior of multi-valued functions, such as logarithm or power functions, across branch cuts?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BranchCutsExploration(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating Branch Cuts\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction to Cauchy's Integral Formula\n        cauchy_formula = MathTex(r\"f(z) = \\frac{1}{2\\pi i} \\int_\\gamma \\frac{f(\\zeta)}{\\zeta - z} d\\zeta\")\n        self.play(Write(cauchy_formula))\n        self.wait(1)\n        \n        # Create a simple complex plane and clear formula\n        self.play(FadeOut(cauchy_formula))\n        \n        plane = NumberPlane(\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n        ).scale(0.7)\n        \n        plane_label = Text(\"Complex Plane\", font_size=18).next_to(plane, DOWN)\n        \n        self.play(FadeIn(plane), Write(plane_label))\n        \n        # A simple closed contour\n        contour = Circle(radius=1, color=YELLOW).move_to(plane.get_center())\n        contour_label = Text(\"Contour \u03b3\", font_size=18).next_to(contour, UP)\n        \n        self.play(Create(contour), Write(contour_label))\n        self.wait(1)\n        \n        # Introduce multi-valued functions\n        multi_eq1 = MathTex(r\"w = \\log z\")\n        multi_eq2 = MathTex(r\"w = z^n\")\n        \n        multi_group = VGroup(multi_eq1, multi_eq2).arrange(DOWN).to_edge(RIGHT).shift(LEFT * 2)\n        \n        self.play(Write(multi_group))\n        self.wait(1)\n        \n        # Introduce branch cut\n        branch_cut = Line(\n            start=plane.get_center(),\n            end=plane.get_center() + RIGHT * 2,\n            color=PURPLE,\n            stroke_width=4\n        )\n        branch_cut_label = Text(\"Branch Cut\", font_size=18).next_to(branch_cut, DOWN)\n        \n        self.play(Create(branch_cut), Write(branch_cut_label))\n        self.wait(1)\n        \n        # Path crossing branch cut\n        path = Arrow(\n            start=plane.get_center() + LEFT + UP,\n            end=plane.get_center() + RIGHT * 1.5 + DOWN * 0.5,\n            color=GREEN,\n            stroke_width=3\n        )\n        \n        path_label = Text(\"Path crosses branch cut\", font_size=18).to_edge(DOWN)\n        \n        self.play(Create(path), Write(path_label))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(plane), FadeOut(contour), FadeOut(contour_label),\n            FadeOut(branch_cut), FadeOut(branch_cut_label),\n            FadeOut(path), FadeOut(path_label), FadeOut(multi_group),\n            FadeOut(plane_label)\n        )\n        \n        conclusion = Text(\"Branch cuts allow Cauchy's formula to work with multi-valued functions\", font_size=24)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can Cauchy's Integral Formula be adapted to elucidate the behavior of multi-valued functions, such as logarithm or power functions, across branch cuts?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that demonstrates the movement of an electron within a basic molecular structure. The molecular structure should be represented by a 3x3 grid with alternating positive and negative ions, somewhat like a simplistic visual representation of a molecular lattice. The animation should include a single electron that appears to be moving randomly across the grid following a defined, albeit intricate, path that makes the electron visit several locations before finally settling at the centre of the grid. I'd like to show this electron's path clearly with pauses in between to signify certain points of interest. The visualization should have a minimalist and educational style suitable for a basic chemistry lesson. Can you create an animation like that for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        # Create a hydrogen atom with one proton and one electron\n        electron_group = self.create_electron()\n        proton = self.create_proton()\n\n        # Create a hydrogen molecule (H2) by adding a second hydrogen atom\n        hydrogen_molecule = VGroup(proton, electron_group).arrange(RIGHT, buff=1)\n        second_hydrogen = hydrogen_molecule.copy().next_to(hydrogen_molecule, RIGHT, buff=0.2)\n        \n        # Combine the individual hydrogen atoms to form a molecule group\n        h2_molecule_group = VGroup(hydrogen_molecule, second_hydrogen)\n\n        # Show the construction of hydrogen molecule\n        self.play(Write(proton))\n        self.play(FadeIn(electron_group))\n        self.play(h2_molecule_group.animate.shift(LEFT*0.6))\n        self.play(FadeIn(second_hydrogen))\n        self.play(h2_molecule_group.animate.scale(0.8).move_to(ORIGIN))\n\n        self.wait(2)\n\n    # Helper function to create an electron\n    def create_electron(self):\n        electron_circle = Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        electron = Tex('e$^-$', color=WHITE, font_size=20).move_to(electron_circle.get_center())\n        return VGroup(electron_circle, electron)\n\n    # Helper function to create a proton\n    def create_proton(self):\n        proton_circle = Circle(radius=0.2, color=RED).set_fill(RED, opacity=0.5)\n        proton = Tex('p$^+$', color=WHITE, font_size=20).move_to(proton_circle.get_center())\n        return VGroup(proton_circle, proton)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that demonstrates the movement of an electron within a basic molecular structure. The molecular structure should be represented by a 3x3 grid with alternating positive and negative ions, somewhat like a simplistic visual representation of a molecular lattice. The animation should include a single electron that appears to be moving randomly across the grid following a defined, albeit intricate, path that makes the electron visit several locations before finally settling at the centre of the grid. I'd like to show this electron's path clearly with pauses in between to signify certain points of interest. The visualization should have a minimalist and educational style suitable for a basic chemistry lesson. Can you create an animation like that for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that demonstrates the movement of an electron within a basic molecular structure. the molecular structure should be represented by a 3x3 grid with alternating positive and negative ions, somewhat like a simplistic visual representation of a molecular lattice. the animation should include a single electron that appears to be moving randomly across the grid following a defined, albeit intricate, path that makes the electron visit several locations before finally settling at the centre of the grid. i'd like to show this electron's path clearly with pauses in between to signify certain points of interest. the visualization should have a minimalist and educational style suitable for a basic chemistry lesson. can you create an animation like that for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Hydrogen(Scene):\n    def construct(self):\n        # Create a hydrogen atom with one proton and one electron\n        electron_group = self.create_electron()\n        proton = self.create_proton()\n\n        # Create a hydrogen molecule (H2) by adding a second hydrogen atom\n        hydrogen_molecule = VGroup(proton, electron_group).arrange(RIGHT, buff=1)\n        second_hydrogen = hydrogen_molecule.copy().next_to(hydrogen_molecule, RIGHT, buff=0.2)\n        \n        # Combine the individual hydrogen atoms to form a molecule group\n        h2_molecule_group = VGroup(hydrogen_molecule, second_hydrogen)\n\n        # Show the construction of hydrogen molecule\n        self.play(Write(proton))\n        self.play(FadeIn(electron_group))\n        self.play(h2_molecule_group.animate.shift(LEFT*0.6))\n        self.play(FadeIn(second_hydrogen))\n        self.play(h2_molecule_group.animate.scale(0.8).move_to(ORIGIN))\n\n        self.wait(2)\n\n    # Helper function to create an electron\n    def create_electron(self):\n        electron_circle = Circle(radius=0.1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        electron = Tex('e$^-$', color=WHITE, font_size=20).move_to(electron_circle.get_center())\n        return VGroup(electron_circle, electron)\n\n    # Helper function to create a proton\n    def create_proton(self):\n        proton_circle = Circle(radius=0.2, color=RED).set_fill(RED, opacity=0.5)\n        proton = Tex('p$^+$', color=WHITE, font_size=20).move_to(proton_circle.get_center())\n        return VGroup(proton_circle, proton)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that demonstrates the movement of an electron within a basic molecular structure. The molecular structure should be represented by a 3x3 grid with alternating positive and negative ions, somewhat like a simplistic visual representation of a molecular lattice. The animation should include a single electron that appears to be moving randomly across the grid following a defined, albeit intricate, path that makes the electron visit several locations before finally settling at the centre of the grid. I'd like to show this electron's path clearly with pauses in between to signify certain points of interest. The visualization should have a minimalist and educational style suitable for a basic chemistry lesson. Can you create an animation like that for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation where different shapes appear one after another. First, I want a blue circle to grow from the center on the left side of the screen. Then, a green rectangle should fade in next to the blue circle on the right. Lastly, a red ellipse should grow from the top edge and appear next to the rectangle. Please make sure that each shape is clearly distinct and has some space between them. Can you also ensure that the animation pauses for a short while after the shapes appear so that the viewers can see the final result clearly?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral result\n        x_integral_result = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), x_integral_result))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral result\n        y_integral_result = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(x_integral_result, y_integral_result))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(y_integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion with result\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The result of the triple integral is:\", font_size=24).to_edge(UP)))\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation where different shapes appear one after another. First, I want a blue circle to grow from the center on the left side of the screen. Then, a green rectangle should fade in next to the blue circle on the right. Lastly, a red ellipse should grow from the top edge and appear next to the rectangle. Please make sure that each shape is clearly distinct and has some space between them. Can you also ensure that the animation pauses for a short while after the shapes appear so that the viewers can see the final result clearly?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation where different shapes appear one after another. first, i want a blue circle to grow from the center on the left side of the screen. then, a green rectangle should fade in next to the blue circle on the right. lastly, a red ellipse should grow from the top edge and appear next to the rectangle. please make sure that each shape is clearly distinct and has some space between them. can you also ensure that the animation pauses for a short while after the shapes appear so that the viewers can see the final result clearly?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dx\\,dy\\,dz\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"First, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral result\n        x_integral_result = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}x^2yz]_{0}^{1} \\,dy\\,dz\")\n        self.play(ReplacementTransform(problem.copy(), x_integral_result))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Next, integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral result\n        y_integral_result = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{2}y^2z]_{0}^{1} \\,dz\")\n        self.play(ReplacementTransform(x_integral_result, y_integral_result))\n        self.wait(1)\n\n        # Explanation for the outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and final solution\n        final_solution = MathTex(r\"= [\\frac{1}{2}z^2]_{0}^{1}\", r\"= \\frac{1}{2}\")\n        self.play(ReplacementTransform(y_integral_result, final_solution))\n        self.wait(1)\n\n        # Conclusion with result\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"The result of the triple integral is:\", font_size=24).to_edge(UP)))\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation where different shapes appear one after another. First, I want a blue circle to grow from the center on the left side of the screen. Then, a green rectangle should fade in next to the blue circle on the right. Lastly, a red ellipse should grow from the top edge and appear next to the rectangle. Please make sure that each shape is clearly distinct and has some space between them. Can you also ensure that the animation pauses for a short while after the shapes appear so that the viewers can see the final result clearly?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does topological invariance arise in Chern-Simons theory, and what implications does it have on gauge symmetries?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChernSimonsTopologicalInvariance(Scene):\n    def construct(self):\n        # Introduction\n        # Timestamp: Introduction\n        title = Text(\"Unraveling the Knots\", font_size=40, color=BLUE)\n        subtitle = Text(\"The Beauty of Chern-Simons Theory\", font_size=32, color=CYAN)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: Gauge Fields\n        # Timestamp: Key concept 1\n        concept1 = Text(\"Gauge Fields as Loops\", font_size=36, color=GREEN)\n        self.play(Write(concept1))\n        self.wait(0.5)\n        self.play(concept1.animate.to_edge(UP))\n        \n        # Simple visualization of a gauge field as a loop\n        loop = Circle(radius=1.5, color=BLUE)\n        self.play(Create(loop))\n        self.wait(1)\n        \n        # Key Concept 2: Topological Invariance\n        # Timestamp: Key concept 2\n        concept2 = Text(\"Topological Invariance\", font_size=28, color=YELLOW)\n        concept2.next_to(concept1, DOWN)\n        self.play(Write(concept2))\n        \n        # Transform the loop to show invariance (shape changes but topology remains)\n        deformed_loop = Ellipse(width=3.0, height=1.5, color=BLUE).shift(RIGHT*0.5)\n        self.play(Transform(loop, deformed_loop))\n        self.wait(1)\n        \n        # Clean up for next part\n        self.play(FadeOut(concept1), FadeOut(concept2), FadeOut(loop))\n        \n        # Key Concept 3: Chern-Simons Form\n        # Timestamp: Key concept 3\n        concept3 = Text(\"Chern-Simons Form\", font_size=36, color=MAGENTA)\n        self.play(Write(concept3))\n        self.wait(0.5)\n        self.play(concept3.animate.to_edge(UP))\n        \n        # Simplified Chern-Simons equation\n        cs_eq = Text(\"\u222b A \u2227 dA\", font_size=40, color=WHITE)\n        self.play(Write(cs_eq))\n        self.wait(1.5)\n        \n        # Additional equation (Wilson Loop) - simplified\n        wilson_eq = Text(\"W = exp(\u222e A\u00b7dx)\", font_size=40, color=WHITE)\n        wilson_eq.next_to(cs_eq, DOWN, buff=1)\n        self.play(Write(wilson_eq))\n        self.wait(1.5)\n        \n        # Clean up\n        self.play(FadeOut(concept3), FadeOut(cs_eq), FadeOut(wilson_eq))\n        \n        # Key Insight\n        # Timestamp: Key Insight\n        insight = Text(\"Topological Invariance in Gauge Theory\", font_size=36, color=YELLOW)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        # Timestamp: Conclusion\n        conclusion = Text(\"Revealing the universe's symmetries\", font_size=32, color=BLUE)\n        conclusion.next_to(insight, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything for clean ending\n        self.play(FadeOut(insight), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does topological invariance arise in Chern-Simons theory, and what implications does it have on gauge symmetries?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does topological invariance arise in chern-simons theory, and what implications does it have on gauge symmetries?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChernSimonsTopologicalInvariance(Scene):\n    def construct(self):\n        # Introduction\n        # Timestamp: Introduction\n        title = Text(\"Unraveling the Knots\", font_size=40, color=BLUE)\n        subtitle = Text(\"The Beauty of Chern-Simons Theory\", font_size=32, color=CYAN)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: Gauge Fields\n        # Timestamp: Key concept 1\n        concept1 = Text(\"Gauge Fields as Loops\", font_size=36, color=GREEN)\n        self.play(Write(concept1))\n        self.wait(0.5)\n        self.play(concept1.animate.to_edge(UP))\n        \n        # Simple visualization of a gauge field as a loop\n        loop = Circle(radius=1.5, color=BLUE)\n        self.play(Create(loop))\n        self.wait(1)\n        \n        # Key Concept 2: Topological Invariance\n        # Timestamp: Key concept 2\n        concept2 = Text(\"Topological Invariance\", font_size=28, color=YELLOW)\n        concept2.next_to(concept1, DOWN)\n        self.play(Write(concept2))\n        \n        # Transform the loop to show invariance (shape changes but topology remains)\n        deformed_loop = Ellipse(width=3.0, height=1.5, color=BLUE).shift(RIGHT*0.5)\n        self.play(Transform(loop, deformed_loop))\n        self.wait(1)\n        \n        # Clean up for next part\n        self.play(FadeOut(concept1), FadeOut(concept2), FadeOut(loop))\n        \n        # Key Concept 3: Chern-Simons Form\n        # Timestamp: Key concept 3\n        concept3 = Text(\"Chern-Simons Form\", font_size=36, color=MAGENTA)\n        self.play(Write(concept3))\n        self.wait(0.5)\n        self.play(concept3.animate.to_edge(UP))\n        \n        # Simplified Chern-Simons equation\n        cs_eq = Text(\"\u222b A \u2227 dA\", font_size=40, color=WHITE)\n        self.play(Write(cs_eq))\n        self.wait(1.5)\n        \n        # Additional equation (Wilson Loop) - simplified\n        wilson_eq = Text(\"W = exp(\u222e A\u00b7dx)\", font_size=40, color=WHITE)\n        wilson_eq.next_to(cs_eq, DOWN, buff=1)\n        self.play(Write(wilson_eq))\n        self.wait(1.5)\n        \n        # Clean up\n        self.play(FadeOut(concept3), FadeOut(cs_eq), FadeOut(wilson_eq))\n        \n        # Key Insight\n        # Timestamp: Key Insight\n        insight = Text(\"Topological Invariance in Gauge Theory\", font_size=36, color=YELLOW)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        # Timestamp: Conclusion\n        conclusion = Text(\"Revealing the universe's symmetries\", font_size=32, color=BLUE)\n        conclusion.next_to(insight, DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything for clean ending\n        self.play(FadeOut(insight), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does topological invariance arise in Chern-Simons theory, and what implications does it have on gauge symmetries?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can we classify the fixed points of a polynomial map under the action of a symmetric group?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InvariantTheoryScene(Scene):\n    def construct(self):\n        # Opening with a simple snowflake (hexagon)\n        snowflake = RegularPolygon(n=6, radius=2, color=BLUE)\n        \n        # Title\n        title = Text(\"Symmetry and Stability\", color=BLUE_D)\n        subtitle = Text(\"Fixed Points in Polynomial Maps\", font_size=24, color=PURPLE_B)\n        subtitle.next_to(title, DOWN)\n        \n        # Show the snowflake\n        self.play(Create(snowflake))\n        self.wait(0.5)\n        \n        # Show title\n        self.play(FadeOut(snowflake))\n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Simple axes - representing complex plane\n        axes = Axes(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n            axis_config={\"color\": BLUE}\n        )\n        x_label = Text(\"Re\", font_size=20).next_to(axes.x_axis, RIGHT)\n        y_label = Text(\"Im\", font_size=20).next_to(axes.y_axis, UP)\n        \n        self.play(Create(axes))\n        self.play(Write(x_label), Write(y_label))\n        self.wait(1)\n        \n        # Fixed point\n        point = Dot(point=[0, 0, 0], color=RED)\n        label = Text(\"Fixed Point\", color=RED).next_to(point, DOWN)\n        \n        self.play(Create(point))\n        self.play(Write(label))\n        self.wait(1)\n        \n        # Equation 1\n        eq1 = MathTex(r\"f(x) = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_0\", color=PURPLE)\n        eq1.to_edge(UP)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Equation 2\n        eq2 = MathTex(r\"S_n : \\{x | f(x) = x\\}\", color=PURPLE)\n        eq2.next_to(eq1, DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Symmetry in Mathematics\", color=BLUE_D)\n        \n        # Fade out everything together\n        self.play(\n            FadeOut(axes),\n            FadeOut(x_label),\n            FadeOut(y_label),\n            FadeOut(point),\n            FadeOut(label),\n            FadeOut(eq1),\n            FadeOut(eq2)\n        )\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we classify the fixed points of a polynomial map under the action of a symmetric group?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can we classify the fixed points of a polynomial map under the action of a symmetric group?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass InvariantTheoryScene(Scene):\n    def construct(self):\n        # Opening with a simple snowflake (hexagon)\n        snowflake = RegularPolygon(n=6, radius=2, color=BLUE)\n        \n        # Title\n        title = Text(\"Symmetry and Stability\", color=BLUE_D)\n        subtitle = Text(\"Fixed Points in Polynomial Maps\", font_size=24, color=PURPLE_B)\n        subtitle.next_to(title, DOWN)\n        \n        # Show the snowflake\n        self.play(Create(snowflake))\n        self.wait(0.5)\n        \n        # Show title\n        self.play(FadeOut(snowflake))\n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Simple axes - representing complex plane\n        axes = Axes(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n            axis_config={\"color\": BLUE}\n        )\n        x_label = Text(\"Re\", font_size=20).next_to(axes.x_axis, RIGHT)\n        y_label = Text(\"Im\", font_size=20).next_to(axes.y_axis, UP)\n        \n        self.play(Create(axes))\n        self.play(Write(x_label), Write(y_label))\n        self.wait(1)\n        \n        # Fixed point\n        point = Dot(point=[0, 0, 0], color=RED)\n        label = Text(\"Fixed Point\", color=RED).next_to(point, DOWN)\n        \n        self.play(Create(point))\n        self.play(Write(label))\n        self.wait(1)\n        \n        # Equation 1\n        eq1 = MathTex(r\"f(x) = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_0\", color=PURPLE)\n        eq1.to_edge(UP)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Equation 2\n        eq2 = MathTex(r\"S_n : \\{x | f(x) = x\\}\", color=PURPLE)\n        eq2.next_to(eq1, DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Symmetry in Mathematics\", color=BLUE_D)\n        \n        # Fade out everything together\n        self.play(\n            FadeOut(axes),\n            FadeOut(x_label),\n            FadeOut(y_label),\n            FadeOut(point),\n            FadeOut(label),\n            FadeOut(eq1),\n            FadeOut(eq2)\n        )\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we classify the fixed points of a polynomial map under the action of a symmetric group?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a five-pointed star shape (pentagram) centered on the screen. Then, a red star with the same outer radius is drawn over it with a smooth animation. After being displayed briefly, the red star fades out gradually."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass StarExample(Scene):\n    def construct(self):\n        pentagram = RegularPolygram(5, radius=2)\n        star = Star(outer_radius=2, color=RED)\n\n        self.add(pentagram)\n        self.play(Create(star), run_time=3)\n        self.play(FadeOut(star), run_time=2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a five-pointed star shape (pentagram) centered on the screen. Then, a red star with the same outer radius is drawn over it with a smooth animation. After being displayed briefly, the red star fades out gradually."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a five-pointed star shape (pentagram) centered on the screen. then, a red star with the same outer radius is drawn over it with a smooth animation. after being displayed briefly, the red star fades out gradually."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass StarExample(Scene):\n    def construct(self):\n        pentagram = RegularPolygram(5, radius=2)\n        star = Star(outer_radius=2, color=RED)\n\n        self.add(pentagram)\n        self.play(Create(star), run_time=3)\n        self.play(FadeOut(star), run_time=2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a five-pointed star shape (pentagram) centered on the screen. Then, a red star with the same outer radius is drawn over it with a smooth animation. After being displayed briefly, the red star fades out gradually."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animated video that explains how to find the sum of a geometric series. Start by displaying the general formula for the sum of the first n terms of a geometric series. Then, introduce the well-known geometric sum formula and show how it applies to the series by transforming the initial formula into the geometric sum formula. Next, explain what happens to the sum when the absolute value of the common ratio is less than one and we let the number of terms grow indefinitely, meaning as n approaches infinity. Show this transition on screen. Finally, evaluate the infinite sum to obtain the simplified formula and clear all the previous work to end the video with just the final evaluated sum visible onscreen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ \\frac{1}{3}r^3 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the inner integral bounds\n        evaluated_inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner_integral))\n        self.wait(1)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[ \\frac{1}{3} \\theta \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(evaluated_inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} \\cdot 2\\pi\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= \\frac{2\\pi}{3}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that explains how to find the sum of a geometric series. Start by displaying the general formula for the sum of the first n terms of a geometric series. Then, introduce the well-known geometric sum formula and show how it applies to the series by transforming the initial formula into the geometric sum formula. Next, explain what happens to the sum when the absolute value of the common ratio is less than one and we let the number of terms grow indefinitely, meaning as n approaches infinity. Show this transition on screen. Finally, evaluate the infinite sum to obtain the simplified formula and clear all the previous work to end the video with just the final evaluated sum visible onscreen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animated video that explains how to find the sum of a geometric series. start by displaying the general formula for the sum of the first n terms of a geometric series. then, introduce the well-known geometric sum formula and show how it applies to the series by transforming the initial formula into the geometric sum formula. next, explain what happens to the sum when the absolute value of the common ratio is less than one and we let the number of terms grow indefinitely, meaning as n approaches infinity. show this transition on screen. finally, evaluate the infinite sum to obtain the simplified formula and clear all the previous work to end the video with just the final evaluated sum visible onscreen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{2\\pi} \\int_{0}^{1} r^2 \\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\left[ \\frac{1}{3}r^3 \\right]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluate the inner integral bounds\n        evaluated_inner_integral = MathTex(r\"= \\int_{0}^{2\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(inner_integral, evaluated_inner_integral))\n        self.wait(1)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\left[ \\frac{1}{3} \\theta \\right]_{0}^{2\\pi}\")\n        self.play(ReplacementTransform(evaluated_inner_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3} \\cdot 2\\pi\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n\n        # Simplify the final solution\n        simplified_solution = MathTex(r\"= \\frac{2\\pi}{3}\")\n        self.play(Transform(final_solution, simplified_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that explains how to find the sum of a geometric series. Start by displaying the general formula for the sum of the first n terms of a geometric series. Then, introduce the well-known geometric sum formula and show how it applies to the series by transforming the initial formula into the geometric sum formula. Next, explain what happens to the sum when the absolute value of the common ratio is less than one and we let the number of terms grow indefinitely, meaning as n approaches infinity. Show this transition on screen. Finally, evaluate the infinite sum to obtain the simplified formula and clear all the previous work to end the video with just the final evaluated sum visible onscreen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the Euler characteristic of non-orientable surfaces like the M\u00f6bius strip?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerCharacteristicNonOrientable(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Non-Orientable Surfaces\", font_size=32)\n        subtitle = Text(\"and the Euler Characteristic\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(2)\n        self.play(FadeOut(title, subtitle))\n        \n        # Introduction\n        intro = Text(\"Let's explore the Euler characteristic\", font_size=28)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Orientable Surface\n        orientable_text = Text(\"Orientable Surfaces (like a sphere)\", font_size=28)\n        self.play(Write(orientable_text))\n        self.wait(1)\n        self.play(orientable_text.animate.to_edge(UP))\n        \n        # Create a simple representation of a sphere\n        sphere = Circle(radius=1.5, color=BLUE)\n        self.play(Create(sphere))\n        self.wait(1)\n        \n        # Euler formula for sphere\n        sphere_eq = MathTex(\"V - E + F = 2\")\n        sphere_eq.next_to(sphere, DOWN, buff=0.5)\n        self.play(Write(sphere_eq))\n        self.wait(2)\n        \n        # Clear for next part\n        self.play(FadeOut(orientable_text, sphere, sphere_eq))\n        \n        # Non-orientable Surface\n        nonorientable_text = Text(\"Non-orientable Surfaces (M\u00f6bius strip)\", font_size=28)\n        self.play(Write(nonorientable_text))\n        self.wait(1)\n        self.play(nonorientable_text.animate.to_edge(UP))\n        \n        # Create a simple representation of a M\u00f6bius strip\n        rect = Rectangle(height=1, width=3, color=RED)\n        \n        # Add arrows to show the twist\n        arrow1 = Arrow(start=[-1.5, 0.5, 0], end=[-1.5, -0.5, 0], color=YELLOW)\n        arrow2 = Arrow(start=[1.5, -0.5, 0], end=[1.5, 0.5, 0], color=YELLOW)\n        twist_text = Text(\"twist\", font_size=20).next_to(rect, DOWN)\n        \n        mobius_group = VGroup(rect, arrow1, arrow2, twist_text)\n        self.play(Create(mobius_group))\n        self.wait(1)\n        \n        # Euler formula for M\u00f6bius strip\n        mobius_eq = MathTex(\"V - E + F = 0\")\n        mobius_eq.next_to(mobius_group, DOWN, buff=0.5)\n        self.play(Write(mobius_eq))\n        self.wait(2)\n        \n        # Comparison\n        self.play(FadeOut(nonorientable_text, mobius_group, twist_text, mobius_eq))\n        \n        compare_title = Text(\"Comparing Euler Characteristics\", font_size=28)\n        self.play(Write(compare_title))\n        self.wait(1)\n        self.play(compare_title.animate.to_edge(UP))\n        \n        # Using simpler text approach to avoid potential issues with \\text{} in MathTex\n        sphere_eq = Text(\"Sphere: V - E + F = 2\", font_size=24)\n        mobius_eq = Text(\"M\u00f6bius Strip: V - E + F = 0\", font_size=24)\n        mobius_eq.next_to(sphere_eq, DOWN, buff=0.5)\n        \n        self.play(Write(sphere_eq))\n        self.wait(0.5)\n        self.play(Write(mobius_eq))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(compare_title, sphere_eq, mobius_eq))\n        \n        conclusion = Text(\"Non-orientable surfaces reveal\", font_size=28)\n        conclusion2 = Text(\"the elegance of topology\", font_size=28)\n        conclusion2.next_to(conclusion, DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(0.5)\n        self.play(Write(conclusion2))\n        self.wait(2)\n        self.play(FadeOut(conclusion, conclusion2))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the Euler characteristic of non-orientable surfaces like the M\u00f6bius strip?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the euler characteristic of non-orientable surfaces like the m\u00f6bius strip?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerCharacteristicNonOrientable(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Non-Orientable Surfaces\", font_size=32)\n        subtitle = Text(\"and the Euler Characteristic\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(2)\n        self.play(FadeOut(title, subtitle))\n        \n        # Introduction\n        intro = Text(\"Let's explore the Euler characteristic\", font_size=28)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Orientable Surface\n        orientable_text = Text(\"Orientable Surfaces (like a sphere)\", font_size=28)\n        self.play(Write(orientable_text))\n        self.wait(1)\n        self.play(orientable_text.animate.to_edge(UP))\n        \n        # Create a simple representation of a sphere\n        sphere = Circle(radius=1.5, color=BLUE)\n        self.play(Create(sphere))\n        self.wait(1)\n        \n        # Euler formula for sphere\n        sphere_eq = MathTex(\"V - E + F = 2\")\n        sphere_eq.next_to(sphere, DOWN, buff=0.5)\n        self.play(Write(sphere_eq))\n        self.wait(2)\n        \n        # Clear for next part\n        self.play(FadeOut(orientable_text, sphere, sphere_eq))\n        \n        # Non-orientable Surface\n        nonorientable_text = Text(\"Non-orientable Surfaces (M\u00f6bius strip)\", font_size=28)\n        self.play(Write(nonorientable_text))\n        self.wait(1)\n        self.play(nonorientable_text.animate.to_edge(UP))\n        \n        # Create a simple representation of a M\u00f6bius strip\n        rect = Rectangle(height=1, width=3, color=RED)\n        \n        # Add arrows to show the twist\n        arrow1 = Arrow(start=[-1.5, 0.5, 0], end=[-1.5, -0.5, 0], color=YELLOW)\n        arrow2 = Arrow(start=[1.5, -0.5, 0], end=[1.5, 0.5, 0], color=YELLOW)\n        twist_text = Text(\"twist\", font_size=20).next_to(rect, DOWN)\n        \n        mobius_group = VGroup(rect, arrow1, arrow2, twist_text)\n        self.play(Create(mobius_group))\n        self.wait(1)\n        \n        # Euler formula for M\u00f6bius strip\n        mobius_eq = MathTex(\"V - E + F = 0\")\n        mobius_eq.next_to(mobius_group, DOWN, buff=0.5)\n        self.play(Write(mobius_eq))\n        self.wait(2)\n        \n        # Comparison\n        self.play(FadeOut(nonorientable_text, mobius_group, twist_text, mobius_eq))\n        \n        compare_title = Text(\"Comparing Euler Characteristics\", font_size=28)\n        self.play(Write(compare_title))\n        self.wait(1)\n        self.play(compare_title.animate.to_edge(UP))\n        \n        # Using simpler text approach to avoid potential issues with \\text{} in MathTex\n        sphere_eq = Text(\"Sphere: V - E + F = 2\", font_size=24)\n        mobius_eq = Text(\"M\u00f6bius Strip: V - E + F = 0\", font_size=24)\n        mobius_eq.next_to(sphere_eq, DOWN, buff=0.5)\n        \n        self.play(Write(sphere_eq))\n        self.wait(0.5)\n        self.play(Write(mobius_eq))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(compare_title, sphere_eq, mobius_eq))\n        \n        conclusion = Text(\"Non-orientable surfaces reveal\", font_size=28)\n        conclusion2 = Text(\"the elegance of topology\", font_size=28)\n        conclusion2.next_to(conclusion, DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(0.5)\n        self.play(Write(conclusion2))\n        self.wait(2)\n        self.play(FadeOut(conclusion, conclusion2))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the Euler characteristic of non-orientable surfaces like the M\u00f6bius strip?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a large, semi-transparent background rectangle filled with a gradient of teal, red, and yellow. In front of it, three matrices are arranged horizontally:\n\n- The first matrix has background rectangles behind each individual entry.\n- The second matrix has a single background rectangle behind the entire matrix.\n- The third matrix has no background rectangles.\n\nAll elements appear on screen simultaneously without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large, semi-transparent background rectangle filled with a gradient of teal, red, and yellow. In front of it, three matrices are arranged horizontally:\n\n- The first matrix has background rectangles behind each individual entry.\n- The second matrix has a single background rectangle behind the entire matrix.\n- The third matrix has no background rectangles.\n\nAll elements appear on screen simultaneously without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a large, semi-transparent background rectangle filled with a gradient of teal, red, and yellow. in front of it, three matrices are arranged horizontally:\n\n- the first matrix has background rectangles behind each individual entry.\n- the second matrix has a single background rectangle behind the entire matrix.\n- the third matrix has no background rectangles.\n\nall elements appear on screen simultaneously without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BackgroundRectanglesExample(Scene):\n    def construct(self):\n        background= Rectangle().scale(3.2)\n        background.set_fill(opacity=.5)\n        background.set_color([TEAL, RED, YELLOW])\n        self.add(background)\n        m0 = Matrix([[12, -30], [-1, 15]],\n            add_background_rectangles_to_entries=True)\n        m1 = Matrix([[2, 0], [-1, 1]],\n            include_background_rectangle=True)\n        m2 = Matrix([[12, -30], [-1, 15]])\n        g = Group(m0, m1, m2).arrange(buff=2)\n        self.add(g)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large, semi-transparent background rectangle filled with a gradient of teal, red, and yellow. In front of it, three matrices are arranged horizontally:\n\n- The first matrix has background rectangles behind each individual entry.\n- The second matrix has a single background rectangle behind the entire matrix.\n- The third matrix has no background rectangles.\n\nAll elements appear on screen simultaneously without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational chemistry animation that visually represents an electrochemical concept. The animation should start with a 3x3 grid of lithium ions to demonstrate the initial state of a battery's electrode. Then, it should transition to a single layer of carbon atoms to represent another electrode. Additionally, I want to include separate animations of an oxygen molecule and a metallic element, cobalt, symbolizing their interactions in the chemical process; have them appear one by one on opposite sides of the screen. \n\nFurthermore, animate the oxygen molecule moving in a triangular path to depict some sort of molecular motion or reaction pathway, showing the dynamic nature of the chemical processes within a battery. Please make sure the elements and ions are correctly labeled with their chemical symbols and charges, make it visually clear, and ensure that the animation runs smoothly and is visually engaging for students learning about chemistry."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Set up axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Displaying the integral problem\n        integral = MathTex(r\"\\int_{0}^{2} (x^2) \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Graph function\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        # Display graph\n        self.play(Create(axes), Create(graph), FadeIn(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Calculate the area\n        solution = MathTex(r\"=\\frac{{(2)^3}}{3} - \\frac{{(0)^3}}{3}\")\n        solution.to_edge(DOWN)\n        self.play(ReplacementTransform(integral.copy(), solution))\n        self.wait(2)\n\n        # Simplify the solution\n        final_solution = MathTex(r\"=\\frac{8}{3}\")\n        final_solution.next_to(solution, DOWN)\n        self.play(Write(final_solution))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational chemistry animation that visually represents an electrochemical concept. The animation should start with a 3x3 grid of lithium ions to demonstrate the initial state of a battery's electrode. Then, it should transition to a single layer of carbon atoms to represent another electrode. Additionally, I want to include separate animations of an oxygen molecule and a metallic element, cobalt, symbolizing their interactions in the chemical process; have them appear one by one on opposite sides of the screen. \n\nFurthermore, animate the oxygen molecule moving in a triangular path to depict some sort of molecular motion or reaction pathway, showing the dynamic nature of the chemical processes within a battery. Please make sure the elements and ions are correctly labeled with their chemical symbols and charges, make it visually clear, and ensure that the animation runs smoothly and is visually engaging for students learning about chemistry."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational chemistry animation that visually represents an electrochemical concept. the animation should start with a 3x3 grid of lithium ions to demonstrate the initial state of a battery's electrode. then, it should transition to a single layer of carbon atoms to represent another electrode. additionally, i want to include separate animations of an oxygen molecule and a metallic element, cobalt, symbolizing their interactions in the chemical process; have them appear one by one on opposite sides of the screen. \n\nfurthermore, animate the oxygen molecule moving in a triangular path to depict some sort of molecular motion or reaction pathway, showing the dynamic nature of the chemical processes within a battery. please make sure the elements and ions are correctly labeled with their chemical symbols and charges, make it visually clear, and ensure that the animation runs smoothly and is visually engaging for students learning about chemistry."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Set up axes\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 4, 1],\n            axis_config={\"color\": BLUE},\n        )\n        \n        # Displaying the integral problem\n        integral = MathTex(r\"\\int_{0}^{2} (x^2) \\,dx\")\n        integral.to_edge(UP)\n        self.play(Write(integral))\n        self.wait(1)\n\n        # Graph function\n        graph = axes.plot(lambda x: x**2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^2')\n\n        # Display graph\n        self.play(Create(axes), Create(graph), FadeIn(graph_label))\n        self.wait(1)\n\n        # Highlight the area under the curve\n        area = axes.get_area(graph, x_range=(0, 2), color=GREEN, opacity=0.5)\n        self.play(FadeIn(area))\n        self.wait(2)\n\n        # Calculate the area\n        solution = MathTex(r\"=\\frac{{(2)^3}}{3} - \\frac{{(0)^3}}{3}\")\n        solution.to_edge(DOWN)\n        self.play(ReplacementTransform(integral.copy(), solution))\n        self.wait(2)\n\n        # Simplify the solution\n        final_solution = MathTex(r\"=\\frac{8}{3}\")\n        final_solution.next_to(solution, DOWN)\n        self.play(Write(final_solution))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational chemistry animation that visually represents an electrochemical concept. The animation should start with a 3x3 grid of lithium ions to demonstrate the initial state of a battery's electrode. Then, it should transition to a single layer of carbon atoms to represent another electrode. Additionally, I want to include separate animations of an oxygen molecule and a metallic element, cobalt, symbolizing their interactions in the chemical process; have them appear one by one on opposite sides of the screen. \n\nFurthermore, animate the oxygen molecule moving in a triangular path to depict some sort of molecular motion or reaction pathway, showing the dynamic nature of the chemical processes within a battery. Please make sure the elements and ions are correctly labeled with their chemical symbols and charges, make it visually clear, and ensure that the animation runs smoothly and is visually engaging for students learning about chemistry."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "neural_network_dropout.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.animations.dropout import (\n    make_neural_network_dropout_animation,\n)\nfrom manim_ml.neural_network import FeedForwardLayer, NeuralNetwork\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass DropoutNeuralNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(4, rectangle_color=BLUE),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "neural_network_dropout.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that neural_network_dropout.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.animations.dropout import (\n    make_neural_network_dropout_animation,\n)\nfrom manim_ml.neural_network import FeedForwardLayer, NeuralNetwork\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass DropoutNeuralNetworkScene(Scene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(3, rectangle_color=BLUE),\n                FeedForwardLayer(5, rectangle_color=BLUE),\n                FeedForwardLayer(4, rectangle_color=BLUE),\n            ],\n            layer_spacing=0.4,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        self.play(\n            make_neural_network_dropout_animation(\n                nn, dropout_rate=0.25, do_forward_pass=True\n            )\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "neural_network_dropout.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "translation_equivariance.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.parent_layers import ThreeDLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 800\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/doggo.jpeg\")\n        numpy_image = np.asarray(image)\n        # Rotate the Three D layer position\n        ThreeDLayer.rotation_angle = 15 * DEGREES\n        ThreeDLayer.rotation_axis = [1, -1.0, 0]\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, 7, 3, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 5, 1, 1, filter_spacing=0.18),\n            ],\n            layer_spacing=0.25,\n            layout_direction=\"top_to_bottom\",\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.scale(1.5)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation(\n            highlight_active_feature_map=True,\n        )\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "translation_equivariance.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that translation_equivariance.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.layers.parent_layers import ThreeDLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 800\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/doggo.jpeg\")\n        numpy_image = np.asarray(image)\n        # Rotate the Three D layer position\n        ThreeDLayer.rotation_angle = 15 * DEGREES\n        ThreeDLayer.rotation_axis = [1, -1.0, 0]\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, 7, 3, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 5, 1, 1, filter_spacing=0.18),\n            ],\n            layer_spacing=0.25,\n            layout_direction=\"top_to_bottom\",\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.scale(1.5)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation(\n            highlight_active_feature_map=True,\n        )\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "translation_equivariance.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Please create an animation that shows the construction of a Fibonacci spiral using arcs with different colors. Start with the first two Fibonacci numbers and calculate the next five numbers in the sequence. Then draw each corresponding segment of the spiral as an arc, with each arc being a quarter of a circle. The arcs should be colored consecutively from a set of six colors: yellow, green, blue, red, purple, and orange. Arrange the arcs in a way that they form the spiral, and animate their creation sequentially with a total run time of 2 seconds, followed by a 1-second pause after the last arc is drawn."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dA\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Express dA in polar coordinates as r dr d\u03b8\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral with polar coordinates\n        polar_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{1} r^2 dr d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), polar_integral))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation2 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Inner integral after r integration\n        r_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(polar_integral, r_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(r_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{3}\\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(3)\n\n        # Explanation for final answer\n        explanation4 = Text(\"The final answer is \u03c0/3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an animation that shows the construction of a Fibonacci spiral using arcs with different colors. Start with the first two Fibonacci numbers and calculate the next five numbers in the sequence. Then draw each corresponding segment of the spiral as an arc, with each arc being a quarter of a circle. The arcs should be colored consecutively from a set of six colors: yellow, green, blue, red, purple, and orange. Arrange the arcs in a way that they form the spiral, and animate their creation sequentially with a total run time of 2 seconds, followed by a 1-second pause after the last arc is drawn."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that please create an animation that shows the construction of a fibonacci spiral using arcs with different colors. start with the first two fibonacci numbers and calculate the next five numbers in the sequence. then draw each corresponding segment of the spiral as an arc, with each arc being a quarter of a circle. the arcs should be colored consecutively from a set of six colors: yellow, green, blue, red, purple, and orange. arrange the arcs in a way that they form the spiral, and animate their creation sequentially with a total run time of 2 seconds, followed by a 1-second pause after the last arc is drawn."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r dA\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Express dA in polar coordinates as r dr d\u03b8\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral with polar coordinates\n        polar_integral = MathTex(r\"= \\int_{0}^{\\pi} \\int_{0}^{1} r^2 dr d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), polar_integral))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation2 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Inner integral after r integration\n        r_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(polar_integral, r_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation3 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3} d\\theta\")\n        self.play(ReplacementTransform(r_integral, final_integral))\n        self.wait(1)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\left[ \\frac{1}{3}\\theta \\right]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(3)\n\n        # Explanation for final answer\n        explanation4 = Text(\"The final answer is \u03c0/3\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an animation that shows the construction of a Fibonacci spiral using arcs with different colors. Start with the first two Fibonacci numbers and calculate the next five numbers in the sequence. Then draw each corresponding segment of the spiral as an arc, with each arc being a quarter of a circle. The arcs should be colored consecutively from a set of six colors: yellow, green, blue, red, purple, and orange. Arrange the arcs in a way that they form the spiral, and animate their creation sequentially with a total run time of 2 seconds, followed by a 1-second pause after the last arc is drawn."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated video that visually explains the steps to solve a triple integral, specifically the integral of xyz from x ranging from -1 to 1, y ranging from -1 to 1, and z ranging from 0 to 1? I would like it to show the written problem, then step-by-step integration for each variable with short explanations for each step, and finally, clear the screen and present the final answer."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\n# Define some constants for colors\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\n\n# Function to create a cookie circle\ndef CookieCircle():\n    return VGroup(\n        Circle(radius=1, color=TEXT_COLOR, fill_opacity=1),\n        Dot(point=UP, color=BACKGROUND_COLOR),\n        Dot(point=DOWN, color=BACKGROUND_COLOR),\n        Dot(point=RIGHT, color=BACKGROUND_COLOR),\n        Dot(point=LEFT, color=BACKGROUND_COLOR)\n    )\n\nclass CookiePartition(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividing cookie into 4 parts\", color=LIGHT_BLUE_COLOR)\n        title.scale(1.3).to_edge(UP)\n        \n        cookie = CookieCircle()\n        partition_lines = VGroup(\n            Line(UP, DOWN, color=BACKGROUND_COLOR),\n            Line(LEFT, RIGHT, color=BACKGROUND_COLOR),\n        )\n        \n        partitioned_cookie = VGroup(cookie, partition_lines)\n        \n        self.play(Write(title))\n        self.play(FadeIn(cookie))\n        self.wait(0.5)\n        \n        for line in partition_lines:\n            self.play(Write(line), run_time=0.5)\n        \n        self.play(partitioned_cookie.animate.scale(0.7).shift(3 * LEFT + 2 * UP))\n        \n        fraction_group = VGroup()\n        \n        # Add fractions to indicate parts of the cookie\n        for i in range(4):\n            frac = MathTex(rf\"\\frac{1}{{4}}\", color=LIGHT_BLUE_COLOR).scale(0.5)\n            pos = cookie.get_critical_point([UP, DOWN, LEFT, RIGHT][i]) + frac.get_width() * [DOWN, UP, RIGHT, LEFT][i]\n            frac.move_to(pos)\n            fraction_group.add(frac)\n        \n        self.play(AnimationGroup(*[FadeIn(f) for f in fraction_group], lag_ratio=0.3))\n        \n        self.wait(1)\n        self.play(Uncreate(title), FadeOut(partitioned_cookie), FadeOut(fraction_group))\n        self.wait(0.5)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video that visually explains the steps to solve a triple integral, specifically the integral of xyz from x ranging from -1 to 1, y ranging from -1 to 1, and z ranging from 0 to 1? I would like it to show the written problem, then step-by-step integration for each variable with short explanations for each step, and finally, clear the screen and present the final answer."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated video that visually explains the steps to solve a triple integral, specifically the integral of xyz from x ranging from -1 to 1, y ranging from -1 to 1, and z ranging from 0 to 1? i would like it to show the written problem, then step-by-step integration for each variable with short explanations for each step, and finally, clear the screen and present the final answer."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nconfig.frame_size = 1080, 1920\nconfig.frame_width = 9\nconfig.frame_height = 16\n\n# Define some constants for colors\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\n\n# Function to create a cookie circle\ndef CookieCircle():\n    return VGroup(\n        Circle(radius=1, color=TEXT_COLOR, fill_opacity=1),\n        Dot(point=UP, color=BACKGROUND_COLOR),\n        Dot(point=DOWN, color=BACKGROUND_COLOR),\n        Dot(point=RIGHT, color=BACKGROUND_COLOR),\n        Dot(point=LEFT, color=BACKGROUND_COLOR)\n    )\n\nclass CookiePartition(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividing cookie into 4 parts\", color=LIGHT_BLUE_COLOR)\n        title.scale(1.3).to_edge(UP)\n        \n        cookie = CookieCircle()\n        partition_lines = VGroup(\n            Line(UP, DOWN, color=BACKGROUND_COLOR),\n            Line(LEFT, RIGHT, color=BACKGROUND_COLOR),\n        )\n        \n        partitioned_cookie = VGroup(cookie, partition_lines)\n        \n        self.play(Write(title))\n        self.play(FadeIn(cookie))\n        self.wait(0.5)\n        \n        for line in partition_lines:\n            self.play(Write(line), run_time=0.5)\n        \n        self.play(partitioned_cookie.animate.scale(0.7).shift(3 * LEFT + 2 * UP))\n        \n        fraction_group = VGroup()\n        \n        # Add fractions to indicate parts of the cookie\n        for i in range(4):\n            frac = MathTex(rf\"\\frac{1}{{4}}\", color=LIGHT_BLUE_COLOR).scale(0.5)\n            pos = cookie.get_critical_point([UP, DOWN, LEFT, RIGHT][i]) + frac.get_width() * [DOWN, UP, RIGHT, LEFT][i]\n            frac.move_to(pos)\n            fraction_group.add(frac)\n        \n        self.play(AnimationGroup(*[FadeIn(f) for f in fraction_group], lag_ratio=0.3))\n        \n        self.wait(1)\n        self.play(Uncreate(title), FadeOut(partitioned_cookie), FadeOut(fraction_group))\n        self.wait(0.5)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video that visually explains the steps to solve a triple integral, specifically the integral of xyz from x ranging from -1 to 1, y ranging from -1 to 1, and z ranging from 0 to 1? I would like it to show the written problem, then step-by-step integration for each variable with short explanations for each step, and finally, clear the screen and present the final answer."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation where a red triangle appears to grow from the center of the screen and then a yellow hexagon fades in to the left side of the triangle with a small separation between them? The triangle should be somewhat transparent, and the hexagon should be even more transparent."}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\nfrom manim_ml.neural_network import Convolutional2DLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork({\n            \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n            \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n            \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1)\n        })\n        # Add the residual connection\n        nn.add_connection(\"layer1\", \"layer3\")\n        # Make the animation\n        self.play(nn.make_forward_pass_animation())\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a red triangle appears to grow from the center of the screen and then a yellow hexagon fades in to the left side of the triangle with a small separation between them? The triangle should be somewhat transparent, and the hexagon should be even more transparent."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation where a red triangle appears to grow from the center of the screen and then a yellow hexagon fades in to the left side of the triangle with a small separation between them? the triangle should be somewhat transparent, and the hexagon should be even more transparent."}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\nfrom manim_ml.neural_network import Convolutional2DLayer, NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\ndef make_code_snippet():\n    code_str = \"\"\"\n        # Make the neural network\n        nn = NeuralNetwork({\n            \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n            \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n            \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1)\n        })\n        # Add the residual connection\n        nn.add_connection(\"layer1\", \"layer3\")\n        # Make the animation\n        self.play(nn.make_forward_pass_animation())\n    \"\"\"\n\n    code = Code(\n        code=code_str,\n        tab_width=4,\n        background_stroke_width=1,\n        background_stroke_color=WHITE,\n        insert_line_no=False,\n        style=\"monokai\",\n        # background=\"window\",\n        language=\"py\",\n    )\n    code.scale(0.38)\n\n    return code\n\n\nclass ConvScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n\n        nn = NeuralNetwork(\n            {\n                \"layer1\": Convolutional2DLayer(1, 5, padding=1),\n                \"layer2\": Convolutional2DLayer(1, 5, 3, padding=1),\n                \"layer3\": Convolutional2DLayer(1, 5, 3, padding=1),\n            },\n            layer_spacing=0.25,\n        )\n\n        nn.add_connection(\"layer1\", \"layer3\")\n\n        self.add(nn)\n\n        code = make_code_snippet()\n        code.next_to(nn, DOWN)\n        self.add(code)\n        Group(code, nn).move_to(ORIGIN)\n\n        self.play(nn.make_forward_pass_animation(), run_time=8)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a red triangle appears to grow from the center of the screen and then a yellow hexagon fades in to the left side of the triangle with a small separation between them? The triangle should be somewhat transparent, and the hexagon should be even more transparent."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can the Lefschetz Fixed Point Theorem illustrate the existence of fixed points in a deformed M\u00f6bius strip?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LefschetzFixedPointTheorem(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Untangling the M\u00f6bius: The Lefschetz Fixed Point Theorem\", font_size=28)\n        title.to_edge(UP)\n        \n        # Introduction\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a simple M\u00f6bius strip representation (as a circle with a twist indication)\n        mobius = Circle(radius=2, color=BLUE)\n        arrow1 = Arrow(start=LEFT, end=RIGHT, color=BLUE_B).shift(UP)\n        arrow2 = Arrow(start=RIGHT, end=LEFT, color=BLUE_B).shift(DOWN)  # Opposite direction to show twist\n        mobius_group = VGroup(mobius, arrow1, arrow2)\n        \n        mobius_label = Text(\"M\u00f6bius Strip\", font_size=24)\n        mobius_label.next_to(mobius_group, DOWN)\n        \n        self.play(Create(mobius_group), Write(mobius_label))\n        self.wait(1)\n        \n        # Explanation text\n        explanation = Text(\"A non-orientable surface with a single side\", font_size=22, color=YELLOW)\n        explanation.next_to(mobius_label, DOWN)\n        \n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Position for the theorem\n        self.play(\n            mobius_group.animate.scale(0.7).to_edge(LEFT),\n            mobius_label.animate.next_to(mobius_group, DOWN),\n            FadeOut(explanation)\n        )\n        \n        # Lefschetz Fixed Point Theorem\n        theorem_title = Text(\"Lefschetz Fixed Point Theorem\", font_size=24, color=BLUE)\n        theorem_title.to_edge(RIGHT).shift(UP)\n        \n        equation = MathTex(r\"L(f) \\neq 0 \\implies \\text{ Fixed Points Exist}\")\n        equation.next_to(theorem_title, DOWN)\n        \n        self.play(Write(theorem_title), Write(equation))\n        self.wait(1)\n        \n        # Deformation explanation\n        deform_text = Text(\"Under continuous deformation...\", font_size=24)\n        deform_text.next_to(title, DOWN)\n        \n        self.play(Write(deform_text))\n        self.wait(1)\n        \n        # Deformed M\u00f6bius\n        deformed_mobius = Circle(radius=2, color=YELLOW).stretch(1.2, 0).stretch(0.8, 1)\n        deformed_arrow1 = Arrow(start=LEFT, end=RIGHT, color=YELLOW_B).shift(UP * 0.8)\n        deformed_arrow2 = Arrow(start=RIGHT, end=LEFT, color=YELLOW_B).shift(DOWN * 0.8)\n        deformed_group = VGroup(deformed_mobius, deformed_arrow1, deformed_arrow2)\n        deformed_group.move_to(mobius_group.get_center())\n        \n        self.play(Transform(mobius_group, deformed_group))\n        self.wait(1)\n        \n        # Show fixed points\n        fixed_points = VGroup(\n            Dot(deformed_mobius.point_from_proportion(0.25), color=RED),\n            Dot(deformed_mobius.point_from_proportion(0.75), color=RED)\n        )\n        \n        fixed_label = Text(\"Fixed Points\", font_size=20, color=RED)\n        fixed_label.next_to(mobius_group, DOWN, buff=1)\n        \n        self.play(Create(fixed_points), Write(fixed_label))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The theorem guarantees fixed points\\nin continuous deformations\", font_size=24)\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can the Lefschetz Fixed Point Theorem illustrate the existence of fixed points in a deformed M\u00f6bius strip?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can the lefschetz fixed point theorem illustrate the existence of fixed points in a deformed m\u00f6bius strip?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LefschetzFixedPointTheorem(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Untangling the M\u00f6bius: The Lefschetz Fixed Point Theorem\", font_size=28)\n        title.to_edge(UP)\n        \n        # Introduction\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a simple M\u00f6bius strip representation (as a circle with a twist indication)\n        mobius = Circle(radius=2, color=BLUE)\n        arrow1 = Arrow(start=LEFT, end=RIGHT, color=BLUE_B).shift(UP)\n        arrow2 = Arrow(start=RIGHT, end=LEFT, color=BLUE_B).shift(DOWN)  # Opposite direction to show twist\n        mobius_group = VGroup(mobius, arrow1, arrow2)\n        \n        mobius_label = Text(\"M\u00f6bius Strip\", font_size=24)\n        mobius_label.next_to(mobius_group, DOWN)\n        \n        self.play(Create(mobius_group), Write(mobius_label))\n        self.wait(1)\n        \n        # Explanation text\n        explanation = Text(\"A non-orientable surface with a single side\", font_size=22, color=YELLOW)\n        explanation.next_to(mobius_label, DOWN)\n        \n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Position for the theorem\n        self.play(\n            mobius_group.animate.scale(0.7).to_edge(LEFT),\n            mobius_label.animate.next_to(mobius_group, DOWN),\n            FadeOut(explanation)\n        )\n        \n        # Lefschetz Fixed Point Theorem\n        theorem_title = Text(\"Lefschetz Fixed Point Theorem\", font_size=24, color=BLUE)\n        theorem_title.to_edge(RIGHT).shift(UP)\n        \n        equation = MathTex(r\"L(f) \\neq 0 \\implies \\text{ Fixed Points Exist}\")\n        equation.next_to(theorem_title, DOWN)\n        \n        self.play(Write(theorem_title), Write(equation))\n        self.wait(1)\n        \n        # Deformation explanation\n        deform_text = Text(\"Under continuous deformation...\", font_size=24)\n        deform_text.next_to(title, DOWN)\n        \n        self.play(Write(deform_text))\n        self.wait(1)\n        \n        # Deformed M\u00f6bius\n        deformed_mobius = Circle(radius=2, color=YELLOW).stretch(1.2, 0).stretch(0.8, 1)\n        deformed_arrow1 = Arrow(start=LEFT, end=RIGHT, color=YELLOW_B).shift(UP * 0.8)\n        deformed_arrow2 = Arrow(start=RIGHT, end=LEFT, color=YELLOW_B).shift(DOWN * 0.8)\n        deformed_group = VGroup(deformed_mobius, deformed_arrow1, deformed_arrow2)\n        deformed_group.move_to(mobius_group.get_center())\n        \n        self.play(Transform(mobius_group, deformed_group))\n        self.wait(1)\n        \n        # Show fixed points\n        fixed_points = VGroup(\n            Dot(deformed_mobius.point_from_proportion(0.25), color=RED),\n            Dot(deformed_mobius.point_from_proportion(0.75), color=RED)\n        )\n        \n        fixed_label = Text(\"Fixed Points\", font_size=20, color=RED)\n        fixed_label.next_to(mobius_group, DOWN, buff=1)\n        \n        self.play(Create(fixed_points), Write(fixed_label))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The theorem guarantees fixed points\\nin continuous deformations\", font_size=24)\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can the Lefschetz Fixed Point Theorem illustrate the existence of fixed points in a deformed M\u00f6bius strip?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animation with seven circles of different colors arranged in a horizontal line, which then simultaneously fade in over two seconds? After they have all appeared, I'd like them to move upward together over another two seconds. Following that, can they rearrange into a vertical line and become smaller, as if they're moving away, but then return to their original size and horizontal arrangement with a brief pause in the smaller form?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\n\nclass SalesBarGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Quarterly Sales\", color=TEXT_COLOR)\n        bars = BarChart(\n            [10, 6, 9, 5], \n            max_value=10,\n            bar_colors=['#5e81ac', '#bf616a', '#a3be8c', '#ebcb8b'],\n            bar_names=['Q1', 'Q2', 'Q3', 'Q4'],\n            bar_label_scale_val=0.7,\n            label_y_axis=True,\n            y_axis_config={'include_tip': False},\n            x_axis_config={'include_tip': False}\n        )\n        title.to_edge(UP)\n        bars.to_edge(DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(bars, lag_ratio=0.2), run_time=2)\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation with seven circles of different colors arranged in a horizontal line, which then simultaneously fade in over two seconds? After they have all appeared, I'd like them to move upward together over another two seconds. Following that, can they rearrange into a vertical line and become smaller, as if they're moving away, but then return to their original size and horizontal arrangement with a brief pause in the smaller form?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animation with seven circles of different colors arranged in a horizontal line, which then simultaneously fade in over two seconds? after they have all appeared, i'd like them to move upward together over another two seconds. following that, can they rearrange into a vertical line and become smaller, as if they're moving away, but then return to their original size and horizontal arrangement with a brief pause in the smaller form?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\n\nclass SalesBarGraph(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Text(\"Quarterly Sales\", color=TEXT_COLOR)\n        bars = BarChart(\n            [10, 6, 9, 5], \n            max_value=10,\n            bar_colors=['#5e81ac', '#bf616a', '#a3be8c', '#ebcb8b'],\n            bar_names=['Q1', 'Q2', 'Q3', 'Q4'],\n            bar_label_scale_val=0.7,\n            label_y_axis=True,\n            y_axis_config={'include_tip': False},\n            x_axis_config={'include_tip': False}\n        )\n        title.to_edge(UP)\n        bars.to_edge(DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(bars, lag_ratio=0.2), run_time=2)\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation with seven circles of different colors arranged in a horizontal line, which then simultaneously fade in over two seconds? After they have all appeared, I'd like them to move upward together over another two seconds. Following that, can they rearrange into a vertical line and become smaller, as if they're moving away, but then return to their original size and horizontal arrangement with a brief pause in the smaller form?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a circle positioned two units to the left of the center. Place a square to the left of the circle with a small gap between them. Then, position a triangle so that its left edge aligns with the left edge of the circle. Show all three shapes on screen and pause for one second."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MobjectPlacement(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        # place the circle two units left from the origin\n        circle.move_to(LEFT * 2)\n        # place the square to the left of the circle\n        square.next_to(circle, LEFT)\n        # align the left border of the triangle to the left border of the circle\n        triangle.align_to(circle, LEFT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a circle positioned two units to the left of the center. Place a square to the left of the circle with a small gap between them. Then, position a triangle so that its left edge aligns with the left edge of the circle. Show all three shapes on screen and pause for one second."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a circle positioned two units to the left of the center. place a square to the left of the circle with a small gap between them. then, position a triangle so that its left edge aligns with the left edge of the circle. show all three shapes on screen and pause for one second."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MobjectPlacement(Scene):\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        triangle = Triangle()\n\n        # place the circle two units left from the origin\n        circle.move_to(LEFT * 2)\n        # place the square to the left of the circle\n        square.next_to(circle, LEFT)\n        # align the left border of the triangle to the left border of the circle\n        triangle.align_to(circle, LEFT)\n\n        self.add(circle, square, triangle)\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a circle positioned two units to the left of the center. Place a square to the left of the circle with a small gap between them. Then, position a triangle so that its left edge aligns with the left edge of the circle. Show all three shapes on screen and pause for one second."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does Monte Carlo Simulation help in understanding the Central Limit Theorem through sampling distributions of means?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MonteCarloAndCLT(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Monte Carlo Simulations & Central Limit Theorem\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Different distributions (Element 1)\n        heights_bubble = Circle(radius=0.5, color=BLUE)\n        heights_label = Text(\"People Heights\", font_size=20).move_to(heights_bubble.get_center())\n        \n        fish_bubble = Circle(radius=0.5, color=GREEN)\n        fish_label = Text(\"Fish Lengths\", font_size=20).move_to(fish_bubble.get_center())\n        \n        cookie_bubble = Circle(radius=0.5, color=RED)\n        cookie_label = Text(\"Chocolate Chips\", font_size=20).move_to(cookie_bubble.get_center())\n        \n        bubbles = VGroup(\n            VGroup(heights_bubble, heights_label),\n            VGroup(fish_bubble, fish_label),\n            VGroup(cookie_bubble, cookie_label)\n        ).arrange(RIGHT, buff=0.8)\n        \n        self.play(Create(bubbles))\n        self.wait(1)\n        \n        # Sampling portal (Element 2)\n        portal = Rectangle(height=3, width=2, color=GOLD)\n        portal_text = Text(\"Sampling\", font_size=24).next_to(portal, UP)\n        monte_carlo = Text(\"Monte Carlo Simulation\", font_size=20).next_to(portal_text, UP)\n        \n        # Move bubbles into portal\n        self.play(\n            bubbles.animate.scale(0.5).next_to(portal, LEFT),\n            Create(portal), \n            Write(portal_text), \n            Write(monte_carlo)\n        )\n        \n        # Create dots that will form a histogram\n        dots = VGroup(*[Dot(color=BLUE_C) for _ in range(10)])\n        dots.arrange(RIGHT, buff=0.2).next_to(portal, RIGHT)\n        \n        self.play(\n            bubbles.animate.move_to(portal.get_center()).scale(0.5).set_opacity(0),\n            FadeIn(dots)\n        )\n        self.wait(1)\n        \n        # Sample mean equation\n        self.play(\n            FadeOut(portal), \n            FadeOut(portal_text), \n            FadeOut(monte_carlo),\n            FadeOut(dots),\n            FadeOut(bubbles)\n        )\n        \n        mean_eq = MathTex(r\"x\u0304 = \\frac{1}{n}\\sum_{i=1}^{n}X_i\")\n        self.play(Write(mean_eq))\n        self.wait(2)\n        \n        # CLT equation\n        clt_eq = MathTex(r\"P(n \\to \\infty) : \\text{Sampling Distribution} \\to N(\\mu, \\frac{\\sigma^2}{n})\")\n        clt_eq.scale(0.8)  # Scale down to fit\n        \n        self.play(ReplacementTransform(mean_eq, clt_eq))\n        self.wait(2)\n        \n        # Bell curve for CLT (Element 4)\n        self.play(FadeOut(clt_eq))\n        \n        # Simple bell curve - draw it with points to make it look better than a squished circle\n        num_points = 15\n        x_values = np.linspace(-3, 3, num_points)\n        y_values = [np.exp(-x**2/2) * 1.5 for x in x_values]  # Scale for visibility\n        \n        bell_points = VGroup()\n        for i in range(num_points):\n            point = Dot(point=[x_values[i], y_values[i], 0], color=BLUE)\n            bell_points.add(point)\n        \n        bell_label = Text(\"Sampling Distribution of Means\").scale(0.8).next_to(bell_points, DOWN)\n        \n        self.play(Create(bell_points), Write(bell_label))\n        self.wait(1)\n        \n        # Draw lines connecting the points to form a curve\n        lines = VGroup()\n        for i in range(num_points-1):\n            start_point = bell_points[i].get_center()\n            end_point = bell_points[i+1].get_center()\n            line = Line(start=start_point, end=end_point, color=BLUE)\n            lines.add(line)\n        \n        self.play(Create(lines))\n        self.wait(1)\n        \n        # CLT text (Element 5)\n        clt = Text(\"Central Limit Theorem\").next_to(bell_points, UP)\n        self.play(Write(clt))\n        \n        order_text = Text(\"Order from Chaos\").next_to(clt, UP)\n        self.play(Write(order_text))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(bell_points), \n            FadeOut(lines),\n            FadeOut(bell_label), \n            FadeOut(clt), \n            FadeOut(order_text)\n        )\n        \n        conclusion = Text(\"Order emerges from Chaos through Sampling!\")\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Monte Carlo Simulation help in understanding the Central Limit Theorem through sampling distributions of means?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does monte carlo simulation help in understanding the central limit theorem through sampling distributions of means?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MonteCarloAndCLT(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Monte Carlo Simulations & Central Limit Theorem\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Different distributions (Element 1)\n        heights_bubble = Circle(radius=0.5, color=BLUE)\n        heights_label = Text(\"People Heights\", font_size=20).move_to(heights_bubble.get_center())\n        \n        fish_bubble = Circle(radius=0.5, color=GREEN)\n        fish_label = Text(\"Fish Lengths\", font_size=20).move_to(fish_bubble.get_center())\n        \n        cookie_bubble = Circle(radius=0.5, color=RED)\n        cookie_label = Text(\"Chocolate Chips\", font_size=20).move_to(cookie_bubble.get_center())\n        \n        bubbles = VGroup(\n            VGroup(heights_bubble, heights_label),\n            VGroup(fish_bubble, fish_label),\n            VGroup(cookie_bubble, cookie_label)\n        ).arrange(RIGHT, buff=0.8)\n        \n        self.play(Create(bubbles))\n        self.wait(1)\n        \n        # Sampling portal (Element 2)\n        portal = Rectangle(height=3, width=2, color=GOLD)\n        portal_text = Text(\"Sampling\", font_size=24).next_to(portal, UP)\n        monte_carlo = Text(\"Monte Carlo Simulation\", font_size=20).next_to(portal_text, UP)\n        \n        # Move bubbles into portal\n        self.play(\n            bubbles.animate.scale(0.5).next_to(portal, LEFT),\n            Create(portal), \n            Write(portal_text), \n            Write(monte_carlo)\n        )\n        \n        # Create dots that will form a histogram\n        dots = VGroup(*[Dot(color=BLUE_C) for _ in range(10)])\n        dots.arrange(RIGHT, buff=0.2).next_to(portal, RIGHT)\n        \n        self.play(\n            bubbles.animate.move_to(portal.get_center()).scale(0.5).set_opacity(0),\n            FadeIn(dots)\n        )\n        self.wait(1)\n        \n        # Sample mean equation\n        self.play(\n            FadeOut(portal), \n            FadeOut(portal_text), \n            FadeOut(monte_carlo),\n            FadeOut(dots),\n            FadeOut(bubbles)\n        )\n        \n        mean_eq = MathTex(r\"x\u0304 = \\frac{1}{n}\\sum_{i=1}^{n}X_i\")\n        self.play(Write(mean_eq))\n        self.wait(2)\n        \n        # CLT equation\n        clt_eq = MathTex(r\"P(n \\to \\infty) : \\text{Sampling Distribution} \\to N(\\mu, \\frac{\\sigma^2}{n})\")\n        clt_eq.scale(0.8)  # Scale down to fit\n        \n        self.play(ReplacementTransform(mean_eq, clt_eq))\n        self.wait(2)\n        \n        # Bell curve for CLT (Element 4)\n        self.play(FadeOut(clt_eq))\n        \n        # Simple bell curve - draw it with points to make it look better than a squished circle\n        num_points = 15\n        x_values = np.linspace(-3, 3, num_points)\n        y_values = [np.exp(-x**2/2) * 1.5 for x in x_values]  # Scale for visibility\n        \n        bell_points = VGroup()\n        for i in range(num_points):\n            point = Dot(point=[x_values[i], y_values[i], 0], color=BLUE)\n            bell_points.add(point)\n        \n        bell_label = Text(\"Sampling Distribution of Means\").scale(0.8).next_to(bell_points, DOWN)\n        \n        self.play(Create(bell_points), Write(bell_label))\n        self.wait(1)\n        \n        # Draw lines connecting the points to form a curve\n        lines = VGroup()\n        for i in range(num_points-1):\n            start_point = bell_points[i].get_center()\n            end_point = bell_points[i+1].get_center()\n            line = Line(start=start_point, end=end_point, color=BLUE)\n            lines.add(line)\n        \n        self.play(Create(lines))\n        self.wait(1)\n        \n        # CLT text (Element 5)\n        clt = Text(\"Central Limit Theorem\").next_to(bell_points, UP)\n        self.play(Write(clt))\n        \n        order_text = Text(\"Order from Chaos\").next_to(clt, UP)\n        self.play(Write(order_text))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(bell_points), \n            FadeOut(lines),\n            FadeOut(bell_label), \n            FadeOut(clt), \n            FadeOut(order_text)\n        )\n        \n        conclusion = Text(\"Order emerges from Chaos through Sampling!\")\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Monte Carlo Simulation help in understanding the Central Limit Theorem through sampling distributions of means?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animated video introduction for a presentation about number sequences using ManimCE. In this video, the background should be a light beige, and the main text should be in a dark gray color. I'd like to have the title \"Sequ\u00eancias Num\u00e9ricas\" divided into two lines, with each word stacked on top of the other, placed in the center of the screen.\n\nAround the title, there should be two concentric squares; the inner one should be just a white outline, and the outer square should be solid red with a white outline as well. Before the title and squares appear, I want two images representing groups of numbers to fly into the frame, one from each side of the two squares. These images should be sourced from \"./assets/NumberGroup1.png\" and \"./assets/NumberGroup2.png\".\n\nAdditionally, I want two thin red horizontal rectangles to fade in next to the squares: one next to the left of the outer square and moving slightly upwards, and the other to the right of the square moving slightly downwards.\n\nOnce everything is set up, the two images of number groups should swiftly move downwards, exiting the frame with the first moving faster and the second following 0.8 seconds later a bit more slowly. To finish the introduction, all elements should simultaneously slide out of the frame to the left as if pushed by an unseen force.\n\nPlease set the video's dimensions to be suitable for a mobile device, with a resolution ratio of 9:16. Can you generate an animation like that for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2\\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3\\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Simplified inner integral step\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [\\frac{1}{3}(-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for final step\n        explanation3 = Text(\"Evaluate the antiderivative at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(1 - (-1))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplified final solution\n        simplified_solution = MathTex(r\"= \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video introduction for a presentation about number sequences using ManimCE. In this video, the background should be a light beige, and the main text should be in a dark gray color. I'd like to have the title \"Sequ\u00eancias Num\u00e9ricas\" divided into two lines, with each word stacked on top of the other, placed in the center of the screen.\n\nAround the title, there should be two concentric squares; the inner one should be just a white outline, and the outer square should be solid red with a white outline as well. Before the title and squares appear, I want two images representing groups of numbers to fly into the frame, one from each side of the two squares. These images should be sourced from \"./assets/NumberGroup1.png\" and \"./assets/NumberGroup2.png\".\n\nAdditionally, I want two thin red horizontal rectangles to fade in next to the squares: one next to the left of the outer square and moving slightly upwards, and the other to the right of the square moving slightly downwards.\n\nOnce everything is set up, the two images of number groups should swiftly move downwards, exiting the frame with the first moving faster and the second following 0.8 seconds later a bit more slowly. To finish the introduction, all elements should simultaneously slide out of the frame to the left as if pushed by an unseen force.\n\nPlease set the video's dimensions to be suitable for a mobile device, with a resolution ratio of 9:16. Can you generate an animation like that for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animated video introduction for a presentation about number sequences using manimce. in this video, the background should be a light beige, and the main text should be in a dark gray color. i'd like to have the title \"sequ\u00eancias num\u00e9ricas\" divided into two lines, with each word stacked on top of the other, placed in the center of the screen.\n\naround the title, there should be two concentric squares; the inner one should be just a white outline, and the outer square should be solid red with a white outline as well. before the title and squares appear, i want two images representing groups of numbers to fly into the frame, one from each side of the two squares. these images should be sourced from \"./assets/numbergroup1.png\" and \"./assets/numbergroup2.png\".\n\nadditionally, i want two thin red horizontal rectangles to fade in next to the squares: one next to the left of the outer square and moving slightly upwards, and the other to the right of the square moving slightly downwards.\n\nonce everything is set up, the two images of number groups should swiftly move downwards, exiting the frame with the first moving faster and the second following 0.8 seconds later a bit more slowly. to finish the introduction, all elements should simultaneously slide out of the frame to the left as if pushed by an unseen force.\n\nplease set the video's dimensions to be suitable for a mobile device, with a resolution ratio of 9:16. can you generate an animation like that for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} r^2\\sin(\\theta) dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{1}{3}r^3\\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem, inner_integral))\n        self.wait(1)\n\n        # Simplified inner integral step\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} \\frac{1}{3}\\sin(\\theta) d\\theta\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to \u03b8\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [\\frac{1}{3}(-\\cos(\\theta))]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for final step\n        explanation3 = Text(\"Evaluate the antiderivative at the limits\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{1}{3}(1 - (-1))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplified final solution\n        simplified_solution = MathTex(r\"= \\frac{2}{3}\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video introduction for a presentation about number sequences using ManimCE. In this video, the background should be a light beige, and the main text should be in a dark gray color. I'd like to have the title \"Sequ\u00eancias Num\u00e9ricas\" divided into two lines, with each word stacked on top of the other, placed in the center of the screen.\n\nAround the title, there should be two concentric squares; the inner one should be just a white outline, and the outer square should be solid red with a white outline as well. Before the title and squares appear, I want two images representing groups of numbers to fly into the frame, one from each side of the two squares. These images should be sourced from \"./assets/NumberGroup1.png\" and \"./assets/NumberGroup2.png\".\n\nAdditionally, I want two thin red horizontal rectangles to fade in next to the squares: one next to the left of the outer square and moving slightly upwards, and the other to the right of the square moving slightly downwards.\n\nOnce everything is set up, the two images of number groups should swiftly move downwards, exiting the frame with the first moving faster and the second following 0.8 seconds later a bit more slowly. To finish the introduction, all elements should simultaneously slide out of the frame to the left as if pushed by an unseen force.\n\nPlease set the video's dimensions to be suitable for a mobile device, with a resolution ratio of 9:16. Can you generate an animation like that for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that introduces the concept of Fourier series by visually demonstrating it using a square wave signal, and then showing how its Fourier series expansion is calculated as well as what the partial sum of the series looks like, with all steps accompanied by clear and concise text explanations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        axes = Axes(x_range=[0, 5], y_range=[0, 4], axis_config={\"color\": BLUE})\n        func_graph = axes.plot(lambda x: 0.1 * x ** 2, color=GREEN)\n        area = axes.get_area(func_graph, x_range=[0.3, 4.5], color=(RED, GREEN), opacity=0.5)\n        self.play(Create(axes), Create(func_graph), FadeIn(area))\n        self.wait(2)\n\n        # Annotating the boundaries of the integral\n        x_labels = [\n            axes.get_x_axis_label(MathTex(f\"{x_label}\")).rotate(90 * DEGREES)\n            for x_label in (0.3, 4.5)\n        ]\n        self.play(*[Write(label) for label in x_labels])\n        self.wait(1)\n\n        # Display the integral representation\n        integral_text = MathTex(r\"\\int_{0.3}^{4.5}\", r\"0.1x^2\", r\"dx\").next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(2)\n\n        # Calculate and show the exact value of the integral\n        exact_value = MathTex(\"= \\\\left. \\\\frac{0.1}{3} x^3 \\\\right|_{0.3}^{4.5}\")\n        self.play(Transform(integral_text, exact_value))\n        self.wait(2)\n\n        # Show the result of the definite integral\n        result = MathTex(\"= \\\\frac{0.1}{3} (4.5^3 - 0.3^3)\").next_to(exact_value, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene and show the definite area\n        self.play(FadeOut(axes), FadeOut(func_graph), FadeOut(integral_text))\n        self.play(FadeIn(area), Write(result))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that introduces the concept of Fourier series by visually demonstrating it using a square wave signal, and then showing how its Fourier series expansion is calculated as well as what the partial sum of the series looks like, with all steps accompanied by clear and concise text explanations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that introduces the concept of fourier series by visually demonstrating it using a square wave signal, and then showing how its fourier series expansion is calculated as well as what the partial sum of the series looks like, with all steps accompanied by clear and concise text explanations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the function and the area problem\n        axes = Axes(x_range=[0, 5], y_range=[0, 4], axis_config={\"color\": BLUE})\n        func_graph = axes.plot(lambda x: 0.1 * x ** 2, color=GREEN)\n        area = axes.get_area(func_graph, x_range=[0.3, 4.5], color=(RED, GREEN), opacity=0.5)\n        self.play(Create(axes), Create(func_graph), FadeIn(area))\n        self.wait(2)\n\n        # Annotating the boundaries of the integral\n        x_labels = [\n            axes.get_x_axis_label(MathTex(f\"{x_label}\")).rotate(90 * DEGREES)\n            for x_label in (0.3, 4.5)\n        ]\n        self.play(*[Write(label) for label in x_labels])\n        self.wait(1)\n\n        # Display the integral representation\n        integral_text = MathTex(r\"\\int_{0.3}^{4.5}\", r\"0.1x^2\", r\"dx\").next_to(area, UP)\n        self.play(Write(integral_text))\n        self.wait(2)\n\n        # Calculate and show the exact value of the integral\n        exact_value = MathTex(\"= \\\\left. \\\\frac{0.1}{3} x^3 \\\\right|_{0.3}^{4.5}\")\n        self.play(Transform(integral_text, exact_value))\n        self.wait(2)\n\n        # Show the result of the definite integral\n        result = MathTex(\"= \\\\frac{0.1}{3} (4.5^3 - 0.3^3)\").next_to(exact_value, DOWN)\n        self.play(Write(result))\n        self.wait(2)\n\n        # Clear the scene and show the definite area\n        self.play(FadeOut(axes), FadeOut(func_graph), FadeOut(integral_text))\n        self.play(FadeIn(area), Write(result))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that introduces the concept of Fourier series by visually demonstrating it using a square wave signal, and then showing how its Fourier series expansion is calculated as well as what the partial sum of the series looks like, with all steps accompanied by clear and concise text explanations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational video that explains how to find the area under a curve using integration. Can you show me a visual animation where it starts by displaying a mathematical function, specifically f(x) = 3x^2 + 2, and poses an initial problem: finding the area under this curve from x = 1 to x = 2? After establishing this problem, I want the animation to graph the function on an x-y plane with axes ranging from 0 to 3 on the x-axis and 0 to 20 on the y-axis. I would also like the area of interest under the curve to be highlighted. Once the problem is visually represented, can the animation then show the integral of the function from 1 to 2, and the steps to solve it, eventually displaying the antiderivative and calculating the numerical area value? Finally, clear everything away and show only the final result of the area value. The explanation should pause at key steps to give viewers time to understand the process, and each part of the problem should smoothly transition into the next."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Display the limits of integration\n        limits = MathTex(r\"[2^4/4, 3^4/4]\")\n        self.play(Write(limits))\n        self.wait(2)\n\n        # Evaluating the definite integral\n        solution1 = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Simplifying the result\n        explanation2 = Text(\"Simplifying the result:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Further simplification\n        final_answer = MathTex(r\"= \\frac{65}{4}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational video that explains how to find the area under a curve using integration. Can you show me a visual animation where it starts by displaying a mathematical function, specifically f(x) = 3x^2 + 2, and poses an initial problem: finding the area under this curve from x = 1 to x = 2? After establishing this problem, I want the animation to graph the function on an x-y plane with axes ranging from 0 to 3 on the x-axis and 0 to 20 on the y-axis. I would also like the area of interest under the curve to be highlighted. Once the problem is visually represented, can the animation then show the integral of the function from 1 to 2, and the steps to solve it, eventually displaying the antiderivative and calculating the numerical area value? Finally, clear everything away and show only the final result of the area value. The explanation should pause at key steps to give viewers time to understand the process, and each part of the problem should smoothly transition into the next."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational video that explains how to find the area under a curve using integration. can you show me a visual animation where it starts by displaying a mathematical function, specifically f(x) = 3x^2 + 2, and poses an initial problem: finding the area under this curve from x = 1 to x = 2? after establishing this problem, i want the animation to graph the function on an x-y plane with axes ranging from 0 to 3 on the x-axis and 0 to 20 on the y-axis. i would also like the area of interest under the curve to be highlighted. once the problem is visually represented, can the animation then show the integral of the function from 1 to 2, and the steps to solve it, eventually displaying the antiderivative and calculating the numerical area value? finally, clear everything away and show only the final result of the area value. the explanation should pause at key steps to give viewers time to understand the process, and each part of the problem should smoothly transition into the next."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_2^3 x^3 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int x^n \\,dx = \\frac{x^{n+1}}{n+1} + C\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Display the limits of integration\n        limits = MathTex(r\"[2^4/4, 3^4/4]\")\n        self.play(Write(limits))\n        self.wait(2)\n\n        # Evaluating the definite integral\n        solution1 = MathTex(r\"= \\frac{3^4}{4} - \\frac{2^4}{4}\")\n        self.play(ReplacementTransform(problem.copy(), solution1))\n        self.wait(1)\n\n        # Simplifying the result\n        explanation2 = Text(\"Simplifying the result:\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\frac{81}{4} - \\frac{16}{4}\")\n        self.play(ReplacementTransform(solution1, final_solution))\n        self.wait(1)\n\n        # Further simplification\n        final_answer = MathTex(r\"= \\frac{65}{4}\")\n        self.play(ReplacementTransform(final_solution, final_answer))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final answer\n        self.play(Write(final_answer))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational video that explains how to find the area under a curve using integration. Can you show me a visual animation where it starts by displaying a mathematical function, specifically f(x) = 3x^2 + 2, and poses an initial problem: finding the area under this curve from x = 1 to x = 2? After establishing this problem, I want the animation to graph the function on an x-y plane with axes ranging from 0 to 3 on the x-axis and 0 to 20 on the y-axis. I would also like the area of interest under the curve to be highlighted. Once the problem is visually represented, can the animation then show the integral of the function from 1 to 2, and the steps to solve it, eventually displaying the antiderivative and calculating the numerical area value? Finally, clear everything away and show only the final result of the area value. The explanation should pause at key steps to give viewers time to understand the process, and each part of the problem should smoothly transition into the next."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_decision_tree.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.decision_tree.decision_tree import (\n    DecisionTreeDiagram,\n    DecisionTreeSurface,\n    IrisDatasetPlot,\n)\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn import datasets\nimport sklearn\nimport matplotlib.pyplot as plt\n\n\ndef learn_iris_decision_tree(iris):\n    decision_tree = DecisionTreeClassifier(\n        random_state=1, max_depth=3, max_leaf_nodes=6\n    )\n    decision_tree = decision_tree.fit(iris.data[:, :2], iris.target)\n    # output the decisioin tree in some format\n    return decision_tree\n\n\ndef make_sklearn_tree(dataset, max_tree_depth=3):\n    tree = learn_iris_decision_tree(dataset)\n    feature_names = dataset.feature_names[0:2]\n    return tree, tree.tree_\n\n\nclass DecisionTreeScene(Scene):\n    def construct(self):\n        \"\"\"Makes a decision tree object\"\"\"\n        iris_dataset = datasets.load_iris()\n        clf, sklearn_tree = make_sklearn_tree(iris_dataset)\n        # sklearn.tree.plot_tree(clf, node_ids=True)\n        # plt.show()\n        decision_tree = DecisionTreeDiagram(\n            sklearn_tree,\n            class_images_paths=[\n                \"images/iris_dataset/SetosaFlower.jpeg\",\n                \"images/iris_dataset/VeriscolorFlower.jpeg\",\n                \"images/iris_dataset/VirginicaFlower.jpeg\",\n            ],\n            class_names=[\"Setosa\", \"Veriscolor\", \"Virginica\"],\n            feature_names=[\"Sepal Length\", \"Sepal Width\"],\n        )\n        decision_tree.move_to(ORIGIN)\n        create_decision_tree = Create(decision_tree, traversal_order=\"bfs\")\n        self.play(create_decision_tree)\n        # self.play(create_decision_tree)\n\n\nclass SurfacePlot(Scene):\n    def construct(self):\n        iris_dataset = datasets.load_iris()\n        iris_dataset_plot = IrisDatasetPlot(iris_dataset)\n        iris_dataset_plot.all_group.scale(1.0)\n        iris_dataset_plot.all_group.shift([-3, 0.2, 0])\n        self.play(Create(iris_dataset_plot))\n        # make the decision tree classifier\n        decision_tree_classifier, sklearn_tree = make_sklearn_tree(iris_dataset)\n        decision_tree_surface = DecisionTreeSurface(\n            decision_tree_classifier, iris_dataset.data, iris_dataset_plot.axes_group[0]\n        )\n        self.play(Create(decision_tree_surface))\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_decision_tree.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_decision_tree.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.decision_tree.decision_tree import (\n    DecisionTreeDiagram,\n    DecisionTreeSurface,\n    IrisDatasetPlot,\n)\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn import datasets\nimport sklearn\nimport matplotlib.pyplot as plt\n\n\ndef learn_iris_decision_tree(iris):\n    decision_tree = DecisionTreeClassifier(\n        random_state=1, max_depth=3, max_leaf_nodes=6\n    )\n    decision_tree = decision_tree.fit(iris.data[:, :2], iris.target)\n    # output the decisioin tree in some format\n    return decision_tree\n\n\ndef make_sklearn_tree(dataset, max_tree_depth=3):\n    tree = learn_iris_decision_tree(dataset)\n    feature_names = dataset.feature_names[0:2]\n    return tree, tree.tree_\n\n\nclass DecisionTreeScene(Scene):\n    def construct(self):\n        \"\"\"Makes a decision tree object\"\"\"\n        iris_dataset = datasets.load_iris()\n        clf, sklearn_tree = make_sklearn_tree(iris_dataset)\n        # sklearn.tree.plot_tree(clf, node_ids=True)\n        # plt.show()\n        decision_tree = DecisionTreeDiagram(\n            sklearn_tree,\n            class_images_paths=[\n                \"images/iris_dataset/SetosaFlower.jpeg\",\n                \"images/iris_dataset/VeriscolorFlower.jpeg\",\n                \"images/iris_dataset/VirginicaFlower.jpeg\",\n            ],\n            class_names=[\"Setosa\", \"Veriscolor\", \"Virginica\"],\n            feature_names=[\"Sepal Length\", \"Sepal Width\"],\n        )\n        decision_tree.move_to(ORIGIN)\n        create_decision_tree = Create(decision_tree, traversal_order=\"bfs\")\n        self.play(create_decision_tree)\n        # self.play(create_decision_tree)\n\n\nclass SurfacePlot(Scene):\n    def construct(self):\n        iris_dataset = datasets.load_iris()\n        iris_dataset_plot = IrisDatasetPlot(iris_dataset)\n        iris_dataset_plot.all_group.scale(1.0)\n        iris_dataset_plot.all_group.shift([-3, 0.2, 0])\n        self.play(Create(iris_dataset_plot))\n        # make the decision tree classifier\n        decision_tree_classifier, sklearn_tree = make_sklearn_tree(iris_dataset)\n        decision_tree_surface = DecisionTreeSurface(\n            decision_tree_classifier, iris_dataset.data, iris_dataset_plot.axes_group[0]\n        )\n        self.play(Create(decision_tree_surface))\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_decision_tree.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that illustrates the concept of finding the area under the curve of the function f(x) = e^(-x^2) using numerical methods, specifically showing the area between x = -1 and x = 1, and ultimately displaying the estimated numerical value of this area?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series_problem = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for convergence test\n        explanation1 = Text(\"Use the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Convergence condition\n        condition = MathTex(r\"p > 1\")\n        self.play(ReplacementTransform(series_problem.copy(), condition))\n        self.wait(1)\n\n        # Applying the p-test\n        p_test_application = MathTex(r\"\\text{Since } p = 2 > 1, \\text{ the series converges.}\")\n        self.play(ReplacementTransform(condition, p_test_application))\n        self.wait(1)\n\n        # Explanation for p-test result\n        explanation2 = Text(\"The series converges by the p-test\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Closing conclusion\n        final_conclusion = MathTex(r\"\\therefore \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ is convergent}\")\n        self.play(ReplacementTransform(p_test_application, final_conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates the concept of finding the area under the curve of the function f(x) = e^(-x^2) using numerical methods, specifically showing the area between x = -1 and x = 1, and ultimately displaying the estimated numerical value of this area?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that illustrates the concept of finding the area under the curve of the function f(x) = e^(-x^2) using numerical methods, specifically showing the area between x = -1 and x = 1, and ultimately displaying the estimated numerical value of this area?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Displaying the series\n        series_problem = MathTex(r\"\\sum_{n=1}^{\\infty} \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(1)\n\n        # Explanation for convergence test\n        explanation1 = Text(\"Use the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Convergence condition\n        condition = MathTex(r\"p > 1\")\n        self.play(ReplacementTransform(series_problem.copy(), condition))\n        self.wait(1)\n\n        # Applying the p-test\n        p_test_application = MathTex(r\"\\text{Since } p = 2 > 1, \\text{ the series converges.}\")\n        self.play(ReplacementTransform(condition, p_test_application))\n        self.wait(1)\n\n        # Explanation for p-test result\n        explanation2 = Text(\"The series converges by the p-test\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Closing conclusion\n        final_conclusion = MathTex(r\"\\therefore \\sum_{n=1}^{\\infty} \\frac{1}{n^2} \\text{ is convergent}\")\n        self.play(ReplacementTransform(p_test_application, final_conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates the concept of finding the area under the curve of the function f(x) = e^(-x^2) using numerical methods, specifically showing the area between x = -1 and x = 1, and ultimately displaying the estimated numerical value of this area?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do Calabi-Yau manifolds mathematically define the compactified extra dimensions predicted by String Theory?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass CalabiYauExploration(Scene):\n    def construct(self):\n        # Introduction with title and subtitle\n        title = Text(\"Exploring Calabi-Yau Manifolds\", font_size=40)\n        subtitle = Text(\"Extra Dimensions in String Theory\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Cosmic background - simple stars and galaxy representation\n        stars = VGroup(*[Dot(point=np.array([i, j, 0]), radius=0.05)\n                       for i in range(-5, 6, 2) \n                       for j in range(-3, 4, 2)])\n        galaxy = Circle(radius=1.5, color=BLUE).set_fill(BLUE, opacity=0.2)\n        \n        self.play(FadeIn(stars))\n        self.play(Create(galaxy))\n        self.wait(1)\n        \n        # Transition to concept of extra dimensions\n        concept_text = Text(\"Extra dimensions curl into tiny spaces\", font_size=30)\n        self.play(FadeOut(stars), FadeOut(galaxy))\n        self.play(Write(concept_text))\n        self.wait(1)\n        self.play(FadeOut(concept_text))\n        \n        # Grid to represent dimensions\n        grid = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE}\n        )\n        \n        self.play(Create(grid))\n        self.wait(1)\n        \n        # Shape transformations to suggest complexity of Calabi-Yau manifolds\n        circle = Circle(radius=1, color=RED)\n        square = Square(side_length=2, color=GREEN)\n        \n        # Simple star-like shape using polygon for compatibility\n        points = []\n        for i in range(5):\n            # Outer points\n            angle = i * 2 * PI / 5\n            points.append([np.cos(angle), np.sin(angle), 0])\n            # Inner points\n            inner_angle = angle + PI / 5\n            points.append([0.4 * np.cos(inner_angle), 0.4 * np.sin(inner_angle), 0])\n        star = Polygon(*points, color=YELLOW)\n        \n        self.play(Create(circle))\n        self.wait(0.5)\n        self.play(Transform(circle, square))\n        self.wait(0.5)\n        self.play(Transform(circle, star))\n        self.wait(1)\n        \n        # Mathematical equations defining Calabi-Yau manifolds - using simple notation\n        eq1 = Text(\"H1(M, OM) = 0\", font_size=36)\n        eq2 = Text(\"H2(M, OM) = 0\", font_size=36)\n        eq2.next_to(eq1, DOWN)\n        \n        self.play(FadeOut(grid), FadeOut(circle))\n        self.play(Write(eq1))\n        self.wait(0.5)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Explanation for the equations\n        explanation = Text(\"These equations define Calabi-Yau manifolds\", font_size=30)\n        explanation.next_to(eq2, DOWN, buff=0.5)\n        \n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Conclusion on significance of Calabi-Yau manifolds\n        self.play(FadeOut(eq1), FadeOut(eq2), FadeOut(explanation))\n        conclusion = Text(\"Calabi-Yau manifolds elegantly define\\nthe hidden dimensions of our universe\", \n                        font_size=30)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n\n# To render this animation with the filename \"video.mp4\", run:\n# manim -pql your_filename.py CalabiYauExploration -o video.mp4\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do Calabi-Yau manifolds mathematically define the compactified extra dimensions predicted by String Theory?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do calabi-yau manifolds mathematically define the compactified extra dimensions predicted by string theory?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass CalabiYauExploration(Scene):\n    def construct(self):\n        # Introduction with title and subtitle\n        title = Text(\"Exploring Calabi-Yau Manifolds\", font_size=40)\n        subtitle = Text(\"Extra Dimensions in String Theory\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Cosmic background - simple stars and galaxy representation\n        stars = VGroup(*[Dot(point=np.array([i, j, 0]), radius=0.05)\n                       for i in range(-5, 6, 2) \n                       for j in range(-3, 4, 2)])\n        galaxy = Circle(radius=1.5, color=BLUE).set_fill(BLUE, opacity=0.2)\n        \n        self.play(FadeIn(stars))\n        self.play(Create(galaxy))\n        self.wait(1)\n        \n        # Transition to concept of extra dimensions\n        concept_text = Text(\"Extra dimensions curl into tiny spaces\", font_size=30)\n        self.play(FadeOut(stars), FadeOut(galaxy))\n        self.play(Write(concept_text))\n        self.wait(1)\n        self.play(FadeOut(concept_text))\n        \n        # Grid to represent dimensions\n        grid = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": BLUE}\n        )\n        \n        self.play(Create(grid))\n        self.wait(1)\n        \n        # Shape transformations to suggest complexity of Calabi-Yau manifolds\n        circle = Circle(radius=1, color=RED)\n        square = Square(side_length=2, color=GREEN)\n        \n        # Simple star-like shape using polygon for compatibility\n        points = []\n        for i in range(5):\n            # Outer points\n            angle = i * 2 * PI / 5\n            points.append([np.cos(angle), np.sin(angle), 0])\n            # Inner points\n            inner_angle = angle + PI / 5\n            points.append([0.4 * np.cos(inner_angle), 0.4 * np.sin(inner_angle), 0])\n        star = Polygon(*points, color=YELLOW)\n        \n        self.play(Create(circle))\n        self.wait(0.5)\n        self.play(Transform(circle, square))\n        self.wait(0.5)\n        self.play(Transform(circle, star))\n        self.wait(1)\n        \n        # Mathematical equations defining Calabi-Yau manifolds - using simple notation\n        eq1 = Text(\"H1(M, OM) = 0\", font_size=36)\n        eq2 = Text(\"H2(M, OM) = 0\", font_size=36)\n        eq2.next_to(eq1, DOWN)\n        \n        self.play(FadeOut(grid), FadeOut(circle))\n        self.play(Write(eq1))\n        self.wait(0.5)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Explanation for the equations\n        explanation = Text(\"These equations define Calabi-Yau manifolds\", font_size=30)\n        explanation.next_to(eq2, DOWN, buff=0.5)\n        \n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Conclusion on significance of Calabi-Yau manifolds\n        self.play(FadeOut(eq1), FadeOut(eq2), FadeOut(explanation))\n        conclusion = Text(\"Calabi-Yau manifolds elegantly define\\nthe hidden dimensions of our universe\", \n                        font_size=30)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n\n# To render this animation with the filename \"video.mp4\", run:\n# manim -pql your_filename.py CalabiYauExploration -o video.mp4\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do Calabi-Yau manifolds mathematically define the compactified extra dimensions predicted by String Theory?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated video using ManimCE that explains how to solve a first-order ordinary differential equation (ODE) using an integrating factor? I would like the video to include: \n\n1. The initial display of the ODE: dy/dx + 3y = x.\n2. A description and display of the integrating factor: mu(x) = e^(3x).\n3. The equation being multiplied by the integrating factor resulting in: e^(3x)*dy/dx + 3e^(3x)*y = xe^(3x).\n4. An announcement that we're looking at the general solution before integration, without actually displaying the integration step.\n5. The general solution after the integration of both sides: y(x) = (e^(-3x)/3)\u222bxe^(3x)dx + Ce^(-3x).\n6. The final general solution presented neatly: y = (1/3)x - (1/9) + Ce^(-3x).\n7. Then conclude by stating that we have solved the ODE and display the final solution again after clearing all previous writing off the screen. \n\nPlease ensure the transitions are smooth and allow for moments where the viewer can take in the information before moving on to the next step."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DiceRollSimulation(Scene):\n    def construct(self):\n        die_face = 0\n        roll_counts = [0] * 6  # List to hold counts of each face\n        roll_count_text = [\n            always_redraw(lambda i=i: Text(f\"{roll_counts[i]}\").next_to(die_face_mob, DOWN).shift(RIGHT * (i - 2.5) * 0.6))\n            for i in range(6)\n        ]\n\n        die_face_mob = Square(side_length=1)\n        die_face_label = always_redraw(lambda: Text(str(die_face)).move_to(die_face_mob.get_center()))\n        die_face_group = VGroup(die_face_mob, die_face_label)\n\n        self.add(die_face_group)\n        self.add(*roll_count_text)\n\n        for i in range(6):\n            self.play(FadeIn(roll_count_text[i]))\n\n        for _ in range(100):\n            die_face = random.randint(1, 6)\n            roll_counts[die_face - 1] += 1\n            self.play(\n                Transform(die_face_label, Text(str(die_face)).move_to(die_face_mob.get_center())),\n                run_time=0.1\n            )\n\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video using ManimCE that explains how to solve a first-order ordinary differential equation (ODE) using an integrating factor? I would like the video to include: \n\n1. The initial display of the ODE: dy/dx + 3y = x.\n2. A description and display of the integrating factor: mu(x) = e^(3x).\n3. The equation being multiplied by the integrating factor resulting in: e^(3x)*dy/dx + 3e^(3x)*y = xe^(3x).\n4. An announcement that we're looking at the general solution before integration, without actually displaying the integration step.\n5. The general solution after the integration of both sides: y(x) = (e^(-3x)/3)\u222bxe^(3x)dx + Ce^(-3x).\n6. The final general solution presented neatly: y = (1/3)x - (1/9) + Ce^(-3x).\n7. Then conclude by stating that we have solved the ODE and display the final solution again after clearing all previous writing off the screen. \n\nPlease ensure the transitions are smooth and allow for moments where the viewer can take in the information before moving on to the next step."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated video using manimce that explains how to solve a first-order ordinary differential equation (ode) using an integrating factor? i would like the video to include: \n\n1. the initial display of the ode: dy/dx + 3y = x.\n2. a description and display of the integrating factor: mu(x) = e^(3x).\n3. the equation being multiplied by the integrating factor resulting in: e^(3x)*dy/dx + 3e^(3x)*y = xe^(3x).\n4. an announcement that we're looking at the general solution before integration, without actually displaying the integration step.\n5. the general solution after the integration of both sides: y(x) = (e^(-3x)/3)\u222bxe^(3x)dx + ce^(-3x).\n6. the final general solution presented neatly: y = (1/3)x - (1/9) + ce^(-3x).\n7. then conclude by stating that we have solved the ode and display the final solution again after clearing all previous writing off the screen. \n\nplease ensure the transitions are smooth and allow for moments where the viewer can take in the information before moving on to the next step."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DiceRollSimulation(Scene):\n    def construct(self):\n        die_face = 0\n        roll_counts = [0] * 6  # List to hold counts of each face\n        roll_count_text = [\n            always_redraw(lambda i=i: Text(f\"{roll_counts[i]}\").next_to(die_face_mob, DOWN).shift(RIGHT * (i - 2.5) * 0.6))\n            for i in range(6)\n        ]\n\n        die_face_mob = Square(side_length=1)\n        die_face_label = always_redraw(lambda: Text(str(die_face)).move_to(die_face_mob.get_center()))\n        die_face_group = VGroup(die_face_mob, die_face_label)\n\n        self.add(die_face_group)\n        self.add(*roll_count_text)\n\n        for i in range(6):\n            self.play(FadeIn(roll_count_text[i]))\n\n        for _ in range(100):\n            die_face = random.randint(1, 6)\n            roll_counts[die_face - 1] += 1\n            self.play(\n                Transform(die_face_label, Text(str(die_face)).move_to(die_face_mob.get_center())),\n                run_time=0.1\n            )\n\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video using ManimCE that explains how to solve a first-order ordinary differential equation (ODE) using an integrating factor? I would like the video to include: \n\n1. The initial display of the ODE: dy/dx + 3y = x.\n2. A description and display of the integrating factor: mu(x) = e^(3x).\n3. The equation being multiplied by the integrating factor resulting in: e^(3x)*dy/dx + 3e^(3x)*y = xe^(3x).\n4. An announcement that we're looking at the general solution before integration, without actually displaying the integration step.\n5. The general solution after the integration of both sides: y(x) = (e^(-3x)/3)\u222bxe^(3x)dx + Ce^(-3x).\n6. The final general solution presented neatly: y = (1/3)x - (1/9) + Ce^(-3x).\n7. Then conclude by stating that we have solved the ODE and display the final solution again after clearing all previous writing off the screen. \n\nPlease ensure the transitions are smooth and allow for moments where the viewer can take in the information before moving on to the next step."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can we use the Euler characteristic to distinguish between different topological spaces, such as a torus and a Klein bottle?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerCharacteristicScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling Surfaces: The Euler Characteristic's Hidden Secrets\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"How can we distinguish different topological spaces?\", font_size=32)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Sphere\n        sphere_text = Text(\"Sphere\", font_size=36)\n        sphere_text.to_edge(UP)\n        sphere = Circle(radius=2, color=BLUE)  # 2D representation of sphere\n        sphere_eq = MathTex(r\"\\chi(Sphere) = 2\")\n        sphere_eq.next_to(sphere, DOWN, buff=1)\n        \n        self.play(Create(sphere), Write(sphere_text))\n        self.wait(1)\n        self.play(Write(sphere_eq))\n        self.wait(2)\n        self.play(FadeOut(sphere), FadeOut(sphere_text), FadeOut(sphere_eq))\n        \n        # Torus\n        torus_text = Text(\"Torus (Donut Shape)\", font_size=36)\n        torus_text.to_edge(UP)\n        \n        # Simple representation of torus using two circles\n        outer_circle = Circle(radius=2, color=ORANGE)\n        inner_circle = Circle(radius=0.5, color=ORANGE).shift(RIGHT * 2)\n        \n        torus_eq = MathTex(r\"\\chi(Torus) = 0\")\n        torus_eq.next_to(outer_circle, DOWN, buff=1)\n        \n        self.play(Create(outer_circle), Write(torus_text))\n        self.play(Create(inner_circle))\n        self.wait(1)\n        self.play(Write(torus_eq))\n        self.wait(2)\n        self.play(FadeOut(outer_circle), FadeOut(inner_circle), FadeOut(torus_text), FadeOut(torus_eq))\n        \n        # Klein Bottle\n        klein_text = Text(\"Klein Bottle\", font_size=36)\n        klein_text.to_edge(UP)\n        \n        # Symbolic representation of Klein bottle\n        klein_circle = Circle(radius=1.5, color=PURPLE)\n        klein_line = Line(start=[-1.5, 0, 0], end=[1.5, 0, 0], color=PURPLE)\n        klein_shape = VGroup(klein_circle, klein_line)\n        \n        klein_eq = MathTex(r\"\\chi(Klein \\ bottle) = 0\")\n        klein_eq.next_to(klein_shape, DOWN, buff=1)\n        \n        self.play(Create(klein_shape), Write(klein_text))\n        self.wait(1)\n        self.play(Write(klein_eq))\n        self.wait(2)\n        self.play(FadeOut(klein_shape), FadeOut(klein_text), FadeOut(klein_eq))\n        \n        # Comparison\n        comparison_text = Text(\"Same Euler Characteristic, Different Structures\", font_size=32)\n        comparison_text.to_edge(UP)\n        \n        torus_small = VGroup(\n            Circle(radius=1, color=ORANGE),\n            Circle(radius=0.25, color=ORANGE).shift(RIGHT * 1)\n        ).scale(0.8).shift(LEFT * 3)\n        \n        klein_small = VGroup(\n            Circle(radius=0.8, color=PURPLE),\n            Line(start=[-0.8, 0, 0], end=[0.8, 0, 0], color=PURPLE)\n        ).scale(0.8).shift(RIGHT * 3)\n        \n        torus_label = Text(\"Torus: \u03c7 = 0\", font_size=26).next_to(torus_small, DOWN)\n        klein_label = Text(\"Klein Bottle: \u03c7 = 0\", font_size=26).next_to(klein_small, DOWN)\n        \n        self.play(Write(comparison_text))\n        self.play(Create(torus_small), Create(klein_small))\n        self.play(Write(torus_label), Write(klein_label))\n        self.wait(2)\n        \n        # Key insight\n        insight = Text(\"The Euler characteristic reveals the structure\\nbut not everything about a surface.\", font_size=32)\n        insight.to_edge(DOWN, buff=1)\n        \n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(comparison_text),\n            FadeOut(torus_small),\n            FadeOut(klein_small),\n            FadeOut(torus_label),\n            FadeOut(klein_label),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"The Euler characteristic: A powerful tool\\nto unveil topological secrets.\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we use the Euler characteristic to distinguish between different topological spaces, such as a torus and a Klein bottle?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can we use the euler characteristic to distinguish between different topological spaces, such as a torus and a klein bottle?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerCharacteristicScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling Surfaces: The Euler Characteristic's Hidden Secrets\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"How can we distinguish different topological spaces?\", font_size=32)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Sphere\n        sphere_text = Text(\"Sphere\", font_size=36)\n        sphere_text.to_edge(UP)\n        sphere = Circle(radius=2, color=BLUE)  # 2D representation of sphere\n        sphere_eq = MathTex(r\"\\chi(Sphere) = 2\")\n        sphere_eq.next_to(sphere, DOWN, buff=1)\n        \n        self.play(Create(sphere), Write(sphere_text))\n        self.wait(1)\n        self.play(Write(sphere_eq))\n        self.wait(2)\n        self.play(FadeOut(sphere), FadeOut(sphere_text), FadeOut(sphere_eq))\n        \n        # Torus\n        torus_text = Text(\"Torus (Donut Shape)\", font_size=36)\n        torus_text.to_edge(UP)\n        \n        # Simple representation of torus using two circles\n        outer_circle = Circle(radius=2, color=ORANGE)\n        inner_circle = Circle(radius=0.5, color=ORANGE).shift(RIGHT * 2)\n        \n        torus_eq = MathTex(r\"\\chi(Torus) = 0\")\n        torus_eq.next_to(outer_circle, DOWN, buff=1)\n        \n        self.play(Create(outer_circle), Write(torus_text))\n        self.play(Create(inner_circle))\n        self.wait(1)\n        self.play(Write(torus_eq))\n        self.wait(2)\n        self.play(FadeOut(outer_circle), FadeOut(inner_circle), FadeOut(torus_text), FadeOut(torus_eq))\n        \n        # Klein Bottle\n        klein_text = Text(\"Klein Bottle\", font_size=36)\n        klein_text.to_edge(UP)\n        \n        # Symbolic representation of Klein bottle\n        klein_circle = Circle(radius=1.5, color=PURPLE)\n        klein_line = Line(start=[-1.5, 0, 0], end=[1.5, 0, 0], color=PURPLE)\n        klein_shape = VGroup(klein_circle, klein_line)\n        \n        klein_eq = MathTex(r\"\\chi(Klein \\ bottle) = 0\")\n        klein_eq.next_to(klein_shape, DOWN, buff=1)\n        \n        self.play(Create(klein_shape), Write(klein_text))\n        self.wait(1)\n        self.play(Write(klein_eq))\n        self.wait(2)\n        self.play(FadeOut(klein_shape), FadeOut(klein_text), FadeOut(klein_eq))\n        \n        # Comparison\n        comparison_text = Text(\"Same Euler Characteristic, Different Structures\", font_size=32)\n        comparison_text.to_edge(UP)\n        \n        torus_small = VGroup(\n            Circle(radius=1, color=ORANGE),\n            Circle(radius=0.25, color=ORANGE).shift(RIGHT * 1)\n        ).scale(0.8).shift(LEFT * 3)\n        \n        klein_small = VGroup(\n            Circle(radius=0.8, color=PURPLE),\n            Line(start=[-0.8, 0, 0], end=[0.8, 0, 0], color=PURPLE)\n        ).scale(0.8).shift(RIGHT * 3)\n        \n        torus_label = Text(\"Torus: \u03c7 = 0\", font_size=26).next_to(torus_small, DOWN)\n        klein_label = Text(\"Klein Bottle: \u03c7 = 0\", font_size=26).next_to(klein_small, DOWN)\n        \n        self.play(Write(comparison_text))\n        self.play(Create(torus_small), Create(klein_small))\n        self.play(Write(torus_label), Write(klein_label))\n        self.wait(2)\n        \n        # Key insight\n        insight = Text(\"The Euler characteristic reveals the structure\\nbut not everything about a surface.\", font_size=32)\n        insight.to_edge(DOWN, buff=1)\n        \n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(comparison_text),\n            FadeOut(torus_small),\n            FadeOut(klein_small),\n            FadeOut(torus_label),\n            FadeOut(klein_label),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"The Euler characteristic: A powerful tool\\nto unveil topological secrets.\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we use the Euler characteristic to distinguish between different topological spaces, such as a torus and a Klein bottle?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can we geometrically interpret the relationship between Sylow p-subgroups and the quotient group when mapping elements via cosets?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExploringSymmetry(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Sylow Theorems: Geometric Group Intuition\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create a circle representing the group\n        circle = Circle(radius=2, color=WHITE)\n        label = Text(\"Group G\", font_size=24).next_to(circle, UP)\n        self.play(Create(circle), Write(label))\n        self.wait(1)\n        \n        # Use dots for cosets (simpler than sectors)\n        n_cosets = 4\n        cosets = VGroup()\n        coset_labels = VGroup()\n        colors = [RED, BLUE, GREEN, YELLOW]\n        \n        for i in range(n_cosets):\n            angle = i * TAU / n_cosets\n            radius = 1.3\n            pos = [radius * np.cos(angle), radius * np.sin(angle), 0]\n            \n            # Create a dot for each coset\n            dot = Dot(point=pos, color=colors[i], radius=0.3)\n            cosets.add(dot)\n            \n            # Add label - position relative to dot location\n            direction = np.array([np.cos(angle), np.sin(angle), 0])\n            coset_label = Text(f\"g{i+1}P\", font_size=20).next_to(dot, direction, buff=0.2)\n            coset_labels.add(coset_label)\n        \n        # Add cosets one by one\n        for i in range(n_cosets):\n            self.play(FadeIn(cosets[i]), Write(coset_labels[i]))\n        \n        self.wait(1)\n        \n        # First equation - coset decomposition\n        eq1 = Text(\"G = \u22c3 giP\", font_size=28).to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1.5)\n        self.play(FadeOut(eq1))\n        \n        # Add arrows between cosets in a clockwise direction\n        arrows = VGroup()\n        for i in range(n_cosets):\n            start = cosets[i].get_center()\n            end = cosets[(i+1) % n_cosets].get_center()\n            \n            # Add buffer to avoid overlap with dots\n            arrow = Arrow(start=start, end=end, color=WHITE, buff=0.4)\n            arrows.add(arrow)\n        \n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Second equation - coset multiplication\n        eq2 = Text(\"gP \u00b7 gjP = gijP\", font_size=28).to_edge(DOWN)\n        self.play(Write(eq2))\n        self.wait(1.5)\n        self.play(FadeOut(eq2))\n        \n        # Third equation - index relationship\n        eq3 = Text(\"|G:P| = [G:Ps]\", font_size=28).to_edge(DOWN)\n        self.play(Write(eq3))\n        self.wait(1.5)\n        \n        # Key insight\n        insight = Text(\"Cosets reveal geometric structure\", font_size=24).to_edge(UP)\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Cleanup - fade out all objects\n        self.play(\n            FadeOut(circle),\n            FadeOut(label),\n            FadeOut(cosets),\n            FadeOut(coset_labels),\n            FadeOut(arrows),\n            FadeOut(insight),\n            FadeOut(eq3)\n        )\n        \n        # Conclusion\n        conclusion = Text(\"Sylow theorems: Abstract algebra visualized\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we geometrically interpret the relationship between Sylow p-subgroups and the quotient group when mapping elements via cosets?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can we geometrically interpret the relationship between sylow p-subgroups and the quotient group when mapping elements via cosets?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExploringSymmetry(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Sylow Theorems: Geometric Group Intuition\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create a circle representing the group\n        circle = Circle(radius=2, color=WHITE)\n        label = Text(\"Group G\", font_size=24).next_to(circle, UP)\n        self.play(Create(circle), Write(label))\n        self.wait(1)\n        \n        # Use dots for cosets (simpler than sectors)\n        n_cosets = 4\n        cosets = VGroup()\n        coset_labels = VGroup()\n        colors = [RED, BLUE, GREEN, YELLOW]\n        \n        for i in range(n_cosets):\n            angle = i * TAU / n_cosets\n            radius = 1.3\n            pos = [radius * np.cos(angle), radius * np.sin(angle), 0]\n            \n            # Create a dot for each coset\n            dot = Dot(point=pos, color=colors[i], radius=0.3)\n            cosets.add(dot)\n            \n            # Add label - position relative to dot location\n            direction = np.array([np.cos(angle), np.sin(angle), 0])\n            coset_label = Text(f\"g{i+1}P\", font_size=20).next_to(dot, direction, buff=0.2)\n            coset_labels.add(coset_label)\n        \n        # Add cosets one by one\n        for i in range(n_cosets):\n            self.play(FadeIn(cosets[i]), Write(coset_labels[i]))\n        \n        self.wait(1)\n        \n        # First equation - coset decomposition\n        eq1 = Text(\"G = \u22c3 giP\", font_size=28).to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1.5)\n        self.play(FadeOut(eq1))\n        \n        # Add arrows between cosets in a clockwise direction\n        arrows = VGroup()\n        for i in range(n_cosets):\n            start = cosets[i].get_center()\n            end = cosets[(i+1) % n_cosets].get_center()\n            \n            # Add buffer to avoid overlap with dots\n            arrow = Arrow(start=start, end=end, color=WHITE, buff=0.4)\n            arrows.add(arrow)\n        \n        self.play(Create(arrows))\n        self.wait(1)\n        \n        # Second equation - coset multiplication\n        eq2 = Text(\"gP \u00b7 gjP = gijP\", font_size=28).to_edge(DOWN)\n        self.play(Write(eq2))\n        self.wait(1.5)\n        self.play(FadeOut(eq2))\n        \n        # Third equation - index relationship\n        eq3 = Text(\"|G:P| = [G:Ps]\", font_size=28).to_edge(DOWN)\n        self.play(Write(eq3))\n        self.wait(1.5)\n        \n        # Key insight\n        insight = Text(\"Cosets reveal geometric structure\", font_size=24).to_edge(UP)\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Cleanup - fade out all objects\n        self.play(\n            FadeOut(circle),\n            FadeOut(label),\n            FadeOut(cosets),\n            FadeOut(coset_labels),\n            FadeOut(arrows),\n            FadeOut(insight),\n            FadeOut(eq3)\n        )\n        \n        # Conclusion\n        conclusion = Text(\"Sylow theorems: Abstract algebra visualized\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we geometrically interpret the relationship between Sylow p-subgroups and the quotient group when mapping elements via cosets?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does Gaussian curvature influence the shape of a surface in four-dimensional spaces compared to three-dimensional spaces?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GaussianCurvatureIn4D(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Curvature Beyond Dimensions: Bending in 4D\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n\n        # Explaining 3D curvature\n        intro_text = Text(\"How does a surface bend in 3D?\", font_size=20)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n\n        # Visualization of a 2D surface (paper)\n        paper = Rectangle(height=2, width=3, color=BLUE, fill_opacity=0.5)\n        self.play(Create(paper))\n        self.wait(1)\n        \n        # Transform to a sphere (positive curvature)\n        sphere_text = Text(\"Sphere: Positive Curvature\", font_size=16).to_edge(DOWN)\n        curved_shape = Circle(radius=1.5, color=BLUE, fill_opacity=0.5)\n        self.play(Write(sphere_text))\n        self.play(Transform(paper, curved_shape))\n        self.wait(1.5)\n        self.play(FadeOut(sphere_text))\n        \n        # Transform to a \"saddle\" representation (negative curvature)\n        saddle_text = Text(\"Saddle: Negative Curvature\", font_size=16).to_edge(DOWN)\n        \n        # Simple representation of a saddle using crossed lines\n        line1 = Line(start=[-1.5, -1.5, 0], end=[1.5, 1.5, 0], color=BLUE)\n        line2 = Line(start=[-1.5, 1.5, 0], end=[1.5, -1.5, 0], color=BLUE)\n        saddle = VGroup(line1, line2)\n        \n        self.play(Write(saddle_text))\n        self.play(Transform(paper, saddle))\n        self.wait(1.5)\n        self.play(FadeOut(saddle_text))\n\n        # Introducing Gaussian curvature in 3D\n        curvature_text = Text(\"In 3D, Gaussian curvature measures how a surface bends\", font_size=18)\n        self.play(Write(curvature_text))\n        self.wait(1.5)\n        self.play(FadeOut(curvature_text))\n        self.play(FadeOut(paper))\n\n        # Showing the equation for Gaussian curvature\n        equation = MathTex(r\"K = \\frac{det\\, II}{det\\, I}\")\n        self.play(Write(equation))\n        self.wait(1.5)\n        self.play(FadeOut(equation))\n\n        # Transition to 4D\n        fourD_text = Text(\"What about in 4D?\", font_size=20)\n        self.play(Write(fourD_text))\n        self.wait(1)\n        self.play(FadeOut(fourD_text))\n\n        # 4D metric equation\n        metric = MathTex(r\"ds^2 = dx^2 + dy^2 + dz^2 + dw^2\")\n        self.play(Write(metric))\n        self.wait(1.5)\n        self.play(FadeOut(metric))\n\n        # Visualization for 4D\n        four_d_text = Text(\"Visualizing 4D projection\", font_size=18)\n        self.play(Write(four_d_text))\n        self.wait(1)\n        self.play(FadeOut(four_d_text))\n        \n        # Using squares to represent dimensions\n        square_3d = Square(side_length=2, color=BLUE, fill_opacity=0.5)\n        self.play(Create(square_3d))\n        self.wait(1)\n        \n        # Create a representation of 4D with nested squares\n        inner_square = Square(side_length=1.5, color=PURPLE, fill_opacity=0.4)\n        inner_square.shift(0.25*UP + 0.25*RIGHT)\n        square_4d = VGroup(\n            square_3d.copy().set_opacity(0.3),\n            inner_square\n        )\n        \n        transform_text = Text(\"Adding a 4th dimension\", font_size=16).to_edge(DOWN)\n        self.play(Write(transform_text))\n        self.play(Transform(square_3d, square_4d))\n        self.wait(1.5)\n        self.play(FadeOut(transform_text))\n        \n        # Rotating to suggest higher-dimensional movement\n        rotation_text = Text(\"Rotating in 4D space\", font_size=16).to_edge(DOWN)\n        self.play(Write(rotation_text))\n        self.play(Rotate(square_3d, angle=PI/2, rate_func=smooth))\n        self.wait(1)\n        self.play(FadeOut(rotation_text))\n        \n        # Final insight\n        conclusion = Text(\"Gaussian curvature influences shape across dimensions!\", font_size=18)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(square_3d))\n\n        # Final title\n        final_title = Text(\"Curvature Beyond Dimensions: Bending in 4D\", font_size=24)\n        self.play(Write(final_title))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Gaussian curvature influence the shape of a surface in four-dimensional spaces compared to three-dimensional spaces?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does gaussian curvature influence the shape of a surface in four-dimensional spaces compared to three-dimensional spaces?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GaussianCurvatureIn4D(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Curvature Beyond Dimensions: Bending in 4D\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n\n        # Explaining 3D curvature\n        intro_text = Text(\"How does a surface bend in 3D?\", font_size=20)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n\n        # Visualization of a 2D surface (paper)\n        paper = Rectangle(height=2, width=3, color=BLUE, fill_opacity=0.5)\n        self.play(Create(paper))\n        self.wait(1)\n        \n        # Transform to a sphere (positive curvature)\n        sphere_text = Text(\"Sphere: Positive Curvature\", font_size=16).to_edge(DOWN)\n        curved_shape = Circle(radius=1.5, color=BLUE, fill_opacity=0.5)\n        self.play(Write(sphere_text))\n        self.play(Transform(paper, curved_shape))\n        self.wait(1.5)\n        self.play(FadeOut(sphere_text))\n        \n        # Transform to a \"saddle\" representation (negative curvature)\n        saddle_text = Text(\"Saddle: Negative Curvature\", font_size=16).to_edge(DOWN)\n        \n        # Simple representation of a saddle using crossed lines\n        line1 = Line(start=[-1.5, -1.5, 0], end=[1.5, 1.5, 0], color=BLUE)\n        line2 = Line(start=[-1.5, 1.5, 0], end=[1.5, -1.5, 0], color=BLUE)\n        saddle = VGroup(line1, line2)\n        \n        self.play(Write(saddle_text))\n        self.play(Transform(paper, saddle))\n        self.wait(1.5)\n        self.play(FadeOut(saddle_text))\n\n        # Introducing Gaussian curvature in 3D\n        curvature_text = Text(\"In 3D, Gaussian curvature measures how a surface bends\", font_size=18)\n        self.play(Write(curvature_text))\n        self.wait(1.5)\n        self.play(FadeOut(curvature_text))\n        self.play(FadeOut(paper))\n\n        # Showing the equation for Gaussian curvature\n        equation = MathTex(r\"K = \\frac{det\\, II}{det\\, I}\")\n        self.play(Write(equation))\n        self.wait(1.5)\n        self.play(FadeOut(equation))\n\n        # Transition to 4D\n        fourD_text = Text(\"What about in 4D?\", font_size=20)\n        self.play(Write(fourD_text))\n        self.wait(1)\n        self.play(FadeOut(fourD_text))\n\n        # 4D metric equation\n        metric = MathTex(r\"ds^2 = dx^2 + dy^2 + dz^2 + dw^2\")\n        self.play(Write(metric))\n        self.wait(1.5)\n        self.play(FadeOut(metric))\n\n        # Visualization for 4D\n        four_d_text = Text(\"Visualizing 4D projection\", font_size=18)\n        self.play(Write(four_d_text))\n        self.wait(1)\n        self.play(FadeOut(four_d_text))\n        \n        # Using squares to represent dimensions\n        square_3d = Square(side_length=2, color=BLUE, fill_opacity=0.5)\n        self.play(Create(square_3d))\n        self.wait(1)\n        \n        # Create a representation of 4D with nested squares\n        inner_square = Square(side_length=1.5, color=PURPLE, fill_opacity=0.4)\n        inner_square.shift(0.25*UP + 0.25*RIGHT)\n        square_4d = VGroup(\n            square_3d.copy().set_opacity(0.3),\n            inner_square\n        )\n        \n        transform_text = Text(\"Adding a 4th dimension\", font_size=16).to_edge(DOWN)\n        self.play(Write(transform_text))\n        self.play(Transform(square_3d, square_4d))\n        self.wait(1.5)\n        self.play(FadeOut(transform_text))\n        \n        # Rotating to suggest higher-dimensional movement\n        rotation_text = Text(\"Rotating in 4D space\", font_size=16).to_edge(DOWN)\n        self.play(Write(rotation_text))\n        self.play(Rotate(square_3d, angle=PI/2, rate_func=smooth))\n        self.wait(1)\n        self.play(FadeOut(rotation_text))\n        \n        # Final insight\n        conclusion = Text(\"Gaussian curvature influences shape across dimensions!\", font_size=18)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(square_3d))\n\n        # Final title\n        final_title = Text(\"Curvature Beyond Dimensions: Bending in 4D\", font_size=24)\n        self.play(Write(final_title))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Gaussian curvature influence the shape of a surface in four-dimensional spaces compared to three-dimensional spaces?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does adding external forces, like magnetic fields, alter the dynamics of a point particle in a billiard system?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DynamicalBilliardsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Dance of Dynamical Billiards: Exploring Forces\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create billiard border\n        billiard_border = Rectangle(height=4, width=6, color=WHITE)\n        label = Text(\"Standard Billiard System\", font_size=24).next_to(billiard_border, UP)\n        \n        # Show billiard table\n        self.play(Create(billiard_border), Write(label))\n        self.wait(1)\n        \n        # Particle and its regular path\n        particle = Dot(color=RED)\n        particle.move_to([-2, -1, 0])  # Starting position\n        \n        # Simple straight line path (a zigzag to show reflections)\n        path_points = [\n            [-2, -1, 0],  # starting point\n            [2, 1, 0],    # first bounce\n            [-1, -1, 0]   # second bounce\n        ]\n        zigzag_path = VMobject(color=RED)\n        zigzag_path.set_points_as_corners(path_points)\n        \n        # Show particle following zigzag path\n        self.play(Create(particle))\n        self.play(MoveAlongPath(particle, zigzag_path), Create(zigzag_path), run_time=2)\n        self.wait(1)\n        \n        # Introducing magnetic field\n        magnetic_label = Text(\"With Magnetic Field\", font_size=24).next_to(billiard_border, UP)\n        self.play(FadeOut(label), Write(magnetic_label))\n        \n        # Simple magnetic field representation\n        field_arrows = VGroup()\n        for x in [-1.5, 0, 1.5]:\n            for y in [-1, 0, 1]:\n                arrow = Arrow(\n                    start=[x, y, 0],\n                    end=[x, y + 0.5, 0],\n                    color=BLUE,\n                    buff=0,\n                    stroke_width=2\n                )\n                field_arrows.add(arrow)\n        \n        # Show magnetic field\n        self.play(FadeIn(field_arrows))\n        self.wait(1)\n        \n        # Equation for magnetic force\n        mag_eq = MathTex(r\"\\mathbf{F}_{\\text{magnetic}} = q (\\mathbf{v} \\times \\mathbf{B})\")\n        mag_eq.to_edge(DOWN)\n        self.play(Write(mag_eq))\n        self.wait(1)\n        \n        # Change particle color for magnetic influence\n        self.play(particle.animate.set_color(GREEN), FadeOut(zigzag_path))\n        \n        # Curved path for magnetic influence\n        # Use a simple circle section to represent curved motion\n        curved_path = Arc(radius=2, angle=PI, color=GREEN).shift(RIGHT*0.5)\n        \n        # Show curved path with magnetic field\n        self.play(Create(curved_path), MoveAlongPath(particle, curved_path), run_time=2)\n        self.wait(1)\n        \n        # Motion equation\n        motion_eq = MathTex(r\"\\frac{d\\mathbf{v}}{dt} = \\frac{\\mathbf{F}_{\\text{total}}}{m}\")\n        motion_eq.next_to(mag_eq, UP)\n        self.play(Write(motion_eq))\n        self.wait(1)\n        \n        # Side by side comparison text\n        comparison = Text(\"Magnetic fields curve particle trajectories\", font_size=24)\n        comparison.to_edge(UP)\n        self.play(FadeOut(magnetic_label), Write(comparison))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"External forces transform billiard dynamics\", font_size=28)\n        self.play(\n            FadeOut(VGroup(\n                billiard_border, field_arrows,\n                particle, curved_path, mag_eq, motion_eq, comparison\n            ))\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final cleanup\n        self.play(FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does adding external forces, like magnetic fields, alter the dynamics of a point particle in a billiard system?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does adding external forces, like magnetic fields, alter the dynamics of a point particle in a billiard system?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DynamicalBilliardsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Dance of Dynamical Billiards: Exploring Forces\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create billiard border\n        billiard_border = Rectangle(height=4, width=6, color=WHITE)\n        label = Text(\"Standard Billiard System\", font_size=24).next_to(billiard_border, UP)\n        \n        # Show billiard table\n        self.play(Create(billiard_border), Write(label))\n        self.wait(1)\n        \n        # Particle and its regular path\n        particle = Dot(color=RED)\n        particle.move_to([-2, -1, 0])  # Starting position\n        \n        # Simple straight line path (a zigzag to show reflections)\n        path_points = [\n            [-2, -1, 0],  # starting point\n            [2, 1, 0],    # first bounce\n            [-1, -1, 0]   # second bounce\n        ]\n        zigzag_path = VMobject(color=RED)\n        zigzag_path.set_points_as_corners(path_points)\n        \n        # Show particle following zigzag path\n        self.play(Create(particle))\n        self.play(MoveAlongPath(particle, zigzag_path), Create(zigzag_path), run_time=2)\n        self.wait(1)\n        \n        # Introducing magnetic field\n        magnetic_label = Text(\"With Magnetic Field\", font_size=24).next_to(billiard_border, UP)\n        self.play(FadeOut(label), Write(magnetic_label))\n        \n        # Simple magnetic field representation\n        field_arrows = VGroup()\n        for x in [-1.5, 0, 1.5]:\n            for y in [-1, 0, 1]:\n                arrow = Arrow(\n                    start=[x, y, 0],\n                    end=[x, y + 0.5, 0],\n                    color=BLUE,\n                    buff=0,\n                    stroke_width=2\n                )\n                field_arrows.add(arrow)\n        \n        # Show magnetic field\n        self.play(FadeIn(field_arrows))\n        self.wait(1)\n        \n        # Equation for magnetic force\n        mag_eq = MathTex(r\"\\mathbf{F}_{\\text{magnetic}} = q (\\mathbf{v} \\times \\mathbf{B})\")\n        mag_eq.to_edge(DOWN)\n        self.play(Write(mag_eq))\n        self.wait(1)\n        \n        # Change particle color for magnetic influence\n        self.play(particle.animate.set_color(GREEN), FadeOut(zigzag_path))\n        \n        # Curved path for magnetic influence\n        # Use a simple circle section to represent curved motion\n        curved_path = Arc(radius=2, angle=PI, color=GREEN).shift(RIGHT*0.5)\n        \n        # Show curved path with magnetic field\n        self.play(Create(curved_path), MoveAlongPath(particle, curved_path), run_time=2)\n        self.wait(1)\n        \n        # Motion equation\n        motion_eq = MathTex(r\"\\frac{d\\mathbf{v}}{dt} = \\frac{\\mathbf{F}_{\\text{total}}}{m}\")\n        motion_eq.next_to(mag_eq, UP)\n        self.play(Write(motion_eq))\n        self.wait(1)\n        \n        # Side by side comparison text\n        comparison = Text(\"Magnetic fields curve particle trajectories\", font_size=24)\n        comparison.to_edge(UP)\n        self.play(FadeOut(magnetic_label), Write(comparison))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"External forces transform billiard dynamics\", font_size=28)\n        self.play(\n            FadeOut(VGroup(\n                billiard_border, field_arrows,\n                particle, curved_path, mag_eq, motion_eq, comparison\n            ))\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final cleanup\n        self.play(FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does adding external forces, like magnetic fields, alter the dynamics of a point particle in a billiard system?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Why do periods of holomorphic differentials form a lattice, and what is its significance in a complex torus structure?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HolomorphicDifferentialForms(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Lattices and Loops: Holomorphic Differentials\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Simple torus representation (just a circle with a hole)\n        outer_circle = Circle(radius=2, color=ORANGE)\n        inner_circle = Circle(radius=1, color=ORANGE)\n        torus = VGroup(outer_circle, inner_circle)\n        \n        # Create the torus\n        self.play(Create(torus))\n        self.wait(1)\n        \n        # Draw two paths on the torus\n        path1 = Circle(radius=1.5, color=RED).set_stroke(width=3, dash_length=0.2)\n        path1_label = Text(\"C\u2081\", font_size=24, color=RED).next_to(path1, UP)\n        \n        path2 = Circle(radius=1.5, color=BLUE).set_stroke(width=3)\n        path2.rotate(PI/2)  # Rotate to represent a different direction\n        path2_label = Text(\"C\u2082\", font_size=24, color=BLUE).next_to(path2, RIGHT)\n        \n        # Create paths\n        self.play(Create(path1), Write(path1_label))\n        self.wait(0.5)\n        self.play(Create(path2), Write(path2_label))\n        self.wait(1)\n        \n        # Show first equation - use simpler text\n        equation1 = Text(\"\u222e\u03c9 = \u222b\u03c6(z)dz\", font_size=30)\n        equation1.next_to(title, DOWN)\n        self.play(Write(equation1))\n        self.wait(1)\n        \n        # Move torus to the left\n        torus_group = VGroup(torus, path1, path2, path1_label, path2_label)\n        self.play(torus_group.animate.scale(0.7).to_edge(LEFT))\n        \n        # Create simple complex plane (just axes)\n        axes = Axes(\n            x_range=[-2, 2],\n            y_range=[-2, 2],\n            axis_config={\"color\": BLUE}\n        ).scale(0.7).to_edge(RIGHT)\n        \n        plane_label = Text(\"Complex Plane\", font_size=24).next_to(axes, UP)\n        self.play(Create(axes), Write(plane_label))\n        \n        # Show periods as points\n        period1 = Dot(axes.c2p(1, 0), color=RED)\n        period1_label = Text(\"\u03c9(C\u2081)\", font_size=24, color=RED).next_to(period1, DOWN)\n        \n        period2 = Dot(axes.c2p(0, 1), color=BLUE)\n        period2_label = Text(\"\u03c9(C\u2082)\", font_size=24, color=BLUE).next_to(period2, LEFT)\n        \n        # Create periods\n        self.play(Create(period1), Write(period1_label))\n        self.wait(0.5)\n        self.play(Create(period2), Write(period2_label))\n        self.wait(1)\n        \n        # Show second equation - use simpler text\n        equation2 = Text(\"\u03c9(C\u2081+C\u2082) = \u03c9(C\u2081) + \u03c9(C\u2082)\", font_size=30)\n        equation2.next_to(equation1, DOWN)\n        self.play(Write(equation2))\n        self.wait(1)\n        \n        # Add a point to show lattice formation\n        period3 = Dot(axes.c2p(1, 1), color=GREEN)\n        period3_label = Text(\"\u03c9(C\u2081+C\u2082)\", font_size=24, color=GREEN).next_to(period3, UP)\n        self.play(Create(period3), Write(period3_label))\n        \n        # Add a couple more points to suggest a lattice\n        period4 = Dot(axes.c2p(1, -1), color=YELLOW)\n        period5 = Dot(axes.c2p(-1, 1), color=YELLOW)\n        self.play(Create(period4), Create(period5))\n        \n        # Conclusion\n        conclusion = Text(\"Periods form a lattice in the complex plane\", font_size=28)\n        conclusion.to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out - explicitly list objects to fade out\n        self.play(\n            FadeOut(title),\n            FadeOut(torus_group),\n            FadeOut(axes),\n            FadeOut(plane_label),\n            FadeOut(period1), FadeOut(period1_label),\n            FadeOut(period2), FadeOut(period2_label),\n            FadeOut(period3), FadeOut(period3_label),\n            FadeOut(period4), FadeOut(period5),\n            FadeOut(equation1), FadeOut(equation2),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why do periods of holomorphic differentials form a lattice, and what is its significance in a complex torus structure?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: why do periods of holomorphic differentials form a lattice, and what is its significance in a complex torus structure?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HolomorphicDifferentialForms(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Lattices and Loops: Holomorphic Differentials\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Simple torus representation (just a circle with a hole)\n        outer_circle = Circle(radius=2, color=ORANGE)\n        inner_circle = Circle(radius=1, color=ORANGE)\n        torus = VGroup(outer_circle, inner_circle)\n        \n        # Create the torus\n        self.play(Create(torus))\n        self.wait(1)\n        \n        # Draw two paths on the torus\n        path1 = Circle(radius=1.5, color=RED).set_stroke(width=3, dash_length=0.2)\n        path1_label = Text(\"C\u2081\", font_size=24, color=RED).next_to(path1, UP)\n        \n        path2 = Circle(radius=1.5, color=BLUE).set_stroke(width=3)\n        path2.rotate(PI/2)  # Rotate to represent a different direction\n        path2_label = Text(\"C\u2082\", font_size=24, color=BLUE).next_to(path2, RIGHT)\n        \n        # Create paths\n        self.play(Create(path1), Write(path1_label))\n        self.wait(0.5)\n        self.play(Create(path2), Write(path2_label))\n        self.wait(1)\n        \n        # Show first equation - use simpler text\n        equation1 = Text(\"\u222e\u03c9 = \u222b\u03c6(z)dz\", font_size=30)\n        equation1.next_to(title, DOWN)\n        self.play(Write(equation1))\n        self.wait(1)\n        \n        # Move torus to the left\n        torus_group = VGroup(torus, path1, path2, path1_label, path2_label)\n        self.play(torus_group.animate.scale(0.7).to_edge(LEFT))\n        \n        # Create simple complex plane (just axes)\n        axes = Axes(\n            x_range=[-2, 2],\n            y_range=[-2, 2],\n            axis_config={\"color\": BLUE}\n        ).scale(0.7).to_edge(RIGHT)\n        \n        plane_label = Text(\"Complex Plane\", font_size=24).next_to(axes, UP)\n        self.play(Create(axes), Write(plane_label))\n        \n        # Show periods as points\n        period1 = Dot(axes.c2p(1, 0), color=RED)\n        period1_label = Text(\"\u03c9(C\u2081)\", font_size=24, color=RED).next_to(period1, DOWN)\n        \n        period2 = Dot(axes.c2p(0, 1), color=BLUE)\n        period2_label = Text(\"\u03c9(C\u2082)\", font_size=24, color=BLUE).next_to(period2, LEFT)\n        \n        # Create periods\n        self.play(Create(period1), Write(period1_label))\n        self.wait(0.5)\n        self.play(Create(period2), Write(period2_label))\n        self.wait(1)\n        \n        # Show second equation - use simpler text\n        equation2 = Text(\"\u03c9(C\u2081+C\u2082) = \u03c9(C\u2081) + \u03c9(C\u2082)\", font_size=30)\n        equation2.next_to(equation1, DOWN)\n        self.play(Write(equation2))\n        self.wait(1)\n        \n        # Add a point to show lattice formation\n        period3 = Dot(axes.c2p(1, 1), color=GREEN)\n        period3_label = Text(\"\u03c9(C\u2081+C\u2082)\", font_size=24, color=GREEN).next_to(period3, UP)\n        self.play(Create(period3), Write(period3_label))\n        \n        # Add a couple more points to suggest a lattice\n        period4 = Dot(axes.c2p(1, -1), color=YELLOW)\n        period5 = Dot(axes.c2p(-1, 1), color=YELLOW)\n        self.play(Create(period4), Create(period5))\n        \n        # Conclusion\n        conclusion = Text(\"Periods form a lattice in the complex plane\", font_size=28)\n        conclusion.to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out - explicitly list objects to fade out\n        self.play(\n            FadeOut(title),\n            FadeOut(torus_group),\n            FadeOut(axes),\n            FadeOut(plane_label),\n            FadeOut(period1), FadeOut(period1_label),\n            FadeOut(period2), FadeOut(period2_label),\n            FadeOut(period3), FadeOut(period3_label),\n            FadeOut(period4), FadeOut(period5),\n            FadeOut(equation1), FadeOut(equation2),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why do periods of holomorphic differentials form a lattice, and what is its significance in a complex torus structure?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a large circle with a double-headed arrow passing through it horizontally from left to right. Above it, another double-headed arrow is shown with both ends featuring filled circular tips. The two elements are vertically stacked with space between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim.mobject.geometry.tips import ArrowCircleFilledTip\nclass DoubleArrowExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2.0)\n        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\n        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\n        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\n        self.add(group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large circle with a double-headed arrow passing through it horizontally from left to right. Above it, another double-headed arrow is shown with both ends featuring filled circular tips. The two elements are vertically stacked with space between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a large circle with a double-headed arrow passing through it horizontally from left to right. above it, another double-headed arrow is shown with both ends featuring filled circular tips. the two elements are vertically stacked with space between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim.mobject.geometry.tips import ArrowCircleFilledTip\nclass DoubleArrowExample(Scene):\n    def construct(self):\n        circle = Circle(radius=2.0)\n        d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\n        d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\n        group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\n        self.add(group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large circle with a double-headed arrow passing through it horizontally from left to right. Above it, another double-headed arrow is shown with both ends featuring filled circular tips. The two elements are vertically stacked with space between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can we illustrate the convergence properties of the maximal function as the averaging region expands infinitely?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MaximalFunctionConvergence(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring the Convergence of the Maximal Function\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple 2D plane\n        plane = NumberPlane(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n            axis_config={\"include_tip\": True}\n        )\n        self.play(Create(plane))\n        \n        # Add a colorful function representation\n        function_visual = Circle(radius=2.5).set_fill(opacity=0.5)\n        function_visual.set_color_by_gradient([BLUE, GREEN, YELLOW, RED])\n        self.play(FadeIn(function_visual))\n        \n        # Key point for maximal function measurement\n        point = Dot().move_to([1, 1, 0])\n        point_label = Text(\"x\", font_size=24).next_to(point, UP)\n        self.play(Create(point), Write(point_label))\n        \n        # First equation: Definition of maximal function\n        eq1 = MathTex(r\"M_{r}f(x) = \\sup_{r > 0} \\frac{1}{\\mu(B(x,r))} \\int_{B(x,r)} |f(y)| dy\").to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Small averaging circle\n        small_circle = Circle(radius=0.3, color=RED).move_to(point.get_center())\n        small_label = Text(\"Small averaging region\", font_size=20).next_to(small_circle, DOWN)\n        self.play(Create(small_circle), Write(small_label))\n        \n        # Random fluctuation arrows for small circle\n        fluctuation_small = VGroup(\n            Arrow(start=[0.8, 0.8, 0], end=[0.9, 0.9, 0], color=YELLOW),\n            Arrow(start=[1.1, 1.1, 0], end=[1.2, 1.2, 0], color=YELLOW)\n        )\n        fluc_small_label = Text(\"High fluctuations\", font_size=16).next_to(fluctuation_small, RIGHT)\n        self.play(Create(fluctuation_small), Write(fluc_small_label))\n        self.wait(1)\n        \n        # Expand to medium circle\n        medium_circle = Circle(radius=1.0, color=RED).move_to(point.get_center())\n        self.play(\n            Transform(small_circle, medium_circle),\n            FadeOut(small_label),\n            FadeOut(fluctuation_small),\n            FadeOut(fluc_small_label)\n        )\n        medium_label = Text(\"Medium averaging region\", font_size=20).next_to(medium_circle, DOWN)\n        self.play(Write(medium_label))\n        \n        # Medium fluctuation arrows\n        fluctuation_medium = VGroup(\n            Arrow(start=[0.7, 0.7, 0], end=[0.9, 0.9, 0], color=GREEN),\n            Arrow(start=[1.1, 1.1, 0], end=[1.3, 1.3, 0], color=GREEN)\n        )\n        fluc_medium_label = Text(\"Medium fluctuations\", font_size=16).next_to(fluctuation_medium, RIGHT)\n        self.play(Create(fluctuation_medium), Write(fluc_medium_label))\n        self.wait(1)\n        \n        # Expand to large circle\n        large_circle = Circle(radius=2.0, color=RED).move_to(point.get_center())\n        self.play(\n            Transform(small_circle, large_circle),\n            FadeOut(medium_label),\n            FadeOut(fluctuation_medium),\n            FadeOut(fluc_medium_label)\n        )\n        large_label = Text(\"Large averaging region\", font_size=20).next_to(large_circle, DOWN)\n        self.play(Write(large_label))\n        \n        # Stable behavior arrows\n        stable_arrows = VGroup(\n            Arrow(start=[0.5, 0.5, 0], end=[0.8, 0.8, 0], color=BLUE),\n            Arrow(start=[1.2, 1.2, 0], end=[1.5, 1.5, 0], color=BLUE)\n        )\n        stable_label = Text(\"Stable behavior\", font_size=16).next_to(stable_arrows, RIGHT)\n        self.play(Create(stable_arrows), Write(stable_label))\n        self.wait(1)\n        \n        # Second equation: Convergence of maximal function\n        eq2 = MathTex(r\"\\lim_{r \\to \\infty} M_r f(x) = g(x)\").next_to(eq1, UP)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(small_circle),\n            FadeOut(large_label),\n            FadeOut(stable_arrows),\n            FadeOut(stable_label),\n            FadeOut(point),\n            FadeOut(point_label),\n            FadeOut(function_visual),\n            FadeOut(plane),\n            FadeOut(eq1),\n            FadeOut(eq2)\n        )\n        \n        conclusion = Text(\"As the circle expands to infinity,\\nthe maximal function converges to stability.\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        final_text = Text(\"Stability achieved.\", font_size=32)\n        self.play(Transform(conclusion, final_text))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can we illustrate the convergence properties of the maximal function as the averaging region expands infinitely?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can we illustrate the convergence properties of the maximal function as the averaging region expands infinitely?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MaximalFunctionConvergence(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring the Convergence of the Maximal Function\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Create a simple 2D plane\n        plane = NumberPlane(\n            x_range=(-3, 3),\n            y_range=(-3, 3),\n            axis_config={\"include_tip\": True}\n        )\n        self.play(Create(plane))\n        \n        # Add a colorful function representation\n        function_visual = Circle(radius=2.5).set_fill(opacity=0.5)\n        function_visual.set_color_by_gradient([BLUE, GREEN, YELLOW, RED])\n        self.play(FadeIn(function_visual))\n        \n        # Key point for maximal function measurement\n        point = Dot().move_to([1, 1, 0])\n        point_label = Text(\"x\", font_size=24).next_to(point, UP)\n        self.play(Create(point), Write(point_label))\n        \n        # First equation: Definition of maximal function\n        eq1 = MathTex(r\"M_{r}f(x) = \\sup_{r > 0} \\frac{1}{\\mu(B(x,r))} \\int_{B(x,r)} |f(y)| dy\").to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Small averaging circle\n        small_circle = Circle(radius=0.3, color=RED).move_to(point.get_center())\n        small_label = Text(\"Small averaging region\", font_size=20).next_to(small_circle, DOWN)\n        self.play(Create(small_circle), Write(small_label))\n        \n        # Random fluctuation arrows for small circle\n        fluctuation_small = VGroup(\n            Arrow(start=[0.8, 0.8, 0], end=[0.9, 0.9, 0], color=YELLOW),\n            Arrow(start=[1.1, 1.1, 0], end=[1.2, 1.2, 0], color=YELLOW)\n        )\n        fluc_small_label = Text(\"High fluctuations\", font_size=16).next_to(fluctuation_small, RIGHT)\n        self.play(Create(fluctuation_small), Write(fluc_small_label))\n        self.wait(1)\n        \n        # Expand to medium circle\n        medium_circle = Circle(radius=1.0, color=RED).move_to(point.get_center())\n        self.play(\n            Transform(small_circle, medium_circle),\n            FadeOut(small_label),\n            FadeOut(fluctuation_small),\n            FadeOut(fluc_small_label)\n        )\n        medium_label = Text(\"Medium averaging region\", font_size=20).next_to(medium_circle, DOWN)\n        self.play(Write(medium_label))\n        \n        # Medium fluctuation arrows\n        fluctuation_medium = VGroup(\n            Arrow(start=[0.7, 0.7, 0], end=[0.9, 0.9, 0], color=GREEN),\n            Arrow(start=[1.1, 1.1, 0], end=[1.3, 1.3, 0], color=GREEN)\n        )\n        fluc_medium_label = Text(\"Medium fluctuations\", font_size=16).next_to(fluctuation_medium, RIGHT)\n        self.play(Create(fluctuation_medium), Write(fluc_medium_label))\n        self.wait(1)\n        \n        # Expand to large circle\n        large_circle = Circle(radius=2.0, color=RED).move_to(point.get_center())\n        self.play(\n            Transform(small_circle, large_circle),\n            FadeOut(medium_label),\n            FadeOut(fluctuation_medium),\n            FadeOut(fluc_medium_label)\n        )\n        large_label = Text(\"Large averaging region\", font_size=20).next_to(large_circle, DOWN)\n        self.play(Write(large_label))\n        \n        # Stable behavior arrows\n        stable_arrows = VGroup(\n            Arrow(start=[0.5, 0.5, 0], end=[0.8, 0.8, 0], color=BLUE),\n            Arrow(start=[1.2, 1.2, 0], end=[1.5, 1.5, 0], color=BLUE)\n        )\n        stable_label = Text(\"Stable behavior\", font_size=16).next_to(stable_arrows, RIGHT)\n        self.play(Create(stable_arrows), Write(stable_label))\n        self.wait(1)\n        \n        # Second equation: Convergence of maximal function\n        eq2 = MathTex(r\"\\lim_{r \\to \\infty} M_r f(x) = g(x)\").next_to(eq1, UP)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(small_circle),\n            FadeOut(large_label),\n            FadeOut(stable_arrows),\n            FadeOut(stable_label),\n            FadeOut(point),\n            FadeOut(point_label),\n            FadeOut(function_visual),\n            FadeOut(plane),\n            FadeOut(eq1),\n            FadeOut(eq2)\n        )\n        \n        conclusion = Text(\"As the circle expands to infinity,\\nthe maximal function converges to stability.\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        final_text = Text(\"Stability achieved.\", font_size=32)\n        self.play(Transform(conclusion, final_text))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can we illustrate the convergence properties of the maximal function as the averaging region expands infinitely?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "convolutional_neural_network_with_images.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n    ImageLayer,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "convolutional_neural_network_with_images.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that convolutional_neural_network_with_images.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network import (\n    Convolutional2DLayer,\n    FeedForwardLayer,\n    NeuralNetwork,\n    ImageLayer,\n)\n\n# Make the specific scene\nconfig.pixel_height = 700\nconfig.pixel_width = 1900\nconfig.frame_height = 7.0\nconfig.frame_width = 7.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        image = Image.open(\"../../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 3, filter_spacing=0.32),\n                Convolutional2DLayer(5, 3, 3, filter_spacing=0.18),\n                FeedForwardLayer(3),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "convolutional_neural_network_with_images.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually explains the concept of finding the area under a curve using integration. Specifically, could you illustrate how to calculate the area under the parabola described by the function y = x^2, between x = 0 and x = 2? I would like the animation to include the following elements:\n\n1. A set of Cartesian axes with a blue color scheme.\n2. The graph of the function y = x^2 plotted in green with the label 'x^2' near the curve.\n3. A shaded area under the curve between x = 0 and x = 2 to represent the definite integral, with a gray color and partial transparency.\n4. A title for the animation that reads \"Area under the curve y = x^2 from 0 to 2\".\n5. An animated sequence where:\n   - The axes and graph are drawn first.\n   - After a short pause, the title appears.\n   - Then the area under the curve gets shaded.\n   - Following another short pause, the mathematical representation of the integral from 0 to 2 of x^2 dx is displayed in the upper left corner.\n   - The evaluated integral value is shown step by step below the integral representation.\n6. Finally, after the calculation is complete, I want to clear the scene and have the final evaluated integral value appear at the top center of the screen.\n\nPlease ensure that each step is visually appealing and paced with pauses to allow viewers time to comprehend each part of the process. Can you create such an animation for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Gather(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n        self.dots = VGroup(\n            *[Dot(radius=self.dot_radius).move_to(\n                self.mobject.get_center() + np.random.uniform(-1, 1, size=3))\n              for _ in range(self.dot_number)]\n        ).set_opacity(0)\n    \n    def begin(self):\n        self.mobject.set_opacity(0)\n        self.starting_mobject = self.mobject.copy()\n        self.starting_mobject.add(self.dots)\n        super().begin()\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.dots)\n            \n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.dots.set_opacity(alpha * 2)\n            for dot in self.dots:\n                dot.move_to(dot.get_center() + alpha*(self.mobject.get_center() - dot.get_center()))\n        else:\n            self.mobject.set_opacity((alpha - 0.5) * 2)\n            self.dots.set_opacity((1 - alpha) * 2)\n            for dot in self.dots:\n                dot.move_to(self.mobject.get_center())\n\nclass CustomAnimationGatherExample(Scene):\n    def construct(self):\n        circle = Circle(color=RED, fill_opacity=1).scale(3)\n        self.play(Gather(circle, dot_number=200, run_time=4))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains the concept of finding the area under a curve using integration. Specifically, could you illustrate how to calculate the area under the parabola described by the function y = x^2, between x = 0 and x = 2? I would like the animation to include the following elements:\n\n1. A set of Cartesian axes with a blue color scheme.\n2. The graph of the function y = x^2 plotted in green with the label 'x^2' near the curve.\n3. A shaded area under the curve between x = 0 and x = 2 to represent the definite integral, with a gray color and partial transparency.\n4. A title for the animation that reads \"Area under the curve y = x^2 from 0 to 2\".\n5. An animated sequence where:\n   - The axes and graph are drawn first.\n   - After a short pause, the title appears.\n   - Then the area under the curve gets shaded.\n   - Following another short pause, the mathematical representation of the integral from 0 to 2 of x^2 dx is displayed in the upper left corner.\n   - The evaluated integral value is shown step by step below the integral representation.\n6. Finally, after the calculation is complete, I want to clear the scene and have the final evaluated integral value appear at the top center of the screen.\n\nPlease ensure that each step is visually appealing and paced with pauses to allow viewers time to comprehend each part of the process. Can you create such an animation for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually explains the concept of finding the area under a curve using integration. specifically, could you illustrate how to calculate the area under the parabola described by the function y = x^2, between x = 0 and x = 2? i would like the animation to include the following elements:\n\n1. a set of cartesian axes with a blue color scheme.\n2. the graph of the function y = x^2 plotted in green with the label 'x^2' near the curve.\n3. a shaded area under the curve between x = 0 and x = 2 to represent the definite integral, with a gray color and partial transparency.\n4. a title for the animation that reads \"area under the curve y = x^2 from 0 to 2\".\n5. an animated sequence where:\n   - the axes and graph are drawn first.\n   - after a short pause, the title appears.\n   - then the area under the curve gets shaded.\n   - following another short pause, the mathematical representation of the integral from 0 to 2 of x^2 dx is displayed in the upper left corner.\n   - the evaluated integral value is shown step by step below the integral representation.\n6. finally, after the calculation is complete, i want to clear the scene and have the final evaluated integral value appear at the top center of the screen.\n\nplease ensure that each step is visually appealing and paced with pauses to allow viewers time to comprehend each part of the process. can you create such an animation for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Gather(Animation):\n    def __init__(self, mobject, dot_radius=0.05, dot_number=100, **kwargs):\n        super().__init__(mobject, **kwargs)\n        self.dot_radius = dot_radius\n        self.dot_number = dot_number\n        self.dots = VGroup(\n            *[Dot(radius=self.dot_radius).move_to(\n                self.mobject.get_center() + np.random.uniform(-1, 1, size=3))\n              for _ in range(self.dot_number)]\n        ).set_opacity(0)\n    \n    def begin(self):\n        self.mobject.set_opacity(0)\n        self.starting_mobject = self.mobject.copy()\n        self.starting_mobject.add(self.dots)\n        super().begin()\n\n    def clean_up_from_scene(self, scene):\n        super().clean_up_from_scene(scene)\n        scene.remove(self.dots)\n            \n    def interpolate_mobject(self, alpha):\n        alpha = self.rate_func(alpha)  # manually apply rate function\n        if alpha <= 0.5:\n            self.dots.set_opacity(alpha * 2)\n            for dot in self.dots:\n                dot.move_to(dot.get_center() + alpha*(self.mobject.get_center() - dot.get_center()))\n        else:\n            self.mobject.set_opacity((alpha - 0.5) * 2)\n            self.dots.set_opacity((1 - alpha) * 2)\n            for dot in self.dots:\n                dot.move_to(self.mobject.get_center())\n\nclass CustomAnimationGatherExample(Scene):\n    def construct(self):\n        circle = Circle(color=RED, fill_opacity=1).scale(3)\n        self.play(Gather(circle, dot_number=200, run_time=4))\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains the concept of finding the area under a curve using integration. Specifically, could you illustrate how to calculate the area under the parabola described by the function y = x^2, between x = 0 and x = 2? I would like the animation to include the following elements:\n\n1. A set of Cartesian axes with a blue color scheme.\n2. The graph of the function y = x^2 plotted in green with the label 'x^2' near the curve.\n3. A shaded area under the curve between x = 0 and x = 2 to represent the definite integral, with a gray color and partial transparency.\n4. A title for the animation that reads \"Area under the curve y = x^2 from 0 to 2\".\n5. An animated sequence where:\n   - The axes and graph are drawn first.\n   - After a short pause, the title appears.\n   - Then the area under the curve gets shaded.\n   - Following another short pause, the mathematical representation of the integral from 0 to 2 of x^2 dx is displayed in the upper left corner.\n   - The evaluated integral value is shown step by step below the integral representation.\n6. Finally, after the calculation is complete, I want to clear the scene and have the final evaluated integral value appear at the top center of the screen.\n\nPlease ensure that each step is visually appealing and paced with pauses to allow viewers time to comprehend each part of the process. Can you create such an animation for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a large circle with two tangent lines:\n\n1. A blue tangent line touching the circle on the right side.\n2. A green tangent line touching the circle at an upper-left point.\n\nBoth lines extend outward from their points of contact, illustrating tangents at different positions on the circle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass VectorExample(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        vector_1 = Vector([1,2])\n        vector_2 = Vector([-5,-2])\n        self.add(plane, vector_1, vector_2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large circle with two tangent lines:\n\n1. A blue tangent line touching the circle on the right side.\n2. A green tangent line touching the circle at an upper-left point.\n\nBoth lines extend outward from their points of contact, illustrating tangents at different positions on the circle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a large circle with two tangent lines:\n\n1. a blue tangent line touching the circle on the right side.\n2. a green tangent line touching the circle at an upper-left point.\n\nboth lines extend outward from their points of contact, illustrating tangents at different positions on the circle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass VectorExample(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        vector_1 = Vector([1,2])\n        vector_2 = Vector([-5,-2])\n        self.add(plane, vector_1, vector_2)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a large circle with two tangent lines:\n\n1. A blue tangent line touching the circle on the right side.\n2. A green tangent line touching the circle at an upper-left point.\n\nBoth lines extend outward from their points of contact, illustrating tangents at different positions on the circle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_ff_residual.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, MathOperationLayer\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass TestFeedForwardResidualNetwork(Scene):\n\n    def construct(self):\n        # Add the network\n        nn = NeuralNetwork({\n                \"feed_forward_1\": FeedForwardLayer(3),\n                \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n                \"feed_forward_3\": FeedForwardLayer(3),\n                \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n            },\n            layer_spacing=0.38\n        )\n        self.add(nn)\n        # Make connections\n        input_blank_dot = Dot(\n            nn.input_layers_dict[\"feed_forward_1\"].get_left() - np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(input_blank_dot, \"feed_forward_1\", arc_direction=\"straight\")\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        output_blank_dot = Dot(\n            nn.input_layers_dict[\"sum_operation\"].get_right() + np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(\"sum_operation\", output_blank_dot, arc_direction=\"straight\")\n\n        # Make forward pass animation\n        self.play(\n            nn.make_forward_pass_animation()\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_ff_residual.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_ff_residual.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer, MathOperationLayer\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass TestFeedForwardResidualNetwork(Scene):\n\n    def construct(self):\n        # Add the network\n        nn = NeuralNetwork({\n                \"feed_forward_1\": FeedForwardLayer(3),\n                \"feed_forward_2\": FeedForwardLayer(3, activation_function=\"ReLU\"),\n                \"feed_forward_3\": FeedForwardLayer(3),\n                \"sum_operation\": MathOperationLayer(\"+\", activation_function=\"ReLU\"),\n            },\n            layer_spacing=0.38\n        )\n        self.add(nn)\n        # Make connections\n        input_blank_dot = Dot(\n            nn.input_layers_dict[\"feed_forward_1\"].get_left() - np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(input_blank_dot, \"feed_forward_1\", arc_direction=\"straight\")\n        nn.add_connection(\"feed_forward_1\", \"sum_operation\")\n        output_blank_dot = Dot(\n            nn.input_layers_dict[\"sum_operation\"].get_right() + np.array([0.65, 0.0, 0.0])\n        )\n        nn.add_connection(\"sum_operation\", output_blank_dot, arc_direction=\"straight\")\n\n        # Make forward pass animation\n        self.play(\n            nn.make_forward_pass_animation()\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_ff_residual.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animated visualization of a variational autoencoder neural network architecture using images as input and output with a code snippet overlay that explains how the network is constructed?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Custom2DGridScene(Scene):\n    def create_grid(self, rows: int, cols: int, cell_size: float = 1.0):\n        \"\"\"\n        Create a 2D grid of squares given row and column counts.\n\n        Args:\n            rows (int): The number of rows in the grid.\n            cols (int): The number of columns in the grid.\n            cell_size (float): The side length of each square cell.\n\n        Returns:\n            VGroup: A group containing all the grid squares.\n        \"\"\"\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                square = Square(side_length=cell_size)\n                square.move_to(np.array([j * cell_size, -i * cell_size, 0]))\n                grid.add(square)\n        grid.move_to(ORIGIN)  # Center the grid.\n        return grid\n\n    def construct(self):\n        rows, cols = 5, 5  # Define the number of rows and columns for the grid.\n        grid = self.create_grid(rows, cols)  # Create the grid using the helper function.\n        self.add(grid)  # Add the grid to the scene.\n\nclass ComplexPathAnimation(Scene):\n    def construct(self):\n        # Create a dot that will move along a path.\n        dot = Dot(radius=0.1, color=RED)\n        \n        # Define the complex path points.\n        path_points = [UP * 2, UP + RIGHT * 2, DOWN + RIGHT * 2, DOWN * 2, DOWN + LEFT * 2, UP + LEFT * 2, UP * 2]\n        complex_path = VGroup()\n        \n        # Iterate over the points to create the visual path with lines.\n        for i in range(len(path_points) - 1):\n            line = Line(path_points[i], path_points[i + 1], stroke_width=2, color=BLUE)\n            complex_path.add(line)\n        \n        # Show the path on screen.\n        self.add(complex_path)\n        \n        # Create a custom animation by moving the dot along the defined path.\n        def custom_path_position(alpha):\n            num_points = len(path_points)\n            curr_point = int(alpha * (num_points - 1))\n            sub_alpha = (alpha * (num_points - 1)) % 1\n            return path_points[curr_point] + (path_points[curr_point + 1] - path_points[curr_point]) * sub_alpha\n\n        self.play(MoveAlongPath(dot, complex_path), run_time=4, rate_func=linear)\n        self.add(dot)  # Keep the dot displayed at the end.\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated visualization of a variational autoencoder neural network architecture using images as input and output with a code snippet overlay that explains how the network is constructed?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animated visualization of a variational autoencoder neural network architecture using images as input and output with a code snippet overlay that explains how the network is constructed?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Custom2DGridScene(Scene):\n    def create_grid(self, rows: int, cols: int, cell_size: float = 1.0):\n        \"\"\"\n        Create a 2D grid of squares given row and column counts.\n\n        Args:\n            rows (int): The number of rows in the grid.\n            cols (int): The number of columns in the grid.\n            cell_size (float): The side length of each square cell.\n\n        Returns:\n            VGroup: A group containing all the grid squares.\n        \"\"\"\n        grid = VGroup()\n        for i in range(rows):\n            for j in range(cols):\n                square = Square(side_length=cell_size)\n                square.move_to(np.array([j * cell_size, -i * cell_size, 0]))\n                grid.add(square)\n        grid.move_to(ORIGIN)  # Center the grid.\n        return grid\n\n    def construct(self):\n        rows, cols = 5, 5  # Define the number of rows and columns for the grid.\n        grid = self.create_grid(rows, cols)  # Create the grid using the helper function.\n        self.add(grid)  # Add the grid to the scene.\n\nclass ComplexPathAnimation(Scene):\n    def construct(self):\n        # Create a dot that will move along a path.\n        dot = Dot(radius=0.1, color=RED)\n        \n        # Define the complex path points.\n        path_points = [UP * 2, UP + RIGHT * 2, DOWN + RIGHT * 2, DOWN * 2, DOWN + LEFT * 2, UP + LEFT * 2, UP * 2]\n        complex_path = VGroup()\n        \n        # Iterate over the points to create the visual path with lines.\n        for i in range(len(path_points) - 1):\n            line = Line(path_points[i], path_points[i + 1], stroke_width=2, color=BLUE)\n            complex_path.add(line)\n        \n        # Show the path on screen.\n        self.add(complex_path)\n        \n        # Create a custom animation by moving the dot along the defined path.\n        def custom_path_position(alpha):\n            num_points = len(path_points)\n            curr_point = int(alpha * (num_points - 1))\n            sub_alpha = (alpha * (num_points - 1)) % 1\n            return path_points[curr_point] + (path_points[curr_point + 1] - path_points[curr_point]) * sub_alpha\n\n        self.play(MoveAlongPath(dot, complex_path), run_time=4, rate_func=linear)\n        self.add(dot)  # Keep the dot displayed at the end.\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animated visualization of a variational autoencoder neural network architecture using images as input and output with a code snippet overlay that explains how the network is constructed?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "How can I create a simple animation using Manim where the word \"Flash\" appears and moves upwards, followed by the word \"Ta Da\" in yellow color flashing on the screen before disappearing?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass AnimationScene(Scene):\n    def construct(self):\n                self.play(Transform(text,Text(\"GrowArrow\").shift(UP*2.5)), run_time=0.5)\n                arrow = Arrow()\n                self.play(GrowArrow(arrow))\n                self.remove(arrow)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create a simple animation using Manim where the word \"Flash\" appears and moves upwards, followed by the word \"Ta Da\" in yellow color flashing on the screen before disappearing?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that how can i create a simple animation using manim where the word \"flash\" appears and moves upwards, followed by the word \"ta da\" in yellow color flashing on the screen before disappearing?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass AnimationScene(Scene):\n    def construct(self):\n                self.play(Transform(text,Text(\"GrowArrow\").shift(UP*2.5)), run_time=0.5)\n                arrow = Arrow()\n                self.play(GrowArrow(arrow))\n                self.remove(arrow)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create a simple animation using Manim where the word \"Flash\" appears and moves upwards, followed by the word \"Ta Da\" in yellow color flashing on the screen before disappearing?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that demonstrates the phases of the Moon as seen from Earth throughout a lunar month? I would like the animation to include a representation of Earth at the center, the Moon's orbit around the Earth as an ellipse, and the Moon moving along this elliptical path. Each phase of the Moon should be highlighted at its appropriate position along the orbit with labels, and the Moon itself should change position to reflect the real-time progress of its orbit. Please ensure that the animation is accurate, and that it runs for a duration that represents one lunar month, with the Moon's movement rate proportional to the actual lunar cycle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n# Constants\nMOON_ORBIT_RADIUS = 3.0\nEARTH_MOON_DISTANCE = 3.8\nEARTH_RADIUS = 0.2\nMOON_RADIUS = 0.05\nMOON_ORBIT_RATE = 0.1\nWAIT_TIME = 15\nMOON_START_PROPORTION = 0.25\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Earth\n        earth = Dot(radius=EARTH_RADIUS, color=BLUE)\n        self.add(earth)\n\n        # Moon\n        moon_orbit_path = Circle(radius=MOON_ORBIT_RADIUS, color=WHITE, stroke_opacity=0.5)\n        self.add(moon_orbit_path)\n\n        moon = Dot(radius=MOON_RADIUS, color=GREY)\n        moon.move_to(moon_orbit_path.point_from_proportion(MOON_START_PROPORTION))\n\n        # Moon orbit\n        orbit_val = ValueTracker(MOON_START_PROPORTION)\n\n        def orbit(m):\n            proportion = (orbit_val.get_value() * MOON_ORBIT_RATE) % 1\n            m.move_to(moon_orbit_path.point_from_proportion(proportion))\n        moon.add_updater(orbit)\n\n        self.add(moon)\n\n        # Earth-Moon connection\n        earth_moon_line = Line(earth.get_center(), moon.get_center(), stroke_width=2, color=WHITE)\n\n        def update_line(line):\n            line.put_start_and_end_on(earth.get_center(), moon.get_center())\n        earth_moon_line.add_updater(update_line)\n\n        self.add(earth_moon_line)\n\n        # Animate\n        self.play(orbit_val.set_value, 1, run_time=WAIT_TIME, rate_func=linear)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that demonstrates the phases of the Moon as seen from Earth throughout a lunar month? I would like the animation to include a representation of Earth at the center, the Moon's orbit around the Earth as an ellipse, and the Moon moving along this elliptical path. Each phase of the Moon should be highlighted at its appropriate position along the orbit with labels, and the Moon itself should change position to reflect the real-time progress of its orbit. Please ensure that the animation is accurate, and that it runs for a duration that represents one lunar month, with the Moon's movement rate proportional to the actual lunar cycle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that demonstrates the phases of the moon as seen from earth throughout a lunar month? i would like the animation to include a representation of earth at the center, the moon's orbit around the earth as an ellipse, and the moon moving along this elliptical path. each phase of the moon should be highlighted at its appropriate position along the orbit with labels, and the moon itself should change position to reflect the real-time progress of its orbit. please ensure that the animation is accurate, and that it runs for a duration that represents one lunar month, with the moon's movement rate proportional to the actual lunar cycle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n# Constants\nMOON_ORBIT_RADIUS = 3.0\nEARTH_MOON_DISTANCE = 3.8\nEARTH_RADIUS = 0.2\nMOON_RADIUS = 0.05\nMOON_ORBIT_RATE = 0.1\nWAIT_TIME = 15\nMOON_START_PROPORTION = 0.25\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Earth\n        earth = Dot(radius=EARTH_RADIUS, color=BLUE)\n        self.add(earth)\n\n        # Moon\n        moon_orbit_path = Circle(radius=MOON_ORBIT_RADIUS, color=WHITE, stroke_opacity=0.5)\n        self.add(moon_orbit_path)\n\n        moon = Dot(radius=MOON_RADIUS, color=GREY)\n        moon.move_to(moon_orbit_path.point_from_proportion(MOON_START_PROPORTION))\n\n        # Moon orbit\n        orbit_val = ValueTracker(MOON_START_PROPORTION)\n\n        def orbit(m):\n            proportion = (orbit_val.get_value() * MOON_ORBIT_RATE) % 1\n            m.move_to(moon_orbit_path.point_from_proportion(proportion))\n        moon.add_updater(orbit)\n\n        self.add(moon)\n\n        # Earth-Moon connection\n        earth_moon_line = Line(earth.get_center(), moon.get_center(), stroke_width=2, color=WHITE)\n\n        def update_line(line):\n            line.put_start_and_end_on(earth.get_center(), moon.get_center())\n        earth_moon_line.add_updater(update_line)\n\n        self.add(earth_moon_line)\n\n        # Animate\n        self.play(orbit_val.set_value, 1, run_time=WAIT_TIME, rate_func=linear)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that demonstrates the phases of the Moon as seen from Earth throughout a lunar month? I would like the animation to include a representation of Earth at the center, the Moon's orbit around the Earth as an ellipse, and the Moon moving along this elliptical path. Each phase of the Moon should be highlighted at its appropriate position along the orbit with labels, and the Moon itself should change position to reflect the real-time progress of its orbit. Please ensure that the animation is accurate, and that it runs for a duration that represents one lunar month, with the Moon's movement rate proportional to the actual lunar cycle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display five horizontal groups of four dots each, labeled with different `lag_ratio` values: 0, 0.1, 0.5, 1, and 2. Each group shifts downward with a staggered animation based on its `lag_ratio`\u2014lower values animate more simultaneously, while higher values animate more sequentially. Then, all groups shift upward together with a slight delay between each group due to a recursive `lag_ratio`."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display five horizontal groups of four dots each, labeled with different `lag_ratio` values: 0, 0.1, 0.5, 1, and 2. Each group shifts downward with a staggered animation based on its `lag_ratio`\u2014lower values animate more simultaneously, while higher values animate more sequentially. Then, all groups shift upward together with a slight delay between each group due to a recursive `lag_ratio`."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display five horizontal groups of four dots each, labeled with different `lag_ratio` values: 0, 0.1, 0.5, 1, and 2. each group shifts downward with a staggered animation based on its `lag_ratio`\u2014lower values animate more simultaneously, while higher values animate more sequentially. then, all groups shift upward together with a slight delay between each group due to a recursive `lag_ratio`."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LagRatios(Scene):\n    def construct(self):\n        ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n        # Create dot groups\n        group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n        groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n        self.add(groups)\n\n        # Label groups\n        self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n        for group, ratio in zip(groups, ratios):\n            self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n        #Animate groups with different lag_ratios\n        self.play(AnimationGroup(*[\n            group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n            for group, ratio in zip(groups, ratios)\n        ]))\n\n        # lag_ratio also works recursively on nested submobjects:\n        self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display five horizontal groups of four dots each, labeled with different `lag_ratio` values: 0, 0.1, 0.5, 1, and 2. Each group shifts downward with a staggered animation based on its `lag_ratio`\u2014lower values animate more simultaneously, while higher values animate more sequentially. Then, all groups shift upward together with a slight delay between each group due to a recursive `lag_ratio`."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "wide_logo.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\n\nimport manim_ml\nmanim_ml.config.color_scheme = \"light_mode\"\n\nfrom manim_ml.neural_network.architectures.feed_forward import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 1000\nconfig.pixel_width = 2000\nconfig.frame_height = 4.0\nconfig.frame_width = 8.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.text = Text(\"ManimML\", color=manim_ml.config.color_scheme.text_color)\n        self.text.scale(1.0)\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 6, 3], layer_spacing=0.3, node_color=BLUE\n        )\n        self.neural_network.scale(0.8)\n        self.neural_network.next_to(self.text, RIGHT, buff=0.5)\n        # self.neural_network.move_to(self.text.get_right())\n        # self.neural_network.shift(1.25 * DOWN)\n        self.logo_group = Group(self.text, self.neural_network)\n        self.logo_group.scale(1.0)\n        self.logo_group.move_to(ORIGIN)\n        self.play(Write(self.text), run_time=1.0)\n        self.play(Create(self.neural_network), run_time=3.0)\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            # Create(self.surrounding_rectangle)\n        )\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            #    Create(self.surrounding_rectangle)\n        )\n        self.play(animation_group, runtime=5.0)\n        self.wait(5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "wide_logo.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that wide_logo.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\n\nimport manim_ml\nmanim_ml.config.color_scheme = \"light_mode\"\n\nfrom manim_ml.neural_network.architectures.feed_forward import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 1000\nconfig.pixel_width = 2000\nconfig.frame_height = 4.0\nconfig.frame_width = 8.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.text = Text(\"ManimML\", color=manim_ml.config.color_scheme.text_color)\n        self.text.scale(1.0)\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 6, 3], layer_spacing=0.3, node_color=BLUE\n        )\n        self.neural_network.scale(0.8)\n        self.neural_network.next_to(self.text, RIGHT, buff=0.5)\n        # self.neural_network.move_to(self.text.get_right())\n        # self.neural_network.shift(1.25 * DOWN)\n        self.logo_group = Group(self.text, self.neural_network)\n        self.logo_group.scale(1.0)\n        self.logo_group.move_to(ORIGIN)\n        self.play(Write(self.text), run_time=1.0)\n        self.play(Create(self.neural_network), run_time=3.0)\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            # Create(self.surrounding_rectangle)\n        )\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            #    Create(self.surrounding_rectangle)\n        )\n        self.play(animation_group, runtime=5.0)\n        self.wait(5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "wide_logo.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a red square and a yellow circle labeled with keys \"s\" and \"c\" respectively, grouped together using a visual dictionary. After a pause, green text labeled \"t\" appears below the square. A rectangle is then added below the text and labeled \"r\". The text changes color to purple, scales up, and is then replaced with new blue text. This new text is removed, followed by the red square being uncreated, the yellow circle fading out, and the rectangle fading out while shifting downward. Finally, two new VDicts appear: one on the left showing integers 1, 2, and 3 stacked vertically, and another on the right showing a square, circle, and rectangle arranged together."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ShapesWithVDict(Scene):\n    def construct(self):\n        square = Square().set_color(RED)\n        circle = Circle().set_color(YELLOW).next_to(square, UP)\n\n        # create dict from list of tuples each having key-mobject pair\n        pairs = [(\"s\", square), (\"c\", circle)]\n        my_dict = VDict(pairs, show_keys=True)\n\n        # display it just like a VGroup\n        self.play(Create(my_dict))\n        self.wait()\n\n        text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\n\n        # add a key-value pair by wrapping it in a single-element list of tuple\n        # after attrs branch is merged, it will be easier like `.add(t=text)`\n        my_dict.add([(\"t\", text)])\n        self.wait()\n\n        rect = Rectangle().next_to(text, DOWN)\n        # can also do key assignment like a python dict\n        my_dict[\"r\"] = rect\n\n        # access submobjects like a python dict\n        my_dict[\"t\"].set_color(PURPLE)\n        self.play(my_dict[\"t\"].animate.scale(3))\n        self.wait()\n\n        # also supports python dict styled reassignment\n        my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\n        self.wait()\n\n        # remove submobject by key\n        my_dict.remove(\"t\")\n        self.wait()\n\n        self.play(Uncreate(my_dict[\"s\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"c\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\n        self.wait()\n\n        # you can also make a VDict from an existing dict of mobjects\n        plain_dict = {\n            1: Integer(1).shift(DOWN),\n            2: Integer(2).shift(2 * DOWN),\n            3: Integer(3).shift(3 * DOWN),\n        }\n\n        vdict_from_plain_dict = VDict(plain_dict)\n        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\n        self.play(Create(vdict_from_plain_dict))\n\n        # you can even use zip\n        vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\n        vdict_using_zip.shift(1.5 * RIGHT)\n        self.play(Create(vdict_using_zip))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a red square and a yellow circle labeled with keys \"s\" and \"c\" respectively, grouped together using a visual dictionary. After a pause, green text labeled \"t\" appears below the square. A rectangle is then added below the text and labeled \"r\". The text changes color to purple, scales up, and is then replaced with new blue text. This new text is removed, followed by the red square being uncreated, the yellow circle fading out, and the rectangle fading out while shifting downward. Finally, two new VDicts appear: one on the left showing integers 1, 2, and 3 stacked vertically, and another on the right showing a square, circle, and rectangle arranged together."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a red square and a yellow circle labeled with keys \"s\" and \"c\" respectively, grouped together using a visual dictionary. after a pause, green text labeled \"t\" appears below the square. a rectangle is then added below the text and labeled \"r\". the text changes color to purple, scales up, and is then replaced with new blue text. this new text is removed, followed by the red square being uncreated, the yellow circle fading out, and the rectangle fading out while shifting downward. finally, two new vdicts appear: one on the left showing integers 1, 2, and 3 stacked vertically, and another on the right showing a square, circle, and rectangle arranged together."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ShapesWithVDict(Scene):\n    def construct(self):\n        square = Square().set_color(RED)\n        circle = Circle().set_color(YELLOW).next_to(square, UP)\n\n        # create dict from list of tuples each having key-mobject pair\n        pairs = [(\"s\", square), (\"c\", circle)]\n        my_dict = VDict(pairs, show_keys=True)\n\n        # display it just like a VGroup\n        self.play(Create(my_dict))\n        self.wait()\n\n        text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\n\n        # add a key-value pair by wrapping it in a single-element list of tuple\n        # after attrs branch is merged, it will be easier like `.add(t=text)`\n        my_dict.add([(\"t\", text)])\n        self.wait()\n\n        rect = Rectangle().next_to(text, DOWN)\n        # can also do key assignment like a python dict\n        my_dict[\"r\"] = rect\n\n        # access submobjects like a python dict\n        my_dict[\"t\"].set_color(PURPLE)\n        self.play(my_dict[\"t\"].animate.scale(3))\n        self.wait()\n\n        # also supports python dict styled reassignment\n        my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\n        self.wait()\n\n        # remove submobject by key\n        my_dict.remove(\"t\")\n        self.wait()\n\n        self.play(Uncreate(my_dict[\"s\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"c\"]))\n        self.wait()\n\n        self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\n        self.wait()\n\n        # you can also make a VDict from an existing dict of mobjects\n        plain_dict = {\n            1: Integer(1).shift(DOWN),\n            2: Integer(2).shift(2 * DOWN),\n            3: Integer(3).shift(3 * DOWN),\n        }\n\n        vdict_from_plain_dict = VDict(plain_dict)\n        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\n        self.play(Create(vdict_from_plain_dict))\n\n        # you can even use zip\n        vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\n        vdict_using_zip.shift(1.5 * RIGHT)\n        self.play(Create(vdict_using_zip))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a red square and a yellow circle labeled with keys \"s\" and \"c\" respectively, grouped together using a visual dictionary. After a pause, green text labeled \"t\" appears below the square. A rectangle is then added below the text and labeled \"r\". The text changes color to purple, scales up, and is then replaced with new blue text. This new text is removed, followed by the red square being uncreated, the yellow circle fading out, and the rectangle fading out while shifting downward. Finally, two new VDicts appear: one on the left showing integers 1, 2, and 3 stacked vertically, and another on the right showing a square, circle, and rectangle arranged together."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that introduces and solves the integral of e to the power of x, detailing each step of the process and highlighting the constant of integration?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the heat equation\n        equation = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for physical meaning\n        explanation1 = Text(\"The heat equation describes the distribution of heat in a given region over time.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=DOWN))\n        self.wait(2)\n\n        # Example of a solution\n        example_solution = MathTex(r\"u(x, t) = \\frac{1}{\\sqrt{4 \\pi \\alpha t}} e^{-\\frac{x^2}{4 \\alpha t}}\")\n        self.play(Transform(equation, example_solution))\n        self.wait(1)\n\n        # Explanation for solution\n        explanation2 = Text(\"This solution represents heat conduction in a rod as time progresses.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Discuss initial conditions\n        initial_conditions = Text(\"Initial and boundary conditions are crucial for specific solutions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, initial_conditions))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        self.play(FadeIn(equation, shift=UP))\n        self.wait(1)\n\n        # Display steady-state solution\n        steady_state = MathTex(r\"u(x) = ax + b\")\n        self.play(Transform(equation, steady_state))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that introduces and solves the integral of e to the power of x, detailing each step of the process and highlighting the constant of integration?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that introduces and solves the integral of e to the power of x, detailing each step of the process and highlighting the constant of integration?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HeatEquationExample(Scene):\n    def construct(self):\n        # Displaying the heat equation\n        equation = MathTex(r\"\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explanation for physical meaning\n        explanation1 = Text(\"The heat equation describes the distribution of heat in a given region over time.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(explanation1, shift=DOWN))\n        self.wait(2)\n\n        # Example of a solution\n        example_solution = MathTex(r\"u(x, t) = \\frac{1}{\\sqrt{4 \\pi \\alpha t}} e^{-\\frac{x^2}{4 \\alpha t}}\")\n        self.play(Transform(equation, example_solution))\n        self.wait(1)\n\n        # Explanation for solution\n        explanation2 = Text(\"This solution represents heat conduction in a rod as time progresses.\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Discuss initial conditions\n        initial_conditions = Text(\"Initial and boundary conditions are crucial for specific solutions.\", font_size=24).to_edge(UP)\n        self.play(ReplacementTransform(explanation1, initial_conditions))\n        self.wait(2)\n\n        # Conclusion\n        self.clear()\n        self.play(FadeIn(equation, shift=UP))\n        self.wait(1)\n\n        # Display steady-state solution\n        steady_state = MathTex(r\"u(x) = ax + b\")\n        self.play(Transform(equation, steady_state))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that introduces and solves the integral of e to the power of x, detailing each step of the process and highlighting the constant of integration?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do Ramsey numbers reveal the inevitability of order within chaos, and what's the smallest number of vertices needed to guarantee a red or blue complete subgraph in any two-color vertex setting?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport random\n\nclass RamseyTheory(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Finding Order in Chaos: The Magic of Ramsey Numbers\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Dinner party analogy\n        table = Circle(radius=1.5, color=BLUE_D)\n        chairs = VGroup(*[Dot(color=BLUE_C).move_to(table.point_at_angle(angle)) \n                         for angle in np.linspace(0, TAU, 6, endpoint=False)])\n        \n        self.play(Create(table))\n        self.play(Create(chairs))\n        \n        dinner_text = Text(\"A dinner party with 6 guests...\", font_size=24)\n        dinner_text.to_edge(DOWN)\n        self.play(Write(dinner_text))\n        self.wait(1)\n        \n        # Transition to graph theory\n        self.play(\n            FadeOut(table),\n            FadeOut(chairs),\n            FadeOut(dinner_text)\n        )\n        \n        # Create a complete graph with 6 vertices\n        vertices = VGroup(*[Dot(point=[2*np.cos(i*TAU/6), 2*np.sin(i*TAU/6), 0]) \n                           for i in range(6)])\n        \n        # Create all edges of the complete graph\n        edges = {}\n        for i in range(6):\n            for j in range(i+1, 6):\n                edge = Line(vertices[i].get_center(), vertices[j].get_center(), stroke_width=2)\n                edges[(i, j)] = edge\n        \n        # Show the complete graph\n        self.play(Create(vertices))\n        self.play(*[Create(edge) for edge in edges.values()])\n        \n        # Explain coloring\n        explanation = Text(\"Coloring edges: Red = Friendship, Blue = Enmity\", font_size=24)\n        explanation.to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Random coloring\n        for edge_pair, edge in edges.items():\n            color = random.choice([RED, BLUE])\n            edge.set_color(color)\n        \n        self.play(*[edge.animate.set_color(edge.get_color()) for edge in edges.values()])\n        self.wait(1)\n        \n        self.play(FadeOut(explanation))\n        \n        # Find a monochromatic triangle\n        triangle_vertices = None\n        triangle_edges = None\n        \n        for i in range(6):\n            for j in range(i+1, 6):\n                for k in range(j+1, 6):\n                    ij_color = edges[(i, j)].get_color()\n                    jk_color = edges[(j, k)].get_color()\n                    ik_color = edges[(i, k)].get_color()\n                    \n                    if (ij_color == jk_color == ik_color):\n                        triangle_vertices = [i, j, k]\n                        triangle_edges = [(i, j), (j, k), (i, k)]\n                        break\n                if triangle_vertices:\n                    break\n            if triangle_vertices:\n                break\n        \n        # If no monochromatic triangle is found (very unlikely but possible with random coloring),\n        # default to highlighting vertices 0, 1, 2\n        if not triangle_vertices:\n            triangle_vertices = [0, 1, 2]\n            triangle_edges = [(0, 1), (1, 2), (0, 2)]\n        \n        triangle_text = Text(\"A monochromatic triangle always forms\", font_size=24)\n        triangle_text.to_edge(DOWN)\n        self.play(Write(triangle_text))\n        \n        self.play(\n            *[vertices[idx].animate.set_color(YELLOW).scale(1.5) for idx in triangle_vertices],\n            *[edges[edge].animate.set_stroke(width=6) for edge in triangle_edges]\n        )\n        self.wait(1)\n        \n        self.play(FadeOut(triangle_text))\n        \n        # Show the Ramsey number\n        equation = Text(\"R(3,3) = 6\", font_size=32)\n        equation.next_to(vertices, DOWN, buff=1)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The magic of Ramsey numbers: Order within chaos\", font_size=24)\n        conclusion.to_edge(DOWN)\n        self.play(\n            FadeOut(equation),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do Ramsey numbers reveal the inevitability of order within chaos, and what's the smallest number of vertices needed to guarantee a red or blue complete subgraph in any two-color vertex setting?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do ramsey numbers reveal the inevitability of order within chaos, and what's the smallest number of vertices needed to guarantee a red or blue complete subgraph in any two-color vertex setting?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport random\n\nclass RamseyTheory(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Finding Order in Chaos: The Magic of Ramsey Numbers\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Dinner party analogy\n        table = Circle(radius=1.5, color=BLUE_D)\n        chairs = VGroup(*[Dot(color=BLUE_C).move_to(table.point_at_angle(angle)) \n                         for angle in np.linspace(0, TAU, 6, endpoint=False)])\n        \n        self.play(Create(table))\n        self.play(Create(chairs))\n        \n        dinner_text = Text(\"A dinner party with 6 guests...\", font_size=24)\n        dinner_text.to_edge(DOWN)\n        self.play(Write(dinner_text))\n        self.wait(1)\n        \n        # Transition to graph theory\n        self.play(\n            FadeOut(table),\n            FadeOut(chairs),\n            FadeOut(dinner_text)\n        )\n        \n        # Create a complete graph with 6 vertices\n        vertices = VGroup(*[Dot(point=[2*np.cos(i*TAU/6), 2*np.sin(i*TAU/6), 0]) \n                           for i in range(6)])\n        \n        # Create all edges of the complete graph\n        edges = {}\n        for i in range(6):\n            for j in range(i+1, 6):\n                edge = Line(vertices[i].get_center(), vertices[j].get_center(), stroke_width=2)\n                edges[(i, j)] = edge\n        \n        # Show the complete graph\n        self.play(Create(vertices))\n        self.play(*[Create(edge) for edge in edges.values()])\n        \n        # Explain coloring\n        explanation = Text(\"Coloring edges: Red = Friendship, Blue = Enmity\", font_size=24)\n        explanation.to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Random coloring\n        for edge_pair, edge in edges.items():\n            color = random.choice([RED, BLUE])\n            edge.set_color(color)\n        \n        self.play(*[edge.animate.set_color(edge.get_color()) for edge in edges.values()])\n        self.wait(1)\n        \n        self.play(FadeOut(explanation))\n        \n        # Find a monochromatic triangle\n        triangle_vertices = None\n        triangle_edges = None\n        \n        for i in range(6):\n            for j in range(i+1, 6):\n                for k in range(j+1, 6):\n                    ij_color = edges[(i, j)].get_color()\n                    jk_color = edges[(j, k)].get_color()\n                    ik_color = edges[(i, k)].get_color()\n                    \n                    if (ij_color == jk_color == ik_color):\n                        triangle_vertices = [i, j, k]\n                        triangle_edges = [(i, j), (j, k), (i, k)]\n                        break\n                if triangle_vertices:\n                    break\n            if triangle_vertices:\n                break\n        \n        # If no monochromatic triangle is found (very unlikely but possible with random coloring),\n        # default to highlighting vertices 0, 1, 2\n        if not triangle_vertices:\n            triangle_vertices = [0, 1, 2]\n            triangle_edges = [(0, 1), (1, 2), (0, 2)]\n        \n        triangle_text = Text(\"A monochromatic triangle always forms\", font_size=24)\n        triangle_text.to_edge(DOWN)\n        self.play(Write(triangle_text))\n        \n        self.play(\n            *[vertices[idx].animate.set_color(YELLOW).scale(1.5) for idx in triangle_vertices],\n            *[edges[edge].animate.set_stroke(width=6) for edge in triangle_edges]\n        )\n        self.wait(1)\n        \n        self.play(FadeOut(triangle_text))\n        \n        # Show the Ramsey number\n        equation = Text(\"R(3,3) = 6\", font_size=32)\n        equation.next_to(vertices, DOWN, buff=1)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"The magic of Ramsey numbers: Order within chaos\", font_size=24)\n        conclusion.to_edge(DOWN)\n        self.play(\n            FadeOut(equation),\n            Write(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do Ramsey numbers reveal the inevitability of order within chaos, and what's the smallest number of vertices needed to guarantee a red or blue complete subgraph in any two-color vertex setting?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does applying the Cycle Counting Theorem to color a cube in k distinct colors help in understanding symmetries?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CycleCountingTheorem(Scene):\n    def construct(self):\n        # Display the title of the animation\n        title = Text(\"A Colorful Dance: Symmetries in Cube Coloring\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction to the topic\n        intro_text = Text(\"Combinatorics & Cycle Counting Theorem\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Visualize a cube (simplified as a square for 2D animation)\n        cube = Square(side_length=2).set_fill(BLUE, opacity=0.5)\n        self.play(Create(cube))\n        self.wait(1)\n        \n        # Demonstrate rotational symmetries of a cube\n        rotation_text = Text(\"Cube has rotational symmetries\", font_size=20)\n        rotation_text.to_edge(DOWN)\n        self.play(Write(rotation_text))\n        self.play(Rotate(cube, angle=PI))\n        self.wait(1)\n        self.play(FadeOut(rotation_text))\n        \n        # Display the Cycle Counting Theorem equation\n        equation = Text(\"1/n \u2211 |Fix(g)| for g in G\", font_size=28)\n        equation_text = Text(\"Cycle Counting Theorem:\", font_size=24)\n        equation_text.to_edge(UP).shift(DOWN*0.5)\n        equation.next_to(equation_text, DOWN)\n        \n        self.play(Write(equation_text), Write(equation))\n        self.wait(1)\n        \n        # Explain how different colorings can be equivalent under symmetry\n        explanation = Text(\"Different colorings can be equivalent under rotations\", font_size=20)\n        explanation.next_to(equation, DOWN, buff=1)\n        self.play(Write(explanation))\n        \n        # Create three colored squares representing different colored cubes\n        red_cube = Square(side_length=1).set_fill(RED, opacity=0.8).shift(LEFT*3)\n        green_cube = Square(side_length=1).set_fill(GREEN, opacity=0.8)\n        blue_cube = Square(side_length=1).set_fill(BLUE, opacity=0.8).shift(RIGHT*3)\n        \n        self.play(Create(red_cube), Create(green_cube), Create(blue_cube))\n        self.wait(1)\n        \n        # Merge the colored cubes to represent equivalence under symmetry\n        self.play(\n            red_cube.animate.move_to(ORIGIN),\n            green_cube.animate.move_to(ORIGIN),\n            blue_cube.animate.move_to(ORIGIN)\n        )\n        \n        # Transform into a single cube to represent the unified counting\n        final_cube = Square(side_length=2).set_fill(PURPLE, opacity=0.7)\n        self.play(Transform(red_cube, final_cube), FadeOut(green_cube), FadeOut(blue_cube))\n        self.wait(1)\n        \n        # Conclusion about the Cycle Counting Theorem\n        self.play(FadeOut(explanation), FadeOut(cube))\n        conclusion = Text(\"The Cycle Counting Theorem helps us understand symmetries!\", font_size=24)\n        conclusion.next_to(equation, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out to end the animation\n        self.play(FadeOut(title), FadeOut(equation_text), FadeOut(equation), FadeOut(red_cube), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does applying the Cycle Counting Theorem to color a cube in k distinct colors help in understanding symmetries?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does applying the cycle counting theorem to color a cube in k distinct colors help in understanding symmetries?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CycleCountingTheorem(Scene):\n    def construct(self):\n        # Display the title of the animation\n        title = Text(\"A Colorful Dance: Symmetries in Cube Coloring\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction to the topic\n        intro_text = Text(\"Combinatorics & Cycle Counting Theorem\", font_size=24)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Visualize a cube (simplified as a square for 2D animation)\n        cube = Square(side_length=2).set_fill(BLUE, opacity=0.5)\n        self.play(Create(cube))\n        self.wait(1)\n        \n        # Demonstrate rotational symmetries of a cube\n        rotation_text = Text(\"Cube has rotational symmetries\", font_size=20)\n        rotation_text.to_edge(DOWN)\n        self.play(Write(rotation_text))\n        self.play(Rotate(cube, angle=PI))\n        self.wait(1)\n        self.play(FadeOut(rotation_text))\n        \n        # Display the Cycle Counting Theorem equation\n        equation = Text(\"1/n \u2211 |Fix(g)| for g in G\", font_size=28)\n        equation_text = Text(\"Cycle Counting Theorem:\", font_size=24)\n        equation_text.to_edge(UP).shift(DOWN*0.5)\n        equation.next_to(equation_text, DOWN)\n        \n        self.play(Write(equation_text), Write(equation))\n        self.wait(1)\n        \n        # Explain how different colorings can be equivalent under symmetry\n        explanation = Text(\"Different colorings can be equivalent under rotations\", font_size=20)\n        explanation.next_to(equation, DOWN, buff=1)\n        self.play(Write(explanation))\n        \n        # Create three colored squares representing different colored cubes\n        red_cube = Square(side_length=1).set_fill(RED, opacity=0.8).shift(LEFT*3)\n        green_cube = Square(side_length=1).set_fill(GREEN, opacity=0.8)\n        blue_cube = Square(side_length=1).set_fill(BLUE, opacity=0.8).shift(RIGHT*3)\n        \n        self.play(Create(red_cube), Create(green_cube), Create(blue_cube))\n        self.wait(1)\n        \n        # Merge the colored cubes to represent equivalence under symmetry\n        self.play(\n            red_cube.animate.move_to(ORIGIN),\n            green_cube.animate.move_to(ORIGIN),\n            blue_cube.animate.move_to(ORIGIN)\n        )\n        \n        # Transform into a single cube to represent the unified counting\n        final_cube = Square(side_length=2).set_fill(PURPLE, opacity=0.7)\n        self.play(Transform(red_cube, final_cube), FadeOut(green_cube), FadeOut(blue_cube))\n        self.wait(1)\n        \n        # Conclusion about the Cycle Counting Theorem\n        self.play(FadeOut(explanation), FadeOut(cube))\n        conclusion = Text(\"The Cycle Counting Theorem helps us understand symmetries!\", font_size=24)\n        conclusion.next_to(equation, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out to end the animation\n        self.play(FadeOut(title), FadeOut(equation_text), FadeOut(equation), FadeOut(red_cube), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does applying the Cycle Counting Theorem to color a cube in k distinct colors help in understanding symmetries?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the mapping of the critical strip illustrate shifts in the prime-counting function?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RiemannHypothesisScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Riemann Hypothesis\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Critical strip visualization\n        strip = Rectangle(height=4, width=1, color=BLUE)\n        strip_label = Text(\"Critical Strip\", font_size=24).next_to(strip, UP)\n        \n        self.play(Create(strip), Write(strip_label))\n        self.wait(1)\n        \n        # Critical line\n        line = Line(start=strip.get_bottom() + UP * 0.2, end=strip.get_top() - UP * 0.2, color=YELLOW)\n        line_label = Text(\"Re(s) = 1/2\", font_size=20).next_to(line, RIGHT)\n        \n        self.play(Create(line), Write(line_label))\n        self.wait(1)\n        \n        # Add dots representing zeros\n        dots = VGroup()\n        for i in range(5):\n            y_pos = -1.5 + i * 0.75  # Spaced out vertically\n            dot = Dot(np.array([0, y_pos, 0]), color=RED)\n            dots.add(dot)\n        \n        self.play(Create(dots))\n        self.wait(1)\n        \n        # Equation\n        eq = Text(\"\u03b6(s) = sum of 1/n^s\", font_size=28).to_edge(UP)\n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Clear the strip visualization\n        self.play(\n            FadeOut(strip),\n            FadeOut(strip_label),\n            FadeOut(line),\n            FadeOut(line_label),\n            FadeOut(dots)\n        )\n        \n        # Prime numbers on a line\n        number_line = Line(LEFT * 4, RIGHT * 4, color=WHITE)\n        number_line.shift(DOWN)\n        \n        # Add some number labels\n        labels = VGroup()\n        for i in range(0, 21, 5):  # 0, 5, 10, 15, 20\n            label = Text(str(i), font_size=16)\n            x_pos = -4 + (i / 20) * 8  # Map from 0-20 to -4 to 4\n            label.next_to(np.array([x_pos, -1, 0]), DOWN)\n            labels.add(label)\n        \n        self.play(Create(number_line), Create(labels))\n        self.wait(1)\n        \n        # Prime dots\n        primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        prime_dots = VGroup()\n        \n        for prime in primes:\n            x_pos = -4 + (prime / 20) * 8\n            dot = Dot(np.array([x_pos, -1, 0]), color=RED)\n            prime_dots.add(dot)\n        \n        self.play(Create(prime_dots))\n        self.wait(1)\n        \n        # Prime counting function\n        eq2 = Text(\"\u03c0(x) counts primes up to x\", font_size=24)\n        eq2.next_to(eq, DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Zeros of \u03b6(s) influence prime distribution\", font_size=28)\n        conclusion.to_edge(DOWN, buff=1.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(eq),\n            FadeOut(eq2),\n            FadeOut(number_line),\n            FadeOut(labels),\n            FadeOut(prime_dots),\n            FadeOut(conclusion)\n        )\n        \n        # Final title\n        final_title = Text(\"Exploring the Riemann Hypothesis\", font_size=35)\n        self.play(Write(final_title))\n        self.wait(2)\n        self.play(FadeOut(final_title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the mapping of the critical strip illustrate shifts in the prime-counting function?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the mapping of the critical strip illustrate shifts in the prime-counting function?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RiemannHypothesisScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Riemann Hypothesis\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Critical strip visualization\n        strip = Rectangle(height=4, width=1, color=BLUE)\n        strip_label = Text(\"Critical Strip\", font_size=24).next_to(strip, UP)\n        \n        self.play(Create(strip), Write(strip_label))\n        self.wait(1)\n        \n        # Critical line\n        line = Line(start=strip.get_bottom() + UP * 0.2, end=strip.get_top() - UP * 0.2, color=YELLOW)\n        line_label = Text(\"Re(s) = 1/2\", font_size=20).next_to(line, RIGHT)\n        \n        self.play(Create(line), Write(line_label))\n        self.wait(1)\n        \n        # Add dots representing zeros\n        dots = VGroup()\n        for i in range(5):\n            y_pos = -1.5 + i * 0.75  # Spaced out vertically\n            dot = Dot(np.array([0, y_pos, 0]), color=RED)\n            dots.add(dot)\n        \n        self.play(Create(dots))\n        self.wait(1)\n        \n        # Equation\n        eq = Text(\"\u03b6(s) = sum of 1/n^s\", font_size=28).to_edge(UP)\n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Clear the strip visualization\n        self.play(\n            FadeOut(strip),\n            FadeOut(strip_label),\n            FadeOut(line),\n            FadeOut(line_label),\n            FadeOut(dots)\n        )\n        \n        # Prime numbers on a line\n        number_line = Line(LEFT * 4, RIGHT * 4, color=WHITE)\n        number_line.shift(DOWN)\n        \n        # Add some number labels\n        labels = VGroup()\n        for i in range(0, 21, 5):  # 0, 5, 10, 15, 20\n            label = Text(str(i), font_size=16)\n            x_pos = -4 + (i / 20) * 8  # Map from 0-20 to -4 to 4\n            label.next_to(np.array([x_pos, -1, 0]), DOWN)\n            labels.add(label)\n        \n        self.play(Create(number_line), Create(labels))\n        self.wait(1)\n        \n        # Prime dots\n        primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        prime_dots = VGroup()\n        \n        for prime in primes:\n            x_pos = -4 + (prime / 20) * 8\n            dot = Dot(np.array([x_pos, -1, 0]), color=RED)\n            prime_dots.add(dot)\n        \n        self.play(Create(prime_dots))\n        self.wait(1)\n        \n        # Prime counting function\n        eq2 = Text(\"\u03c0(x) counts primes up to x\", font_size=24)\n        eq2.next_to(eq, DOWN)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Zeros of \u03b6(s) influence prime distribution\", font_size=28)\n        conclusion.to_edge(DOWN, buff=1.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(eq),\n            FadeOut(eq2),\n            FadeOut(number_line),\n            FadeOut(labels),\n            FadeOut(prime_dots),\n            FadeOut(conclusion)\n        )\n        \n        # Final title\n        final_title = Text(\"Exploring the Riemann Hypothesis\", font_size=35)\n        self.play(Write(final_title))\n        self.wait(2)\n        self.play(FadeOut(final_title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the mapping of the critical strip illustrate shifts in the prime-counting function?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four styled numbers positioned around the screen:\n\n1. An orange number \u201c2\u201d (rounded from 2.5) scaled up and placed slightly left and near the top.\n2. A large number \u201c3\u201d (from 3.14159) with ellipsis, scaled by its own value and placed in the upper right.\n3. A gradient-colored number \u201c42\u201d in blue and teal, scaled and placed in the lower right.\n4. A yellow number \u201c6\u201d (from 6.28), scaled and positioned in the lower left.\n\nEach number is rendered using the `Integer` class, which rounds the input to the nearest whole number."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IntegerExample(Scene):\n    def construct(self):\n        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))\n        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))\n        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))\n        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four styled numbers positioned around the screen:\n\n1. An orange number \u201c2\u201d (rounded from 2.5) scaled up and placed slightly left and near the top.\n2. A large number \u201c3\u201d (from 3.14159) with ellipsis, scaled by its own value and placed in the upper right.\n3. A gradient-colored number \u201c42\u201d in blue and teal, scaled and placed in the lower right.\n4. A yellow number \u201c6\u201d (from 6.28), scaled and positioned in the lower left.\n\nEach number is rendered using the `Integer` class, which rounds the input to the nearest whole number."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four styled numbers positioned around the screen:\n\n1. an orange number \u201c2\u201d (rounded from 2.5) scaled up and placed slightly left and near the top.\n2. a large number \u201c3\u201d (from 3.14159) with ellipsis, scaled by its own value and placed in the upper right.\n3. a gradient-colored number \u201c42\u201d in blue and teal, scaled and placed in the lower right.\n4. a yellow number \u201c6\u201d (from 6.28), scaled and positioned in the lower left.\n\neach number is rendered using the `integer` class, which rounds the input to the nearest whole number."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IntegerExample(Scene):\n    def construct(self):\n        self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))\n        self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))\n        self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))\n        self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four styled numbers positioned around the screen:\n\n1. An orange number \u201c2\u201d (rounded from 2.5) scaled up and placed slightly left and near the top.\n2. A large number \u201c3\u201d (from 3.14159) with ellipsis, scaled by its own value and placed in the upper right.\n3. A gradient-colored number \u201c42\u201d in blue and teal, scaled and placed in the lower right.\n4. A yellow number \u201c6\u201d (from 6.28), scaled and positioned in the lower left.\n\nEach number is rendered using the `Integer` class, which rounds the input to the nearest whole number."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what way does the Euclidean Algorithm mirror patterns found in nature, such as the spirals of a sunflower or the geometry of a snail's shell?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EuclideanAlgorithmNature(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Nature's Arithmetic: The Euclidean Algorithm & Natural Spirals\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction - Simple visualization of nature's patterns\n        intro_text = Text(\"Patterns in Nature\", font_size=36)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Creating a circle to represent a sunflower\n        circle = Circle(radius=1.5, color=YELLOW).shift(LEFT*2)\n        dot = Dot(point=circle.get_center(), color=YELLOW)\n        \n        # Creating simple arcs to represent a spiral (like a snail shell)\n        arcs = VGroup()\n        for i in range(1, 6):\n            arc = Arc(radius=i*0.3, start_angle=0, angle=i*PI, color=YELLOW).shift(RIGHT*2)\n            arcs.add(arc)\n        \n        self.play(Create(circle), Create(dot))\n        self.play(Create(arcs))\n        self.wait(1)\n        self.play(FadeOut(circle), FadeOut(dot), FadeOut(arcs))\n        \n        # Key Concept 1 - Introduction to Euclidean Algorithm\n        concept1 = Text(\"The Euclidean Algorithm finds the GCD\", font_size=32)\n        self.play(Write(concept1))\n        self.wait(1)\n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2 - Example calculation\n        example = Text(\"Example: GCD(84, 32)\", font_size=32)\n        self.play(Write(example))\n        self.wait(1)\n        self.play(FadeOut(example))\n        \n        # Show algorithm steps - calculating GCD of 84 and 32\n        eq1 = Text(\"84 = 32 \u00d7 2 + 20\", font_size=28)\n        eq2 = Text(\"32 = 20 \u00d7 1 + 12\", font_size=28)\n        eq3 = Text(\"20 = 12 \u00d7 1 + 8\", font_size=28)\n        eq4 = Text(\"12 = 8 \u00d7 1 + 4\", font_size=28)\n        eq5 = Text(\"8 = 4 \u00d7 2 + 0\", font_size=28)\n        \n        equations = VGroup(eq1, eq2, eq3, eq4, eq5).arrange(DOWN, buff=0.3).scale(0.9)\n        \n        for eq in equations:\n            self.play(Write(eq))\n            self.wait(0.3)\n        \n        result = Text(\"Therefore, GCD(84, 32) = 4\", color=YELLOW, font_size=28)\n        result.next_to(equations, DOWN, buff=0.5)\n        \n        self.play(Write(result))\n        self.wait(1)\n        self.play(FadeOut(equations), FadeOut(result))\n        \n        # Key Concept 3 - Visual representation\n        concept3 = Text(\"The algorithm creates patterns similar to spirals\", font_size=32)\n        self.play(Write(concept3))\n        self.wait(1)\n        self.play(FadeOut(concept3))\n        \n        # Rectangle spiral visualization - representing the Euclidean Algorithm geometrically\n        rect1 = Rectangle(width=4, height=2, color=GREEN)\n        rect2 = Rectangle(width=2, height=1, color=YELLOW).next_to(rect1, RIGHT, buff=0)\n        rect3 = Rectangle(width=1, height=1, color=RED).next_to(rect2, DOWN, buff=0)\n        rect4 = Rectangle(width=1, height=0.5, color=BLUE).next_to(rect3, LEFT, buff=0)\n        \n        rectangles = VGroup(rect1, rect2, rect3, rect4).center()\n        \n        for rect in rectangles:\n            self.play(Create(rect))\n            self.wait(0.3)\n        \n        self.wait(1)\n        self.play(FadeOut(rectangles))\n        \n        # Key Insight - connecting math to nature\n        insight = Text(\"This recursive pattern forms the backbone\\nof many growing patterns in nature\", font_size=28)\n        self.play(Write(insight))\n        self.wait(1)\n        self.play(FadeOut(insight))\n        \n        # Conclusion - connecting math to nature\n        conclusion = Text(\"Mathematics and nature share beautiful patterns\", font_size=32)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))\n        \n        # Final title\n        final = Text(\"Nature's Arithmetic\", color=YELLOW, font_size=40)\n        self.play(Write(final))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way does the Euclidean Algorithm mirror patterns found in nature, such as the spirals of a sunflower or the geometry of a snail's shell?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what way does the euclidean algorithm mirror patterns found in nature, such as the spirals of a sunflower or the geometry of a snail's shell?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EuclideanAlgorithmNature(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Nature's Arithmetic: The Euclidean Algorithm & Natural Spirals\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction - Simple visualization of nature's patterns\n        intro_text = Text(\"Patterns in Nature\", font_size=36)\n        self.play(Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Creating a circle to represent a sunflower\n        circle = Circle(radius=1.5, color=YELLOW).shift(LEFT*2)\n        dot = Dot(point=circle.get_center(), color=YELLOW)\n        \n        # Creating simple arcs to represent a spiral (like a snail shell)\n        arcs = VGroup()\n        for i in range(1, 6):\n            arc = Arc(radius=i*0.3, start_angle=0, angle=i*PI, color=YELLOW).shift(RIGHT*2)\n            arcs.add(arc)\n        \n        self.play(Create(circle), Create(dot))\n        self.play(Create(arcs))\n        self.wait(1)\n        self.play(FadeOut(circle), FadeOut(dot), FadeOut(arcs))\n        \n        # Key Concept 1 - Introduction to Euclidean Algorithm\n        concept1 = Text(\"The Euclidean Algorithm finds the GCD\", font_size=32)\n        self.play(Write(concept1))\n        self.wait(1)\n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2 - Example calculation\n        example = Text(\"Example: GCD(84, 32)\", font_size=32)\n        self.play(Write(example))\n        self.wait(1)\n        self.play(FadeOut(example))\n        \n        # Show algorithm steps - calculating GCD of 84 and 32\n        eq1 = Text(\"84 = 32 \u00d7 2 + 20\", font_size=28)\n        eq2 = Text(\"32 = 20 \u00d7 1 + 12\", font_size=28)\n        eq3 = Text(\"20 = 12 \u00d7 1 + 8\", font_size=28)\n        eq4 = Text(\"12 = 8 \u00d7 1 + 4\", font_size=28)\n        eq5 = Text(\"8 = 4 \u00d7 2 + 0\", font_size=28)\n        \n        equations = VGroup(eq1, eq2, eq3, eq4, eq5).arrange(DOWN, buff=0.3).scale(0.9)\n        \n        for eq in equations:\n            self.play(Write(eq))\n            self.wait(0.3)\n        \n        result = Text(\"Therefore, GCD(84, 32) = 4\", color=YELLOW, font_size=28)\n        result.next_to(equations, DOWN, buff=0.5)\n        \n        self.play(Write(result))\n        self.wait(1)\n        self.play(FadeOut(equations), FadeOut(result))\n        \n        # Key Concept 3 - Visual representation\n        concept3 = Text(\"The algorithm creates patterns similar to spirals\", font_size=32)\n        self.play(Write(concept3))\n        self.wait(1)\n        self.play(FadeOut(concept3))\n        \n        # Rectangle spiral visualization - representing the Euclidean Algorithm geometrically\n        rect1 = Rectangle(width=4, height=2, color=GREEN)\n        rect2 = Rectangle(width=2, height=1, color=YELLOW).next_to(rect1, RIGHT, buff=0)\n        rect3 = Rectangle(width=1, height=1, color=RED).next_to(rect2, DOWN, buff=0)\n        rect4 = Rectangle(width=1, height=0.5, color=BLUE).next_to(rect3, LEFT, buff=0)\n        \n        rectangles = VGroup(rect1, rect2, rect3, rect4).center()\n        \n        for rect in rectangles:\n            self.play(Create(rect))\n            self.wait(0.3)\n        \n        self.wait(1)\n        self.play(FadeOut(rectangles))\n        \n        # Key Insight - connecting math to nature\n        insight = Text(\"This recursive pattern forms the backbone\\nof many growing patterns in nature\", font_size=28)\n        self.play(Write(insight))\n        self.wait(1)\n        self.play(FadeOut(insight))\n        \n        # Conclusion - connecting math to nature\n        conclusion = Text(\"Mathematics and nature share beautiful patterns\", font_size=32)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))\n        \n        # Final title\n        final = Text(\"Nature's Arithmetic\", color=YELLOW, font_size=40)\n        self.play(Write(final))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way does the Euclidean Algorithm mirror patterns found in nature, such as the spirals of a sunflower or the geometry of a snail's shell?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do complex power series exhibit different convergence properties when expanded around essential singularities as opposed to regular points?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ComplexPowerSeriesScene(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Diving into the Kaleidoscope of Complex Power Series\", font_size=28)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.to_edge(UP))\n        \n        # Simple kaleidoscope effect using colored shapes\n        kaleidoscope = VGroup()\n        for i in range(6):\n            triangle = RegularPolygon(n=3, fill_opacity=0.5, \n                                     color=interpolate_color(BLUE, RED, i/6))\n            triangle.scale(1.2)\n            triangle.rotate(i * PI/3)\n            kaleidoscope.add(triangle)\n        \n        self.play(FadeIn(kaleidoscope))\n        self.play(Rotate(kaleidoscope, angle=PI), run_time=2)\n        self.play(FadeOut(kaleidoscope))\n        \n        # Section for regular point\n        reg_point_text = Text(\"Regular Point:\", font_size=24).to_edge(LEFT).shift(UP)\n        self.play(Write(reg_point_text))\n        \n        # Create a dot representing a regular point with a convergence circle\n        dot1 = Dot(point=RIGHT*2 + UP, color=BLUE)\n        circle1 = Circle(radius=1, color=GREEN).move_to(dot1)\n        \n        self.play(Create(dot1))\n        self.play(Create(circle1))\n        \n        # Display the power series equation\n        power_eq = MathTex(r\"f(z) = \\sum_{n=0}^{\\infty} a_n(z-c)^n\")\n        power_eq.next_to(reg_point_text, DOWN).shift(RIGHT)\n        self.play(Write(power_eq))\n        \n        # Create concentric circles to show orderly convergence\n        small_circles = VGroup()\n        for i in range(1, 4):\n            c = Circle(radius=i*0.2, color=BLUE_C).move_to(dot1)\n            small_circles.add(c)\n        \n        self.play(Create(small_circles))\n        self.wait()\n        \n        # Section for essential singularity\n        sing_point_text = Text(\"Essential Singularity:\", font_size=24).to_edge(LEFT).shift(DOWN*2)\n        self.play(Write(sing_point_text))\n        \n        # Create a dot representing an essential singularity\n        dot2 = Dot(point=RIGHT*2 + DOWN*2, color=RED)\n        self.play(Create(dot2))\n        \n        # Display the Laurent series equation\n        laurent_eq = MathTex(r\"f(z) = \\sum_{n=-\\infty}^{\\infty} a_n(z-c)^n\")\n        laurent_eq.next_to(sing_point_text, DOWN).shift(RIGHT)\n        self.play(Write(laurent_eq))\n        \n        # Create circles with different radii to represent erratic behavior\n        c1 = Circle(radius=0.7, color=RED).move_to(dot2)\n        c2 = Circle(radius=0.4, color=YELLOW).move_to(dot2)\n        c3 = Circle(radius=1.0, color=ORANGE).move_to(dot2)\n        \n        self.play(Create(c1))\n        self.play(Create(c2))\n        self.play(Create(c3))\n        \n        # Animate the circles to visualize unpredictable behavior\n        self.play(\n            c1.animate.scale(1.3),\n            c2.animate.scale(1.8),\n            c3.animate.scale(0.6),\n            run_time=2\n        )\n        self.wait()\n        \n        # Clear screen and show conclusion\n        self.play(\n            FadeOut(reg_point_text), FadeOut(dot1), FadeOut(circle1), FadeOut(small_circles),\n            FadeOut(sing_point_text), FadeOut(dot2), FadeOut(c1), FadeOut(c2), FadeOut(c3),\n            FadeOut(power_eq), FadeOut(laurent_eq), FadeOut(title)\n        )\n        \n        conclusion = Text(\"Complex power series exhibit different convergence\\nproperties around essential singularities\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do complex power series exhibit different convergence properties when expanded around essential singularities as opposed to regular points?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do complex power series exhibit different convergence properties when expanded around essential singularities as opposed to regular points?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ComplexPowerSeriesScene(Scene):\n    def construct(self):\n        # Title of the animation\n        title = Text(\"Diving into the Kaleidoscope of Complex Power Series\", font_size=28)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.to_edge(UP))\n        \n        # Simple kaleidoscope effect using colored shapes\n        kaleidoscope = VGroup()\n        for i in range(6):\n            triangle = RegularPolygon(n=3, fill_opacity=0.5, \n                                     color=interpolate_color(BLUE, RED, i/6))\n            triangle.scale(1.2)\n            triangle.rotate(i * PI/3)\n            kaleidoscope.add(triangle)\n        \n        self.play(FadeIn(kaleidoscope))\n        self.play(Rotate(kaleidoscope, angle=PI), run_time=2)\n        self.play(FadeOut(kaleidoscope))\n        \n        # Section for regular point\n        reg_point_text = Text(\"Regular Point:\", font_size=24).to_edge(LEFT).shift(UP)\n        self.play(Write(reg_point_text))\n        \n        # Create a dot representing a regular point with a convergence circle\n        dot1 = Dot(point=RIGHT*2 + UP, color=BLUE)\n        circle1 = Circle(radius=1, color=GREEN).move_to(dot1)\n        \n        self.play(Create(dot1))\n        self.play(Create(circle1))\n        \n        # Display the power series equation\n        power_eq = MathTex(r\"f(z) = \\sum_{n=0}^{\\infty} a_n(z-c)^n\")\n        power_eq.next_to(reg_point_text, DOWN).shift(RIGHT)\n        self.play(Write(power_eq))\n        \n        # Create concentric circles to show orderly convergence\n        small_circles = VGroup()\n        for i in range(1, 4):\n            c = Circle(radius=i*0.2, color=BLUE_C).move_to(dot1)\n            small_circles.add(c)\n        \n        self.play(Create(small_circles))\n        self.wait()\n        \n        # Section for essential singularity\n        sing_point_text = Text(\"Essential Singularity:\", font_size=24).to_edge(LEFT).shift(DOWN*2)\n        self.play(Write(sing_point_text))\n        \n        # Create a dot representing an essential singularity\n        dot2 = Dot(point=RIGHT*2 + DOWN*2, color=RED)\n        self.play(Create(dot2))\n        \n        # Display the Laurent series equation\n        laurent_eq = MathTex(r\"f(z) = \\sum_{n=-\\infty}^{\\infty} a_n(z-c)^n\")\n        laurent_eq.next_to(sing_point_text, DOWN).shift(RIGHT)\n        self.play(Write(laurent_eq))\n        \n        # Create circles with different radii to represent erratic behavior\n        c1 = Circle(radius=0.7, color=RED).move_to(dot2)\n        c2 = Circle(radius=0.4, color=YELLOW).move_to(dot2)\n        c3 = Circle(radius=1.0, color=ORANGE).move_to(dot2)\n        \n        self.play(Create(c1))\n        self.play(Create(c2))\n        self.play(Create(c3))\n        \n        # Animate the circles to visualize unpredictable behavior\n        self.play(\n            c1.animate.scale(1.3),\n            c2.animate.scale(1.8),\n            c3.animate.scale(0.6),\n            run_time=2\n        )\n        self.wait()\n        \n        # Clear screen and show conclusion\n        self.play(\n            FadeOut(reg_point_text), FadeOut(dot1), FadeOut(circle1), FadeOut(small_circles),\n            FadeOut(sing_point_text), FadeOut(dot2), FadeOut(c1), FadeOut(c2), FadeOut(c3),\n            FadeOut(power_eq), FadeOut(laurent_eq), FadeOut(title)\n        )\n        \n        conclusion = Text(\"Complex power series exhibit different convergence\\nproperties around essential singularities\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do complex power series exhibit different convergence properties when expanded around essential singularities as opposed to regular points?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually explains how to integrate the function e raised to the power of 2x with respect to x. The animation should start by displaying the integration problem, followed by a brief written explanation that we use a reverse power rule to integrate the function. Then, the function should be replaced by the integrated function, which includes a constant C, demonstrating the result of the integration. The scene should clear before concluding by presenting the final integrated function once more. The presentation should be paced with pauses for the information to be absorbed by the viewers. Can you create such an animation for me, please?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SixDivisors(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(6, 1)\n        by_one.scale(1.3)\n        by_two = Division(6, 2)\n        by_two.scale(1.3)\n        by_three = Division(6, 3)\n        by_three.scale(1.3)\n        by_four = Division(6, 4)\n        by_four.scale(1.3)\n        by_five = Division(6, 5)\n        by_five.scale(1.3)\n        by_six = Division(6, 6)\n        by_six.scale(1.3)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_three,\n                by_four,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=0.5),\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_three, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_six, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains how to integrate the function e raised to the power of 2x with respect to x. The animation should start by displaying the integration problem, followed by a brief written explanation that we use a reverse power rule to integrate the function. Then, the function should be replaced by the integrated function, which includes a constant C, demonstrating the result of the integration. The scene should clear before concluding by presenting the final integrated function once more. The presentation should be paced with pauses for the information to be absorbed by the viewers. Can you create such an animation for me, please?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually explains how to integrate the function e raised to the power of 2x with respect to x. the animation should start by displaying the integration problem, followed by a brief written explanation that we use a reverse power rule to integrate the function. then, the function should be replaced by the integrated function, which includes a constant c, demonstrating the result of the integration. the scene should clear before concluding by presenting the final integrated function once more. the presentation should be paced with pauses for the information to be absorbed by the viewers. can you create such an animation for me, please?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass SixDivisors(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        by_one = Division(6, 1)\n        by_one.scale(1.3)\n        by_two = Division(6, 2)\n        by_two.scale(1.3)\n        by_three = Division(6, 3)\n        by_three.scale(1.3)\n        by_four = Division(6, 4)\n        by_four.scale(1.3)\n        by_five = Division(6, 5)\n        by_five.scale(1.3)\n        by_six = Division(6, 6)\n        by_six.scale(1.3)\n        divisions = VGroup(\n            VGroup(\n                by_one,\n                by_two,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_three,\n                by_four,\n            ).arrange(RIGHT, buff=0.5),\n            VGroup(\n                by_five,\n                by_six\n            ).arrange(RIGHT, buff=0.5),\n        )\n        divisions.arrange(DOWN, buff=1)\n        square1 = SurroundingRectangle(by_one, color=LIGHT_RED_COLOR)\n        square2 = SurroundingRectangle(by_two, color=LIGHT_RED_COLOR)\n        square3 = SurroundingRectangle(by_three, color=LIGHT_RED_COLOR)\n        square4 = SurroundingRectangle(by_six, color=LIGHT_RED_COLOR)\n\n        self.play(LaggedStart(\n            FadeIn(by_one), \n            FadeIn(by_two),\n            FadeIn(by_three),\n            FadeIn(by_four),\n            FadeIn(by_five),\n            FadeIn(by_six),\n            lag_ratio=0.3, \n            run_time=1.5\n        ))\n        self.wait(1)\n        self.play(LaggedStart(\n            Create(square1),\n            Create(square2),\n            Create(square3),\n            Create(square4),\n            lag_ratio=0.3,\n            run_time=2.5\n        ))\n        self.wait(2)\n        self.play(\n            FadeOut(square1), \n            FadeOut(square2), \n            FadeOut(square3), \n            FadeOut(square4), \n            FadeOut(divisions), \n            run_time=0.5\n        )\n        self.wait(0.5)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains how to integrate the function e raised to the power of 2x with respect to x. The animation should start by displaying the integration problem, followed by a brief written explanation that we use a reverse power rule to integrate the function. Then, the function should be replaced by the integrated function, which includes a constant C, demonstrating the result of the integration. The scene should clear before concluding by presenting the final integrated function once more. The presentation should be paced with pauses for the information to be absorbed by the viewers. Can you create such an animation for me, please?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually shows the calculation of the area under the curve y = x^2 from x=0 to x=2, including the graph, the shaded area, and step by step integration to find the exact area, with transitions between each step of the explanation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GrowingCircles(Scene):\n    def construct(self):\n        circle_array = VGroup(*[Circle(radius=i*0.3, color=BLUE, fill_opacity=0.5) for i in range(1, 6)])\n        circle_array.arrange_in_grid(rows=1, buff=1)\n        self.play(AnimationGroup(*(GrowFromCenter(circle) for circle in circle_array), lag_ratio=0.5))\n        self.wait(1)\n\n        for i in range(len(circle_array) - 1, 0, -1):\n            circle_to_swap = circle_array[i - 1]\n            self.play(\n                circle_array[i].animate.move_to(circle_to_swap.get_center()),\n                circle_to_swap.animate.move_to(circle_array[i].get_center()),\n                run_time=0.5\n            )\n            circle_array[i - 1], circle_array[i] = circle_array[i], circle_array[i - 1]\n            self.wait(0.1)\n\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually shows the calculation of the area under the curve y = x^2 from x=0 to x=2, including the graph, the shaded area, and step by step integration to find the exact area, with transitions between each step of the explanation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually shows the calculation of the area under the curve y = x^2 from x=0 to x=2, including the graph, the shaded area, and step by step integration to find the exact area, with transitions between each step of the explanation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GrowingCircles(Scene):\n    def construct(self):\n        circle_array = VGroup(*[Circle(radius=i*0.3, color=BLUE, fill_opacity=0.5) for i in range(1, 6)])\n        circle_array.arrange_in_grid(rows=1, buff=1)\n        self.play(AnimationGroup(*(GrowFromCenter(circle) for circle in circle_array), lag_ratio=0.5))\n        self.wait(1)\n\n        for i in range(len(circle_array) - 1, 0, -1):\n            circle_to_swap = circle_array[i - 1]\n            self.play(\n                circle_array[i].animate.move_to(circle_to_swap.get_center()),\n                circle_to_swap.animate.move_to(circle_array[i].get_center()),\n                run_time=0.5\n            )\n            circle_array[i - 1], circle_array[i] = circle_array[i], circle_array[i - 1]\n            self.wait(0.1)\n\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually shows the calculation of the area under the curve y = x^2 from x=0 to x=2, including the graph, the shaded area, and step by step integration to find the exact area, with transitions between each step of the explanation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What geometric patterns emerge when visualizing potential outcomes of coordination games on a triangular plot like a simplex?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TriangularStrategiesScene(Scene):\n    def construct(self):\n        # Introduction: Title\n        title = Text(\"Triangular Stories of Strategy\")\n        subtitle = Text(\"Navigating Coordination Games\").next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Building Intuition: Introduce the simplex\n        # Create a triangle with specific vertex positions\n        v1 = LEFT * 3 + DOWN\n        v2 = RIGHT * 3 + DOWN\n        v3 = UP * 2\n        \n        simplex = Polygon(v1, v2, v3, fill_opacity=0.2, fill_color=BLUE, stroke_width=2)\n        \n        self.play(Create(simplex))\n        self.wait(0.5)\n        \n        # Create avatars for Alice and Bob\n        alice_circle = Circle(radius=0.3, fill_opacity=1, color=GREEN).move_to(v1)\n        alice_label = Text(\"Alice\").next_to(alice_circle, DOWN)\n        \n        bob_circle = Circle(radius=0.3, fill_opacity=1, color=RED).move_to(v2)\n        bob_label = Text(\"Bob\").next_to(bob_circle, DOWN)\n        \n        self.play(Create(alice_circle), Write(alice_label))\n        self.play(Create(bob_circle), Write(bob_label))\n        self.wait(1)\n        \n        # Show a path representing strategy adjustments\n        path = Line(alice_circle.get_center(), bob_circle.get_center(), color=YELLOW)\n        self.play(Create(path))\n        self.wait(0.5)\n        \n        # Add a dot moving along the path\n        moving_dot = Dot(color=YELLOW).move_to(path.get_start())\n        self.play(Create(moving_dot))\n        self.play(moving_dot.animate.move_to(path.get_end()), run_time=2)\n        self.wait(0.5)\n        \n        # Show equilibrium point\n        equilibrium = Dot(simplex.get_center() + UP * 0.5, color=YELLOW)\n        equilibrium_label = Text(\"Equilibrium\").next_to(equilibrium, UP)\n        \n        self.play(Create(equilibrium), Write(equilibrium_label))\n        self.wait(0.5)\n        \n        # Show arrows pointing to equilibrium\n        arrow1 = Arrow(alice_circle.get_center(), equilibrium.get_center(), color=GREEN)\n        arrow2 = Arrow(bob_circle.get_center(), equilibrium.get_center(), color=RED)\n        \n        self.play(Create(arrow1), Create(arrow2))\n        self.wait(1)\n        \n        # Show simple equations\n        eq1 = Text(\"P_A(x) + P_B(y) = 1\").to_edge(DOWN, buff=1)\n        self.play(Write(eq1))\n        self.wait(0.5)\n        \n        eq2 = Text(\"grad S(u,v) = 0 at equilibrium\").next_to(eq1, DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Fade out elements\n        self.play(\n            FadeOut(path), FadeOut(moving_dot),\n            FadeOut(arrow1), FadeOut(arrow2),\n            FadeOut(equilibrium_label),\n            FadeOut(eq1), FadeOut(eq2)\n        )\n        \n        # Conclusion\n        conclusion = Text(\"Balanced Equilibrium\").to_edge(UP)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What geometric patterns emerge when visualizing potential outcomes of coordination games on a triangular plot like a simplex?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what geometric patterns emerge when visualizing potential outcomes of coordination games on a triangular plot like a simplex?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TriangularStrategiesScene(Scene):\n    def construct(self):\n        # Introduction: Title\n        title = Text(\"Triangular Stories of Strategy\")\n        subtitle = Text(\"Navigating Coordination Games\").next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Building Intuition: Introduce the simplex\n        # Create a triangle with specific vertex positions\n        v1 = LEFT * 3 + DOWN\n        v2 = RIGHT * 3 + DOWN\n        v3 = UP * 2\n        \n        simplex = Polygon(v1, v2, v3, fill_opacity=0.2, fill_color=BLUE, stroke_width=2)\n        \n        self.play(Create(simplex))\n        self.wait(0.5)\n        \n        # Create avatars for Alice and Bob\n        alice_circle = Circle(radius=0.3, fill_opacity=1, color=GREEN).move_to(v1)\n        alice_label = Text(\"Alice\").next_to(alice_circle, DOWN)\n        \n        bob_circle = Circle(radius=0.3, fill_opacity=1, color=RED).move_to(v2)\n        bob_label = Text(\"Bob\").next_to(bob_circle, DOWN)\n        \n        self.play(Create(alice_circle), Write(alice_label))\n        self.play(Create(bob_circle), Write(bob_label))\n        self.wait(1)\n        \n        # Show a path representing strategy adjustments\n        path = Line(alice_circle.get_center(), bob_circle.get_center(), color=YELLOW)\n        self.play(Create(path))\n        self.wait(0.5)\n        \n        # Add a dot moving along the path\n        moving_dot = Dot(color=YELLOW).move_to(path.get_start())\n        self.play(Create(moving_dot))\n        self.play(moving_dot.animate.move_to(path.get_end()), run_time=2)\n        self.wait(0.5)\n        \n        # Show equilibrium point\n        equilibrium = Dot(simplex.get_center() + UP * 0.5, color=YELLOW)\n        equilibrium_label = Text(\"Equilibrium\").next_to(equilibrium, UP)\n        \n        self.play(Create(equilibrium), Write(equilibrium_label))\n        self.wait(0.5)\n        \n        # Show arrows pointing to equilibrium\n        arrow1 = Arrow(alice_circle.get_center(), equilibrium.get_center(), color=GREEN)\n        arrow2 = Arrow(bob_circle.get_center(), equilibrium.get_center(), color=RED)\n        \n        self.play(Create(arrow1), Create(arrow2))\n        self.wait(1)\n        \n        # Show simple equations\n        eq1 = Text(\"P_A(x) + P_B(y) = 1\").to_edge(DOWN, buff=1)\n        self.play(Write(eq1))\n        self.wait(0.5)\n        \n        eq2 = Text(\"grad S(u,v) = 0 at equilibrium\").next_to(eq1, DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Fade out elements\n        self.play(\n            FadeOut(path), FadeOut(moving_dot),\n            FadeOut(arrow1), FadeOut(arrow2),\n            FadeOut(equilibrium_label),\n            FadeOut(eq1), FadeOut(eq2)\n        )\n        \n        # Conclusion\n        conclusion = Text(\"Balanced Equilibrium\").to_edge(UP)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What geometric patterns emerge when visualizing potential outcomes of coordination games on a triangular plot like a simplex?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a red-filled square on the screen. Animate the square changing its fill color to white. Then, simultaneously move the square upward and rotate it 60 degrees. Pause for one second after each animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AnimateExample(Scene):\n    def construct(self):\n        square = Square().set_fill(RED, opacity=1.0)\n        self.add(square)\n\n        # animate the change of color\n        self.play(square.animate.set_fill(WHITE))\n        self.wait(1)\n\n        # animate the change of position and the rotation at the same time\n        self.play(square.animate.shift(UP).rotate(PI / 3))\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a red-filled square on the screen. Animate the square changing its fill color to white. Then, simultaneously move the square upward and rotate it 60 degrees. Pause for one second after each animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a red-filled square on the screen. animate the square changing its fill color to white. then, simultaneously move the square upward and rotate it 60 degrees. pause for one second after each animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AnimateExample(Scene):\n    def construct(self):\n        square = Square().set_fill(RED, opacity=1.0)\n        self.add(square)\n\n        # animate the change of color\n        self.play(square.animate.set_fill(WHITE))\n        self.wait(1)\n\n        # animate the change of position and the rotation at the same time\n        self.play(square.animate.shift(UP).rotate(PI / 3))\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a red-filled square on the screen. Animate the square changing its fill color to white. Then, simultaneously move the square upward and rotate it 60 degrees. Pause for one second after each animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 2\u00d72 table with row and column labels. The bottom-right cell is outlined in red to highlight it, while the rest of the table appears normally."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        cell = table.get_cell((2,2), color=RED)\n        self.add(table, cell)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 table with row and column labels. The bottom-right cell is outlined in red to highlight it, while the rest of the table appears normally."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 2\u00d72 table with row and column labels. the bottom-right cell is outlined in red to highlight it, while the rest of the table appears normally."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetCellExample(Scene):\n    def construct(self):\n        table = Table(\n            [[\"First\", \"Second\"],\n            [\"Third\",\"Fourth\"]],\n            row_labels=[Text(\"R1\"), Text(\"R2\")],\n            col_labels=[Text(\"C1\"), Text(\"C2\")])\n        cell = table.get_cell((2,2), color=RED)\n        self.add(table, cell)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 2\u00d72 table with row and column labels. The bottom-right cell is outlined in red to highlight it, while the rest of the table appears normally."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the impact of introducing uncertainty in payoff values on Nash equilibria in mixed strategy games?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UncertaintyInGameTheory(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Uncertainty in Game Theory\")\n        subtitle = Text(\"The Ripple Effect on Nash Equilibria\").next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a 2x2 grid for the game matrix\n        square1 = Square(side_length=2).move_to([-1, 1, 0])\n        square2 = Square(side_length=2).move_to([1, 1, 0])\n        square3 = Square(side_length=2).move_to([-1, -1, 0])\n        square4 = Square(side_length=2).move_to([1, -1, 0])\n        \n        grid = VGroup(square1, square2, square3, square4)\n        \n        payoff1 = Text(\"(3,3)\").move_to(square1.get_center())\n        payoff2 = Text(\"(0,5)\").move_to(square2.get_center())\n        payoff3 = Text(\"(5,0)\").move_to(square3.get_center())\n        payoff4 = Text(\"(1,1)\").move_to(square4.get_center())\n        \n        payoffs = VGroup(payoff1, payoff2, payoff3, payoff4)\n        \n        matrix_title = Text(\"Game Matrix (Without Uncertainty)\").next_to(grid, UP)\n        \n        self.play(Create(grid))\n        self.play(Write(payoffs))\n        self.play(Write(matrix_title))\n        self.wait(1)\n        \n        # Nash Equilibrium point\n        eq_point = Dot(color=RED).move_to([0, 0, 0])\n        eq_label = Text(\"Nash Equilibrium\").next_to(eq_point, DOWN)\n        \n        self.play(Create(eq_point))\n        self.play(Write(eq_label))\n        self.wait(1)\n        \n        # Uncertainty - changing payoffs\n        uncertain_payoff1 = Text(\"(3\u00b10.5,3\u00b10.5)\").move_to(square1.get_center())\n        uncertain_payoff2 = Text(\"(0\u00b10.5,5\u00b10.5)\").move_to(square2.get_center())\n        uncertain_payoff3 = Text(\"(5\u00b10.5,0\u00b10.5)\").move_to(square3.get_center())\n        uncertain_payoff4 = Text(\"(1\u00b10.5,1\u00b10.5)\").move_to(square4.get_center())\n        \n        uncertain_payoffs = VGroup(uncertain_payoff1, uncertain_payoff2, uncertain_payoff3, uncertain_payoff4)\n        \n        uncertain_matrix_title = Text(\"Game Matrix (With Uncertainty)\").next_to(grid, UP)\n        \n        self.play(FadeOut(payoffs))\n        self.play(Write(uncertain_payoffs))\n        self.play(FadeOut(matrix_title))\n        self.play(Write(uncertain_matrix_title))\n        self.wait(1)\n        \n        # Uncertainty circle - showing range of equilibria\n        circle = Circle(radius=1, color=RED).move_to([0, 0, 0])\n        uncertainty_label = Text(\"Equilibrium Range with Uncertainty\").next_to(circle, UP)\n        \n        self.play(Create(circle))\n        self.play(Write(uncertainty_label))\n        self.wait(1)\n        \n        # Clear the screen for equation\n        self.play(FadeOut(grid), FadeOut(uncertain_payoffs), FadeOut(uncertain_matrix_title))\n        self.play(FadeOut(eq_point), FadeOut(eq_label))\n        self.play(FadeOut(circle), FadeOut(uncertainty_label))\n        \n        # Show equation\n        eq = Text(\"p*x(A) + (1-p)*x(B) = C\")\n        \n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Final message\n        final_message = Text(\"Uncertainty broadens strategic possibilities\")\n        \n        self.play(FadeOut(eq))\n        self.play(Write(final_message))\n        self.wait(2)\n        self.play(FadeOut(final_message))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the impact of introducing uncertainty in payoff values on Nash equilibria in mixed strategy games?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the impact of introducing uncertainty in payoff values on nash equilibria in mixed strategy games?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UncertaintyInGameTheory(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Uncertainty in Game Theory\")\n        subtitle = Text(\"The Ripple Effect on Nash Equilibria\").next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a 2x2 grid for the game matrix\n        square1 = Square(side_length=2).move_to([-1, 1, 0])\n        square2 = Square(side_length=2).move_to([1, 1, 0])\n        square3 = Square(side_length=2).move_to([-1, -1, 0])\n        square4 = Square(side_length=2).move_to([1, -1, 0])\n        \n        grid = VGroup(square1, square2, square3, square4)\n        \n        payoff1 = Text(\"(3,3)\").move_to(square1.get_center())\n        payoff2 = Text(\"(0,5)\").move_to(square2.get_center())\n        payoff3 = Text(\"(5,0)\").move_to(square3.get_center())\n        payoff4 = Text(\"(1,1)\").move_to(square4.get_center())\n        \n        payoffs = VGroup(payoff1, payoff2, payoff3, payoff4)\n        \n        matrix_title = Text(\"Game Matrix (Without Uncertainty)\").next_to(grid, UP)\n        \n        self.play(Create(grid))\n        self.play(Write(payoffs))\n        self.play(Write(matrix_title))\n        self.wait(1)\n        \n        # Nash Equilibrium point\n        eq_point = Dot(color=RED).move_to([0, 0, 0])\n        eq_label = Text(\"Nash Equilibrium\").next_to(eq_point, DOWN)\n        \n        self.play(Create(eq_point))\n        self.play(Write(eq_label))\n        self.wait(1)\n        \n        # Uncertainty - changing payoffs\n        uncertain_payoff1 = Text(\"(3\u00b10.5,3\u00b10.5)\").move_to(square1.get_center())\n        uncertain_payoff2 = Text(\"(0\u00b10.5,5\u00b10.5)\").move_to(square2.get_center())\n        uncertain_payoff3 = Text(\"(5\u00b10.5,0\u00b10.5)\").move_to(square3.get_center())\n        uncertain_payoff4 = Text(\"(1\u00b10.5,1\u00b10.5)\").move_to(square4.get_center())\n        \n        uncertain_payoffs = VGroup(uncertain_payoff1, uncertain_payoff2, uncertain_payoff3, uncertain_payoff4)\n        \n        uncertain_matrix_title = Text(\"Game Matrix (With Uncertainty)\").next_to(grid, UP)\n        \n        self.play(FadeOut(payoffs))\n        self.play(Write(uncertain_payoffs))\n        self.play(FadeOut(matrix_title))\n        self.play(Write(uncertain_matrix_title))\n        self.wait(1)\n        \n        # Uncertainty circle - showing range of equilibria\n        circle = Circle(radius=1, color=RED).move_to([0, 0, 0])\n        uncertainty_label = Text(\"Equilibrium Range with Uncertainty\").next_to(circle, UP)\n        \n        self.play(Create(circle))\n        self.play(Write(uncertainty_label))\n        self.wait(1)\n        \n        # Clear the screen for equation\n        self.play(FadeOut(grid), FadeOut(uncertain_payoffs), FadeOut(uncertain_matrix_title))\n        self.play(FadeOut(eq_point), FadeOut(eq_label))\n        self.play(FadeOut(circle), FadeOut(uncertainty_label))\n        \n        # Show equation\n        eq = Text(\"p*x(A) + (1-p)*x(B) = C\")\n        \n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Final message\n        final_message = Text(\"Uncertainty broadens strategic possibilities\")\n        \n        self.play(FadeOut(eq))\n        self.play(Write(final_message))\n        self.wait(2)\n        self.play(FadeOut(final_message))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the impact of introducing uncertainty in payoff values on Nash equilibria in mixed strategy games?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animated video that starts with a mathematical equation a^2 + b^2 = c^2 that transforms into the equation a^2 - c^2 = -b^2. I want the animation to be quick, with the transformation clearly showing each term in the equation moving to its new position, ideally in an arc motion, and the entire sequence to take place in just a few seconds. The final equations should briefly appear on the screen and then disappear. Can you do that?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"Integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and the final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"The triple integral value is 1/8\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video that starts with a mathematical equation a^2 + b^2 = c^2 that transforms into the equation a^2 - c^2 = -b^2. I want the animation to be quick, with the transformation clearly showing each term in the equation moving to its new position, ideally in an arc motion, and the entire sequence to take place in just a few seconds. The final equations should briefly appear on the screen and then disappear. Can you do that?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animated video that starts with a mathematical equation a^2 + b^2 = c^2 that transforms into the equation a^2 - c^2 = -b^2. i want the animation to be quick, with the transformation clearly showing each term in the equation moving to its new position, ideally in an arc motion, and the entire sequence to take place in just a few seconds. the final equations should briefly appear on the screen and then disappear. can you do that?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TripleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{1} \\int_{0}^{1} xyz \\,dz\\,dy\\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for innermost integral\n        explanation1 = Text(\"Integrate with respect to z\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Innermost integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} \\int_{0}^{1} [\\frac{1}{2}xyz^2]_{0}^{1} \\,dy\\,dx\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for middle integral\n        explanation2 = Text(\"Now integrate the result with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Middle integral step\n        middle_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{4}xy^2]_{0}^{1} \\,dx\")\n        self.play(ReplacementTransform(inner_integral, middle_integral))\n        self.wait(1)\n\n        # Explanation for outermost integral\n        explanation3 = Text(\"Finally, integrate with respect to x\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Outermost integral step and the final solution\n        final_solution = MathTex(r\"= [\\frac{1}{8}x^2]_{0}^{1}\", r\"= \\frac{1}{8}\")\n        self.play(ReplacementTransform(middle_integral, final_solution))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        conclusion = Text(\"The triple integral value is 1/8\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video that starts with a mathematical equation a^2 + b^2 = c^2 that transforms into the equation a^2 - c^2 = -b^2. I want the animation to be quick, with the transformation clearly showing each term in the equation moving to its new position, ideally in an arc motion, and the entire sequence to take place in just a few seconds. The final equations should briefly appear on the screen and then disappear. Can you do that?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually explains the steps to solve a triple integral using spherical coordinates. Specifically, I want to solve the triple integral of \u03c1^2 sin \u03c6 with respect to \u03c1, then \u03b8, and finally \u03c6, over the ranges of 0 to 1 for \u03c1, 0 to 2\u03c0 for \u03b8, and 0 to \u03c0 for \u03c6. The animation should include the written integral problem, and step-by-step animations showcasing each stage of the integration process, complete with textual explanations guiding through the integration with respect to \u03c1, then \u03b8, then \u03c6, and finally evaluating the integral to find the numerical result. Can you create this animated visualization to help students understand the concept and steps of evaluating triple integrals in spherical coordinates?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MolecularAnimation(Scene):\n    def construct(self):\n        # Create a sequence of objects\n        mol1 = electron()\n        mol2 = metal()\n        mol3 = positive()\n        mol4 = negative()\n        \n        # Position objects on the screen\n        mol_group = VGroup(mol1, mol2, mol3, mol4).arrange(RIGHT, buff=1)\n\n        # Animate the objects\n        self.play(Create(mol_group))\n        self.wait(1)\n\n        # Show them moving to different locations\n        self.play(\n            mol1.animate.shift(UP * 2),\n            mol2.animate.shift(DOWN * 2),\n            mol3.animate.shift(LEFT * 2),\n            mol4.animate.shift(RIGHT * 2),\n        )\n        self.wait(2)\n\n        # Disappear animation\n        self.play(FadeOut(mol_group))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains the steps to solve a triple integral using spherical coordinates. Specifically, I want to solve the triple integral of \u03c1^2 sin \u03c6 with respect to \u03c1, then \u03b8, and finally \u03c6, over the ranges of 0 to 1 for \u03c1, 0 to 2\u03c0 for \u03b8, and 0 to \u03c0 for \u03c6. The animation should include the written integral problem, and step-by-step animations showcasing each stage of the integration process, complete with textual explanations guiding through the integration with respect to \u03c1, then \u03b8, then \u03c6, and finally evaluating the integral to find the numerical result. Can you create this animated visualization to help students understand the concept and steps of evaluating triple integrals in spherical coordinates?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually explains the steps to solve a triple integral using spherical coordinates. specifically, i want to solve the triple integral of \u03c1^2 sin \u03c6 with respect to \u03c1, then \u03b8, and finally \u03c6, over the ranges of 0 to 1 for \u03c1, 0 to 2\u03c0 for \u03b8, and 0 to \u03c0 for \u03c6. the animation should include the written integral problem, and step-by-step animations showcasing each stage of the integration process, complete with textual explanations guiding through the integration with respect to \u03c1, then \u03b8, then \u03c6, and finally evaluating the integral to find the numerical result. can you create this animated visualization to help students understand the concept and steps of evaluating triple integrals in spherical coordinates?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MolecularAnimation(Scene):\n    def construct(self):\n        # Create a sequence of objects\n        mol1 = electron()\n        mol2 = metal()\n        mol3 = positive()\n        mol4 = negative()\n        \n        # Position objects on the screen\n        mol_group = VGroup(mol1, mol2, mol3, mol4).arrange(RIGHT, buff=1)\n\n        # Animate the objects\n        self.play(Create(mol_group))\n        self.wait(1)\n\n        # Show them moving to different locations\n        self.play(\n            mol1.animate.shift(UP * 2),\n            mol2.animate.shift(DOWN * 2),\n            mol3.animate.shift(LEFT * 2),\n            mol4.animate.shift(RIGHT * 2),\n        )\n        self.wait(2)\n\n        # Disappear animation\n        self.play(FadeOut(mol_group))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually explains the steps to solve a triple integral using spherical coordinates. Specifically, I want to solve the triple integral of \u03c1^2 sin \u03c6 with respect to \u03c1, then \u03b8, and finally \u03c6, over the ranges of 0 to 1 for \u03c1, 0 to 2\u03c0 for \u03b8, and 0 to \u03c0 for \u03c6. The animation should include the written integral problem, and step-by-step animations showcasing each stage of the integration process, complete with textual explanations guiding through the integration with respect to \u03c1, then \u03b8, then \u03c6, and finally evaluating the integral to find the numerical result. Can you create this animated visualization to help students understand the concept and steps of evaluating triple integrals in spherical coordinates?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can different Finsler metrics on a two-dimensional surface alter the typical geodesic paths compared to Riemannian metrics?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FinslerGeodesics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Curved Adventures: Discovering Finsler Geodesics\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"How do different metrics change geodesic paths?\", font_size=22)\n        self.play(Write(intro_text))\n        self.wait(2)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple surface\n        surface = Rectangle(height=4, width=6, color=BLUE).set_fill(BLUE_E, opacity=0.3)\n        \n        # Simple grid lines\n        h_lines = VGroup()\n        for i in range(-2, 3):\n            line = Line(LEFT*3, RIGHT*3, stroke_opacity=0.5)\n            line.shift(UP*i)\n            h_lines.add(line)\n            \n        v_lines = VGroup()\n        for i in range(-3, 4):\n            line = Line(UP*2, DOWN*2, stroke_opacity=0.5)\n            line.shift(RIGHT*i)\n            v_lines.add(line)\n        \n        grid = VGroup(h_lines, v_lines)\n        \n        self.play(Create(surface))\n        self.play(Create(grid))\n        \n        # Create a simple ant (dot)\n        ant = Dot(color=BLACK).scale(1.5)\n        start_point = np.array([-2.5, 1.5, 0])\n        end_point = np.array([2.5, -1.5, 0])\n        ant.move_to(start_point)\n        \n        self.play(FadeIn(ant))\n        \n        # Riemannian geodesics\n        text1 = Text(\"Riemannian Geodesics\", font_size=22, color=YELLOW)\n        text1.next_to(surface, UP)\n        self.play(Write(text1))\n        \n        # Straight path\n        straight_path = Line(start_point, end_point, color=YELLOW)\n        self.play(Create(straight_path))\n        \n        # Move ant along straight path\n        self.play(ant.animate.move_to(end_point), run_time=2)\n        \n        # Equation\n        eq1 = Text(\"ds\u00b2 = g_ij dx^i dx^j\", font_size=20)\n        eq1.next_to(surface, DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Reset ant\n        self.play(\n            ant.animate.move_to(start_point),\n            FadeOut(text1),\n            FadeOut(straight_path),\n            FadeOut(eq1)\n        )\n        \n        # Finsler geodesics\n        text2 = Text(\"Finsler Geodesics\", font_size=22, color=RED)\n        text2.next_to(surface, UP)\n        self.play(Write(text2))\n        \n        # For the curved path, use a simple arc-like shape\n        midpoint = np.array([0, 1, 0])  # A point above the direct line\n        \n        # Create simple polyline to simulate curve\n        curved_path = VMobject()\n        curved_path.set_points_as_corners([start_point, midpoint, end_point])\n        curved_path.set_color(RED)\n        \n        self.play(Create(curved_path))\n        \n        # Move ant along this path (via the midpoint)\n        self.play(ant.animate.move_to(midpoint), run_time=1)\n        self.play(ant.animate.move_to(end_point), run_time=1)\n        \n        # Equation\n        eq2 = Text(\"F(x,dx) = sqrt(g_ij dx^i dx^j) + direction\", font_size=18)\n        eq2.next_to(surface, DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Key insight\n        self.play(\n            FadeOut(surface),\n            FadeOut(grid),\n            FadeOut(ant),\n            FadeOut(curved_path),\n            FadeOut(text2),\n            FadeOut(eq2)\n        )\n        \n        insight = Text(\"In Finsler geometry, the 'straightest' path\\ndepends on direction!\", font_size=24)\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"Discovering new geometry through\\ndifferent ways of measuring distance\", font_size=22)\n        self.play(Transform(insight, conclusion))\n        self.wait(2)\n        \n        # Final title\n        self.play(\n            FadeOut(insight),\n            title.animate.center()\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can different Finsler metrics on a two-dimensional surface alter the typical geodesic paths compared to Riemannian metrics?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can different finsler metrics on a two-dimensional surface alter the typical geodesic paths compared to riemannian metrics?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FinslerGeodesics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Curved Adventures: Discovering Finsler Geodesics\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"How do different metrics change geodesic paths?\", font_size=22)\n        self.play(Write(intro_text))\n        self.wait(2)\n        self.play(FadeOut(intro_text))\n        \n        # Create a simple surface\n        surface = Rectangle(height=4, width=6, color=BLUE).set_fill(BLUE_E, opacity=0.3)\n        \n        # Simple grid lines\n        h_lines = VGroup()\n        for i in range(-2, 3):\n            line = Line(LEFT*3, RIGHT*3, stroke_opacity=0.5)\n            line.shift(UP*i)\n            h_lines.add(line)\n            \n        v_lines = VGroup()\n        for i in range(-3, 4):\n            line = Line(UP*2, DOWN*2, stroke_opacity=0.5)\n            line.shift(RIGHT*i)\n            v_lines.add(line)\n        \n        grid = VGroup(h_lines, v_lines)\n        \n        self.play(Create(surface))\n        self.play(Create(grid))\n        \n        # Create a simple ant (dot)\n        ant = Dot(color=BLACK).scale(1.5)\n        start_point = np.array([-2.5, 1.5, 0])\n        end_point = np.array([2.5, -1.5, 0])\n        ant.move_to(start_point)\n        \n        self.play(FadeIn(ant))\n        \n        # Riemannian geodesics\n        text1 = Text(\"Riemannian Geodesics\", font_size=22, color=YELLOW)\n        text1.next_to(surface, UP)\n        self.play(Write(text1))\n        \n        # Straight path\n        straight_path = Line(start_point, end_point, color=YELLOW)\n        self.play(Create(straight_path))\n        \n        # Move ant along straight path\n        self.play(ant.animate.move_to(end_point), run_time=2)\n        \n        # Equation\n        eq1 = Text(\"ds\u00b2 = g_ij dx^i dx^j\", font_size=20)\n        eq1.next_to(surface, DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Reset ant\n        self.play(\n            ant.animate.move_to(start_point),\n            FadeOut(text1),\n            FadeOut(straight_path),\n            FadeOut(eq1)\n        )\n        \n        # Finsler geodesics\n        text2 = Text(\"Finsler Geodesics\", font_size=22, color=RED)\n        text2.next_to(surface, UP)\n        self.play(Write(text2))\n        \n        # For the curved path, use a simple arc-like shape\n        midpoint = np.array([0, 1, 0])  # A point above the direct line\n        \n        # Create simple polyline to simulate curve\n        curved_path = VMobject()\n        curved_path.set_points_as_corners([start_point, midpoint, end_point])\n        curved_path.set_color(RED)\n        \n        self.play(Create(curved_path))\n        \n        # Move ant along this path (via the midpoint)\n        self.play(ant.animate.move_to(midpoint), run_time=1)\n        self.play(ant.animate.move_to(end_point), run_time=1)\n        \n        # Equation\n        eq2 = Text(\"F(x,dx) = sqrt(g_ij dx^i dx^j) + direction\", font_size=18)\n        eq2.next_to(surface, DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Key insight\n        self.play(\n            FadeOut(surface),\n            FadeOut(grid),\n            FadeOut(ant),\n            FadeOut(curved_path),\n            FadeOut(text2),\n            FadeOut(eq2)\n        )\n        \n        insight = Text(\"In Finsler geometry, the 'straightest' path\\ndepends on direction!\", font_size=24)\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Conclusion\n        conclusion = Text(\"Discovering new geometry through\\ndifferent ways of measuring distance\", font_size=22)\n        self.play(Transform(insight, conclusion))\n        self.wait(2)\n        \n        # Final title\n        self.play(\n            FadeOut(insight),\n            title.animate.center()\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can different Finsler metrics on a two-dimensional surface alter the typical geodesic paths compared to Riemannian metrics?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I want to create an animation of a blue square that wiggles as if it's being jostled or shaken. The square should expand a bit and rotate slightly while it wiggles. The whole animation should take about 2 seconds to complete. How could I do that using an animation software?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_physics import *\n\n\nclass MagneticFieldExample(ThreeDScene):\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(wire)\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I want to create an animation of a blue square that wiggles as if it's being jostled or shaken. The square should expand a bit and rotate slightly while it wiggles. The whole animation should take about 2 seconds to complete. How could I do that using an animation software?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i want to create an animation of a blue square that wiggles as if it's being jostled or shaken. the square should expand a bit and rotate slightly while it wiggles. the whole animation should take about 2 seconds to complete. how could i do that using an animation software?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_physics import *\n\n\nclass MagneticFieldExample(ThreeDScene):\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(wire)\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I want to create an animation of a blue square that wiggles as if it's being jostled or shaken. The square should expand a bit and rotate slightly while it wiggles. The whole animation should take about 2 seconds to complete. How could I do that using an animation software?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what way do stable and unstable manifolds guide the trajectory behavior in a non-linear dynamical system, like the pendulum, as energy levels shift?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PendulumManifolds(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating the Dance of Stability: Pendulum and Manifolds\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Basic pendulum visualization\n        pendulum_origin = Dot(UP * 2)\n        pendulum_bob = Dot(DOWN * 2)\n        pendulum_string = Line(pendulum_origin.get_center(), pendulum_bob.get_center())\n        pendulum = VGroup(pendulum_origin, pendulum_string, pendulum_bob)\n        \n        pendulum_label = Text(\"Low Energy Pendulum\", font_size=20).next_to(pendulum, DOWN)\n        self.play(Create(pendulum), Write(pendulum_label))\n        self.wait(1)\n        \n        # Basic equation\n        eq1 = MathTex(r\"\\dot{\\theta} = -\\frac{g}{l} \\sin(\\theta)\")\n        self.play(Write(eq1.next_to(pendulum, RIGHT)))\n        self.wait(1)\n        \n        # Second equation\n        eq2 = MathTex(r\"\\frac{d\\theta}{dt} = f(\\theta, E)\")\n        self.play(Transform(eq1, eq2.next_to(pendulum, RIGHT)))\n        self.wait(1)\n        \n        # Clear screen for phase space\n        self.play(FadeOut(pendulum), FadeOut(pendulum_label), FadeOut(eq1))\n        \n        # Phase space setup\n        phase_title = Text(\"Phase Space\", font_size=24)\n        self.play(Write(phase_title.next_to(title, DOWN)))\n        \n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            x_length=6,\n            y_length=6,\n        )\n        \n        x_label = Text(\"\u03b8\", font_size=20).next_to(axes.x_axis, RIGHT)\n        y_label = Text(\"\u03c9\", font_size=20).next_to(axes.y_axis, UP)\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        \n        # Fixed point\n        fixed_point = Dot(axes.c2p(0, 0), color=YELLOW)\n        fixed_label = Text(\"Fixed Point\", font_size=20, color=YELLOW).next_to(fixed_point, DOWN)\n        \n        self.play(Create(fixed_point), Write(fixed_label))\n        \n        # Stable manifold - simplified as a line\n        stable_line = Line(axes.c2p(-2, -2), axes.c2p(2, 2), color=BLUE)\n        stable_label = Text(\"Stable Manifold\", font_size=20, color=BLUE).next_to(stable_line, UP+LEFT)\n        \n        self.play(Create(stable_line), Write(stable_label))\n        \n        # Unstable manifold - simplified as a line\n        unstable_line = Line(axes.c2p(-2, 2), axes.c2p(2, -2), color=RED)\n        unstable_label = Text(\"Unstable Manifold\", font_size=20, color=RED).next_to(unstable_line, UP+RIGHT)\n        \n        self.play(Create(unstable_line), Write(unstable_label))\n        \n        # Low energy trajectory\n        low_energy = Circle(radius=1, color=GREEN).move_to(axes.c2p(0, 0))\n        low_label = Text(\"Low Energy\", font_size=20, color=GREEN).to_edge(RIGHT)\n        \n        self.play(Create(low_energy), Write(low_label))\n        self.wait(1)\n        \n        # Show trajectory following stable manifold\n        stable_arrow = Arrow(axes.c2p(1.5, 1.3), axes.c2p(1, 1), color=BLUE)\n        self.play(Create(stable_arrow))\n        stable_dot = Dot(axes.c2p(1.5, 1.3), color=GREEN)\n        self.play(Create(stable_dot))\n        self.play(stable_dot.animate.move_to(axes.c2p(1, 1)))\n        self.play(stable_dot.animate.move_to(axes.c2p(0.5, 0.5)))\n        self.play(stable_dot.animate.move_to(axes.c2p(0, 0)))\n        self.wait(1)\n        \n        # High energy trajectory\n        high_energy = Circle(radius=2, color=ORANGE).move_to(axes.c2p(0, 0))\n        high_label = Text(\"High Energy\", font_size=20, color=ORANGE).next_to(low_label, DOWN)\n        \n        self.play(Create(high_energy), Write(high_label))\n        \n        # Show trajectory following unstable manifold\n        unstable_arrow = Arrow(axes.c2p(-0.5, 0.5), axes.c2p(-1, 1), color=RED)\n        self.play(Create(unstable_arrow))\n        unstable_dot = Dot(axes.c2p(-0.5, 0.5), color=ORANGE)\n        self.play(Create(unstable_dot))\n        self.play(unstable_dot.animate.move_to(axes.c2p(-1, 1)))\n        self.play(unstable_dot.animate.move_to(axes.c2p(-1.5, 1.5)))\n        self.play(unstable_dot.animate.move_to(axes.c2p(-2, 2)))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Manifolds guide trajectories as energy levels change\", font_size=24)\n        \n        self.play(\n            FadeOut(axes), FadeOut(x_label), FadeOut(y_label),\n            FadeOut(fixed_point), FadeOut(fixed_label),\n            FadeOut(stable_line), FadeOut(stable_label),\n            FadeOut(unstable_line), FadeOut(unstable_label),\n            FadeOut(low_energy), FadeOut(low_label),\n            FadeOut(high_energy), FadeOut(high_label),\n            FadeOut(stable_arrow), FadeOut(stable_dot),\n            FadeOut(unstable_arrow), FadeOut(unstable_dot),\n            FadeOut(phase_title), FadeOut(title)\n        )\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way do stable and unstable manifolds guide the trajectory behavior in a non-linear dynamical system, like the pendulum, as energy levels shift?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what way do stable and unstable manifolds guide the trajectory behavior in a non-linear dynamical system, like the pendulum, as energy levels shift?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PendulumManifolds(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating the Dance of Stability: Pendulum and Manifolds\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Basic pendulum visualization\n        pendulum_origin = Dot(UP * 2)\n        pendulum_bob = Dot(DOWN * 2)\n        pendulum_string = Line(pendulum_origin.get_center(), pendulum_bob.get_center())\n        pendulum = VGroup(pendulum_origin, pendulum_string, pendulum_bob)\n        \n        pendulum_label = Text(\"Low Energy Pendulum\", font_size=20).next_to(pendulum, DOWN)\n        self.play(Create(pendulum), Write(pendulum_label))\n        self.wait(1)\n        \n        # Basic equation\n        eq1 = MathTex(r\"\\dot{\\theta} = -\\frac{g}{l} \\sin(\\theta)\")\n        self.play(Write(eq1.next_to(pendulum, RIGHT)))\n        self.wait(1)\n        \n        # Second equation\n        eq2 = MathTex(r\"\\frac{d\\theta}{dt} = f(\\theta, E)\")\n        self.play(Transform(eq1, eq2.next_to(pendulum, RIGHT)))\n        self.wait(1)\n        \n        # Clear screen for phase space\n        self.play(FadeOut(pendulum), FadeOut(pendulum_label), FadeOut(eq1))\n        \n        # Phase space setup\n        phase_title = Text(\"Phase Space\", font_size=24)\n        self.play(Write(phase_title.next_to(title, DOWN)))\n        \n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            x_length=6,\n            y_length=6,\n        )\n        \n        x_label = Text(\"\u03b8\", font_size=20).next_to(axes.x_axis, RIGHT)\n        y_label = Text(\"\u03c9\", font_size=20).next_to(axes.y_axis, UP)\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        \n        # Fixed point\n        fixed_point = Dot(axes.c2p(0, 0), color=YELLOW)\n        fixed_label = Text(\"Fixed Point\", font_size=20, color=YELLOW).next_to(fixed_point, DOWN)\n        \n        self.play(Create(fixed_point), Write(fixed_label))\n        \n        # Stable manifold - simplified as a line\n        stable_line = Line(axes.c2p(-2, -2), axes.c2p(2, 2), color=BLUE)\n        stable_label = Text(\"Stable Manifold\", font_size=20, color=BLUE).next_to(stable_line, UP+LEFT)\n        \n        self.play(Create(stable_line), Write(stable_label))\n        \n        # Unstable manifold - simplified as a line\n        unstable_line = Line(axes.c2p(-2, 2), axes.c2p(2, -2), color=RED)\n        unstable_label = Text(\"Unstable Manifold\", font_size=20, color=RED).next_to(unstable_line, UP+RIGHT)\n        \n        self.play(Create(unstable_line), Write(unstable_label))\n        \n        # Low energy trajectory\n        low_energy = Circle(radius=1, color=GREEN).move_to(axes.c2p(0, 0))\n        low_label = Text(\"Low Energy\", font_size=20, color=GREEN).to_edge(RIGHT)\n        \n        self.play(Create(low_energy), Write(low_label))\n        self.wait(1)\n        \n        # Show trajectory following stable manifold\n        stable_arrow = Arrow(axes.c2p(1.5, 1.3), axes.c2p(1, 1), color=BLUE)\n        self.play(Create(stable_arrow))\n        stable_dot = Dot(axes.c2p(1.5, 1.3), color=GREEN)\n        self.play(Create(stable_dot))\n        self.play(stable_dot.animate.move_to(axes.c2p(1, 1)))\n        self.play(stable_dot.animate.move_to(axes.c2p(0.5, 0.5)))\n        self.play(stable_dot.animate.move_to(axes.c2p(0, 0)))\n        self.wait(1)\n        \n        # High energy trajectory\n        high_energy = Circle(radius=2, color=ORANGE).move_to(axes.c2p(0, 0))\n        high_label = Text(\"High Energy\", font_size=20, color=ORANGE).next_to(low_label, DOWN)\n        \n        self.play(Create(high_energy), Write(high_label))\n        \n        # Show trajectory following unstable manifold\n        unstable_arrow = Arrow(axes.c2p(-0.5, 0.5), axes.c2p(-1, 1), color=RED)\n        self.play(Create(unstable_arrow))\n        unstable_dot = Dot(axes.c2p(-0.5, 0.5), color=ORANGE)\n        self.play(Create(unstable_dot))\n        self.play(unstable_dot.animate.move_to(axes.c2p(-1, 1)))\n        self.play(unstable_dot.animate.move_to(axes.c2p(-1.5, 1.5)))\n        self.play(unstable_dot.animate.move_to(axes.c2p(-2, 2)))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Manifolds guide trajectories as energy levels change\", font_size=24)\n        \n        self.play(\n            FadeOut(axes), FadeOut(x_label), FadeOut(y_label),\n            FadeOut(fixed_point), FadeOut(fixed_label),\n            FadeOut(stable_line), FadeOut(stable_label),\n            FadeOut(unstable_line), FadeOut(unstable_label),\n            FadeOut(low_energy), FadeOut(low_label),\n            FadeOut(high_energy), FadeOut(high_label),\n            FadeOut(stable_arrow), FadeOut(stable_dot),\n            FadeOut(unstable_arrow), FadeOut(unstable_dot),\n            FadeOut(phase_title), FadeOut(title)\n        )\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what way do stable and unstable manifolds guide the trajectory behavior in a non-linear dynamical system, like the pendulum, as energy levels shift?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Please create an educational animation that explains the process of evaluating a basic definite integral in calculus. Start by showing the integral of x cubed from 0 to 2. Then, demonstrate step by step how to apply the power rule of integration. After that, show how to evaluate the integral from the lower limit to the upper limit, finishing by calculating the specific values at the bounds. Conclude by simplifying the results to display the final numerical answer. Include textual explanations for each step and ensure that the transition between each part of the solution is clear and easy to follow."}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingTwoSteps(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{4}{8}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{1}{2}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{5}{10}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=2)\n        arrow_up_1 = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_1 = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_up_1.scale(0.7)\n        text_up_1.next_to(arrow_up_1, UP)\n        text_down_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_down_1.scale(0.7)\n        text_down_1.next_to(arrow_down_1, DOWN)\n        equal_1 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_1.shift(1.5 * LEFT)\n        equal_1.scale(2)\n        arrow_up_2 = ArcBetweenPoints(\n            fractions[1].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[2].get_top() + 0.2 * UP, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_2 = ArcBetweenPoints(\n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[2].get_bottom() + 0.2 * DOWN, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_up_2.scale(0.7)\n        text_up_2.next_to(arrow_up_2, UP, buff=0.2)\n        text_down_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_down_2.scale(0.7)\n        text_down_2.next_to(arrow_down_2, DOWN, buff=0.2)\n        equal_2 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_2.shift(1.1 * RIGHT)\n        equal_2.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up_1),\n            Write(text_up_1, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_1),\n            Write(text_down_1, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_1), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_1), \n            FadeOut(arrow_down_1), \n            FadeOut(text_up_1), \n            FadeOut(text_down_1), \n            run_time=0.7\n        )\n        self.play(\n            Write(arrow_up_2),\n            Write(text_up_2, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_2),\n            Write(text_down_2, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_2), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_2), \n            FadeOut(arrow_down_2), \n            FadeOut(text_up_2), \n            FadeOut(text_down_2), \n            run_time=0.7\n        )\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an educational animation that explains the process of evaluating a basic definite integral in calculus. Start by showing the integral of x cubed from 0 to 2. Then, demonstrate step by step how to apply the power rule of integration. After that, show how to evaluate the integral from the lower limit to the upper limit, finishing by calculating the specific values at the bounds. Conclude by simplifying the results to display the final numerical answer. Include textual explanations for each step and ensure that the transition between each part of the solution is clear and easy to follow."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that please create an educational animation that explains the process of evaluating a basic definite integral in calculus. start by showing the integral of x cubed from 0 to 2. then, demonstrate step by step how to apply the power rule of integration. after that, show how to evaluate the integral from the lower limit to the upper limit, finishing by calculating the specific values at the bounds. conclude by simplifying the results to display the final numerical answer. include textual explanations for each step and ensure that the transition between each part of the solution is clear and easy to follow."}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass MultiplyingTwoSteps(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        fractions = VGroup(\n            MathTex(r\"\\frac{4}{8}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{1}{2}\", color=TEXT_COLOR).scale(2),\n            MathTex(r\"\\frac{5}{10}\", color=TEXT_COLOR).scale(2)\n        ).arrange(RIGHT, buff=2)\n        arrow_up_1 = ArcBetweenPoints(\n            fractions[0].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[1].get_top() + 0.2 * UP + 0.1 * LEFT, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_1 = ArcBetweenPoints(\n            fractions[0].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * LEFT, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_up_1.scale(0.7)\n        text_up_1.next_to(arrow_up_1, UP)\n        text_down_1 = Tex(r\"Dividido por 4\", color=LIGHT_BLUE_COLOR)\n        text_down_1.scale(0.7)\n        text_down_1.next_to(arrow_down_1, DOWN)\n        equal_1 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_1.shift(1.5 * LEFT)\n        equal_1.scale(2)\n        arrow_up_2 = ArcBetweenPoints(\n            fractions[1].get_top() + 0.2 * UP + 0.1 * RIGHT, \n            fractions[2].get_top() + 0.2 * UP, \n            angle=-TAU / 4, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        arrow_down_2 = ArcBetweenPoints(\n            fractions[1].get_bottom() + 0.2 * DOWN + 0.1 * RIGHT, \n            fractions[2].get_bottom() + 0.2 * DOWN, \n            color=LIGHT_BLUE_COLOR\n        ).add_tip()\n        text_up_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_up_2.scale(0.7)\n        text_up_2.next_to(arrow_up_2, UP, buff=0.2)\n        text_down_2 = Tex(r\"Multiplicado por 5\", color=LIGHT_BLUE_COLOR)\n        text_down_2.scale(0.7)\n        text_down_2.next_to(arrow_down_2, DOWN, buff=0.2)\n        equal_2 = MathTex(r\"=\", color=LIGHT_BLUE_COLOR)\n        equal_2.shift(1.1 * RIGHT)\n        equal_2.scale(2)\n\n        self.play(Write(fractions), run_time=0.5)\n        self.play(\n            Write(arrow_up_1),\n            Write(text_up_1, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_1),\n            Write(text_down_1, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_1), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_1), \n            FadeOut(arrow_down_1), \n            FadeOut(text_up_1), \n            FadeOut(text_down_1), \n            run_time=0.7\n        )\n        self.play(\n            Write(arrow_up_2),\n            Write(text_up_2, run_time=0.7)\n        )\n        self.wait(0.5)\n        self.play(\n            Write(arrow_down_2),\n            Write(text_down_2, run_time=0.7)\n        )\n        self.wait(1)\n        self.play(Write(equal_2), run_time=0.5)\n        self.wait(0.5)\n        self.play(\n            FadeOut(arrow_up_2), \n            FadeOut(arrow_down_2), \n            FadeOut(text_up_2), \n            FadeOut(text_down_2), \n            run_time=0.7\n        )\n        self.wait(1)\n        self.play(FadeOut(Group(*self.mobjects)), run_time=0.7)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Please create an educational animation that explains the process of evaluating a basic definite integral in calculus. Start by showing the integral of x cubed from 0 to 2. Then, demonstrate step by step how to apply the power rule of integration. After that, show how to evaluate the integral from the lower limit to the upper limit, finishing by calculating the specific values at the bounds. Conclude by simplifying the results to display the final numerical answer. Include textual explanations for each step and ensure that the transition between each part of the solution is clear and easy to follow."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does Alexander Duality relate the dimensions of cycles and boundaries in the complement of a non-trivial knot to those within the knot itself?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AlexanderDualityScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Tying the Knots of Understanding: Unveiling Alexander Duality\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create a simple knot representation (just a circle for simplicity)\n        knot = Circle(radius=1, color=BLUE)\n        knot_label = Text(\"Knot (K)\", font_size=24).next_to(knot, DOWN)\n        \n        self.play(Create(knot))\n        self.play(Write(knot_label))\n        self.wait(1)\n        \n        # Represent the ambient space (S\u00b3) and complement\n        ambient_space = Circle(radius=2.5, color=GRAY, fill_opacity=0.1)\n        complement_label = Text(\"Complement (S\u00b3-K)\", font_size=24).next_to(ambient_space, UP)\n        \n        self.play(Create(ambient_space))\n        self.play(Write(complement_label))\n        self.wait(1)\n        \n        # Show a cycle in the knot\n        cycle = Circle(radius=0.5, color=RED).move_to(knot.get_center())\n        cycle_label = Text(\"Cycle in K\", font_size=24, color=RED).next_to(cycle, LEFT)\n        \n        self.play(Create(cycle))\n        self.play(Write(cycle_label))\n        self.wait(1)\n        \n        # Show corresponding boundary in the complement\n        boundary = DashedVMobject(Circle(radius=1.75, color=GREEN))\n        boundary_label = Text(\"Boundary in S\u00b3-K\", font_size=24, color=GREEN).next_to(boundary, RIGHT)\n        \n        self.play(Create(boundary))\n        self.play(Write(boundary_label))\n        self.wait(1)\n        \n        # Illustrate duality\n        arrow = Arrow(cycle.get_center(), boundary.get_center(), color=YELLOW)\n        duality_text = Text(\"Alexander Duality\", font_size=28, color=YELLOW).next_to(arrow, UP)\n        \n        self.play(Create(arrow))\n        self.play(Write(duality_text))\n        self.wait(2)\n        \n        # Clear for equation\n        self.play(\n            FadeOut(knot),\n            FadeOut(knot_label),\n            FadeOut(ambient_space),\n            FadeOut(complement_label),\n            FadeOut(cycle),\n            FadeOut(cycle_label),\n            FadeOut(boundary),\n            FadeOut(boundary_label),\n            FadeOut(arrow),\n            FadeOut(duality_text)\n        )\n        \n        # Show Alexander Duality equation\n        equation = MathTex(\"H_k(K) \\\\cong H^{n-k-1}(S^3-K)\")\n        \n        self.play(Write(equation))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(equation))\n        conclusion = Text(\"In topology, Alexander Duality relates\\ncycles in a knot to boundaries in its complement\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Alexander Duality relate the dimensions of cycles and boundaries in the complement of a non-trivial knot to those within the knot itself?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does alexander duality relate the dimensions of cycles and boundaries in the complement of a non-trivial knot to those within the knot itself?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AlexanderDualityScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Tying the Knots of Understanding: Unveiling Alexander Duality\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Create a simple knot representation (just a circle for simplicity)\n        knot = Circle(radius=1, color=BLUE)\n        knot_label = Text(\"Knot (K)\", font_size=24).next_to(knot, DOWN)\n        \n        self.play(Create(knot))\n        self.play(Write(knot_label))\n        self.wait(1)\n        \n        # Represent the ambient space (S\u00b3) and complement\n        ambient_space = Circle(radius=2.5, color=GRAY, fill_opacity=0.1)\n        complement_label = Text(\"Complement (S\u00b3-K)\", font_size=24).next_to(ambient_space, UP)\n        \n        self.play(Create(ambient_space))\n        self.play(Write(complement_label))\n        self.wait(1)\n        \n        # Show a cycle in the knot\n        cycle = Circle(radius=0.5, color=RED).move_to(knot.get_center())\n        cycle_label = Text(\"Cycle in K\", font_size=24, color=RED).next_to(cycle, LEFT)\n        \n        self.play(Create(cycle))\n        self.play(Write(cycle_label))\n        self.wait(1)\n        \n        # Show corresponding boundary in the complement\n        boundary = DashedVMobject(Circle(radius=1.75, color=GREEN))\n        boundary_label = Text(\"Boundary in S\u00b3-K\", font_size=24, color=GREEN).next_to(boundary, RIGHT)\n        \n        self.play(Create(boundary))\n        self.play(Write(boundary_label))\n        self.wait(1)\n        \n        # Illustrate duality\n        arrow = Arrow(cycle.get_center(), boundary.get_center(), color=YELLOW)\n        duality_text = Text(\"Alexander Duality\", font_size=28, color=YELLOW).next_to(arrow, UP)\n        \n        self.play(Create(arrow))\n        self.play(Write(duality_text))\n        self.wait(2)\n        \n        # Clear for equation\n        self.play(\n            FadeOut(knot),\n            FadeOut(knot_label),\n            FadeOut(ambient_space),\n            FadeOut(complement_label),\n            FadeOut(cycle),\n            FadeOut(cycle_label),\n            FadeOut(boundary),\n            FadeOut(boundary_label),\n            FadeOut(arrow),\n            FadeOut(duality_text)\n        )\n        \n        # Show Alexander Duality equation\n        equation = MathTex(\"H_k(K) \\\\cong H^{n-k-1}(S^3-K)\")\n        \n        self.play(Write(equation))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(equation))\n        conclusion = Text(\"In topology, Alexander Duality relates\\ncycles in a knot to boundaries in its complement\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does Alexander Duality relate the dimensions of cycles and boundaries in the complement of a non-trivial knot to those within the knot itself?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation that shows a ball rolling down an inclined plane. The plane should be visibly tilted and colored blue, while the ball should be red. Can you make the animation reflect the effect of gravity on the ball's acceleration as it rolls down? The whole action should take around 2 seconds, followed by a brief pause before the animation ends."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nMOON_ORBIT_RADIUS = 2\nMOON_RATE = 0.1\nMOON_SIZE = 0.2\nMOON_COLOR = WHITE\nEARTH_SIZE = 0.4\nEARTH_COLOR = BLUE\nSUN_SIZE = 0.8\nSUN_COLOR = YELLOW\nANIMATION_TIME = 50\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Sun\n        sun = Dot(radius=SUN_SIZE, color=SUN_COLOR).move_to(ORIGIN)\n        self.add(sun)\n\n        # Earth orbit (invisible)\n        earth_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        self.add(earth_orbit)\n\n        # Earth\n        earth = Dot(radius=EARTH_SIZE, color=EARTH_COLOR)\n        earth.move_to(earth_orbit.point_from_proportion(0))\n        self.add(earth)\n\n        # Moon orbit (invisible, relative to Earth)\n        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        moon_orbit.move_to(earth.get_center())\n        self.add(moon_orbit)\n\n        # Moon\n        moon = Dot(radius=MOON_SIZE, color=MOON_COLOR)\n        moon.move_to(moon_orbit.point_from_proportion(0))\n        self.add(moon)\n\n        # Set up the ValueTracker for the moon's orbit\n        moon_phase = ValueTracker(0)\n\n        def update_moon(mob, dt):\n            phase = moon_phase.get_value()\n            new_phase = (phase + MOON_RATE * dt) % 1\n            mob.move_to(moon_orbit.point_from_proportion(new_phase))\n            moon_phase.set_value(new_phase)\n\n        # Add the update function to the moon\n        moon.add_updater(update_moon)\n\n        # Animate the system\n        self.play(moon_phase.set_value, 1, run_time=ANIMATION_TIME, rate_func=linear)\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that shows a ball rolling down an inclined plane. The plane should be visibly tilted and colored blue, while the ball should be red. Can you make the animation reflect the effect of gravity on the ball's acceleration as it rolls down? The whole action should take around 2 seconds, followed by a brief pause before the animation ends."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation that shows a ball rolling down an inclined plane. the plane should be visibly tilted and colored blue, while the ball should be red. can you make the animation reflect the effect of gravity on the ball's acceleration as it rolls down? the whole action should take around 2 seconds, followed by a brief pause before the animation ends."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nMOON_ORBIT_RADIUS = 2\nMOON_RATE = 0.1\nMOON_SIZE = 0.2\nMOON_COLOR = WHITE\nEARTH_SIZE = 0.4\nEARTH_COLOR = BLUE\nSUN_SIZE = 0.8\nSUN_COLOR = YELLOW\nANIMATION_TIME = 50\n\nclass MoonOrbitScene(MovingCameraScene):\n    def construct(self):\n        # Sun\n        sun = Dot(radius=SUN_SIZE, color=SUN_COLOR).move_to(ORIGIN)\n        self.add(sun)\n\n        # Earth orbit (invisible)\n        earth_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        self.add(earth_orbit)\n\n        # Earth\n        earth = Dot(radius=EARTH_SIZE, color=EARTH_COLOR)\n        earth.move_to(earth_orbit.point_from_proportion(0))\n        self.add(earth)\n\n        # Moon orbit (invisible, relative to Earth)\n        moon_orbit = Circle(radius=MOON_ORBIT_RADIUS, stroke_opacity=0)\n        moon_orbit.move_to(earth.get_center())\n        self.add(moon_orbit)\n\n        # Moon\n        moon = Dot(radius=MOON_SIZE, color=MOON_COLOR)\n        moon.move_to(moon_orbit.point_from_proportion(0))\n        self.add(moon)\n\n        # Set up the ValueTracker for the moon's orbit\n        moon_phase = ValueTracker(0)\n\n        def update_moon(mob, dt):\n            phase = moon_phase.get_value()\n            new_phase = (phase + MOON_RATE * dt) % 1\n            mob.move_to(moon_orbit.point_from_proportion(new_phase))\n            moon_phase.set_value(new_phase)\n\n        # Add the update function to the moon\n        moon.add_updater(update_moon)\n\n        # Animate the system\n        self.play(moon_phase.set_value, 1, run_time=ANIMATION_TIME, rate_func=linear)\n        self.wait()\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that shows a ball rolling down an inclined plane. The plane should be visibly tilted and colored blue, while the ball should be red. Can you make the animation reflect the effect of gravity on the ball's acceleration as it rolls down? The whole action should take around 2 seconds, followed by a brief pause before the animation ends."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the Pythagorean identity \\( x^2 + y^2 = z^2 \\) in large font, rendered using a French cursive LaTeX math font style."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LaTeXMathFonts(Scene):\n    def construct(self):\n        tex = Tex(\n            r\"$x^2 + y^2 = z^2$\",\n            tex_template=TexFontTemplates.french_cursive,\n            font_size=144,\n        )\n        self.add(tex)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the Pythagorean identity \\( x^2 + y^2 = z^2 \\) in large font, rendered using a French cursive LaTeX math font style."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the pythagorean identity \\( x^2 + y^2 = z^2 \\) in large font, rendered using a french cursive latex math font style."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LaTeXMathFonts(Scene):\n    def construct(self):\n        tex = Tex(\n            r\"$x^2 + y^2 = z^2$\",\n            tex_template=TexFontTemplates.french_cursive,\n            font_size=144,\n        )\n        self.add(tex)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the Pythagorean identity \\( x^2 + y^2 = z^2 \\) in large font, rendered using a French cursive LaTeX math font style."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the bifurcation diagram of the logistic map illustrate the transition from order to chaos?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass LogisticMapScene(Scene):\n    def construct(self):\n        # Introduction with title\n        title = Text(\"Chaos in Motion: The Beauty of the Logistic Map\", font_size=32)\n        title.to_edge(UP)\n        self.play(FadeIn(title))\n        self.wait(1)\n        \n        # Display the logistic map equation\n        equation = MathTex(r\"x_{n+1} = rx_n(1-x_n)\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation to upper corner\n        self.play(equation.animate.scale(0.8).to_corner(UL))\n        self.wait(0.5)\n        \n        # Create axes for the bifurcation diagram\n        axes = Axes(\n            x_range=[2.5, 4.0, 0.5],\n            y_range=[0, 1, 0.2],\n            x_length=6,\n            y_length=3,\n            axis_config={\"include_tip\": False},\n        )\n        \n        # Add axis labels\n        x_label = Text(\"r\", font_size=24).next_to(axes.x_axis, DOWN)\n        y_label = Text(\"x\", font_size=24).next_to(axes.y_axis, LEFT)\n        \n        diagram_group = VGroup(axes, x_label, y_label)\n        diagram_group.center()\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.wait(1)\n        \n        # Create a simplified bifurcation diagram with three phases\n        \n        # 1. Stability region (r < 3)\n        stability_dots = VGroup()\n        for r in np.linspace(2.5, 3.0, 10):\n            dot = Dot(axes.c2p(r, 0.66), color=BLUE, radius=0.04)\n            stability_dots.add(dot)\n        \n        stability_label = Text(\"Stability\", font_size=20, color=BLUE)\n        stability_label.next_to(axes.c2p(2.7, 0.66), UP)\n        \n        self.play(Create(stability_dots))\n        self.play(Write(stability_label))\n        self.wait(1)\n        \n        # 2. Period doubling (3 < r < 3.5)\n        period2_dots_upper = VGroup()\n        period2_dots_lower = VGroup()\n        \n        for r in np.linspace(3.0, 3.45, 10):\n            # Approximate bifurcation values\n            value1 = 0.5 + 0.25 * (r - 3.0) / 0.45\n            value2 = 0.5 - 0.25 * (r - 3.0) / 0.45\n            \n            dot1 = Dot(axes.c2p(r, value1), color=GREEN, radius=0.04)\n            dot2 = Dot(axes.c2p(r, value2), color=GREEN, radius=0.04)\n            \n            period2_dots_upper.add(dot1)\n            period2_dots_lower.add(dot2)\n        \n        period_label = Text(\"Period Doubling\", font_size=20, color=GREEN)\n        period_label.next_to(axes.c2p(3.2, 0.4), DOWN)\n        \n        self.play(Create(period2_dots_upper), Create(period2_dots_lower))\n        self.play(Write(period_label))\n        self.wait(1)\n        \n        # 3. Chaos region (r > 3.6)\n        chaos_dots = VGroup()\n        for r in np.linspace(3.6, 4.0, 8):\n            for _ in range(15):\n                # Random y positions to simulate chaos\n                y = np.random.uniform(0.1, 0.9)\n                dot = Dot(axes.c2p(r, y), color=RED, radius=0.03)\n                chaos_dots.add(dot)\n        \n        chaos_label = Text(\"Chaos\", font_size=20, color=RED)\n        chaos_label.next_to(axes.c2p(3.8, 0.5), RIGHT)\n        \n        self.play(Create(chaos_dots))\n        self.play(Write(chaos_label))\n        self.wait(1)\n        \n        # Add conclusion\n        conclusion = Text(\"From order to chaos in a simple equation\", font_size=24)\n        conclusion.to_edge(DOWN)\n        self.play(FadeIn(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the bifurcation diagram of the logistic map illustrate the transition from order to chaos?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the bifurcation diagram of the logistic map illustrate the transition from order to chaos?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass LogisticMapScene(Scene):\n    def construct(self):\n        # Introduction with title\n        title = Text(\"Chaos in Motion: The Beauty of the Logistic Map\", font_size=32)\n        title.to_edge(UP)\n        self.play(FadeIn(title))\n        self.wait(1)\n        \n        # Display the logistic map equation\n        equation = MathTex(r\"x_{n+1} = rx_n(1-x_n)\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Move equation to upper corner\n        self.play(equation.animate.scale(0.8).to_corner(UL))\n        self.wait(0.5)\n        \n        # Create axes for the bifurcation diagram\n        axes = Axes(\n            x_range=[2.5, 4.0, 0.5],\n            y_range=[0, 1, 0.2],\n            x_length=6,\n            y_length=3,\n            axis_config={\"include_tip\": False},\n        )\n        \n        # Add axis labels\n        x_label = Text(\"r\", font_size=24).next_to(axes.x_axis, DOWN)\n        y_label = Text(\"x\", font_size=24).next_to(axes.y_axis, LEFT)\n        \n        diagram_group = VGroup(axes, x_label, y_label)\n        diagram_group.center()\n        \n        self.play(Create(axes), Write(x_label), Write(y_label))\n        self.wait(1)\n        \n        # Create a simplified bifurcation diagram with three phases\n        \n        # 1. Stability region (r < 3)\n        stability_dots = VGroup()\n        for r in np.linspace(2.5, 3.0, 10):\n            dot = Dot(axes.c2p(r, 0.66), color=BLUE, radius=0.04)\n            stability_dots.add(dot)\n        \n        stability_label = Text(\"Stability\", font_size=20, color=BLUE)\n        stability_label.next_to(axes.c2p(2.7, 0.66), UP)\n        \n        self.play(Create(stability_dots))\n        self.play(Write(stability_label))\n        self.wait(1)\n        \n        # 2. Period doubling (3 < r < 3.5)\n        period2_dots_upper = VGroup()\n        period2_dots_lower = VGroup()\n        \n        for r in np.linspace(3.0, 3.45, 10):\n            # Approximate bifurcation values\n            value1 = 0.5 + 0.25 * (r - 3.0) / 0.45\n            value2 = 0.5 - 0.25 * (r - 3.0) / 0.45\n            \n            dot1 = Dot(axes.c2p(r, value1), color=GREEN, radius=0.04)\n            dot2 = Dot(axes.c2p(r, value2), color=GREEN, radius=0.04)\n            \n            period2_dots_upper.add(dot1)\n            period2_dots_lower.add(dot2)\n        \n        period_label = Text(\"Period Doubling\", font_size=20, color=GREEN)\n        period_label.next_to(axes.c2p(3.2, 0.4), DOWN)\n        \n        self.play(Create(period2_dots_upper), Create(period2_dots_lower))\n        self.play(Write(period_label))\n        self.wait(1)\n        \n        # 3. Chaos region (r > 3.6)\n        chaos_dots = VGroup()\n        for r in np.linspace(3.6, 4.0, 8):\n            for _ in range(15):\n                # Random y positions to simulate chaos\n                y = np.random.uniform(0.1, 0.9)\n                dot = Dot(axes.c2p(r, y), color=RED, radius=0.03)\n                chaos_dots.add(dot)\n        \n        chaos_label = Text(\"Chaos\", font_size=20, color=RED)\n        chaos_label.next_to(axes.c2p(3.8, 0.5), RIGHT)\n        \n        self.play(Create(chaos_dots))\n        self.play(Write(chaos_label))\n        self.wait(1)\n        \n        # Add conclusion\n        conclusion = Text(\"From order to chaos in a simple equation\", font_size=24)\n        conclusion.to_edge(DOWN)\n        self.play(FadeIn(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the bifurcation diagram of the logistic map illustrate the transition from order to chaos?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation that demonstrates the approximation of a sine wave using a simple polynomial. Start by showing a coordinate system that spans from 0 to 10 on the x-axis and -2 to 2 on the y-axis. Then plot the actual sine wave on these axes. At the top of the scene, add the text \"Sine wave approximation with polynomials.\" After showing the sine wave, draw a green polynomial curve that approximates the sine wave. Could you then place a red dot at the point where the angle is pi on the sine curve? Finally, from that red dot, draw a dashed yellow vertical line straight down to the x-axis. Please pause briefly after each step so that I can see each part clearly."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_min=-1, x_max=10,\n            y_min=-1, y_max=8,\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"y\")\n        \n        # Creating the graph\n        graph = axes.plot(lambda x: 0.1 * (x-2)**2, color=WHITE)\n        area = axes.get_area(graph, x_min=2, x_max=8, color=BLUE, opacity=0.3)\n\n        # Problem statement\n        problem = MathTex(r\"A = \\int_{2}^{8} 0.1(x-2)^2 \\, dx\").to_edge(UP)\n\n        # Writing the problem\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Drawing the axes, graph, and shaded area\n        self.play(Write(axes), Write(labels))\n        self.wait(1)\n        self.play(Create(graph), FadeIn(area, run_time=3))\n        self.wait(2)\n\n        # Explanation for computation\n        explanation = Text(\"Calculate the area under the curve\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and present final answer\n        self.clear()\n        final_answer = MathTex(r\"A = \\frac{1}{0.3} [ \\frac{(x-2)^3}{3} ]_{2}^{8}\").move_to(problem)\n        self.play(Write(final_answer))\n        self.wait(3)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that demonstrates the approximation of a sine wave using a simple polynomial. Start by showing a coordinate system that spans from 0 to 10 on the x-axis and -2 to 2 on the y-axis. Then plot the actual sine wave on these axes. At the top of the scene, add the text \"Sine wave approximation with polynomials.\" After showing the sine wave, draw a green polynomial curve that approximates the sine wave. Could you then place a red dot at the point where the angle is pi on the sine curve? Finally, from that red dot, draw a dashed yellow vertical line straight down to the x-axis. Please pause briefly after each step so that I can see each part clearly."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation that demonstrates the approximation of a sine wave using a simple polynomial. start by showing a coordinate system that spans from 0 to 10 on the x-axis and -2 to 2 on the y-axis. then plot the actual sine wave on these axes. at the top of the scene, add the text \"sine wave approximation with polynomials.\" after showing the sine wave, draw a green polynomial curve that approximates the sine wave. could you then place a red dot at the point where the angle is pi on the sine curve? finally, from that red dot, draw a dashed yellow vertical line straight down to the x-axis. please pause briefly after each step so that i can see each part clearly."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurve(Scene):\n    def construct(self):\n        axes = Axes(\n            x_min=-1, x_max=10,\n            y_min=-1, y_max=8,\n            axis_config={\"color\": BLUE},\n        )\n\n        # Labels for axes\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"y\")\n        \n        # Creating the graph\n        graph = axes.plot(lambda x: 0.1 * (x-2)**2, color=WHITE)\n        area = axes.get_area(graph, x_min=2, x_max=8, color=BLUE, opacity=0.3)\n\n        # Problem statement\n        problem = MathTex(r\"A = \\int_{2}^{8} 0.1(x-2)^2 \\, dx\").to_edge(UP)\n\n        # Writing the problem\n        self.play(Write(problem))\n        self.wait(1)\n        \n        # Drawing the axes, graph, and shaded area\n        self.play(Write(axes), Write(labels))\n        self.wait(1)\n        self.play(Create(graph), FadeIn(area, run_time=3))\n        self.wait(2)\n\n        # Explanation for computation\n        explanation = Text(\"Calculate the area under the curve\", font_size=24).to_edge(DOWN)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Clear the scene and present final answer\n        self.clear()\n        final_answer = MathTex(r\"A = \\frac{1}{0.3} [ \\frac{(x-2)^3}{3} ]_{2}^{8}\").move_to(problem)\n        self.play(Write(final_answer))\n        self.wait(3)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that demonstrates the approximation of a sine wave using a simple polynomial. Start by showing a coordinate system that spans from 0 to 10 on the x-axis and -2 to 2 on the y-axis. Then plot the actual sine wave on these axes. At the top of the scene, add the text \"Sine wave approximation with polynomials.\" After showing the sine wave, draw a green polynomial curve that approximates the sine wave. Could you then place a red dot at the point where the angle is pi on the sine curve? Finally, from that red dot, draw a dashed yellow vertical line straight down to the x-axis. Please pause briefly after each step so that I can see each part clearly."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display four colored arcs of varying sizes and angles, each paired with a brace that curves along its outer edge:\n\n- A red arc with a left-facing brace.\n- A yellow arc with a standard brace.\n- A blue arc with a semicircular shape and a brace.\n- A green arc forming three-quarters of a circle with a brace.\n\nAll arc-brace pairs are arranged in a grid layout with ample spacing and centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArcBraceExample(Scene):\n    def construct(self):\n        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)\n        brace_1 = ArcBrace(arc_1,LEFT)\n        group_1 = VGroup(arc_1,brace_1)\n\n        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)\n        brace_2 = ArcBrace(arc_2)\n        group_2 = VGroup(arc_2,brace_2)\n\n        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n        brace_3 = ArcBrace(arc_3)\n        group_3 = VGroup(arc_3,brace_3)\n\n        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)\n        brace_4 = ArcBrace(arc_4)\n        group_4 = VGroup(arc_4,brace_4)\n\n        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n        self.add(arc_group.center())\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four colored arcs of varying sizes and angles, each paired with a brace that curves along its outer edge:\n\n- A red arc with a left-facing brace.\n- A yellow arc with a standard brace.\n- A blue arc with a semicircular shape and a brace.\n- A green arc forming three-quarters of a circle with a brace.\n\nAll arc-brace pairs are arranged in a grid layout with ample spacing and centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display four colored arcs of varying sizes and angles, each paired with a brace that curves along its outer edge:\n\n- a red arc with a left-facing brace.\n- a yellow arc with a standard brace.\n- a blue arc with a semicircular shape and a brace.\n- a green arc forming three-quarters of a circle with a brace.\n\nall arc-brace pairs are arranged in a grid layout with ample spacing and centered on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArcBraceExample(Scene):\n    def construct(self):\n        arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)\n        brace_1 = ArcBrace(arc_1,LEFT)\n        group_1 = VGroup(arc_1,brace_1)\n\n        arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)\n        brace_2 = ArcBrace(arc_2)\n        group_2 = VGroup(arc_2,brace_2)\n\n        arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n        brace_3 = ArcBrace(arc_3)\n        group_3 = VGroup(arc_3,brace_3)\n\n        arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)\n        brace_4 = ArcBrace(arc_4)\n        group_4 = VGroup(arc_4,brace_4)\n\n        arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n        self.add(arc_group.center())\n```"}], "metadata": {"source": "manimbench", "original_description": "Display four colored arcs of varying sizes and angles, each paired with a brace that curves along its outer edge:\n\n- A red arc with a left-facing brace.\n- A yellow arc with a standard brace.\n- A blue arc with a semicircular shape and a brace.\n- A green arc forming three-quarters of a circle with a brace.\n\nAll arc-brace pairs are arranged in a grid layout with ample spacing and centered on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How might data appear differently if the Law of Large Numbers didn't hold true?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DivergingAverages(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Diverging Averages: A Probability Fantasy\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"What if the Law of Large Numbers didn't hold?\")\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create axes for normal convergence\n        axes1 = Axes(\n            x_range=[0, 10],\n            y_range=[0, 1],\n        )\n        axes1_title = Text(\"Traditional Convergence\").next_to(axes1, UP)\n        \n        # Simple line for traditional convergence (using basic Line objects)\n        line1_1 = Line(axes1.c2p(0, 0.3), axes1.c2p(2, 0.4), color=BLUE)\n        line1_2 = Line(axes1.c2p(2, 0.4), axes1.c2p(4, 0.45), color=BLUE)\n        line1_3 = Line(axes1.c2p(4, 0.45), axes1.c2p(6, 0.48), color=BLUE)\n        line1_4 = Line(axes1.c2p(6, 0.48), axes1.c2p(8, 0.49), color=BLUE)\n        line1_5 = Line(axes1.c2p(8, 0.49), axes1.c2p(10, 0.5), color=BLUE)\n        \n        # Target line at y=0.5\n        target1 = Line(axes1.c2p(0, 0.5), axes1.c2p(10, 0.5), color=YELLOW)\n        \n        # Show normal convergence\n        self.play(Create(axes1), Write(axes1_title))\n        self.play(Create(line1_1), Create(line1_2), Create(line1_3), \n                 Create(line1_4), Create(line1_5))\n        self.play(Create(target1))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(FadeOut(axes1), FadeOut(axes1_title), \n                 FadeOut(line1_1), FadeOut(line1_2), FadeOut(line1_3),\n                 FadeOut(line1_4), FadeOut(line1_5), FadeOut(target1))\n        \n        # Create axes for divergent scenario\n        axes2 = Axes(\n            x_range=[0, 10],\n            y_range=[0, 1],\n        )\n        axes2_title = Text(\"Without Law of Large Numbers\").next_to(axes2, UP)\n        \n        # Simple line for divergent scenario (using basic Line objects)\n        line2_1 = Line(axes2.c2p(0, 0.3), axes2.c2p(2, 0.6), color=RED)\n        line2_2 = Line(axes2.c2p(2, 0.6), axes2.c2p(4, 0.2), color=RED)\n        line2_3 = Line(axes2.c2p(4, 0.2), axes2.c2p(6, 0.7), color=RED)\n        line2_4 = Line(axes2.c2p(6, 0.7), axes2.c2p(8, 0.4), color=RED)\n        line2_5 = Line(axes2.c2p(8, 0.4), axes2.c2p(10, 0.8), color=RED)\n        \n        # Target line at y=0.5\n        target2 = Line(axes2.c2p(0, 0.5), axes2.c2p(10, 0.5), color=YELLOW)\n        \n        # Show divergent scenario\n        self.play(Create(axes2), Write(axes2_title))\n        self.play(Create(line2_1), Create(line2_2), Create(line2_3), \n                 Create(line2_4), Create(line2_5))\n        self.play(Create(target2))\n        \n        # Key insight\n        insight = Text(\"Averages become meaningless!\").to_edge(DOWN)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(FadeOut(axes2), FadeOut(axes2_title), \n                 FadeOut(line2_1), FadeOut(line2_2), FadeOut(line2_3),\n                 FadeOut(line2_4), FadeOut(line2_5), FadeOut(target2),\n                 FadeOut(insight))\n        \n        # Main equation\n        eq1 = MathTex(r\"P(\\lim_{n \\to \\infty} \\frac{S_n}{n} = \\mu) = 1\")\n        eq1_label = Text(\"Law of Large Numbers\").next_to(eq1, DOWN)\n        \n        self.play(Write(eq1))\n        self.play(Write(eq1_label))\n        self.wait(1)\n        \n        # Alternate equation\n        eq2 = MathTex(r\"\\overline{X}_n \\ne \\mu\")\n        eq2_label = Text(\"Without the law\").next_to(eq2, DOWN)\n        \n        self.play(Transform(eq1, eq2), Transform(eq1_label, eq2_label))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(FadeOut(eq1), FadeOut(eq1_label))\n        \n        # Conclusion\n        conclusion = Text(\"Convergence makes statistics possible!\")\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How might data appear differently if the Law of Large Numbers didn't hold true?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how might data appear differently if the law of large numbers didn't hold true?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DivergingAverages(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Diverging Averages: A Probability Fantasy\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction\n        intro = Text(\"What if the Law of Large Numbers didn't hold?\")\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create axes for normal convergence\n        axes1 = Axes(\n            x_range=[0, 10],\n            y_range=[0, 1],\n        )\n        axes1_title = Text(\"Traditional Convergence\").next_to(axes1, UP)\n        \n        # Simple line for traditional convergence (using basic Line objects)\n        line1_1 = Line(axes1.c2p(0, 0.3), axes1.c2p(2, 0.4), color=BLUE)\n        line1_2 = Line(axes1.c2p(2, 0.4), axes1.c2p(4, 0.45), color=BLUE)\n        line1_3 = Line(axes1.c2p(4, 0.45), axes1.c2p(6, 0.48), color=BLUE)\n        line1_4 = Line(axes1.c2p(6, 0.48), axes1.c2p(8, 0.49), color=BLUE)\n        line1_5 = Line(axes1.c2p(8, 0.49), axes1.c2p(10, 0.5), color=BLUE)\n        \n        # Target line at y=0.5\n        target1 = Line(axes1.c2p(0, 0.5), axes1.c2p(10, 0.5), color=YELLOW)\n        \n        # Show normal convergence\n        self.play(Create(axes1), Write(axes1_title))\n        self.play(Create(line1_1), Create(line1_2), Create(line1_3), \n                 Create(line1_4), Create(line1_5))\n        self.play(Create(target1))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(FadeOut(axes1), FadeOut(axes1_title), \n                 FadeOut(line1_1), FadeOut(line1_2), FadeOut(line1_3),\n                 FadeOut(line1_4), FadeOut(line1_5), FadeOut(target1))\n        \n        # Create axes for divergent scenario\n        axes2 = Axes(\n            x_range=[0, 10],\n            y_range=[0, 1],\n        )\n        axes2_title = Text(\"Without Law of Large Numbers\").next_to(axes2, UP)\n        \n        # Simple line for divergent scenario (using basic Line objects)\n        line2_1 = Line(axes2.c2p(0, 0.3), axes2.c2p(2, 0.6), color=RED)\n        line2_2 = Line(axes2.c2p(2, 0.6), axes2.c2p(4, 0.2), color=RED)\n        line2_3 = Line(axes2.c2p(4, 0.2), axes2.c2p(6, 0.7), color=RED)\n        line2_4 = Line(axes2.c2p(6, 0.7), axes2.c2p(8, 0.4), color=RED)\n        line2_5 = Line(axes2.c2p(8, 0.4), axes2.c2p(10, 0.8), color=RED)\n        \n        # Target line at y=0.5\n        target2 = Line(axes2.c2p(0, 0.5), axes2.c2p(10, 0.5), color=YELLOW)\n        \n        # Show divergent scenario\n        self.play(Create(axes2), Write(axes2_title))\n        self.play(Create(line2_1), Create(line2_2), Create(line2_3), \n                 Create(line2_4), Create(line2_5))\n        self.play(Create(target2))\n        \n        # Key insight\n        insight = Text(\"Averages become meaningless!\").to_edge(DOWN)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(FadeOut(axes2), FadeOut(axes2_title), \n                 FadeOut(line2_1), FadeOut(line2_2), FadeOut(line2_3),\n                 FadeOut(line2_4), FadeOut(line2_5), FadeOut(target2),\n                 FadeOut(insight))\n        \n        # Main equation\n        eq1 = MathTex(r\"P(\\lim_{n \\to \\infty} \\frac{S_n}{n} = \\mu) = 1\")\n        eq1_label = Text(\"Law of Large Numbers\").next_to(eq1, DOWN)\n        \n        self.play(Write(eq1))\n        self.play(Write(eq1_label))\n        self.wait(1)\n        \n        # Alternate equation\n        eq2 = MathTex(r\"\\overline{X}_n \\ne \\mu\")\n        eq2_label = Text(\"Without the law\").next_to(eq2, DOWN)\n        \n        self.play(Transform(eq1, eq2), Transform(eq1_label, eq2_label))\n        self.wait(1)\n        \n        # Clear screen\n        self.play(FadeOut(eq1), FadeOut(eq1_label))\n        \n        # Conclusion\n        conclusion = Text(\"Convergence makes statistics possible!\")\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How might data appear differently if the Law of Large Numbers didn't hold true?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated educational video that explains step-by-step how to solve a triple integral mathematically, specifically the integral of xyz over the ranges z from 0 to 3, x from 0 to 2, and y from 0 to 1? The explanation should include writing out the problem, integrating with respect to z first, then x, and finally y, showing the intermediate steps, and finishing with the numerical value of the triple integral. Each step should have clear text guidance on what is happening and highlight the integral calculation at each stage."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define lower and upper bounds\n        a = 1\n        b = 2\n\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{\", str(a), r\"}^{\", str(b), r\"} x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration with bounds:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int_{a}^{b} x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"\\left. \\frac{x^{3}}{3} \\right|_{\", str(a), \"}^{\", str(b), \"}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the expression at bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculation step\n        calc_step = MathTex(r\"= \\frac{\", str(b), r\"^3}{3} - \\frac{\", str(a), r\"^3}{3}\")\n        self.play(ReplacementTransform(integration_step, calc_step))\n        self.wait(2)\n\n        # Final solution with numerical values\n        final_solution_numeric = MathTex(r\"= \\frac{8}{3} - \\frac{1}{3}\")\n        self.play(Transform(calc_step, final_solution_numeric))\n        self.wait(1)\n\n        # Reduce to the simplest form\n        final_solution_simple = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(final_solution_numeric, final_solution_simple))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution_simple))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated educational video that explains step-by-step how to solve a triple integral mathematically, specifically the integral of xyz over the ranges z from 0 to 3, x from 0 to 2, and y from 0 to 1? The explanation should include writing out the problem, integrating with respect to z first, then x, and finally y, showing the intermediate steps, and finishing with the numerical value of the triple integral. Each step should have clear text guidance on what is happening and highlight the integral calculation at each stage."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated educational video that explains step-by-step how to solve a triple integral mathematically, specifically the integral of xyz over the ranges z from 0 to 3, x from 0 to 2, and y from 0 to 1? the explanation should include writing out the problem, integrating with respect to z first, then x, and finally y, showing the intermediate steps, and finishing with the numerical value of the triple integral. each step should have clear text guidance on what is happening and highlight the integral calculation at each stage."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BasicDefiniteIntegral(Scene):\n    def construct(self):\n        # Define lower and upper bounds\n        a = 1\n        b = 2\n\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{\", str(a), r\"}^{\", str(b), r\"} x^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the integration rule\n        explanation1 = Text(\"Using the power rule of integration with bounds:\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Demonstrating the power rule\n        power_rule = MathTex(r\"\\int_{a}^{b} x^n \\,dx = \\left. \\frac{x^{n+1}}{n+1} \\right|_{a}^{b}\")\n        self.play(Write(power_rule))\n        self.wait(2)\n\n        # Performing the integration step\n        integration_step = MathTex(r\"\\left. \\frac{x^{3}}{3} \\right|_{\", str(a), \"}^{\", str(b), \"}\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for evaluating the definite integral\n        explanation2 = Text(\"Evaluate the expression at bounds\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Calculation step\n        calc_step = MathTex(r\"= \\frac{\", str(b), r\"^3}{3} - \\frac{\", str(a), r\"^3}{3}\")\n        self.play(ReplacementTransform(integration_step, calc_step))\n        self.wait(2)\n\n        # Final solution with numerical values\n        final_solution_numeric = MathTex(r\"= \\frac{8}{3} - \\frac{1}{3}\")\n        self.play(Transform(calc_step, final_solution_numeric))\n        self.wait(1)\n\n        # Reduce to the simplest form\n        final_solution_simple = MathTex(r\"= \\frac{7}{3}\")\n        self.play(ReplacementTransform(final_solution_numeric, final_solution_simple))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Conclude with the final solution\n        self.play(Write(final_solution_simple))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated educational video that explains step-by-step how to solve a triple integral mathematically, specifically the integral of xyz over the ranges z from 0 to 3, x from 0 to 2, and y from 0 to 1? The explanation should include writing out the problem, integrating with respect to z first, then x, and finally y, showing the intermediate steps, and finishing with the numerical value of the triple integral. Each step should have clear text guidance on what is happening and highlight the integral calculation at each stage."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do group actions impact the possible transformations of a Rubik's cube and determine its solvable states?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GroupActionsRubiksCube(Scene):\n    def construct(self):\n        # Set background color (compatible with newer manim versions)\n        self.camera.background_color = Color(\"#0C2D48\")\n        \n        # Title\n        title = Text(\"Unlocking the Magic of Group Actions on a Rubik's Cube\", font_size=28, color=WHITE)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        \n        # Introduction\n        intro = Text(\"Group actions dictate Rubik's cube transformations\", font_size=24, color=WHITE)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro))\n        self.wait(1)\n        \n        self.play(FadeOut(intro))\n        \n        # Create a simplified Rubik's Cube representation (one face with 3x3 grid)\n        cube = VGroup()\n        colors = [BLUE, RED, GREEN, YELLOW, ORANGE, WHITE]\n        \n        for i in range(3):\n            for j in range(3):\n                square = Square(side_length=0.8)\n                color_index = (i * 3 + j) % len(colors)\n                square.set_fill(colors[color_index], opacity=0.8)\n                square.set_stroke(WHITE, 2)\n                square.move_to([(i-1)*0.8, (j-1)*0.8, 0])\n                cube.add(square)\n        \n        cube.scale(1.5)\n        cube.move_to(ORIGIN)\n        \n        # Create the cube\n        self.play(Create(cube))\n        \n        # Visual Element 1: Cube rotating\n        self.play(Rotate(cube, angle=PI/4))\n        self.wait(0.5)\n        \n        # Key Concept 1\n        concept1 = Text(\"Key Concept 1: Group actions as permutations\", font_size=22, color=WHITE)\n        concept1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept1))\n        self.wait(0.5)\n        \n        # Visual Element 2: Highlighting certain squares to simulate a twist\n        highlight_squares = VGroup(cube[0], cube[1], cube[2])  # Top row\n        self.play(highlight_squares.animate.set_stroke(YELLOW, 4))\n        self.play(Rotate(highlight_squares, angle=PI/2, about_point=ORIGIN))\n        self.play(highlight_squares.animate.set_stroke(WHITE, 2))\n        self.wait(0.5)\n        \n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2\n        concept2 = Text(\"Key Concept 2: Symmetry Group of the Cube\", font_size=22, color=WHITE)\n        concept2.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept2))\n        self.wait(0.5)\n        \n        # Equation for group action\n        eq1 = MathTex(r\"x \\rightarrow gx, g \\in G\", color=WHITE)\n        eq1.next_to(cube, DOWN, buff=1)\n        self.play(Write(eq1))\n        self.wait(0.5)\n        \n        # Visual Element 3: Arrows showing movement\n        arrow = Arrow(start=cube[4].get_center(), end=cube[5].get_center(), buff=0.1, color=YELLOW)\n        self.play(Create(arrow))\n        self.wait(0.5)\n        self.play(FadeOut(arrow))\n        \n        self.play(FadeOut(concept2), FadeOut(eq1))\n        \n        # Key Concept 3\n        concept3 = Text(\"Key Concept 3: Group Orbits\", font_size=22, color=WHITE)\n        concept3.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept3))\n        self.wait(0.5)\n        \n        # Equation for orbit\n        eq2 = MathTex(r\"G(x) = \\{g(x) : g \\in G\\}\", color=WHITE)\n        eq2.next_to(cube, DOWN, buff=1)\n        self.play(Write(eq2))\n        self.wait(0.5)\n        \n        # Visual Element 4: Circle representing an orbit\n        orbit = Circle(radius=2, color=ORANGE)\n        orbit.move_to(cube.get_center())\n        self.play(Create(orbit))\n        self.wait(0.5)\n        \n        self.play(FadeOut(orbit))\n        self.play(FadeOut(concept3), FadeOut(eq2))\n        \n        # Key Insight\n        insight = Text(\"Key Insight: Group actions determine solvable states\", font_size=22, color=WHITE)\n        insight.next_to(title, DOWN, buff=0.5)\n        self.play(Write(insight))\n        self.wait(0.5)\n        \n        # Visual Element 5: Change color to indicate solved state\n        self.play(cube.animate.set_fill(GREEN, opacity=0.7))\n        self.wait(0.5)\n        \n        self.play(FadeOut(insight))\n        \n        # Conclusion\n        conclusion = Text(\"Group actions reveal the mathematics in every move!\", font_size=24, color=WHITE)\n        conclusion.next_to(title, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion), FadeOut(cube))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do group actions impact the possible transformations of a Rubik's cube and determine its solvable states?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do group actions impact the possible transformations of a rubik's cube and determine its solvable states?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GroupActionsRubiksCube(Scene):\n    def construct(self):\n        # Set background color (compatible with newer manim versions)\n        self.camera.background_color = Color(\"#0C2D48\")\n        \n        # Title\n        title = Text(\"Unlocking the Magic of Group Actions on a Rubik's Cube\", font_size=28, color=WHITE)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        \n        # Introduction\n        intro = Text(\"Group actions dictate Rubik's cube transformations\", font_size=24, color=WHITE)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro))\n        self.wait(1)\n        \n        self.play(FadeOut(intro))\n        \n        # Create a simplified Rubik's Cube representation (one face with 3x3 grid)\n        cube = VGroup()\n        colors = [BLUE, RED, GREEN, YELLOW, ORANGE, WHITE]\n        \n        for i in range(3):\n            for j in range(3):\n                square = Square(side_length=0.8)\n                color_index = (i * 3 + j) % len(colors)\n                square.set_fill(colors[color_index], opacity=0.8)\n                square.set_stroke(WHITE, 2)\n                square.move_to([(i-1)*0.8, (j-1)*0.8, 0])\n                cube.add(square)\n        \n        cube.scale(1.5)\n        cube.move_to(ORIGIN)\n        \n        # Create the cube\n        self.play(Create(cube))\n        \n        # Visual Element 1: Cube rotating\n        self.play(Rotate(cube, angle=PI/4))\n        self.wait(0.5)\n        \n        # Key Concept 1\n        concept1 = Text(\"Key Concept 1: Group actions as permutations\", font_size=22, color=WHITE)\n        concept1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept1))\n        self.wait(0.5)\n        \n        # Visual Element 2: Highlighting certain squares to simulate a twist\n        highlight_squares = VGroup(cube[0], cube[1], cube[2])  # Top row\n        self.play(highlight_squares.animate.set_stroke(YELLOW, 4))\n        self.play(Rotate(highlight_squares, angle=PI/2, about_point=ORIGIN))\n        self.play(highlight_squares.animate.set_stroke(WHITE, 2))\n        self.wait(0.5)\n        \n        self.play(FadeOut(concept1))\n        \n        # Key Concept 2\n        concept2 = Text(\"Key Concept 2: Symmetry Group of the Cube\", font_size=22, color=WHITE)\n        concept2.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept2))\n        self.wait(0.5)\n        \n        # Equation for group action\n        eq1 = MathTex(r\"x \\rightarrow gx, g \\in G\", color=WHITE)\n        eq1.next_to(cube, DOWN, buff=1)\n        self.play(Write(eq1))\n        self.wait(0.5)\n        \n        # Visual Element 3: Arrows showing movement\n        arrow = Arrow(start=cube[4].get_center(), end=cube[5].get_center(), buff=0.1, color=YELLOW)\n        self.play(Create(arrow))\n        self.wait(0.5)\n        self.play(FadeOut(arrow))\n        \n        self.play(FadeOut(concept2), FadeOut(eq1))\n        \n        # Key Concept 3\n        concept3 = Text(\"Key Concept 3: Group Orbits\", font_size=22, color=WHITE)\n        concept3.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept3))\n        self.wait(0.5)\n        \n        # Equation for orbit\n        eq2 = MathTex(r\"G(x) = \\{g(x) : g \\in G\\}\", color=WHITE)\n        eq2.next_to(cube, DOWN, buff=1)\n        self.play(Write(eq2))\n        self.wait(0.5)\n        \n        # Visual Element 4: Circle representing an orbit\n        orbit = Circle(radius=2, color=ORANGE)\n        orbit.move_to(cube.get_center())\n        self.play(Create(orbit))\n        self.wait(0.5)\n        \n        self.play(FadeOut(orbit))\n        self.play(FadeOut(concept3), FadeOut(eq2))\n        \n        # Key Insight\n        insight = Text(\"Key Insight: Group actions determine solvable states\", font_size=22, color=WHITE)\n        insight.next_to(title, DOWN, buff=0.5)\n        self.play(Write(insight))\n        self.wait(0.5)\n        \n        # Visual Element 5: Change color to indicate solved state\n        self.play(cube.animate.set_fill(GREEN, opacity=0.7))\n        self.wait(0.5)\n        \n        self.play(FadeOut(insight))\n        \n        # Conclusion\n        conclusion = Text(\"Group actions reveal the mathematics in every move!\", font_size=24, color=WHITE)\n        conclusion.next_to(title, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        # Final fade out\n        self.play(FadeOut(title), FadeOut(conclusion), FadeOut(cube))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do group actions impact the possible transformations of a Rubik's cube and determine its solvable states?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can the Central Limit Theorem be extended to apply to dependent random variables, and if so, under what conditions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CLTDependencies(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dancing with Dependencies: CLT Unleashed\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction to CLT\n        intro = Text(\"Central Limit Theorem\", font_size=28, color=BLUE)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Element 1: Independent vs Dependent Variables\n        # Independent dice\n        indep_text = Text(\"Independent Variables\", font_size=24, color=BLUE)\n        indep_text.to_edge(UP)\n        \n        # Create simple squares to represent dice\n        dice = VGroup(*[Square(side_length=0.5) for _ in range(4)])\n        dice.arrange(RIGHT, buff=0.3)\n        \n        self.play(Write(indep_text), Create(dice))\n        self.wait(1)\n        \n        # Transform to dependent variables\n        dep_text = Text(\"Dependent Variables\", font_size=24, color=GREEN)\n        dep_text.to_edge(UP)\n        \n        # Create a simple network of dots\n        dots = VGroup(*[Dot() for _ in range(4)])\n        dots.arrange_in_grid(2, 2, buff=1)\n        \n        # Create connections between dots\n        lines = VGroup()\n        for i in range(len(dots)):\n            for j in range(i+1, len(dots)):\n                line = Line(dots[i].get_center(), dots[j].get_center(), color=GREEN)\n                lines.add(line)\n        \n        self.play(\n            FadeOut(indep_text),\n            Write(dep_text),\n            FadeOut(dice)\n        )\n        self.play(Create(dots))\n        self.play(Create(lines))\n        self.wait(1)\n        \n        # Element 2: Bell Curve\n        self.play(\n            FadeOut(dep_text),\n            FadeOut(dots),\n            FadeOut(lines)\n        )\n        \n        bell_text = Text(\"Bell Curve (Normal Distribution)\", font_size=24, color=BLUE)\n        bell_text.to_edge(UP)\n        \n        # Create a simple bell curve\n        bell_curve = FunctionGraph(\n            lambda x: np.exp(-(x**2)/2),\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        \n        self.play(Write(bell_text))\n        self.play(Create(bell_curve))\n        \n        # Show first equation\n        equation = MathTex(r\"X_n = \\frac{1}{n}\\sum_{i=1}^n X_i\")\n        equation.next_to(bell_curve, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Element 3: Strong Mixing\n        self.play(\n            FadeOut(bell_text),\n            FadeOut(bell_curve),\n            FadeOut(equation)\n        )\n        \n        mixing_text = Text(\"Strong Mixing: Dependencies Fade\", font_size=24, color=GREEN)\n        mixing_text.to_edge(UP)\n        \n        # Create new dots for the mixing demonstration\n        new_dots = VGroup(*[Dot() for _ in range(4)])\n        new_dots.arrange_in_grid(2, 2, buff=1)\n        \n        # Create connections\n        new_lines = VGroup()\n        for i in range(len(new_dots)):\n            for j in range(i+1, len(new_dots)):\n                line = Line(new_dots[i].get_center(), new_dots[j].get_center(), color=GREEN)\n                new_lines.add(line)\n        \n        self.play(Write(mixing_text))\n        self.play(Create(new_dots), Create(new_lines))\n        \n        # Fade some connections to represent mixing\n        fade_animations = []\n        for i, line in enumerate(new_lines):\n            if i % 2 == 0:\n                fade_animations.append(FadeOut(line))\n        \n        self.play(*fade_animations)\n        self.wait(1)\n        \n        # Element 4: Bell Curve with Dependent Variables\n        bell_curve2 = FunctionGraph(\n            lambda x: np.exp(-(x**2)/2),\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        bell_curve2.next_to(new_dots, DOWN, buff=1)\n        \n        self.play(Create(bell_curve2))\n        \n        # Show second equation\n        equation2 = MathTex(\n            r\"L \\left(\\sum_{i=1}^{n}X_i - \\mu_i \\right) \\rightarrow N(0, \\sigma^2)\"\n        )\n        equation2.scale(0.7)\n        equation2.next_to(bell_curve2, DOWN, buff=0.5)\n        \n        self.play(Write(equation2))\n        self.wait(1)\n        \n        # Element 5: Conclusion\n        self.play(\n            FadeOut(mixing_text),\n            FadeOut(new_dots),\n            FadeOut(new_lines),\n            FadeOut(bell_curve2),\n            FadeOut(equation2)\n        )\n        \n        conclusion = Text(\"Randomness in Harmony\", font_size=36, color=YELLOW)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can the Central Limit Theorem be extended to apply to dependent random variables, and if so, under what conditions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can the central limit theorem be extended to apply to dependent random variables, and if so, under what conditions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CLTDependencies(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dancing with Dependencies: CLT Unleashed\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction to CLT\n        intro = Text(\"Central Limit Theorem\", font_size=28, color=BLUE)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Element 1: Independent vs Dependent Variables\n        # Independent dice\n        indep_text = Text(\"Independent Variables\", font_size=24, color=BLUE)\n        indep_text.to_edge(UP)\n        \n        # Create simple squares to represent dice\n        dice = VGroup(*[Square(side_length=0.5) for _ in range(4)])\n        dice.arrange(RIGHT, buff=0.3)\n        \n        self.play(Write(indep_text), Create(dice))\n        self.wait(1)\n        \n        # Transform to dependent variables\n        dep_text = Text(\"Dependent Variables\", font_size=24, color=GREEN)\n        dep_text.to_edge(UP)\n        \n        # Create a simple network of dots\n        dots = VGroup(*[Dot() for _ in range(4)])\n        dots.arrange_in_grid(2, 2, buff=1)\n        \n        # Create connections between dots\n        lines = VGroup()\n        for i in range(len(dots)):\n            for j in range(i+1, len(dots)):\n                line = Line(dots[i].get_center(), dots[j].get_center(), color=GREEN)\n                lines.add(line)\n        \n        self.play(\n            FadeOut(indep_text),\n            Write(dep_text),\n            FadeOut(dice)\n        )\n        self.play(Create(dots))\n        self.play(Create(lines))\n        self.wait(1)\n        \n        # Element 2: Bell Curve\n        self.play(\n            FadeOut(dep_text),\n            FadeOut(dots),\n            FadeOut(lines)\n        )\n        \n        bell_text = Text(\"Bell Curve (Normal Distribution)\", font_size=24, color=BLUE)\n        bell_text.to_edge(UP)\n        \n        # Create a simple bell curve\n        bell_curve = FunctionGraph(\n            lambda x: np.exp(-(x**2)/2),\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        \n        self.play(Write(bell_text))\n        self.play(Create(bell_curve))\n        \n        # Show first equation\n        equation = MathTex(r\"X_n = \\frac{1}{n}\\sum_{i=1}^n X_i\")\n        equation.next_to(bell_curve, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Element 3: Strong Mixing\n        self.play(\n            FadeOut(bell_text),\n            FadeOut(bell_curve),\n            FadeOut(equation)\n        )\n        \n        mixing_text = Text(\"Strong Mixing: Dependencies Fade\", font_size=24, color=GREEN)\n        mixing_text.to_edge(UP)\n        \n        # Create new dots for the mixing demonstration\n        new_dots = VGroup(*[Dot() for _ in range(4)])\n        new_dots.arrange_in_grid(2, 2, buff=1)\n        \n        # Create connections\n        new_lines = VGroup()\n        for i in range(len(new_dots)):\n            for j in range(i+1, len(new_dots)):\n                line = Line(new_dots[i].get_center(), new_dots[j].get_center(), color=GREEN)\n                new_lines.add(line)\n        \n        self.play(Write(mixing_text))\n        self.play(Create(new_dots), Create(new_lines))\n        \n        # Fade some connections to represent mixing\n        fade_animations = []\n        for i, line in enumerate(new_lines):\n            if i % 2 == 0:\n                fade_animations.append(FadeOut(line))\n        \n        self.play(*fade_animations)\n        self.wait(1)\n        \n        # Element 4: Bell Curve with Dependent Variables\n        bell_curve2 = FunctionGraph(\n            lambda x: np.exp(-(x**2)/2),\n            x_range=[-3, 3],\n            color=BLUE\n        )\n        bell_curve2.next_to(new_dots, DOWN, buff=1)\n        \n        self.play(Create(bell_curve2))\n        \n        # Show second equation\n        equation2 = MathTex(\n            r\"L \\left(\\sum_{i=1}^{n}X_i - \\mu_i \\right) \\rightarrow N(0, \\sigma^2)\"\n        )\n        equation2.scale(0.7)\n        equation2.next_to(bell_curve2, DOWN, buff=0.5)\n        \n        self.play(Write(equation2))\n        self.wait(1)\n        \n        # Element 5: Conclusion\n        self.play(\n            FadeOut(mixing_text),\n            FadeOut(new_dots),\n            FadeOut(new_lines),\n            FadeOut(bell_curve2),\n            FadeOut(equation2)\n        )\n        \n        conclusion = Text(\"Randomness in Harmony\", font_size=36, color=YELLOW)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can the Central Limit Theorem be extended to apply to dependent random variables, and if so, under what conditions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a circle at the center of the screen with a square to its left, a dot to its right, and a triangle below it. All four geometric shapes are arranged around the circle and shown simultaneously."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GeometricShapes(Scene):\n    def construct(self):\n        d = Dot()\n        c = Circle()\n        s = Square()\n        t = Triangle()\n        d.next_to(c, RIGHT)\n        s.next_to(c, LEFT)\n        t.next_to(c, DOWN)\n        self.add(d, c, s, t)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a circle at the center of the screen with a square to its left, a dot to its right, and a triangle below it. All four geometric shapes are arranged around the circle and shown simultaneously."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a circle at the center of the screen with a square to its left, a dot to its right, and a triangle below it. all four geometric shapes are arranged around the circle and shown simultaneously."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GeometricShapes(Scene):\n    def construct(self):\n        d = Dot()\n        c = Circle()\n        s = Square()\n        t = Triangle()\n        d.next_to(c, RIGHT)\n        s.next_to(c, LEFT)\n        t.next_to(c, DOWN)\n        self.add(d, c, s, t)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a circle at the center of the screen with a square to its left, a dot to its right, and a triangle below it. All four geometric shapes are arranged around the circle and shown simultaneously."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that explains whether the harmonic series converges or diverges using visual aids and mathematical proofs with step-by-step demonstrations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes and labels\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Function\n        function = axes.plot(lambda x: x**2, color=RED)\n        area = axes.get_riemann_rectangles(function, x_range=[0, 2], dx=0.1, color=PURPLE, fill_opacity=0.5)\n\n        # Display axes and function\n        self.play(Create(axes), Write(labels))\n        self.wait(1)\n\n        # Show function and area under curve\n        self.play(Create(function))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Title of the action\n        title = Text(\"Area under the curve f(x) = x^2 from x=0 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n        self.wait(2)\n\n        # Calculate the area under the curve\n        area_value = MathTex(r\"A = \\int_0^2 x^2 \\,dx\")\n        area_solution = MathTex(r\"A = \\left.\\frac{x^3}{3}\\right|_0^2\", r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(Write(area_value))\n        self.wait(1)\n        self.play(ReplacementTransform(area_value, area_solution))\n        self.wait(3)\n\n        # Conclusion\n        self.play(FadeOut(title), FadeOut(area_solution), FadeOut(area), FadeOut(function), FadeOut(axes), FadeOut(labels))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that explains whether the harmonic series converges or diverges using visual aids and mathematical proofs with step-by-step demonstrations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that explains whether the harmonic series converges or diverges using visual aids and mathematical proofs with step-by-step demonstrations?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        axes = Axes(\n            x_range=[0, 5, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"color\": BLUE},\n        )\n\n        # Axes and labels\n        labels = axes.get_axis_labels(x_label=\"x\", y_label=\"f(x)\")\n\n        # Function\n        function = axes.plot(lambda x: x**2, color=RED)\n        area = axes.get_riemann_rectangles(function, x_range=[0, 2], dx=0.1, color=PURPLE, fill_opacity=0.5)\n\n        # Display axes and function\n        self.play(Create(axes), Write(labels))\n        self.wait(1)\n\n        # Show function and area under curve\n        self.play(Create(function))\n        self.wait(1)\n        self.play(Create(area))\n        self.wait(2)\n\n        # Title of the action\n        title = Text(\"Area under the curve f(x) = x^2 from x=0 to x=2\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n        self.wait(2)\n\n        # Calculate the area under the curve\n        area_value = MathTex(r\"A = \\int_0^2 x^2 \\,dx\")\n        area_solution = MathTex(r\"A = \\left.\\frac{x^3}{3}\\right|_0^2\", r\"= \\frac{2^3}{3} - \\frac{0^3}{3}\", r\"= \\frac{8}{3}\")\n        self.play(Write(area_value))\n        self.wait(1)\n        self.play(ReplacementTransform(area_value, area_solution))\n        self.wait(3)\n\n        # Conclusion\n        self.play(FadeOut(title), FadeOut(area_solution), FadeOut(area), FadeOut(function), FadeOut(axes), FadeOut(labels))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that explains whether the harmonic series converges or diverges using visual aids and mathematical proofs with step-by-step demonstrations?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What patterns emerge when visualizing reachability in a graph as clusters formed by path connectivity, and what could these suggest about network resilience?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphReachability(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling Connections: The Visibility of Graph Reachability\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Imagine cities connected by roads...\", font_size=24)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create cities (nodes)\n        city1 = Dot(point=RIGHT * 3 + UP * 2, color=BLUE)\n        city2 = Dot(point=LEFT * 2 + UP * 1, color=BLUE)\n        city3 = Dot(point=RIGHT * 1 + DOWN * 2, color=BLUE)\n        city4 = Dot(point=LEFT * 3 + DOWN * 1, color=BLUE)\n        city5 = Dot(point=RIGHT * 2 + UP * 1, color=BLUE)\n        city6 = Dot(point=LEFT * 1 + DOWN * 2, color=BLUE)\n        city7 = Dot(point=ORIGIN, color=BLUE)  # Central city\n        \n        # Create roads (edges)\n        road1 = Line(city1.get_center(), city5.get_center(), color=YELLOW)\n        road2 = Line(city2.get_center(), city7.get_center(), color=YELLOW)\n        road3 = Line(city3.get_center(), city7.get_center(), color=YELLOW)\n        road4 = Line(city4.get_center(), city6.get_center(), color=YELLOW)\n        road5 = Line(city5.get_center(), city7.get_center(), color=YELLOW)\n        road6 = Line(city6.get_center(), city7.get_center(), color=YELLOW)\n        \n        # Show cities and roads\n        self.play(Create(city1), Create(city2), Create(city3), Create(city4), \n                 Create(city5), Create(city6), Create(city7))\n        self.play(Create(road1), Create(road2), Create(road3), \n                 Create(road4), Create(road5), Create(road6))\n        self.wait(1)\n        \n        # Highlight connected clusters\n        self.play(\n            city1.animate.set_color(RED),\n            city5.animate.set_color(RED),\n            city7.animate.set_color(RED),\n            road1.animate.set_color(RED),\n            road5.animate.set_color(RED),\n            \n            city2.animate.set_color(GREEN),\n            road2.animate.set_color(GREEN),\n            \n            city3.animate.set_color(PURPLE),\n            road3.animate.set_color(PURPLE),\n            \n            city4.animate.set_color(ORANGE),\n            city6.animate.set_color(ORANGE),\n            road4.animate.set_color(ORANGE),\n            road6.animate.set_color(ORANGE)\n        )\n        self.wait(1)\n        \n        # Text about clusters\n        cluster_text = Text(\"Connected clusters form paths\", font_size=24).to_edge(DOWN)\n        self.play(Write(cluster_text))\n        self.wait(1)\n        self.play(FadeOut(cluster_text))\n        \n        # Emphasize the central city\n        self.play(city7.animate.scale(1.5))\n        \n        # Text about key node\n        key_node_text = Text(\"What if we remove this city?\", font_size=24).to_edge(DOWN)\n        self.play(Write(key_node_text))\n        self.wait(1)\n        self.play(FadeOut(key_node_text))\n        \n        # Remove the central city and its connected roads\n        self.play(\n            FadeOut(city7),\n            FadeOut(road2),\n            FadeOut(road3),\n            FadeOut(road5),\n            FadeOut(road6)\n        )\n        self.wait(1)\n        \n        # Show the effect\n        effect_text = Text(\"Clusters are now disconnected!\", font_size=24).to_edge(DOWN)\n        self.play(Write(effect_text))\n        self.wait(1)\n        self.play(FadeOut(effect_text))\n        \n        # Clean up for equation\n        self.play(\n            FadeOut(city1), FadeOut(city2), FadeOut(city3), FadeOut(city4),\n            FadeOut(city5), FadeOut(city6),\n            FadeOut(road1), FadeOut(road4),\n            FadeOut(title)\n        )\n        \n        # Equation\n        equation = MathTex(r\"C(a, b) = \\{x \\in V : \\text{there exists a path from } a \\text{ to } x \\text{ and } b\\text{ to } x\\}\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Understanding reachability helps predict network resilience.\", font_size=24)\n        self.play(FadeOut(equation), Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What patterns emerge when visualizing reachability in a graph as clusters formed by path connectivity, and what could these suggest about network resilience?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what patterns emerge when visualizing reachability in a graph as clusters formed by path connectivity, and what could these suggest about network resilience?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphReachability(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unraveling Connections: The Visibility of Graph Reachability\", font_size=28)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Imagine cities connected by roads...\", font_size=24)\n        self.play(Write(intro))\n        self.wait(1)\n        self.play(FadeOut(intro))\n        \n        # Create cities (nodes)\n        city1 = Dot(point=RIGHT * 3 + UP * 2, color=BLUE)\n        city2 = Dot(point=LEFT * 2 + UP * 1, color=BLUE)\n        city3 = Dot(point=RIGHT * 1 + DOWN * 2, color=BLUE)\n        city4 = Dot(point=LEFT * 3 + DOWN * 1, color=BLUE)\n        city5 = Dot(point=RIGHT * 2 + UP * 1, color=BLUE)\n        city6 = Dot(point=LEFT * 1 + DOWN * 2, color=BLUE)\n        city7 = Dot(point=ORIGIN, color=BLUE)  # Central city\n        \n        # Create roads (edges)\n        road1 = Line(city1.get_center(), city5.get_center(), color=YELLOW)\n        road2 = Line(city2.get_center(), city7.get_center(), color=YELLOW)\n        road3 = Line(city3.get_center(), city7.get_center(), color=YELLOW)\n        road4 = Line(city4.get_center(), city6.get_center(), color=YELLOW)\n        road5 = Line(city5.get_center(), city7.get_center(), color=YELLOW)\n        road6 = Line(city6.get_center(), city7.get_center(), color=YELLOW)\n        \n        # Show cities and roads\n        self.play(Create(city1), Create(city2), Create(city3), Create(city4), \n                 Create(city5), Create(city6), Create(city7))\n        self.play(Create(road1), Create(road2), Create(road3), \n                 Create(road4), Create(road5), Create(road6))\n        self.wait(1)\n        \n        # Highlight connected clusters\n        self.play(\n            city1.animate.set_color(RED),\n            city5.animate.set_color(RED),\n            city7.animate.set_color(RED),\n            road1.animate.set_color(RED),\n            road5.animate.set_color(RED),\n            \n            city2.animate.set_color(GREEN),\n            road2.animate.set_color(GREEN),\n            \n            city3.animate.set_color(PURPLE),\n            road3.animate.set_color(PURPLE),\n            \n            city4.animate.set_color(ORANGE),\n            city6.animate.set_color(ORANGE),\n            road4.animate.set_color(ORANGE),\n            road6.animate.set_color(ORANGE)\n        )\n        self.wait(1)\n        \n        # Text about clusters\n        cluster_text = Text(\"Connected clusters form paths\", font_size=24).to_edge(DOWN)\n        self.play(Write(cluster_text))\n        self.wait(1)\n        self.play(FadeOut(cluster_text))\n        \n        # Emphasize the central city\n        self.play(city7.animate.scale(1.5))\n        \n        # Text about key node\n        key_node_text = Text(\"What if we remove this city?\", font_size=24).to_edge(DOWN)\n        self.play(Write(key_node_text))\n        self.wait(1)\n        self.play(FadeOut(key_node_text))\n        \n        # Remove the central city and its connected roads\n        self.play(\n            FadeOut(city7),\n            FadeOut(road2),\n            FadeOut(road3),\n            FadeOut(road5),\n            FadeOut(road6)\n        )\n        self.wait(1)\n        \n        # Show the effect\n        effect_text = Text(\"Clusters are now disconnected!\", font_size=24).to_edge(DOWN)\n        self.play(Write(effect_text))\n        self.wait(1)\n        self.play(FadeOut(effect_text))\n        \n        # Clean up for equation\n        self.play(\n            FadeOut(city1), FadeOut(city2), FadeOut(city3), FadeOut(city4),\n            FadeOut(city5), FadeOut(city6),\n            FadeOut(road1), FadeOut(road4),\n            FadeOut(title)\n        )\n        \n        # Equation\n        equation = MathTex(r\"C(a, b) = \\{x \\in V : \\text{there exists a path from } a \\text{ to } x \\text{ and } b\\text{ to } x\\}\")\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Understanding reachability helps predict network resilience.\", font_size=24)\n        self.play(FadeOut(equation), Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What patterns emerge when visualizing reachability in a graph as clusters formed by path connectivity, and what could these suggest about network resilience?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around 3D space of the scene at a fast rate to create an illusion effect of the 3D space. Stop the camera rotation after a quarter turn. "}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDCameraIllusionRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI/2)\n        self.stop_3dillusion_camera_rotation()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around 3D space of the scene at a fast rate to create an illusion effect of the 3D space. Stop the camera rotation after a quarter turn. "}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display 3d axes and a circle. set the camera orientation to a specific angle. begin rotating the camera around 3d space of the scene at a fast rate to create an illusion effect of the 3d space. stop the camera rotation after a quarter turn. "}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDCameraIllusionRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI/2)\n        self.stop_3dillusion_camera_rotation()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around 3D space of the scene at a fast rate to create an illusion effect of the 3D space. Stop the camera rotation after a quarter turn. "}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the text \u201cCircum- scribe\u201d in large font. Then animate several variations of the circumscribe effect around the text:\n\n1. Draw a default border around the text.\n2. Draw a circular border instead of the default shape.\n3. Draw a border that fades out after appearing.\n4. Animate a slower border drawing with a longer duration.\n5. Draw a circular border that fades out after appearing."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \u201cCircum- scribe\u201d in large font. Then animate several variations of the circumscribe effect around the text:\n\n1. Draw a default border around the text.\n2. Draw a circular border instead of the default shape.\n3. Draw a border that fades out after appearing.\n4. Animate a slower border drawing with a longer duration.\n5. Draw a circular border that fades out after appearing."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the text \u201ccircum- scribe\u201d in large font. then animate several variations of the circumscribe effect around the text:\n\n1. draw a default border around the text.\n2. draw a circular border instead of the default shape.\n3. draw a border that fades out after appearing.\n4. animate a slower border drawing with a longer duration.\n5. draw a circular border that fades out after appearing."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UsingCircumscribe(Scene):\n    def construct(self):\n        lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n        self.add(lbl)\n        self.play(Circumscribe(lbl))\n        self.play(Circumscribe(lbl, Circle))\n        self.play(Circumscribe(lbl, fade_out=True))\n        self.play(Circumscribe(lbl, time_width=2))\n        self.play(Circumscribe(lbl, Circle, True))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \u201cCircum- scribe\u201d in large font. Then animate several variations of the circumscribe effect around the text:\n\n1. Draw a default border around the text.\n2. Draw a circular border instead of the default shape.\n3. Draw a border that fades out after appearing.\n4. Animate a slower border drawing with a longer duration.\n5. Draw a circular border that fades out after appearing."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What geometric insights can be drawn by examining the norm of functions in Sobolev spaces that vanish at the boundary of a domain?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SobolevSpacesScene(Scene):\n    def construct(self):\n        # Create and display the title\n        title = Text(\"Boundary Play: Sobolev Spaces\", font_size=40, color=BLUE_C)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Create a square to represent the domain \u03a9\n        domain = Square(side_length=4, color=GREEN_C)\n        domain_label = Text(\"Domain \u03a9\", font_size=24).next_to(domain, DOWN)\n        self.play(Create(domain), Write(domain_label))\n        self.wait(1)\n        \n        # Create a circle to represent a function f(x,y)\n        function_circle = Circle(radius=1.5, color=YELLOW_C).move_to(domain.get_center())\n        function_label = Text(\"f(x,y)\", font_size=24).next_to(function_circle, UP)\n        self.play(Create(function_circle), Write(function_label))\n        self.wait(1)\n        \n        # Animate the function shrinking to visualize it approaching zero at the boundary\n        shrinking_animation = function_circle.animate.scale(0.1)\n        self.play(shrinking_animation)\n        self.wait(1)\n        \n        # Display text explaining the boundary condition\n        boundary_text = Text(\"f = 0 at the boundary\", font_size=30, color=RED_C)\n        self.play(Write(boundary_text))\n        self.wait(2)\n        self.play(FadeOut(boundary_text))\n        \n        # Display text explaining the Sobolev norm\n        norm_text = Text(\"Sobolev norm measures function and its gradient\", font_size=24, color=PURPLE_C)\n        self.play(Write(norm_text))\n        self.wait(2)\n        self.play(FadeOut(norm_text))\n        \n        # Display the conclusion\n        conclusion = Text(\"Boundary conditions shape the geometry of functions\", font_size=30, color=BLUE_C)\n        self.play(FadeOut(domain), FadeOut(domain_label),\n                  FadeOut(function_circle), FadeOut(function_label))\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out all remaining elements\n        self.play(FadeOut(conclusion), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What geometric insights can be drawn by examining the norm of functions in Sobolev spaces that vanish at the boundary of a domain?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what geometric insights can be drawn by examining the norm of functions in sobolev spaces that vanish at the boundary of a domain?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SobolevSpacesScene(Scene):\n    def construct(self):\n        # Create and display the title\n        title = Text(\"Boundary Play: Sobolev Spaces\", font_size=40, color=BLUE_C)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Create a square to represent the domain \u03a9\n        domain = Square(side_length=4, color=GREEN_C)\n        domain_label = Text(\"Domain \u03a9\", font_size=24).next_to(domain, DOWN)\n        self.play(Create(domain), Write(domain_label))\n        self.wait(1)\n        \n        # Create a circle to represent a function f(x,y)\n        function_circle = Circle(radius=1.5, color=YELLOW_C).move_to(domain.get_center())\n        function_label = Text(\"f(x,y)\", font_size=24).next_to(function_circle, UP)\n        self.play(Create(function_circle), Write(function_label))\n        self.wait(1)\n        \n        # Animate the function shrinking to visualize it approaching zero at the boundary\n        shrinking_animation = function_circle.animate.scale(0.1)\n        self.play(shrinking_animation)\n        self.wait(1)\n        \n        # Display text explaining the boundary condition\n        boundary_text = Text(\"f = 0 at the boundary\", font_size=30, color=RED_C)\n        self.play(Write(boundary_text))\n        self.wait(2)\n        self.play(FadeOut(boundary_text))\n        \n        # Display text explaining the Sobolev norm\n        norm_text = Text(\"Sobolev norm measures function and its gradient\", font_size=24, color=PURPLE_C)\n        self.play(Write(norm_text))\n        self.wait(2)\n        self.play(FadeOut(norm_text))\n        \n        # Display the conclusion\n        conclusion = Text(\"Boundary conditions shape the geometry of functions\", font_size=30, color=BLUE_C)\n        self.play(FadeOut(domain), FadeOut(domain_label),\n                  FadeOut(function_circle), FadeOut(function_label))\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out all remaining elements\n        self.play(FadeOut(conclusion), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What geometric insights can be drawn by examining the norm of functions in Sobolev spaces that vanish at the boundary of a domain?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that introduces and explains the wave equation, including a transition from the general form to the one-dimensional version, and demonstrates possible solutions as waves moving in opposite directions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain the integration step\n        explanation1 = Text(\"Integrate by reversing the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show integration result\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(2)\n\n        # Clear the screen and show conclusion\n        self.clear()\n        self.play(Write(Text(\"The integral of an exponential\", font_size=24)))\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that introduces and explains the wave equation, including a transition from the general form to the one-dimensional version, and demonstrates possible solutions as waves moving in opposite directions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that introduces and explains the wave equation, including a transition from the general form to the one-dimensional version, and demonstrates possible solutions as waves moving in opposite directions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExponentialIntegrationExample(Scene):\n    def construct(self):\n        # Display the integration problem\n        problem = MathTex(r\"\\int e^{2x} \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explain the integration step\n        explanation1 = Text(\"Integrate by reversing the power rule\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Show integration result\n        integration_step = MathTex(r\"\\frac{1}{2} e^{2x} + C\")\n        self.play(ReplacementTransform(problem, integration_step))\n        self.wait(2)\n\n        # Clear the screen and show conclusion\n        self.clear()\n        self.play(Write(Text(\"The integral of an exponential\", font_size=24)))\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that introduces and explains the wave equation, including a transition from the general form to the one-dimensional version, and demonstrates possible solutions as waves moving in opposite directions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the Hopf fibration contribute to our understanding of the topology of spheres by illustrating nontrivial fiber bundles?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HopfFibrationScene(Scene):\n    def construct(self):\n        # Create a background with midnight blue color\n        background = Rectangle(\n            width=FRAME_WIDTH, \n            height=FRAME_HEIGHT,\n            fill_color=\"#0A1931\",\n            fill_opacity=1,\n            stroke_width=0\n        )\n        self.add(background)\n        \n        # Title animation\n        title = Text(\"The Tangled Web of Hopf Fibrations\", color=GOLD).scale(0.8)\n        subtitle = Text(\"Unpacking Spheres in 3D\", color=GOLD).scale(0.6)\n        subtitle.next_to(title, DOWN)\n        title_group = VGroup(title, subtitle)\n        \n        self.play(Write(title), run_time=1.5)\n        self.play(FadeIn(subtitle), run_time=1)\n        self.wait(1)\n        self.play(FadeOut(title_group))\n        \n        # Simple sphere visualization\n        intro_text = Text(\"Imagine a simple sphere...\", color=WHITE).scale(0.7)\n        self.play(Write(intro_text), run_time=1)\n        \n        sphere = Circle(radius=2, color=BLUE).set_fill(BLUE, opacity=0.3)\n        self.play(FadeOut(intro_text))\n        self.play(Create(sphere), run_time=1)\n        \n        sphere_text = Text(\"A simple sphere appears straightforward\", color=WHITE).scale(0.7)\n        sphere_text.to_edge(UP)\n        self.play(Write(sphere_text), run_time=1)\n        self.wait(0.5)\n        \n        # Adding fibers to show complexity\n        fiber_text = Text(\"But it contains complex structures\", color=WHITE).scale(0.7)\n        fiber_text.to_edge(UP)\n        \n        fibers = VGroup()\n        for angle in range(0, 360, 40):\n            arc = Arc(radius=2, angle=PI, start_angle=angle*DEGREES, color=GOLD)\n            fibers.add(arc)\n        \n        self.play(Transform(sphere_text, fiber_text), run_time=1)\n        self.play(Create(fibers), run_time=1.5)\n        self.wait(0.5)\n        \n        # Clear screen for next concept\n        self.play(FadeOut(sphere), FadeOut(fibers), FadeOut(sphere_text))\n        \n        # Thread visualization \n        thread_text = Text(\"Visualize fibers as threads through beads\", color=WHITE).scale(0.7)\n        thread_text.to_edge(UP)\n        \n        bead = Circle(radius=0.5, color=WHITE).set_fill(WHITE, opacity=0.3)\n        thread = Line(LEFT*3, RIGHT*3, color=GOLD)\n        \n        self.play(Write(thread_text), run_time=1)\n        self.play(Create(thread), Create(bead), run_time=1)\n        self.wait(0.5)\n        \n        # Complex circle structure\n        complex_text = Text(\"In higher dimensions, these fibers form intricate patterns\", color=WHITE).scale(0.6)\n        complex_text.to_edge(UP)\n        \n        circle1 = Circle(radius=1.2, color=GOLD)\n        circle2 = Circle(radius=1.2, color=BLUE).shift(RIGHT*0.8)\n        \n        self.play(Transform(thread_text, complex_text), run_time=1)\n        self.play(Transform(bead, circle1), Transform(thread, circle2), run_time=1.5)\n        self.wait(0.5)\n        \n        # Clear for equations\n        self.play(FadeOut(thread_text), FadeOut(bead), FadeOut(thread))\n        \n        # First equation\n        equation1 = MathTex(\"S^1 \\\\rightarrow S^3 \\\\rightarrow S^2\", color=WHITE)\n        eq1_text = Text(\"The Hopf fibration maps a 3-sphere to a 2-sphere\", color=WHITE).scale(0.6)\n        eq1_text.next_to(equation1, DOWN)\n        \n        self.play(Write(equation1), run_time=1.5)\n        self.play(FadeIn(eq1_text), run_time=1)\n        self.wait(1)\n        \n        # Second equation\n        equation2 = MathTex(\"\\\\pi_3(S^2) = \\\\mathbb{Z}\", color=WHITE)\n        eq2_text = Text(\"This reveals the third homotopy group of S\u00b2\", color=WHITE).scale(0.6)\n        eq2_text.next_to(equation2, DOWN)\n        \n        self.play(FadeOut(equation1), FadeOut(eq1_text))\n        self.play(Write(equation2), run_time=1.5)\n        self.play(FadeIn(eq2_text), run_time=1)\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(equation2), FadeOut(eq2_text))\n        \n        conclusion_text = Text(\n            \"Hopf fibrations reveal the hidden complexity\\nwithin the seemingly simple sphere\",\n            color=GOLD\n        ).scale(0.7)\n        \n        self.play(Write(conclusion_text), run_time=2)\n        self.wait(1.5)\n        self.play(FadeOut(conclusion_text))\n        self.wait(0.5)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Hopf fibration contribute to our understanding of the topology of spheres by illustrating nontrivial fiber bundles?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the hopf fibration contribute to our understanding of the topology of spheres by illustrating nontrivial fiber bundles?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HopfFibrationScene(Scene):\n    def construct(self):\n        # Create a background with midnight blue color\n        background = Rectangle(\n            width=FRAME_WIDTH, \n            height=FRAME_HEIGHT,\n            fill_color=\"#0A1931\",\n            fill_opacity=1,\n            stroke_width=0\n        )\n        self.add(background)\n        \n        # Title animation\n        title = Text(\"The Tangled Web of Hopf Fibrations\", color=GOLD).scale(0.8)\n        subtitle = Text(\"Unpacking Spheres in 3D\", color=GOLD).scale(0.6)\n        subtitle.next_to(title, DOWN)\n        title_group = VGroup(title, subtitle)\n        \n        self.play(Write(title), run_time=1.5)\n        self.play(FadeIn(subtitle), run_time=1)\n        self.wait(1)\n        self.play(FadeOut(title_group))\n        \n        # Simple sphere visualization\n        intro_text = Text(\"Imagine a simple sphere...\", color=WHITE).scale(0.7)\n        self.play(Write(intro_text), run_time=1)\n        \n        sphere = Circle(radius=2, color=BLUE).set_fill(BLUE, opacity=0.3)\n        self.play(FadeOut(intro_text))\n        self.play(Create(sphere), run_time=1)\n        \n        sphere_text = Text(\"A simple sphere appears straightforward\", color=WHITE).scale(0.7)\n        sphere_text.to_edge(UP)\n        self.play(Write(sphere_text), run_time=1)\n        self.wait(0.5)\n        \n        # Adding fibers to show complexity\n        fiber_text = Text(\"But it contains complex structures\", color=WHITE).scale(0.7)\n        fiber_text.to_edge(UP)\n        \n        fibers = VGroup()\n        for angle in range(0, 360, 40):\n            arc = Arc(radius=2, angle=PI, start_angle=angle*DEGREES, color=GOLD)\n            fibers.add(arc)\n        \n        self.play(Transform(sphere_text, fiber_text), run_time=1)\n        self.play(Create(fibers), run_time=1.5)\n        self.wait(0.5)\n        \n        # Clear screen for next concept\n        self.play(FadeOut(sphere), FadeOut(fibers), FadeOut(sphere_text))\n        \n        # Thread visualization \n        thread_text = Text(\"Visualize fibers as threads through beads\", color=WHITE).scale(0.7)\n        thread_text.to_edge(UP)\n        \n        bead = Circle(radius=0.5, color=WHITE).set_fill(WHITE, opacity=0.3)\n        thread = Line(LEFT*3, RIGHT*3, color=GOLD)\n        \n        self.play(Write(thread_text), run_time=1)\n        self.play(Create(thread), Create(bead), run_time=1)\n        self.wait(0.5)\n        \n        # Complex circle structure\n        complex_text = Text(\"In higher dimensions, these fibers form intricate patterns\", color=WHITE).scale(0.6)\n        complex_text.to_edge(UP)\n        \n        circle1 = Circle(radius=1.2, color=GOLD)\n        circle2 = Circle(radius=1.2, color=BLUE).shift(RIGHT*0.8)\n        \n        self.play(Transform(thread_text, complex_text), run_time=1)\n        self.play(Transform(bead, circle1), Transform(thread, circle2), run_time=1.5)\n        self.wait(0.5)\n        \n        # Clear for equations\n        self.play(FadeOut(thread_text), FadeOut(bead), FadeOut(thread))\n        \n        # First equation\n        equation1 = MathTex(\"S^1 \\\\rightarrow S^3 \\\\rightarrow S^2\", color=WHITE)\n        eq1_text = Text(\"The Hopf fibration maps a 3-sphere to a 2-sphere\", color=WHITE).scale(0.6)\n        eq1_text.next_to(equation1, DOWN)\n        \n        self.play(Write(equation1), run_time=1.5)\n        self.play(FadeIn(eq1_text), run_time=1)\n        self.wait(1)\n        \n        # Second equation\n        equation2 = MathTex(\"\\\\pi_3(S^2) = \\\\mathbb{Z}\", color=WHITE)\n        eq2_text = Text(\"This reveals the third homotopy group of S\u00b2\", color=WHITE).scale(0.6)\n        eq2_text.next_to(equation2, DOWN)\n        \n        self.play(FadeOut(equation1), FadeOut(eq1_text))\n        self.play(Write(equation2), run_time=1.5)\n        self.play(FadeIn(eq2_text), run_time=1)\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(equation2), FadeOut(eq2_text))\n        \n        conclusion_text = Text(\n            \"Hopf fibrations reveal the hidden complexity\\nwithin the seemingly simple sphere\",\n            color=GOLD\n        ).scale(0.7)\n        \n        self.play(Write(conclusion_text), run_time=2)\n        self.wait(1.5)\n        self.play(FadeOut(conclusion_text))\n        self.wait(0.5)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Hopf fibration contribute to our understanding of the topology of spheres by illustrating nontrivial fiber bundles?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animated video that visualizes a simple atom model. The video should begin by fading in a blue nucleus representing eight protons and eight neutrons, labeled accordingly. Around this nucleus, electrons should orbit in two separate paths: the first orbit with two electrons and the second orbit with four electrons. The electrons themselves should be tiny red dots moving around grey elliptical paths that represent their orbits. The animation should show the electrons starting to move along these paths one after the other, with a slight delay between each electron's movement. Once all electrons are in motion, the animation should play for a short while before ending."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SimpleHarmonicMotion(Scene):\n    def construct(self):\n        # Display the differential equation for Simple Harmonic Motion\n        differential_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\frac{k}{m}x = 0\")\n        self.play(Write(differential_eq))\n        self.wait(2)\n\n        # Explain the transformation to the angular frequency\n        explanation1 = Text(\"Introduce angular frequency \", r\"\\(\\omega=\\sqrt{\\frac{k}{m}}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Show the transformed equation\n        transformed_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(ReplacementTransform(differential_eq.copy(), transformed_eq))\n        self.wait(2)\n\n        # Explain the solution process\n        explanation2 = Text(\"General solution of SHM\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Write down the general solution\n        general_solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(transformed_eq, general_solution))\n        self.wait(2)\n\n        # State the initial conditions\n        initial_conditions = Text(\"Given initial conditions determine \\(A\\) and \\(\\phi\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(initial_conditions))\n        self.wait(3)\n\n        # Show the system in motion (example)\n        oscillator = Dot().shift(LEFT * 2)\n        path = TracedPath(oscillator.get_center, stroke_width=6, stroke_color=YELLOW)\n        self.add(path)\n        self.play(MoveAlongPath(oscillator, Circle(radius=2).shift(LEFT * 2)), run_time=4, rate_func=lambda t: there_and_back(t))\n        self.wait(2)\n\n        # Concluding the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the SHM demonstration.\", font_size=30)))\n        self.wait(3)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that visualizes a simple atom model. The video should begin by fading in a blue nucleus representing eight protons and eight neutrons, labeled accordingly. Around this nucleus, electrons should orbit in two separate paths: the first orbit with two electrons and the second orbit with four electrons. The electrons themselves should be tiny red dots moving around grey elliptical paths that represent their orbits. The animation should show the electrons starting to move along these paths one after the other, with a slight delay between each electron's movement. Once all electrons are in motion, the animation should play for a short while before ending."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animated video that visualizes a simple atom model. the video should begin by fading in a blue nucleus representing eight protons and eight neutrons, labeled accordingly. around this nucleus, electrons should orbit in two separate paths: the first orbit with two electrons and the second orbit with four electrons. the electrons themselves should be tiny red dots moving around grey elliptical paths that represent their orbits. the animation should show the electrons starting to move along these paths one after the other, with a slight delay between each electron's movement. once all electrons are in motion, the animation should play for a short while before ending."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SimpleHarmonicMotion(Scene):\n    def construct(self):\n        # Display the differential equation for Simple Harmonic Motion\n        differential_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\frac{k}{m}x = 0\")\n        self.play(Write(differential_eq))\n        self.wait(2)\n\n        # Explain the transformation to the angular frequency\n        explanation1 = Text(\"Introduce angular frequency \", r\"\\(\\omega=\\sqrt{\\frac{k}{m}}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(3)\n\n        # Show the transformed equation\n        transformed_eq = MathTex(r\"\\frac{d^2x}{dt^2} + \\omega^2 x = 0\")\n        self.play(ReplacementTransform(differential_eq.copy(), transformed_eq))\n        self.wait(2)\n\n        # Explain the solution process\n        explanation2 = Text(\"General solution of SHM\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(3)\n\n        # Write down the general solution\n        general_solution = MathTex(r\"x(t) = A \\cos(\\omega t + \\phi)\")\n        self.play(ReplacementTransform(transformed_eq, general_solution))\n        self.wait(2)\n\n        # State the initial conditions\n        initial_conditions = Text(\"Given initial conditions determine \\(A\\) and \\(\\phi\\)\", font_size=24).to_edge(DOWN)\n        self.play(Write(initial_conditions))\n        self.wait(3)\n\n        # Show the system in motion (example)\n        oscillator = Dot().shift(LEFT * 2)\n        path = TracedPath(oscillator.get_center, stroke_width=6, stroke_color=YELLOW)\n        self.add(path)\n        self.play(MoveAlongPath(oscillator, Circle(radius=2).shift(LEFT * 2)), run_time=4, rate_func=lambda t: there_and_back(t))\n        self.wait(2)\n\n        # Concluding the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(\"End of the SHM demonstration.\", font_size=30)))\n        self.wait(3)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animated video that visualizes a simple atom model. The video should begin by fading in a blue nucleus representing eight protons and eight neutrons, labeled accordingly. Around this nucleus, electrons should orbit in two separate paths: the first orbit with two electrons and the second orbit with four electrons. The electrons themselves should be tiny red dots moving around grey elliptical paths that represent their orbits. The animation should show the electrons starting to move along these paths one after the other, with a slight delay between each electron's movement. Once all electrons are in motion, the animation should play for a short while before ending."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display two rounded rectangles arranged horizontally:\n\n1. A standard-sized rectangle with mildly rounded corners.\n2. A larger square-shaped rectangle with more prominently rounded corners, giving it a softer, more circular appearance."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RoundedRectangleExample(Scene):\n    def construct(self):\n        rect_1 = RoundedRectangle(corner_radius=0.5)\n        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\n\n        rect_group = Group(rect_1, rect_2).arrange(buff=1)\n        self.add(rect_group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display two rounded rectangles arranged horizontally:\n\n1. A standard-sized rectangle with mildly rounded corners.\n2. A larger square-shaped rectangle with more prominently rounded corners, giving it a softer, more circular appearance."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display two rounded rectangles arranged horizontally:\n\n1. a standard-sized rectangle with mildly rounded corners.\n2. a larger square-shaped rectangle with more prominently rounded corners, giving it a softer, more circular appearance."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RoundedRectangleExample(Scene):\n    def construct(self):\n        rect_1 = RoundedRectangle(corner_radius=0.5)\n        rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\n\n        rect_group = Group(rect_1, rect_2).arrange(buff=1)\n        self.add(rect_group)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display two rounded rectangles arranged horizontally:\n\n1. A standard-sized rectangle with mildly rounded corners.\n2. A larger square-shaped rectangle with more prominently rounded corners, giving it a softer, more circular appearance."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like to create an animation where a piece of text reading \"GrowFromCenter\" appears at the top of the screen and instantly transforms into an outlined triangle that expands from its center and then vanishes. Can this animation be completed in just half a second?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_color_by_gradient\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.add(square)\n            self.play(square.animate.set_color_by_gradient(RED,BLUE,YELLOW))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animation where a piece of text reading \"GrowFromCenter\" appears at the top of the screen and instantly transforms into an outlined triangle that expands from its center and then vanishes. Can this animation be completed in just half a second?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like to create an animation where a piece of text reading \"growfromcenter\" appears at the top of the screen and instantly transforms into an outlined triangle that expands from its center and then vanishes. can this animation be completed in just half a second?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.set_color_by_gradient\").shift(UP*2.5)), run_time=0.5)\n            square = Square(fill_opacity=1)\n            self.add(square)\n            self.play(square.animate.set_color_by_gradient(RED,BLUE,YELLOW))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animation where a piece of text reading \"GrowFromCenter\" appears at the top of the screen and instantly transforms into an outlined triangle that expands from its center and then vanishes. Can this animation be completed in just half a second?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the concept of an infinite-dimensional orthonormal basis differ from the finite-dimensional case, specifically in function spaces like L\u00b2?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass OrthonormalBasisScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Infinite: Orthonormal Bases\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Finite vs. Infinite Dimensional Bases\", font_size=24)\n        self.play(FadeIn(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Create a function space visualization (just a square)\n        function_space = Square(side_length=4).set_fill(BLUE_E, opacity=0.2)\n        function_space_text = Text(\"Function Space (L\u00b2)\", font_size=20).next_to(function_space, UP)\n        \n        self.play(Create(function_space), Write(function_space_text))\n        self.wait(1)\n        \n        # Finite dimensional visualization\n        vector1 = Arrow(start=ORIGIN, end=RIGHT*2, color=RED)\n        vector2 = Arrow(start=ORIGIN, end=UP*2, color=GREEN)\n        vectors = VGroup(vector1, vector2).move_to(function_space.get_center())\n        finite_text = Text(\"Finite-dimensional basis\", font_size=20).next_to(function_space, DOWN)\n        \n        self.play(\n            Create(vectors),\n            Write(finite_text)\n        )\n        self.wait(1)\n        \n        # Transform to infinite dimensional visualization\n        sine_wave = ParametricFunction(\n            lambda t: np.array([t, np.sin(2*t), 0]),\n            t_range=[-1, 1],\n            color=RED\n        ).scale(0.5)\n        \n        cosine_wave = ParametricFunction(\n            lambda t: np.array([t, np.cos(2*t), 0]),\n            t_range=[-1, 1],\n            color=GREEN\n        ).scale(0.5)\n        \n        waves = VGroup(sine_wave, cosine_wave).move_to(function_space.get_center())\n        infinite_text = Text(\"Infinite-dimensional basis\", font_size=20).next_to(function_space, DOWN)\n        \n        self.play(\n            ReplacementTransform(vectors, waves),\n            ReplacementTransform(finite_text, infinite_text)\n        )\n        self.wait(1)\n        \n        # Key equation\n        eq = MathTex(r\"\\sum_{n=1}^{\\infty} \\langle x, e_n \\rangle e_n = x\").scale(0.8)\n        eq.next_to(infinite_text, DOWN, buff=0.5)\n        \n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Key insight\n        insight_text = Text(\"Orthogonality creates order in infinite dimensions\", font_size=24)\n        \n        self.play(\n            FadeOut(function_space),\n            FadeOut(function_space_text),\n            FadeOut(waves),\n            FadeOut(infinite_text),\n            FadeOut(eq),\n            FadeIn(insight_text)\n        )\n        self.wait(2)\n        \n        # Conclusion\n        conclusion_text = Text(\"Beauty through infinite synchronicity\", font_size=24)\n        \n        self.play(Transform(insight_text, conclusion_text))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(insight_text),\n            FadeOut(title)\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the concept of an infinite-dimensional orthonormal basis differ from the finite-dimensional case, specifically in function spaces like L\u00b2?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the concept of an infinite-dimensional orthonormal basis differ from the finite-dimensional case, specifically in function spaces like l\u00b2?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass OrthonormalBasisScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Infinite: Orthonormal Bases\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro_text = Text(\"Finite vs. Infinite Dimensional Bases\", font_size=24)\n        self.play(FadeIn(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Create a function space visualization (just a square)\n        function_space = Square(side_length=4).set_fill(BLUE_E, opacity=0.2)\n        function_space_text = Text(\"Function Space (L\u00b2)\", font_size=20).next_to(function_space, UP)\n        \n        self.play(Create(function_space), Write(function_space_text))\n        self.wait(1)\n        \n        # Finite dimensional visualization\n        vector1 = Arrow(start=ORIGIN, end=RIGHT*2, color=RED)\n        vector2 = Arrow(start=ORIGIN, end=UP*2, color=GREEN)\n        vectors = VGroup(vector1, vector2).move_to(function_space.get_center())\n        finite_text = Text(\"Finite-dimensional basis\", font_size=20).next_to(function_space, DOWN)\n        \n        self.play(\n            Create(vectors),\n            Write(finite_text)\n        )\n        self.wait(1)\n        \n        # Transform to infinite dimensional visualization\n        sine_wave = ParametricFunction(\n            lambda t: np.array([t, np.sin(2*t), 0]),\n            t_range=[-1, 1],\n            color=RED\n        ).scale(0.5)\n        \n        cosine_wave = ParametricFunction(\n            lambda t: np.array([t, np.cos(2*t), 0]),\n            t_range=[-1, 1],\n            color=GREEN\n        ).scale(0.5)\n        \n        waves = VGroup(sine_wave, cosine_wave).move_to(function_space.get_center())\n        infinite_text = Text(\"Infinite-dimensional basis\", font_size=20).next_to(function_space, DOWN)\n        \n        self.play(\n            ReplacementTransform(vectors, waves),\n            ReplacementTransform(finite_text, infinite_text)\n        )\n        self.wait(1)\n        \n        # Key equation\n        eq = MathTex(r\"\\sum_{n=1}^{\\infty} \\langle x, e_n \\rangle e_n = x\").scale(0.8)\n        eq.next_to(infinite_text, DOWN, buff=0.5)\n        \n        self.play(Write(eq))\n        self.wait(2)\n        \n        # Key insight\n        insight_text = Text(\"Orthogonality creates order in infinite dimensions\", font_size=24)\n        \n        self.play(\n            FadeOut(function_space),\n            FadeOut(function_space_text),\n            FadeOut(waves),\n            FadeOut(infinite_text),\n            FadeOut(eq),\n            FadeIn(insight_text)\n        )\n        self.wait(2)\n        \n        # Conclusion\n        conclusion_text = Text(\"Beauty through infinite synchronicity\", font_size=24)\n        \n        self.play(Transform(insight_text, conclusion_text))\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(insight_text),\n            FadeOut(title)\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the concept of an infinite-dimensional orthonormal basis differ from the finite-dimensional case, specifically in function spaces like L\u00b2?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does loss aversion bias affect the Nash Equilibrium in repeated prisoner's dilemma games?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PrisonersDilemmaAnimation(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"The Prisoner's Dilemma: Navigating Bias and Equilibrium\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Key Concept 1: Prisoner's Dilemma Matrix\n        matrix_text = Text(\"Prisoner's Dilemma Payoff Matrix\", font_size=28).to_edge(UP)\n        self.play(Write(matrix_text))\n        \n        # Create a simplified version of the payoff matrix\n        matrix = VGroup(\n            Text(\"Betray, Betray: (-1,-1)\", font_size=24),\n            Text(\"Cooperate, Betray: (-3,0)\", font_size=24),\n            Text(\"Betray, Cooperate: (0,-3)\", font_size=24),\n            Text(\"Cooperate, Cooperate: (-2,-2)\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.5).next_to(matrix_text, DOWN, buff=0.5)\n        \n        self.play(Create(matrix))\n        self.wait(1)\n        \n        # Key Concept 2: Players and Loss Aversion\n        self.play(FadeOut(matrix), FadeOut(matrix_text))\n        \n        player_title = Text(\"Players in the Prisoner's Dilemma\", font_size=28).to_edge(UP)\n        self.play(Write(player_title))\n        \n        # Create two player circles with thought bubbles\n        player1 = Circle(radius=0.5, color=BLUE).shift(LEFT*2)\n        player2 = Circle(radius=0.5, color=RED).shift(RIGHT*2)\n        player1_label = Text(\"Player 1\", font_size=20).next_to(player1, DOWN)\n        player2_label = Text(\"Player 2\", font_size=20).next_to(player2, DOWN)\n        \n        thought1 = Circle(radius=1, color=WHITE).next_to(player1, UP, buff=0.5)\n        thought2 = Circle(radius=1, color=WHITE).next_to(player2, UP, buff=0.5)\n        \n        thought1_text = Text(\"Should I\\ncooperate?\", font_size=14).move_to(thought1.get_center())\n        thought2_text = Text(\"Afraid to\\nlose...\", font_size=14).move_to(thought2.get_center())\n        \n        player_group = VGroup(player1, player2, player1_label, player2_label)\n        thought_group = VGroup(thought1, thought2, thought1_text, thought2_text)\n        \n        self.play(Create(player_group))\n        self.play(Create(thought_group))\n        self.wait(1)\n        \n        # Key Concept 3: Loss Aversion Effect\n        self.play(FadeOut(player_group), FadeOut(thought_group), FadeOut(player_title))\n        \n        loss_aversion_title = Text(\"Loss Aversion Bias\", font_size=28).to_edge(UP)\n        self.play(Write(loss_aversion_title))\n        \n        # Loss aversion equation in simple text format\n        equation = Text(\"Utility(Loss Aversion) = \u03bb \u00d7 (Utility_Gain - Utility_Loss)\", font_size=24)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Show Nash Equilibrium shift\n        self.play(FadeOut(equation), FadeOut(loss_aversion_title))\n        \n        nash_title = Text(\"Effect on Nash Equilibrium\", font_size=28).to_edge(UP)\n        self.play(Write(nash_title))\n        \n        # Simple visualization of equilibrium shift\n        arrow = Arrow(start=LEFT*2, end=RIGHT*2, color=YELLOW)\n        standard_eq = Dot(point=LEFT*1.5, color=GREEN).scale(1.5)\n        biased_eq = Dot(point=RIGHT*1.5, color=RED).scale(1.5)\n        \n        standard_label = Text(\"Standard\\nEquilibrium\", font_size=16).next_to(standard_eq, DOWN)\n        biased_label = Text(\"Equilibrium with\\nLoss Aversion\", font_size=16).next_to(biased_eq, DOWN)\n        \n        self.play(Create(arrow))\n        self.play(Create(standard_eq), Write(standard_label))\n        self.play(Create(biased_eq), Write(biased_label))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(arrow), FadeOut(standard_eq), FadeOut(biased_eq),\n            FadeOut(standard_label), FadeOut(biased_label), FadeOut(nash_title)\n        )\n        \n        conclusion = Text(\"Loss aversion pulls players towards\\ncooperation in repeated games\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        final_title = Text(\"The Prisoner's Dilemma: Navigating Bias and Equilibrium\", font_size=32)\n        self.play(FadeOut(conclusion))\n        self.play(Write(final_title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does loss aversion bias affect the Nash Equilibrium in repeated prisoner's dilemma games?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does loss aversion bias affect the nash equilibrium in repeated prisoner's dilemma games?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PrisonersDilemmaAnimation(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"The Prisoner's Dilemma: Navigating Bias and Equilibrium\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Key Concept 1: Prisoner's Dilemma Matrix\n        matrix_text = Text(\"Prisoner's Dilemma Payoff Matrix\", font_size=28).to_edge(UP)\n        self.play(Write(matrix_text))\n        \n        # Create a simplified version of the payoff matrix\n        matrix = VGroup(\n            Text(\"Betray, Betray: (-1,-1)\", font_size=24),\n            Text(\"Cooperate, Betray: (-3,0)\", font_size=24),\n            Text(\"Betray, Cooperate: (0,-3)\", font_size=24),\n            Text(\"Cooperate, Cooperate: (-2,-2)\", font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.5).next_to(matrix_text, DOWN, buff=0.5)\n        \n        self.play(Create(matrix))\n        self.wait(1)\n        \n        # Key Concept 2: Players and Loss Aversion\n        self.play(FadeOut(matrix), FadeOut(matrix_text))\n        \n        player_title = Text(\"Players in the Prisoner's Dilemma\", font_size=28).to_edge(UP)\n        self.play(Write(player_title))\n        \n        # Create two player circles with thought bubbles\n        player1 = Circle(radius=0.5, color=BLUE).shift(LEFT*2)\n        player2 = Circle(radius=0.5, color=RED).shift(RIGHT*2)\n        player1_label = Text(\"Player 1\", font_size=20).next_to(player1, DOWN)\n        player2_label = Text(\"Player 2\", font_size=20).next_to(player2, DOWN)\n        \n        thought1 = Circle(radius=1, color=WHITE).next_to(player1, UP, buff=0.5)\n        thought2 = Circle(radius=1, color=WHITE).next_to(player2, UP, buff=0.5)\n        \n        thought1_text = Text(\"Should I\\ncooperate?\", font_size=14).move_to(thought1.get_center())\n        thought2_text = Text(\"Afraid to\\nlose...\", font_size=14).move_to(thought2.get_center())\n        \n        player_group = VGroup(player1, player2, player1_label, player2_label)\n        thought_group = VGroup(thought1, thought2, thought1_text, thought2_text)\n        \n        self.play(Create(player_group))\n        self.play(Create(thought_group))\n        self.wait(1)\n        \n        # Key Concept 3: Loss Aversion Effect\n        self.play(FadeOut(player_group), FadeOut(thought_group), FadeOut(player_title))\n        \n        loss_aversion_title = Text(\"Loss Aversion Bias\", font_size=28).to_edge(UP)\n        self.play(Write(loss_aversion_title))\n        \n        # Loss aversion equation in simple text format\n        equation = Text(\"Utility(Loss Aversion) = \u03bb \u00d7 (Utility_Gain - Utility_Loss)\", font_size=24)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Show Nash Equilibrium shift\n        self.play(FadeOut(equation), FadeOut(loss_aversion_title))\n        \n        nash_title = Text(\"Effect on Nash Equilibrium\", font_size=28).to_edge(UP)\n        self.play(Write(nash_title))\n        \n        # Simple visualization of equilibrium shift\n        arrow = Arrow(start=LEFT*2, end=RIGHT*2, color=YELLOW)\n        standard_eq = Dot(point=LEFT*1.5, color=GREEN).scale(1.5)\n        biased_eq = Dot(point=RIGHT*1.5, color=RED).scale(1.5)\n        \n        standard_label = Text(\"Standard\\nEquilibrium\", font_size=16).next_to(standard_eq, DOWN)\n        biased_label = Text(\"Equilibrium with\\nLoss Aversion\", font_size=16).next_to(biased_eq, DOWN)\n        \n        self.play(Create(arrow))\n        self.play(Create(standard_eq), Write(standard_label))\n        self.play(Create(biased_eq), Write(biased_label))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(arrow), FadeOut(standard_eq), FadeOut(biased_eq),\n            FadeOut(standard_label), FadeOut(biased_label), FadeOut(nash_title)\n        )\n        \n        conclusion = Text(\"Loss aversion pulls players towards\\ncooperation in repeated games\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        final_title = Text(\"The Prisoner's Dilemma: Navigating Bias and Equilibrium\", font_size=32)\n        self.play(FadeOut(conclusion))\n        self.play(Write(final_title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does loss aversion bias affect the Nash Equilibrium in repeated prisoner's dilemma games?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I need to create an educational animation to help students understand how to integrate exponential functions. Specifically, I want to showcase the process of integrating the function e raised to the 2x power with respect to x. The animation should start by displaying the integral of e^(2x) with respect to x. Then, it should include a step-by-step explanation that demonstrates integrating by using the reverse power rule, complete with written commentary. After showing the result of this integration, which is one-half times e^(2x) plus a constant of integration, I would like the initial problem to transform smoothly into the final answer. Once that is done, I want to clear the frame and conclude by stating, \"The integral of an exponential\", followed by a display of the final integration result again. The entire process should be paced slowly enough for students to follow along, with each step displayed for a couple of seconds before moving on to the next. Can you create an animation that meets these requirements?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExponentIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x^2 e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula\n        parts_formula = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(ReplacementTransform(problem.copy(), parts_formula))\n        self.wait(1)\n\n        # Define u and dv\n        u_and_dv = MathTex(r\"u=x^2\", r\", \\quad dv=e^x\\,dx\")\n        self.play(Write(u_and_dv))\n        self.wait(2)\n\n        # Define du and v\n        du_and_v = MathTex(r\"du=2x \\,dx\", r\", \\quad v=e^x\")\n        self.play(Transform(u_and_dv, du_and_v))\n        self.wait(2)\n\n        # Apply the formula\n        substitute_parts = MathTex(r\"x^2 e^x - \\int 2x e^x \\,dx\")\n        self.play(ReplacementTransform(parts_formula, substitute_parts))\n        self.wait(2)\n\n        # Solve the remaining integral\n        final_integration = MathTex(r\"x^2 e^x - \\left( 2xe^x - 2\\int e^x \\,dx \\right)\")\n        self.play(Transform(substitute_parts, final_integration))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x^2 e^x - 2xe^x + 2e^x + C\")\n        self.play(ReplacementTransform(final_integration, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I need to create an educational animation to help students understand how to integrate exponential functions. Specifically, I want to showcase the process of integrating the function e raised to the 2x power with respect to x. The animation should start by displaying the integral of e^(2x) with respect to x. Then, it should include a step-by-step explanation that demonstrates integrating by using the reverse power rule, complete with written commentary. After showing the result of this integration, which is one-half times e^(2x) plus a constant of integration, I would like the initial problem to transform smoothly into the final answer. Once that is done, I want to clear the frame and conclude by stating, \"The integral of an exponential\", followed by a display of the final integration result again. The entire process should be paced slowly enough for students to follow along, with each step displayed for a couple of seconds before moving on to the next. Can you create an animation that meets these requirements?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i need to create an educational animation to help students understand how to integrate exponential functions. specifically, i want to showcase the process of integrating the function e raised to the 2x power with respect to x. the animation should start by displaying the integral of e^(2x) with respect to x. then, it should include a step-by-step explanation that demonstrates integrating by using the reverse power rule, complete with written commentary. after showing the result of this integration, which is one-half times e^(2x) plus a constant of integration, i would like the initial problem to transform smoothly into the final answer. once that is done, i want to clear the frame and conclude by stating, \"the integral of an exponential\", followed by a display of the final integration result again. the entire process should be paced slowly enough for students to follow along, with each step displayed for a couple of seconds before moving on to the next. can you create an animation that meets these requirements?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExponentIntegrationExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int x^2 e^x \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for using integration by parts\n        explanation1 = Text(\"Use integration by parts\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration by parts formula\n        parts_formula = MathTex(r\"\\int u \\,dv = uv - \\int v \\,du\")\n        self.play(ReplacementTransform(problem.copy(), parts_formula))\n        self.wait(1)\n\n        # Define u and dv\n        u_and_dv = MathTex(r\"u=x^2\", r\", \\quad dv=e^x\\,dx\")\n        self.play(Write(u_and_dv))\n        self.wait(2)\n\n        # Define du and v\n        du_and_v = MathTex(r\"du=2x \\,dx\", r\", \\quad v=e^x\")\n        self.play(Transform(u_and_dv, du_and_v))\n        self.wait(2)\n\n        # Apply the formula\n        substitute_parts = MathTex(r\"x^2 e^x - \\int 2x e^x \\,dx\")\n        self.play(ReplacementTransform(parts_formula, substitute_parts))\n        self.wait(2)\n\n        # Solve the remaining integral\n        final_integration = MathTex(r\"x^2 e^x - \\left( 2xe^x - 2\\int e^x \\,dx \\right)\")\n        self.play(Transform(substitute_parts, final_integration))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= x^2 e^x - 2xe^x + 2e^x + C\")\n        self.play(ReplacementTransform(final_integration, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I need to create an educational animation to help students understand how to integrate exponential functions. Specifically, I want to showcase the process of integrating the function e raised to the 2x power with respect to x. The animation should start by displaying the integral of e^(2x) with respect to x. Then, it should include a step-by-step explanation that demonstrates integrating by using the reverse power rule, complete with written commentary. After showing the result of this integration, which is one-half times e^(2x) plus a constant of integration, I would like the initial problem to transform smoothly into the final answer. Once that is done, I want to clear the frame and conclude by stating, \"The integral of an exponential\", followed by a display of the final integration result again. The entire process should be paced slowly enough for students to follow along, with each step displayed for a couple of seconds before moving on to the next. Can you create an animation that meets these requirements?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What role does the Laplacian matrix play in determining the stability of electrical networks modeled as graphs?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphLaplacianScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Stability of Networks: Unveiling the Power of Laplacian Matrices\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP).scale(0.7))\n        \n        # Create a simple graph with 4 nodes in a square arrangement\n        # Node positions\n        p1 = [-1.5, 1.5, 0]\n        p2 = [1.5, 1.5, 0]\n        p3 = [1.5, -1.5, 0]\n        p4 = [-1.5, -1.5, 0]\n        \n        # Create nodes\n        node1 = Dot(point=p1, radius=0.2, color=BLUE)\n        node2 = Dot(point=p2, radius=0.2, color=BLUE)\n        node3 = Dot(point=p3, radius=0.2, color=BLUE)\n        node4 = Dot(point=p4, radius=0.2, color=BLUE)\n        nodes = VGroup(node1, node2, node3, node4)\n        \n        # Create edges\n        edge1 = Line(p1, p2, color=WHITE)\n        edge2 = Line(p2, p3, color=WHITE)\n        edge3 = Line(p3, p4, color=WHITE)\n        edge4 = Line(p4, p1, color=WHITE)\n        edge5 = Line(p1, p3, color=WHITE)  # Diagonal\n        edges = VGroup(edge1, edge2, edge3, edge4, edge5)\n        \n        # Show the graph\n        graph = VGroup(nodes, edges)\n        self.play(Create(graph))\n        graph_text = Text(\"Electrical Network as a Graph\", font_size=24).next_to(graph, DOWN, buff=0.5)\n        self.play(Write(graph_text))\n        self.wait(1)\n        \n        # Laplacian matrix equation\n        self.play(FadeOut(graph_text))\n        laplacian_eq = MathTex(\"L(G) = D - A\").next_to(graph, DOWN, buff=0.5)\n        laplacian_text = Text(\"Laplacian Matrix\", font_size=24).next_to(laplacian_eq, DOWN, buff=0.3)\n        self.play(Write(laplacian_eq), Write(laplacian_text))\n        self.wait(1)\n        \n        # Zero eigenvalue indicates stability\n        self.play(FadeOut(laplacian_text))\n        eigen_eq = MathTex(\"\\\\lambda_0 = 0\").next_to(laplacian_eq, DOWN, buff=0.5)\n        eigen_text = Text(\"Zero Eigenvalue = Stability\", font_size=24).next_to(eigen_eq, DOWN, buff=0.3)\n        self.play(Write(eigen_eq), Write(eigen_text))\n        self.wait(1)\n        \n        # Show stable current flow\n        self.play(FadeOut(eigen_text))\n        flow_text = Text(\"Stable Current Flow\", font_size=24).next_to(eigen_eq, DOWN, buff=0.5)\n        self.play(Write(flow_text))\n        \n        # Make edges change color to yellow to indicate current\n        self.play(\n            edge1.animate.set_color(YELLOW),\n            edge2.animate.set_color(YELLOW),\n            edge3.animate.set_color(YELLOW),\n            edge4.animate.set_color(YELLOW),\n            edge5.animate.set_color(YELLOW),\n            run_time=1\n        )\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph), FadeOut(laplacian_eq), \n            FadeOut(eigen_eq), FadeOut(flow_text)\n        )\n        conclusion = Text(\"Laplacian matrices reveal network stability\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What role does the Laplacian matrix play in determining the stability of electrical networks modeled as graphs?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what role does the laplacian matrix play in determining the stability of electrical networks modeled as graphs?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphLaplacianScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Stability of Networks: Unveiling the Power of Laplacian Matrices\", font_size=32)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP).scale(0.7))\n        \n        # Create a simple graph with 4 nodes in a square arrangement\n        # Node positions\n        p1 = [-1.5, 1.5, 0]\n        p2 = [1.5, 1.5, 0]\n        p3 = [1.5, -1.5, 0]\n        p4 = [-1.5, -1.5, 0]\n        \n        # Create nodes\n        node1 = Dot(point=p1, radius=0.2, color=BLUE)\n        node2 = Dot(point=p2, radius=0.2, color=BLUE)\n        node3 = Dot(point=p3, radius=0.2, color=BLUE)\n        node4 = Dot(point=p4, radius=0.2, color=BLUE)\n        nodes = VGroup(node1, node2, node3, node4)\n        \n        # Create edges\n        edge1 = Line(p1, p2, color=WHITE)\n        edge2 = Line(p2, p3, color=WHITE)\n        edge3 = Line(p3, p4, color=WHITE)\n        edge4 = Line(p4, p1, color=WHITE)\n        edge5 = Line(p1, p3, color=WHITE)  # Diagonal\n        edges = VGroup(edge1, edge2, edge3, edge4, edge5)\n        \n        # Show the graph\n        graph = VGroup(nodes, edges)\n        self.play(Create(graph))\n        graph_text = Text(\"Electrical Network as a Graph\", font_size=24).next_to(graph, DOWN, buff=0.5)\n        self.play(Write(graph_text))\n        self.wait(1)\n        \n        # Laplacian matrix equation\n        self.play(FadeOut(graph_text))\n        laplacian_eq = MathTex(\"L(G) = D - A\").next_to(graph, DOWN, buff=0.5)\n        laplacian_text = Text(\"Laplacian Matrix\", font_size=24).next_to(laplacian_eq, DOWN, buff=0.3)\n        self.play(Write(laplacian_eq), Write(laplacian_text))\n        self.wait(1)\n        \n        # Zero eigenvalue indicates stability\n        self.play(FadeOut(laplacian_text))\n        eigen_eq = MathTex(\"\\\\lambda_0 = 0\").next_to(laplacian_eq, DOWN, buff=0.5)\n        eigen_text = Text(\"Zero Eigenvalue = Stability\", font_size=24).next_to(eigen_eq, DOWN, buff=0.3)\n        self.play(Write(eigen_eq), Write(eigen_text))\n        self.wait(1)\n        \n        # Show stable current flow\n        self.play(FadeOut(eigen_text))\n        flow_text = Text(\"Stable Current Flow\", font_size=24).next_to(eigen_eq, DOWN, buff=0.5)\n        self.play(Write(flow_text))\n        \n        # Make edges change color to yellow to indicate current\n        self.play(\n            edge1.animate.set_color(YELLOW),\n            edge2.animate.set_color(YELLOW),\n            edge3.animate.set_color(YELLOW),\n            edge4.animate.set_color(YELLOW),\n            edge5.animate.set_color(YELLOW),\n            run_time=1\n        )\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph), FadeOut(laplacian_eq), \n            FadeOut(eigen_eq), FadeOut(flow_text)\n        )\n        conclusion = Text(\"Laplacian matrices reveal network stability\", font_size=28)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(FadeOut(conclusion), FadeOut(title))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What role does the Laplacian matrix play in determining the stability of electrical networks modeled as graphs?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like to create an animated video using a Python library that showcases various mathematical and text objects. The video should start by displaying the phrase \"A Showcase of MObjects\" at the top. Then I want to see a collection of different geometric shapes like squares, circles, triangles, annuluses, ellipses, dots, arrows, and stars. Below the shapes, there should be a line of different text and number-related objects including simple text, an integral formula, a rounded integer number, a decimal number, a bulleted list with three items, and a snippet of Python code that says 'Hello, World!'. \n\nThese collections of objects should be arranged in a grid layout with a nice visual spacing between them. Each object should fade into the scene starting from the top-left and moving to the bottom-right. After they all appear, I'd like the geometric shapes to have a wave-like effect applied one by one, and the text-based objects to be highlighted in sequence. This should be visually engaging showing a little bit of what can be done with objects in this library. \n\nFinally, all objects should fade out, including the title, to end the animation. Can you create something like that for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the original function\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for calculating area under curve\n        explanation1 = Text(\"Calculate area under curve from x = 0 to x = 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The definite integral setup\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(ReplacementTransform(function_text, integral_text))\n        self.wait(1)\n\n        # Explanation for using the integral to find the area\n        explanation2 = Text(\"Use the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solution\n        solution = MathTex(r\"= \\frac{1}{3}x^3\\Big|_0^2\")\n        self.play(ReplacementTransform(integral_text, solution))\n        self.wait(1)\n\n        solution_result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(solution, solution_result))\n        self.wait(1)\n\n        # Clear the scene and show final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_result))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animated video using a Python library that showcases various mathematical and text objects. The video should start by displaying the phrase \"A Showcase of MObjects\" at the top. Then I want to see a collection of different geometric shapes like squares, circles, triangles, annuluses, ellipses, dots, arrows, and stars. Below the shapes, there should be a line of different text and number-related objects including simple text, an integral formula, a rounded integer number, a decimal number, a bulleted list with three items, and a snippet of Python code that says 'Hello, World!'. \n\nThese collections of objects should be arranged in a grid layout with a nice visual spacing between them. Each object should fade into the scene starting from the top-left and moving to the bottom-right. After they all appear, I'd like the geometric shapes to have a wave-like effect applied one by one, and the text-based objects to be highlighted in sequence. This should be visually engaging showing a little bit of what can be done with objects in this library. \n\nFinally, all objects should fade out, including the title, to end the animation. Can you create something like that for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like to create an animated video using a python library that showcases various mathematical and text objects. the video should start by displaying the phrase \"a showcase of mobjects\" at the top. then i want to see a collection of different geometric shapes like squares, circles, triangles, annuluses, ellipses, dots, arrows, and stars. below the shapes, there should be a line of different text and number-related objects including simple text, an integral formula, a rounded integer number, a decimal number, a bulleted list with three items, and a snippet of python code that says 'hello, world!'. \n\nthese collections of objects should be arranged in a grid layout with a nice visual spacing between them. each object should fade into the scene starting from the top-left and moving to the bottom-right. after they all appear, i'd like the geometric shapes to have a wave-like effect applied one by one, and the text-based objects to be highlighted in sequence. this should be visually engaging showing a little bit of what can be done with objects in this library. \n\nfinally, all objects should fade out, including the title, to end the animation. can you create something like that for me?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Displaying the original function\n        function_text = MathTex(r\"f(x) = x^2\")\n        self.play(Write(function_text))\n        self.wait(1)\n\n        # Explanation for calculating area under curve\n        explanation1 = Text(\"Calculate area under curve from x = 0 to x = 2\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # The definite integral setup\n        integral_text = MathTex(r\"\\int_0^2 x^2 \\,dx\")\n        self.play(ReplacementTransform(function_text, integral_text))\n        self.wait(1)\n\n        # Explanation for using the integral to find the area\n        explanation2 = Text(\"Use the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Solution\n        solution = MathTex(r\"= \\frac{1}{3}x^3\\Big|_0^2\")\n        self.play(ReplacementTransform(integral_text, solution))\n        self.wait(1)\n\n        solution_result = MathTex(r\"= \\frac{8}{3}\")\n        self.play(Transform(solution, solution_result))\n        self.wait(1)\n\n        # Clear the scene and show final result\n        self.clear()\n        self.wait(1)\n        self.play(Write(solution_result))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an animated video using a Python library that showcases various mathematical and text objects. The video should start by displaying the phrase \"A Showcase of MObjects\" at the top. Then I want to see a collection of different geometric shapes like squares, circles, triangles, annuluses, ellipses, dots, arrows, and stars. Below the shapes, there should be a line of different text and number-related objects including simple text, an integral formula, a rounded integer number, a decimal number, a bulleted list with three items, and a snippet of Python code that says 'Hello, World!'. \n\nThese collections of objects should be arranged in a grid layout with a nice visual spacing between them. Each object should fade into the scene starting from the top-left and moving to the bottom-right. After they all appear, I'd like the geometric shapes to have a wave-like effect applied one by one, and the text-based objects to be highlighted in sequence. This should be visually engaging showing a little bit of what can be done with objects in this library. \n\nFinally, all objects should fade out, including the title, to end the animation. Can you create something like that for me?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can commutative diagrams express the concept of adjunctions between two categories?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CommutativeDiagramsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Magic of Commutative Diagrams in Category Theory\", color=BLUE)\n        title = title.scale(0.7)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Key Concept 1: Commutative Diagrams\n        subtitle1 = Text(\"Commutative Diagrams\", color=GOLD, font_size=30)\n        subtitle1.next_to(title, DOWN)\n        self.play(Write(subtitle1))\n        \n        # Create a simple commutative diagram with three objects\n        dot1 = Dot([-2, 0, 0], color=BLUE)\n        dot2 = Dot([2, 0, 0], color=BLUE)\n        dot3 = Dot([0, -2, 0], color=BLUE)\n        \n        # Labels for objects\n        label1 = Text(\"A\", font_size=24).next_to(dot1, UP)\n        label2 = Text(\"B\", font_size=24).next_to(dot2, UP)\n        label3 = Text(\"C\", font_size=24).next_to(dot3, DOWN)\n        \n        # Create dots and labels\n        self.play(Create(dot1), Create(dot2), Create(dot3))\n        self.play(Write(label1), Write(label2), Write(label3))\n        \n        # Create arrows (morphisms) between objects\n        arrow1 = Arrow(dot1.get_center(), dot2.get_center(), buff=0.2, color=GOLD)\n        arrow2 = Arrow(dot1.get_center(), dot3.get_center(), buff=0.2, color=GOLD)\n        arrow3 = Arrow(dot3.get_center(), dot2.get_center(), buff=0.2, color=GOLD)\n        \n        self.play(Create(arrow1), Create(arrow2), Create(arrow3))\n        \n        # Text explaining commutative diagrams\n        explanation = Text(\"In commutative diagrams, all paths between\\ntwo objects give the same result\", font_size=24)\n        explanation.next_to(dot3, DOWN, buff=1)\n        self.play(Write(explanation))\n        \n        self.wait(2)\n        \n        # Clear for next section\n        self.play(\n            FadeOut(dot1), FadeOut(dot2), FadeOut(dot3),\n            FadeOut(label1), FadeOut(label2), FadeOut(label3),\n            FadeOut(arrow1), FadeOut(arrow2), FadeOut(arrow3),\n            FadeOut(explanation), FadeOut(subtitle1)\n        )\n        \n        # Key Concept 2: Adjunctions\n        subtitle2 = Text(\"Adjunctions\", color=GOLD, font_size=30)\n        subtitle2.next_to(title, DOWN)\n        self.play(Write(subtitle2))\n        \n        # Create two categories\n        cat_c = Circle(radius=1, color=BLUE).shift(LEFT*2)\n        cat_d = Circle(radius=1, color=RED).shift(RIGHT*2)\n        \n        label_c = Text(\"C\", font_size=30).move_to(cat_c)\n        label_d = Text(\"D\", font_size=30).move_to(cat_d)\n        \n        self.play(Create(cat_c), Create(cat_d))\n        self.play(Write(label_c), Write(label_d))\n        \n        # Create functors between categories\n        arrow_f = Arrow(cat_c.get_right(), cat_d.get_left(), buff=0.1, color=GOLD)\n        arrow_g = Arrow(cat_d.get_left(), cat_c.get_right(), buff=0.1, color=GREEN)\n        \n        label_f = Text(\"F\", font_size=24).next_to(arrow_f, UP)\n        label_g = Text(\"G\", font_size=24).next_to(arrow_g, DOWN)\n        \n        self.play(Create(arrow_f), Create(arrow_g))\n        self.play(Write(label_f), Write(label_g))\n        \n        # Show the key equation for adjunctions\n        eq = Text(\"Hom(F(A), B) \u2245 Hom(A, G(B))\", font_size=30)\n        eq.next_to(cat_d, DOWN*3)\n        self.play(Write(eq))\n        \n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(cat_c), FadeOut(cat_d),\n            FadeOut(label_c), FadeOut(label_d),\n            FadeOut(arrow_f), FadeOut(arrow_g),\n            FadeOut(label_f), FadeOut(label_g),\n            FadeOut(eq), FadeOut(subtitle2), FadeOut(title)\n        )\n        \n        conclusion = Text(\"Commutative Diagrams:\\nElegant Portrayals of Mathematical Structures\", color=GOLD)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can commutative diagrams express the concept of adjunctions between two categories?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can commutative diagrams express the concept of adjunctions between two categories?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CommutativeDiagramsScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Magic of Commutative Diagrams in Category Theory\", color=BLUE)\n        title = title.scale(0.7)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Key Concept 1: Commutative Diagrams\n        subtitle1 = Text(\"Commutative Diagrams\", color=GOLD, font_size=30)\n        subtitle1.next_to(title, DOWN)\n        self.play(Write(subtitle1))\n        \n        # Create a simple commutative diagram with three objects\n        dot1 = Dot([-2, 0, 0], color=BLUE)\n        dot2 = Dot([2, 0, 0], color=BLUE)\n        dot3 = Dot([0, -2, 0], color=BLUE)\n        \n        # Labels for objects\n        label1 = Text(\"A\", font_size=24).next_to(dot1, UP)\n        label2 = Text(\"B\", font_size=24).next_to(dot2, UP)\n        label3 = Text(\"C\", font_size=24).next_to(dot3, DOWN)\n        \n        # Create dots and labels\n        self.play(Create(dot1), Create(dot2), Create(dot3))\n        self.play(Write(label1), Write(label2), Write(label3))\n        \n        # Create arrows (morphisms) between objects\n        arrow1 = Arrow(dot1.get_center(), dot2.get_center(), buff=0.2, color=GOLD)\n        arrow2 = Arrow(dot1.get_center(), dot3.get_center(), buff=0.2, color=GOLD)\n        arrow3 = Arrow(dot3.get_center(), dot2.get_center(), buff=0.2, color=GOLD)\n        \n        self.play(Create(arrow1), Create(arrow2), Create(arrow3))\n        \n        # Text explaining commutative diagrams\n        explanation = Text(\"In commutative diagrams, all paths between\\ntwo objects give the same result\", font_size=24)\n        explanation.next_to(dot3, DOWN, buff=1)\n        self.play(Write(explanation))\n        \n        self.wait(2)\n        \n        # Clear for next section\n        self.play(\n            FadeOut(dot1), FadeOut(dot2), FadeOut(dot3),\n            FadeOut(label1), FadeOut(label2), FadeOut(label3),\n            FadeOut(arrow1), FadeOut(arrow2), FadeOut(arrow3),\n            FadeOut(explanation), FadeOut(subtitle1)\n        )\n        \n        # Key Concept 2: Adjunctions\n        subtitle2 = Text(\"Adjunctions\", color=GOLD, font_size=30)\n        subtitle2.next_to(title, DOWN)\n        self.play(Write(subtitle2))\n        \n        # Create two categories\n        cat_c = Circle(radius=1, color=BLUE).shift(LEFT*2)\n        cat_d = Circle(radius=1, color=RED).shift(RIGHT*2)\n        \n        label_c = Text(\"C\", font_size=30).move_to(cat_c)\n        label_d = Text(\"D\", font_size=30).move_to(cat_d)\n        \n        self.play(Create(cat_c), Create(cat_d))\n        self.play(Write(label_c), Write(label_d))\n        \n        # Create functors between categories\n        arrow_f = Arrow(cat_c.get_right(), cat_d.get_left(), buff=0.1, color=GOLD)\n        arrow_g = Arrow(cat_d.get_left(), cat_c.get_right(), buff=0.1, color=GREEN)\n        \n        label_f = Text(\"F\", font_size=24).next_to(arrow_f, UP)\n        label_g = Text(\"G\", font_size=24).next_to(arrow_g, DOWN)\n        \n        self.play(Create(arrow_f), Create(arrow_g))\n        self.play(Write(label_f), Write(label_g))\n        \n        # Show the key equation for adjunctions\n        eq = Text(\"Hom(F(A), B) \u2245 Hom(A, G(B))\", font_size=30)\n        eq.next_to(cat_d, DOWN*3)\n        self.play(Write(eq))\n        \n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(cat_c), FadeOut(cat_d),\n            FadeOut(label_c), FadeOut(label_d),\n            FadeOut(arrow_f), FadeOut(arrow_g),\n            FadeOut(label_f), FadeOut(label_g),\n            FadeOut(eq), FadeOut(subtitle2), FadeOut(title)\n        )\n        \n        conclusion = Text(\"Commutative Diagrams:\\nElegant Portrayals of Mathematical Structures\", color=GOLD)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can commutative diagrams express the concept of adjunctions between two categories?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a green-outlined circle on the left and a semi-transparent pink triangle on the right, each with a faint white background rectangle behind them. The background rectangles are then animated: the one behind the circle rotates 45 degrees, and the one behind the triangle rotates 90 degrees, creating a dynamic visual effect."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleBackgroundRectangle(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        circle.set_stroke(color=GREEN, width=20)\n        triangle = Triangle().shift(2 * RIGHT)\n        triangle.set_fill(PINK, opacity=0.5)\n        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)\n        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)\n        self.add(backgroundRectangle1)\n        self.add(backgroundRectangle2)\n        self.add(circle)\n        self.add(triangle)\n        self.play(Rotate(backgroundRectangle1, PI / 4))\n        self.play(Rotate(backgroundRectangle2, PI / 2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a green-outlined circle on the left and a semi-transparent pink triangle on the right, each with a faint white background rectangle behind them. The background rectangles are then animated: the one behind the circle rotates 45 degrees, and the one behind the triangle rotates 90 degrees, creating a dynamic visual effect."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a green-outlined circle on the left and a semi-transparent pink triangle on the right, each with a faint white background rectangle behind them. the background rectangles are then animated: the one behind the circle rotates 45 degrees, and the one behind the triangle rotates 90 degrees, creating a dynamic visual effect."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleBackgroundRectangle(Scene):\n    def construct(self):\n        circle = Circle().shift(LEFT)\n        circle.set_stroke(color=GREEN, width=20)\n        triangle = Triangle().shift(2 * RIGHT)\n        triangle.set_fill(PINK, opacity=0.5)\n        backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)\n        backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)\n        self.add(backgroundRectangle1)\n        self.add(backgroundRectangle2)\n        self.add(circle)\n        self.add(triangle)\n        self.play(Rotate(backgroundRectangle1, PI / 4))\n        self.play(Rotate(backgroundRectangle2, PI / 2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a green-outlined circle on the left and a semi-transparent pink triangle on the right, each with a faint white background rectangle behind them. The background rectangles are then animated: the one behind the circle rotates 45 degrees, and the one behind the triangle rotates 90 degrees, creating a dynamic visual effect."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Given G\u00f6del's and Cohen's opposite results on the Continuum Hypothesis, how can a model of set theory be constructed that supports or refutes the hypothesis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ContinuumHypothesisScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Exploring the Unseen Layers of the Continuum\").scale(0.8)\n        title.to_edge(UP)\n        \n        # Create two circles representing different infinities\n        natural_circle = Circle(radius=1, color=BLUE_C).shift(LEFT*1.5)\n        real_circle = Circle(radius=1.5, color=GREEN_C).shift(RIGHT*1.5)\n        \n        natural_label = Text(\"Natural Numbers\").scale(0.5).next_to(natural_circle, DOWN)\n        real_label = Text(\"Real Numbers\").scale(0.5).next_to(real_circle, DOWN)\n        \n        question = Text(\"Is there a size of infinity between?\").scale(0.6)\n        question.next_to(title, DOWN, buff=1)\n        \n        # Animate introduction\n        self.play(Write(title))\n        self.play(Create(natural_circle), Create(real_circle))\n        self.play(Write(natural_label), Write(real_label))\n        self.play(FadeIn(question))\n        self.wait(1)\n        \n        # Clear screen for next concept\n        intro_objects = VGroup(natural_circle, natural_label, real_circle, real_label, question)\n        self.play(FadeOut(intro_objects))\n        \n        # Key Concept 1 - G\u00f6del's Constructible Universe\n        concept1_title = Text(\"G\u00f6del's Constructible Universe\").scale(0.8)\n        concept1_title.to_edge(UP)\n        \n        # Create a simple structure for G\u00f6del's Universe\n        godel_universe = Square(side_length=3, color=BLUE_C, fill_opacity=0.3)\n        \n        # Equation for G\u00f6del's model (simplified)\n        godel_eq = MathTex(\"L = \\\\bigcup L_{\\\\alpha}\").scale(0.9)\n        godel_eq.next_to(godel_universe, DOWN, buff=0.5)\n        \n        # Animate key concept 1\n        self.play(Transform(title, concept1_title))\n        self.play(Create(godel_universe))\n        self.play(Write(godel_eq))\n        self.wait(1)\n        \n        # Clear screen for next concept\n        concept1_objects = VGroup(godel_universe, godel_eq)\n        self.play(FadeOut(concept1_objects))\n        \n        # Key Concept 2 - Cohen's Forcing\n        concept2_title = Text(\"Cohen's Forcing\").scale(0.8)\n        concept2_title.to_edge(UP)\n        \n        # Create a simple grid for Cohen's Forcing\n        horizontal_line = Line(LEFT*3, RIGHT*3, color=GREEN_C)\n        vertical_line = Line(UP*3, DOWN*3, color=GREEN_C)\n        grid = VGroup(horizontal_line, vertical_line)\n        \n        # Equation for Cohen's forcing\n        cohen_eq = MathTex(\"V[G]\").scale(0.9)\n        cohen_eq.next_to(grid, DOWN, buff=0.5)\n        \n        # Animate key concept 2\n        self.play(Transform(title, concept2_title))\n        self.play(Create(grid))\n        self.play(Write(cohen_eq))\n        self.wait(1)\n        \n        # Clear screen for next concept\n        concept2_objects = VGroup(grid, cohen_eq)\n        self.play(FadeOut(concept2_objects))\n        \n        # Key Concept 3 - Models of Set Theory\n        concept3_title = Text(\"Models of Set Theory\").scale(0.8)\n        concept3_title.to_edge(UP)\n        \n        # Create simple models\n        model1 = Circle(radius=1, color=BLUE_C, fill_opacity=0.3).shift(LEFT*2)\n        model2 = Circle(radius=1.3, color=GREEN_C, fill_opacity=0.3)\n        model3 = Circle(radius=1.6, color=PURPLE_C, fill_opacity=0.3).shift(RIGHT*2)\n        \n        # Continuum Hypothesis equation\n        ch_eq = MathTex(\"2^{\\\\aleph_0} = \\\\aleph_1\").scale(0.9)\n        ch_eq.to_edge(DOWN, buff=1)\n        \n        # Animate key concept 3\n        self.play(Transform(title, concept3_title))\n        self.play(Create(model1), Create(model2), Create(model3))\n        self.play(Write(ch_eq))\n        self.wait(1)\n        \n        # Clear screen for key insight\n        concept3_objects = VGroup(model1, model2, model3, ch_eq)\n        self.play(FadeOut(concept3_objects))\n        \n        # Key Insight\n        insight_title = Text(\"The Flexibility of Mathematics\").scale(0.8)\n        insight_title.to_edge(UP)\n        \n        insight_text = Text(\"The Continuum Hypothesis: neither provable nor disprovable\").scale(0.6)\n        insight_text.next_to(insight_title, DOWN, buff=1)\n        \n        # Animate key insight\n        self.play(Transform(title, insight_title))\n        self.play(Write(insight_text))\n        self.wait(1)\n        \n        # Clear screen for conclusion\n        self.play(FadeOut(insight_text))\n        \n        # Conclusion\n        conclusion_title = Text(\"The Unsolved Enigma\").scale(0.8)\n        conclusion_title.to_edge(UP)\n        \n        conclusion_text = Text(\"A fascinating puzzle in the world of infinity\").scale(0.6)\n        conclusion_text.next_to(conclusion_title, DOWN, buff=1)\n        \n        # Animate conclusion\n        self.play(Transform(title, conclusion_title))\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        \n        # Final fade out\n        final_objects = VGroup(title, conclusion_text)\n        self.play(FadeOut(final_objects))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Given G\u00f6del's and Cohen's opposite results on the Continuum Hypothesis, how can a model of set theory be constructed that supports or refutes the hypothesis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: given g\u00f6del's and cohen's opposite results on the continuum hypothesis, how can a model of set theory be constructed that supports or refutes the hypothesis?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ContinuumHypothesisScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Exploring the Unseen Layers of the Continuum\").scale(0.8)\n        title.to_edge(UP)\n        \n        # Create two circles representing different infinities\n        natural_circle = Circle(radius=1, color=BLUE_C).shift(LEFT*1.5)\n        real_circle = Circle(radius=1.5, color=GREEN_C).shift(RIGHT*1.5)\n        \n        natural_label = Text(\"Natural Numbers\").scale(0.5).next_to(natural_circle, DOWN)\n        real_label = Text(\"Real Numbers\").scale(0.5).next_to(real_circle, DOWN)\n        \n        question = Text(\"Is there a size of infinity between?\").scale(0.6)\n        question.next_to(title, DOWN, buff=1)\n        \n        # Animate introduction\n        self.play(Write(title))\n        self.play(Create(natural_circle), Create(real_circle))\n        self.play(Write(natural_label), Write(real_label))\n        self.play(FadeIn(question))\n        self.wait(1)\n        \n        # Clear screen for next concept\n        intro_objects = VGroup(natural_circle, natural_label, real_circle, real_label, question)\n        self.play(FadeOut(intro_objects))\n        \n        # Key Concept 1 - G\u00f6del's Constructible Universe\n        concept1_title = Text(\"G\u00f6del's Constructible Universe\").scale(0.8)\n        concept1_title.to_edge(UP)\n        \n        # Create a simple structure for G\u00f6del's Universe\n        godel_universe = Square(side_length=3, color=BLUE_C, fill_opacity=0.3)\n        \n        # Equation for G\u00f6del's model (simplified)\n        godel_eq = MathTex(\"L = \\\\bigcup L_{\\\\alpha}\").scale(0.9)\n        godel_eq.next_to(godel_universe, DOWN, buff=0.5)\n        \n        # Animate key concept 1\n        self.play(Transform(title, concept1_title))\n        self.play(Create(godel_universe))\n        self.play(Write(godel_eq))\n        self.wait(1)\n        \n        # Clear screen for next concept\n        concept1_objects = VGroup(godel_universe, godel_eq)\n        self.play(FadeOut(concept1_objects))\n        \n        # Key Concept 2 - Cohen's Forcing\n        concept2_title = Text(\"Cohen's Forcing\").scale(0.8)\n        concept2_title.to_edge(UP)\n        \n        # Create a simple grid for Cohen's Forcing\n        horizontal_line = Line(LEFT*3, RIGHT*3, color=GREEN_C)\n        vertical_line = Line(UP*3, DOWN*3, color=GREEN_C)\n        grid = VGroup(horizontal_line, vertical_line)\n        \n        # Equation for Cohen's forcing\n        cohen_eq = MathTex(\"V[G]\").scale(0.9)\n        cohen_eq.next_to(grid, DOWN, buff=0.5)\n        \n        # Animate key concept 2\n        self.play(Transform(title, concept2_title))\n        self.play(Create(grid))\n        self.play(Write(cohen_eq))\n        self.wait(1)\n        \n        # Clear screen for next concept\n        concept2_objects = VGroup(grid, cohen_eq)\n        self.play(FadeOut(concept2_objects))\n        \n        # Key Concept 3 - Models of Set Theory\n        concept3_title = Text(\"Models of Set Theory\").scale(0.8)\n        concept3_title.to_edge(UP)\n        \n        # Create simple models\n        model1 = Circle(radius=1, color=BLUE_C, fill_opacity=0.3).shift(LEFT*2)\n        model2 = Circle(radius=1.3, color=GREEN_C, fill_opacity=0.3)\n        model3 = Circle(radius=1.6, color=PURPLE_C, fill_opacity=0.3).shift(RIGHT*2)\n        \n        # Continuum Hypothesis equation\n        ch_eq = MathTex(\"2^{\\\\aleph_0} = \\\\aleph_1\").scale(0.9)\n        ch_eq.to_edge(DOWN, buff=1)\n        \n        # Animate key concept 3\n        self.play(Transform(title, concept3_title))\n        self.play(Create(model1), Create(model2), Create(model3))\n        self.play(Write(ch_eq))\n        self.wait(1)\n        \n        # Clear screen for key insight\n        concept3_objects = VGroup(model1, model2, model3, ch_eq)\n        self.play(FadeOut(concept3_objects))\n        \n        # Key Insight\n        insight_title = Text(\"The Flexibility of Mathematics\").scale(0.8)\n        insight_title.to_edge(UP)\n        \n        insight_text = Text(\"The Continuum Hypothesis: neither provable nor disprovable\").scale(0.6)\n        insight_text.next_to(insight_title, DOWN, buff=1)\n        \n        # Animate key insight\n        self.play(Transform(title, insight_title))\n        self.play(Write(insight_text))\n        self.wait(1)\n        \n        # Clear screen for conclusion\n        self.play(FadeOut(insight_text))\n        \n        # Conclusion\n        conclusion_title = Text(\"The Unsolved Enigma\").scale(0.8)\n        conclusion_title.to_edge(UP)\n        \n        conclusion_text = Text(\"A fascinating puzzle in the world of infinity\").scale(0.6)\n        conclusion_text.next_to(conclusion_title, DOWN, buff=1)\n        \n        # Animate conclusion\n        self.play(Transform(title, conclusion_title))\n        self.play(Write(conclusion_text))\n        self.wait(2)\n        \n        # Final fade out\n        final_objects = VGroup(title, conclusion_text)\n        self.play(FadeOut(final_objects))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Given G\u00f6del's and Cohen's opposite results on the Continuum Hypothesis, how can a model of set theory be constructed that supports or refutes the hypothesis?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "setting_up_a_scene.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n# Import modules here\n\n\nclass BasicScene(ThreeDScene):\n    def construct(self):\n        # Your code goes here\n        text = Text(\"Your first scene!\")\n        self.add(text)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "setting_up_a_scene.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that setting_up_a_scene.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n# Import modules here\n\n\nclass BasicScene(ThreeDScene):\n    def construct(self):\n        # Your code goes here\n        text = Text(\"Your first scene!\")\n        self.add(text)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "setting_up_a_scene.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a red 3D helical spring-like curve winding upward along the z-axis, defined by the parametric equations \\((1.2 \\cos(u), 1.2 \\sin(u), 0.05u)\\) for \\(u\\) ranging from \\(-3\\tau\\) to \\(5\\tau\\), overlaid on a 3D coordinate axis. The camera is set to an angled perspective, and the scene appears without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDParametricSpring(ThreeDScene):\n    def construct(self):\n        curve1 = ParametricFunction(\n            lambda u: (\n                1.2 * np.cos(u),\n                1.2 * np.sin(u),\n                u * 0.05\n            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\n        ).set_shade_in_3d(True)\n        axes = ThreeDAxes()\n        self.add(axes, curve1)\n        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a red 3D helical spring-like curve winding upward along the z-axis, defined by the parametric equations \\((1.2 \\cos(u), 1.2 \\sin(u), 0.05u)\\) for \\(u\\) ranging from \\(-3\\tau\\) to \\(5\\tau\\), overlaid on a 3D coordinate axis. The camera is set to an angled perspective, and the scene appears without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a red 3d helical spring-like curve winding upward along the z-axis, defined by the parametric equations \\((1.2 \\cos(u), 1.2 \\sin(u), 0.05u)\\) for \\(u\\) ranging from \\(-3\\tau\\) to \\(5\\tau\\), overlaid on a 3d coordinate axis. the camera is set to an angled perspective, and the scene appears without animation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDParametricSpring(ThreeDScene):\n    def construct(self):\n        curve1 = ParametricFunction(\n            lambda u: (\n                1.2 * np.cos(u),\n                1.2 * np.sin(u),\n                u * 0.05\n            ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\n        ).set_shade_in_3d(True)\n        axes = ThreeDAxes()\n        self.add(axes, curve1)\n        self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a red 3D helical spring-like curve winding upward along the z-axis, defined by the parametric equations \\((1.2 \\cos(u), 1.2 \\sin(u), 0.05u)\\) for \\(u\\) ranging from \\(-3\\tau\\) to \\(5\\tau\\), overlaid on a 3D coordinate axis. The camera is set to an angled perspective, and the scene appears without animation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation of a simple pendulum swinging back and forth at a fixed point in space. The pendulum should have a string or rod of moderate length, with a small bob at the end that is colored blue. The pendulum should swing from a small angle, making it look like a typical pendulum motion, with the swing slowing down at the ends before it swings back the other way. I want to see the pendulum perform this swinging motion a few times, with a brief pause at the end of each swing before it changes direction. Additionally, the pendulum should be anchored to a point above that is fixed in space and should not move throughout the animation. Can you create something like this?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_x\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((LEFT+UP)*2)\n            star = Star()\n            self.add(dot,star)\n            self.play(star.animate.match_x(dot))\n            self.remove(star,dot)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation of a simple pendulum swinging back and forth at a fixed point in space. The pendulum should have a string or rod of moderate length, with a small bob at the end that is colored blue. The pendulum should swing from a small angle, making it look like a typical pendulum motion, with the swing slowing down at the ends before it swings back the other way. I want to see the pendulum perform this swinging motion a few times, with a brief pause at the end of each swing before it changes direction. Additionally, the pendulum should be anchored to a point above that is fixed in space and should not move throughout the animation. Can you create something like this?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation of a simple pendulum swinging back and forth at a fixed point in space. the pendulum should have a string or rod of moderate length, with a small bob at the end that is colored blue. the pendulum should swing from a small angle, making it look like a typical pendulum motion, with the swing slowing down at the ends before it swings back the other way. i want to see the pendulum perform this swinging motion a few times, with a brief pause at the end of each swing before it changes direction. additionally, the pendulum should be anchored to a point above that is fixed in space and should not move throughout the animation. can you create something like this?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_x\").shift(UP*2.5)), run_time=0.5)\n            dot = Dot().shift((LEFT+UP)*2)\n            star = Star()\n            self.add(dot,star)\n            self.play(star.animate.match_x(dot))\n            self.remove(star,dot)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation of a simple pendulum swinging back and forth at a fixed point in space. The pendulum should have a string or rod of moderate length, with a small bob at the end that is colored blue. The pendulum should swing from a small angle, making it look like a typical pendulum motion, with the swing slowing down at the ends before it swings back the other way. I want to see the pendulum perform this swinging motion a few times, with a brief pause at the end of each swing before it changes direction. Additionally, the pendulum should be anchored to a point above that is fixed in space and should not move throughout the animation. Can you create something like this?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "website_logo.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\nfrom manim_ml.neural_network.neural_network import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 400\nconfig.pixel_width = 600\nconfig.frame_height = 8.0\nconfig.frame_width = 10.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 5], layer_spacing=0.6, node_color=BLUE, edge_width=6\n        )\n        self.neural_network.scale(3)\n        self.neural_network.move_to(ORIGIN)\n        self.play(Create(self.neural_network))\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n        )\n        self.play(animation_group)\n        self.wait(5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "website_logo.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that website_logo.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\nfrom manim_ml.neural_network.neural_network import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 400\nconfig.pixel_width = 600\nconfig.frame_height = 8.0\nconfig.frame_width = 10.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 5], layer_spacing=0.6, node_color=BLUE, edge_width=6\n        )\n        self.neural_network.scale(3)\n        self.neural_network.move_to(ORIGIN)\n        self.play(Create(self.neural_network))\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n        )\n        self.play(animation_group)\n        self.wait(5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "website_logo.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a graph with five connected nodes initially arranged in a straight horizontal line. After being created, the graph smoothly transitions into a circular layout, repositioning the nodes evenly around a circle while maintaining their connections."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChangeGraphLayout(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                          4: [1, 0, 0], 5: [2, 0, 0]}\n                  )\n        self.play(Create(G))\n        self.play(G.animate.change_layout(\"circular\"))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with five connected nodes initially arranged in a straight horizontal line. After being created, the graph smoothly transitions into a circular layout, repositioning the nodes evenly around a circle while maintaining their connections."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a graph with five connected nodes initially arranged in a straight horizontal line. after being created, the graph smoothly transitions into a circular layout, repositioning the nodes evenly around a circle while maintaining their connections."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChangeGraphLayout(Scene):\n    def construct(self):\n        G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                  layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                          4: [1, 0, 0], 5: [2, 0, 0]}\n                  )\n        self.play(Create(G))\n        self.play(G.animate.change_layout(\"circular\"))\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a graph with five connected nodes initially arranged in a straight horizontal line. After being created, the graph smoothly transitions into a circular layout, repositioning the nodes evenly around a circle while maintaining their connections."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to see an animated video explaining the concept of finding the area under the curve y = x^2 from x = 0 to x = 2, including the steps for calculating the definite integral, writing out the antiderivative, substituting the upper and lower limits, and showing the final numerical value of the area. Can you create a visual presentation of this process, with each mathematical step appearing one after another?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        s = self.square_with_text(2, \"Manim\", RED, 36, WHITE, 3, YELLOW)\n        self.play(Create(s))\n        self.wait(2)\n\n    def square_with_text(\n        self, side_length: float, txt: str, color=WHITE, font_size: int = 48,\n        font_color=BLACK, stroke_width: int = 2, fill_color=WHITE\n    ) -> Mobject:\n        sqr = Square(side_length, color).set_stroke(color).set_fill(fill_color, opacity=1.0)\n        t = Text(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(sqr, t).move_to(ORIGIN)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to see an animated video explaining the concept of finding the area under the curve y = x^2 from x = 0 to x = 2, including the steps for calculating the definite integral, writing out the antiderivative, substituting the upper and lower limits, and showing the final numerical value of the area. Can you create a visual presentation of this process, with each mathematical step appearing one after another?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to see an animated video explaining the concept of finding the area under the curve y = x^2 from x = 0 to x = 2, including the steps for calculating the definite integral, writing out the antiderivative, substituting the upper and lower limits, and showing the final numerical value of the area. can you create a visual presentation of this process, with each mathematical step appearing one after another?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SquareWithText(Scene):\n    def construct(self):\n        s = self.square_with_text(2, \"Manim\", RED, 36, WHITE, 3, YELLOW)\n        self.play(Create(s))\n        self.wait(2)\n\n    def square_with_text(\n        self, side_length: float, txt: str, color=WHITE, font_size: int = 48,\n        font_color=BLACK, stroke_width: int = 2, fill_color=WHITE\n    ) -> Mobject:\n        sqr = Square(side_length, color).set_stroke(color).set_fill(fill_color, opacity=1.0)\n        t = Text(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(sqr, t).move_to(ORIGIN)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to see an animated video explaining the concept of finding the area under the curve y = x^2 from x = 0 to x = 2, including the steps for calculating the definite integral, writing out the antiderivative, substituting the upper and lower limits, and showing the final numerical value of the area. Can you create a visual presentation of this process, with each mathematical step appearing one after another?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can we imagine the process of wrapping a higher-dimensional sphere (n-sphere) within a manifold?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UnwrappingTheNSphere(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unwrapping the N-Sphere\", font_size=48)\n        subtitle = Text(\"A Journey in Higher Dimensions\", font_size=36)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Explanation of manifolds with globe analogy\n        globe = Circle(radius=2, color=BLUE)\n        rubber_band = Circle(radius=2.1, color=RED)\n        \n        self.play(Create(globe))\n        self.play(Create(rubber_band))\n        \n        text1 = Text(\"Rubber band on a globe\", font_size=36)\n        text1.to_edge(UP)\n        \n        self.play(Write(text1))\n        self.wait(1)\n        \n        # Zooming into a local area (flattening)\n        local_area = Square(side_length=1, color=GREEN)\n        local_area.move_to(RIGHT * 1.5 + UP * 1.5)\n        \n        text2 = Text(\"Locally flat\", font_size=36)\n        text2.to_edge(UP)\n        \n        self.play(Transform(text1, text2))\n        self.play(Create(local_area))\n        self.wait(1)\n        \n        # Explain n-sphere\n        self.play(FadeOut(text1), FadeOut(rubber_band), FadeOut(local_area))\n        \n        text3 = Text(\"N-Sphere Definition\", font_size=36)\n        text3.to_edge(UP)\n        \n        self.play(Write(text3))\n        self.wait(1)\n        \n        eq_nsphere = MathTex(r\"S^n = \\{ x \\in \\mathbb{R}^{n+1} : ||x|| = 1 \\}\")\n        eq_nsphere.next_to(text3, DOWN, buff=0.5)\n        \n        self.play(Write(eq_nsphere))\n        self.wait(1)\n        \n        # Visualize stereographic projection\n        text4 = Text(\"Stereographic Projection\", font_size=36)\n        text4.to_edge(UP)\n        \n        self.play(Transform(text3, text4))\n        self.play(FadeOut(eq_nsphere))\n        \n        stereo_proj = MathTex(r\"f: S^n \\setminus \\{N\\} \\to \\mathbb{R}^n\")\n        stereo_proj.next_to(text4, DOWN, buff=0.5)\n        \n        self.play(Write(stereo_proj))\n        \n        # Create a visual for stereographic projection\n        north_pole = Dot(UP * 2, color=YELLOW)\n        plane = Line(LEFT * 3, RIGHT * 3, color=GREEN).shift(DOWN * 2)\n        projection_line = Line(north_pole.get_center(), DOWN * 2, color=RED)\n        \n        self.play(Create(north_pole), Create(plane))\n        self.play(Create(projection_line))\n        self.wait(1)\n        \n        # Create multiple charts\n        self.play(FadeOut(text3), FadeOut(stereo_proj), FadeOut(north_pole), FadeOut(plane), FadeOut(projection_line))\n        \n        text5 = Text(\"Multiple Charts\", font_size=36)\n        text5.to_edge(UP)\n        \n        self.play(Write(text5))\n        \n        charts = VGroup()\n        for i in range(5):\n            chart = Square(side_length=1, color=GREEN_A)\n            chart.move_to([-2 + i, 0, 0])\n            charts.add(chart)\n        \n        self.play(Create(charts))\n        self.wait(1)\n        \n        # Conclusion\n        text6 = Text(\"Unwrapping through transformations\", font_size=36)\n        text6.to_edge(UP)\n        \n        self.play(Transform(text5, text6))\n        self.wait(1)\n        \n        # Final transformation\n        self.play(FadeOut(charts), FadeOut(text5))\n        \n        conclusion = Text(\"The beauty of manifolds\", font_size=48)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(FadeOut(globe), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we imagine the process of wrapping a higher-dimensional sphere (n-sphere) within a manifold?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can we imagine the process of wrapping a higher-dimensional sphere (n-sphere) within a manifold?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass UnwrappingTheNSphere(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unwrapping the N-Sphere\", font_size=48)\n        subtitle = Text(\"A Journey in Higher Dimensions\", font_size=36)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Explanation of manifolds with globe analogy\n        globe = Circle(radius=2, color=BLUE)\n        rubber_band = Circle(radius=2.1, color=RED)\n        \n        self.play(Create(globe))\n        self.play(Create(rubber_band))\n        \n        text1 = Text(\"Rubber band on a globe\", font_size=36)\n        text1.to_edge(UP)\n        \n        self.play(Write(text1))\n        self.wait(1)\n        \n        # Zooming into a local area (flattening)\n        local_area = Square(side_length=1, color=GREEN)\n        local_area.move_to(RIGHT * 1.5 + UP * 1.5)\n        \n        text2 = Text(\"Locally flat\", font_size=36)\n        text2.to_edge(UP)\n        \n        self.play(Transform(text1, text2))\n        self.play(Create(local_area))\n        self.wait(1)\n        \n        # Explain n-sphere\n        self.play(FadeOut(text1), FadeOut(rubber_band), FadeOut(local_area))\n        \n        text3 = Text(\"N-Sphere Definition\", font_size=36)\n        text3.to_edge(UP)\n        \n        self.play(Write(text3))\n        self.wait(1)\n        \n        eq_nsphere = MathTex(r\"S^n = \\{ x \\in \\mathbb{R}^{n+1} : ||x|| = 1 \\}\")\n        eq_nsphere.next_to(text3, DOWN, buff=0.5)\n        \n        self.play(Write(eq_nsphere))\n        self.wait(1)\n        \n        # Visualize stereographic projection\n        text4 = Text(\"Stereographic Projection\", font_size=36)\n        text4.to_edge(UP)\n        \n        self.play(Transform(text3, text4))\n        self.play(FadeOut(eq_nsphere))\n        \n        stereo_proj = MathTex(r\"f: S^n \\setminus \\{N\\} \\to \\mathbb{R}^n\")\n        stereo_proj.next_to(text4, DOWN, buff=0.5)\n        \n        self.play(Write(stereo_proj))\n        \n        # Create a visual for stereographic projection\n        north_pole = Dot(UP * 2, color=YELLOW)\n        plane = Line(LEFT * 3, RIGHT * 3, color=GREEN).shift(DOWN * 2)\n        projection_line = Line(north_pole.get_center(), DOWN * 2, color=RED)\n        \n        self.play(Create(north_pole), Create(plane))\n        self.play(Create(projection_line))\n        self.wait(1)\n        \n        # Create multiple charts\n        self.play(FadeOut(text3), FadeOut(stereo_proj), FadeOut(north_pole), FadeOut(plane), FadeOut(projection_line))\n        \n        text5 = Text(\"Multiple Charts\", font_size=36)\n        text5.to_edge(UP)\n        \n        self.play(Write(text5))\n        \n        charts = VGroup()\n        for i in range(5):\n            chart = Square(side_length=1, color=GREEN_A)\n            chart.move_to([-2 + i, 0, 0])\n            charts.add(chart)\n        \n        self.play(Create(charts))\n        self.wait(1)\n        \n        # Conclusion\n        text6 = Text(\"Unwrapping through transformations\", font_size=36)\n        text6.to_edge(UP)\n        \n        self.play(Transform(text5, text6))\n        self.wait(1)\n        \n        # Final transformation\n        self.play(FadeOut(charts), FadeOut(text5))\n        \n        conclusion = Text(\"The beauty of manifolds\", font_size=48)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(FadeOut(globe), FadeOut(conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can we imagine the process of wrapping a higher-dimensional sphere (n-sphere) within a manifold?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a set of coordinate axes with labeled ticks, then place a dot at the point \\((-4, 1.5)\\). A horizontal line extends from this point across the graph, visually marking the y-value of the dot."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetHorizontalLineExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        point = ax @ (-4, 1.5)\n\n        dot = Dot(point)\n        line = ax.get_horizontal_line(point, line_func=Line)\n\n        self.add(ax, line, dot)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a set of coordinate axes with labeled ticks, then place a dot at the point \\((-4, 1.5)\\). A horizontal line extends from this point across the graph, visually marking the y-value of the dot."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a set of coordinate axes with labeled ticks, then place a dot at the point \\((-4, 1.5)\\). a horizontal line extends from this point across the graph, visually marking the y-value of the dot."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GetHorizontalLineExample(Scene):\n    def construct(self):\n        ax = Axes().add_coordinates()\n        point = ax @ (-4, 1.5)\n\n        dot = Dot(point)\n        line = ax.get_horizontal_line(point, line_func=Line)\n\n        self.add(ax, line, dot)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a set of coordinate axes with labeled ticks, then place a dot at the point \\((-4, 1.5)\\). A horizontal line extends from this point across the graph, visually marking the y-value of the dot."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_triplet.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import TripletLayer, triplet\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass TripletScene(Scene):\n    def construct(self):\n        anchor_path = \"../assets/triplet/anchor.jpg\"\n        positive_path = \"../assets/triplet/positive.jpg\"\n        negative_path = \"../assets/triplet/negative.jpg\"\n\n        triplet_layer = TripletLayer.from_paths(\n            anchor_path, positive_path, negative_path, grayscale=False\n        )\n\n        triplet_layer.scale(0.08)\n\n        neural_network = NeuralNetwork(\n            [triplet_layer, FeedForwardLayer(5), FeedForwardLayer(3)]\n        )\n\n        neural_network.scale(1)\n\n        self.play(Create(neural_network), run_time=3)\n\n        self.play(neural_network.make_forward_pass_animation(), run_time=10)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_triplet.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_triplet.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import TripletLayer, triplet\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass TripletScene(Scene):\n    def construct(self):\n        anchor_path = \"../assets/triplet/anchor.jpg\"\n        positive_path = \"../assets/triplet/positive.jpg\"\n        negative_path = \"../assets/triplet/negative.jpg\"\n\n        triplet_layer = TripletLayer.from_paths(\n            anchor_path, positive_path, negative_path, grayscale=False\n        )\n\n        triplet_layer.scale(0.08)\n\n        neural_network = NeuralNetwork(\n            [triplet_layer, FeedForwardLayer(5), FeedForwardLayer(3)]\n        )\n\n        neural_network.scale(1)\n\n        self.play(Create(neural_network), run_time=3)\n\n        self.play(neural_network.make_forward_pass_animation(), run_time=10)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_triplet.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation using ManimCE that shows a point moving along a circular path, while highlighting that the path is a parametric curve defined by a specific mathematical function? Include text explanations to describe the circle's parametric function, explain how the function represents a circle, and show the point tracing the path as the parameter changes from 0 to 2\u03c0. Finally, end the animation with a message stating that parametric curves can describe complex shapes."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChemistryScene(Scene):\n    def construct(self):\n        # Create grid of lithium ions\n        li_grid = self.lithium_grid(3, 3)\n\n        # Create a single carbon layer\n        carbon_l = self.carbon_layer()\n\n        # Create a molecule of oxygen and a metal\n        oxy = self.oxygen().shift(LEFT * 2)\n        met = self.metal().shift(RIGHT * 2)\n\n        # Animate the objects\n        self.play(FadeIn(li_grid))\n        self.wait(1)\n        self.play(Transform(li_grid, carbon_l))\n        self.wait(1)\n        self.play(FadeIn(oxy), FadeIn(met))\n        self.wait(2)\n\n        # Move the oxygen in a triangle path\n        tri_points = [UP * 2 + LEFT, UP * 2, UP * 2 + RIGHT]\n        oxy_animations = self.move_along_complex_path(oxy, [1], tri_points, run_time=3)\n        self.play(*oxy_animations)\n\n        self.wait(3)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1]))\n\n        for i in range(len(paths)):\n            animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n        return animations\n\n    def lithium_grid(self, rows, cols) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                list.append(self.lithium_ion().set_x(j).set_y(i))\n        return VGroup(*list).set_x(0).set_y(0)\n\n    def carbon_layer(self) -> Mobject:\n        list = []\n        positions = [\n            [-1.2, 0, 0],\n            [-0.45, 0.4, 0],\n            [0.45, 0.4, 0],\n            [1.2, 0, 0],\n            [0.55, -0.3, 0],\n            [-0.55, -0.3, 0],\n        ]\n        small = [2, 1, 1, 2, 0, 0]\n        for i in range(len(positions)):\n            list.append(Line(positions[i], positions[(i + 1) % len(positions)], color=GREY_B).set_z_index(4))\n            list.append(self.carbon(small[i]).set_x(positions[i][0]).set_y(positions[i][1]))\n        list.append(Polygon(*positions, color=WHITE).set_fill(WHITE, 0.075).set_z_index(-1))\n        return VGroup(*list)\n\n    def lithium_ion(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Li$^+$\", RED_D, 25, WHITE, 1)\n\n    def oxygen(self) -> Mobject:\n        list = []\n        start = 0.3\n        end = 0.6\n        list.append(Line(start=LEFT * start, end=LEFT * end))\n        list.append(Line(start=RIGHT * start, end=RIGHT * end))\n        list.append(Line(start=UP * start, end=UP * end))\n        list.append(Line(start=DOWN * start, end=DOWN * end))\n        list = map(lambda x: x.set_opacity(0.7), list)\n        return VGroup(self.circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n    def metal(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)\n\n    def carbon(self, small: int = False) -> Mobject:\n        return self.circle_with_text(\n            0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n            \"C\",\n            GRAY_B,\n            30 if small == 0 else (24 if small == 1 else 27),\n            WHITE,\n            1,\n        ).set_z_index(5 if small == 1 else 10)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation using ManimCE that shows a point moving along a circular path, while highlighting that the path is a parametric curve defined by a specific mathematical function? Include text explanations to describe the circle's parametric function, explain how the function represents a circle, and show the point tracing the path as the parameter changes from 0 to 2\u03c0. Finally, end the animation with a message stating that parametric curves can describe complex shapes."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation using manimce that shows a point moving along a circular path, while highlighting that the path is a parametric curve defined by a specific mathematical function? include text explanations to describe the circle's parametric function, explain how the function represents a circle, and show the point tracing the path as the parameter changes from 0 to 2\u03c0. finally, end the animation with a message stating that parametric curves can describe complex shapes."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChemistryScene(Scene):\n    def construct(self):\n        # Create grid of lithium ions\n        li_grid = self.lithium_grid(3, 3)\n\n        # Create a single carbon layer\n        carbon_l = self.carbon_layer()\n\n        # Create a molecule of oxygen and a metal\n        oxy = self.oxygen().shift(LEFT * 2)\n        met = self.metal().shift(RIGHT * 2)\n\n        # Animate the objects\n        self.play(FadeIn(li_grid))\n        self.wait(1)\n        self.play(Transform(li_grid, carbon_l))\n        self.wait(1)\n        self.play(FadeIn(oxy), FadeIn(met))\n        self.wait(2)\n\n        # Move the oxygen in a triangle path\n        tri_points = [UP * 2 + LEFT, UP * 2, UP * 2 + RIGHT]\n        oxy_animations = self.move_along_complex_path(oxy, [1], tri_points, run_time=3)\n        self.play(*oxy_animations)\n\n        self.wait(3)\n\n    def move_along_complex_path(self, obj: Mobject, stop_indices, points, run_time: float, rate_func=linear):\n        animations = []\n        paths = []\n        for i in range(len(points) - 1):\n            if i not in stop_indices:\n                paths.append(Line(points[i], points[i + 1]))\n\n        for i in range(len(paths)):\n            animations.append(MoveAlongPath(obj, paths[i], run_time=run_time, rate_func=rate_func))\n\n        return animations\n\n    def lithium_grid(self, rows, cols) -> Mobject:\n        list = []\n        for i in range(rows):\n            for j in range(cols):\n                list.append(self.lithium_ion().set_x(j).set_y(i))\n        return VGroup(*list).set_x(0).set_y(0)\n\n    def carbon_layer(self) -> Mobject:\n        list = []\n        positions = [\n            [-1.2, 0, 0],\n            [-0.45, 0.4, 0],\n            [0.45, 0.4, 0],\n            [1.2, 0, 0],\n            [0.55, -0.3, 0],\n            [-0.55, -0.3, 0],\n        ]\n        small = [2, 1, 1, 2, 0, 0]\n        for i in range(len(positions)):\n            list.append(Line(positions[i], positions[(i + 1) % len(positions)], color=GREY_B).set_z_index(4))\n            list.append(self.carbon(small[i]).set_x(positions[i][0]).set_y(positions[i][1]))\n        list.append(Polygon(*positions, color=WHITE).set_fill(WHITE, 0.075).set_z_index(-1))\n        return VGroup(*list)\n\n    def lithium_ion(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Li$^+$\", RED_D, 25, WHITE, 1)\n\n    def oxygen(self) -> Mobject:\n        list = []\n        start = 0.3\n        end = 0.6\n        list.append(Line(start=LEFT * start, end=LEFT * end))\n        list.append(Line(start=RIGHT * start, end=RIGHT * end))\n        list.append(Line(start=UP * start, end=UP * end))\n        list.append(Line(start=DOWN * start, end=DOWN * end))\n        list = map(lambda x: x.set_opacity(0.7), list)\n        return VGroup(self.circle_with_text(0.285, \"O$^2$\", GREY_B, 25, WHITE, 1), *list)\n\n    def metal(self) -> Mobject:\n        return self.circle_with_text(0.285, \"Co\", BLUE_D, 25, WHITE, 1)\n\n    def circle_with_text(\n        self, r: int, txt: str, color=BLACK, font_size: int = 10, font_color=BLACK, stroke_width: int = 2, fill_color=BLACK\n    ) -> Mobject:\n        c = Circle(r, color).set_opacity(1).set_fill(fill_color)\n        t = Tex(txt, stroke_width=stroke_width, font_size=font_size, color=font_color)\n        return VGroup(c, t)\n\n    def carbon(self, small: int = False) -> Mobject:\n        return self.circle_with_text(\n            0.285 if small == 0 else (0.225 if small == 1 else 0.25),\n            \"C\",\n            GRAY_B,\n            30 if small == 0 else (24 if small == 1 else 27),\n            WHITE,\n            1,\n        ).set_z_index(5 if small == 1 else 10)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation using ManimCE that shows a point moving along a circular path, while highlighting that the path is a parametric curve defined by a specific mathematical function? Include text explanations to describe the circle's parametric function, explain how the function represents a circle, and show the point tracing the path as the parameter changes from 0 to 2\u03c0. Finally, end the animation with a message stating that parametric curves can describe complex shapes."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what scenarios does the Holladay Inequality become an equality, and what does this reveal about combinatorial structures?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HolladayInequalityScene(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Unveiling the Holladay Inequality\")\n        subtitle = Text(\"The Art of Combinatorial Balance\", font_size=36)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        \n        # Clear screen for main content\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introducing the inequality\n        inequality = Text(\"a_i(x) <= b_i(x)\")\n        self.play(Write(inequality))\n        self.wait(1)\n        \n        # Move inequality up to make room\n        self.play(inequality.animate.to_edge(UP))\n        \n        # Explain partitions with simple circles\n        partition_text = Text(\"Partitions\")\n        partition_text.next_to(inequality, DOWN)\n        \n        # Simple circle visualization for partitions\n        circles = VGroup(\n            Circle(radius=0.3, color=BLUE).shift(LEFT * 2),\n            Circle(radius=0.3, color=BLUE),\n            Circle(radius=0.3, color=BLUE).shift(RIGHT * 2)\n        )\n        circles.next_to(partition_text, DOWN)\n        \n        self.play(Write(partition_text))\n        self.play(Create(circles))\n        self.wait(1)\n        \n        # When equality occurs\n        equality_text = Text(\"When Equality Occurs:\")\n        equality_equation = Text(\"a_i(x) = b_1(x) + b_2(x) + ... + b_k(x)\")\n        \n        equality_text.next_to(circles, DOWN, buff=1)\n        equality_equation.next_to(equality_text, DOWN)\n        \n        self.play(Write(equality_text))\n        self.play(Write(equality_equation))\n        self.wait(1)\n        \n        # Visualize balance with squares for binomials\n        squares = VGroup(\n            Square(side_length=0.6, color=GREEN).shift(LEFT * 2),\n            Square(side_length=0.6, color=GREEN),\n            Square(side_length=0.6, color=GREEN).shift(RIGHT * 2)\n        )\n        squares.next_to(equality_equation, DOWN)\n        \n        self.play(Create(squares))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Equality reveals balanced combinatorial structures\")\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            FadeOut(inequality),\n            FadeOut(partition_text),\n            FadeOut(circles),\n            FadeOut(equality_text),\n            FadeOut(equality_equation),\n            FadeOut(squares),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what scenarios does the Holladay Inequality become an equality, and what does this reveal about combinatorial structures?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what scenarios does the holladay inequality become an equality, and what does this reveal about combinatorial structures?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HolladayInequalityScene(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Unveiling the Holladay Inequality\")\n        subtitle = Text(\"The Art of Combinatorial Balance\", font_size=36)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        \n        # Clear screen for main content\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Introducing the inequality\n        inequality = Text(\"a_i(x) <= b_i(x)\")\n        self.play(Write(inequality))\n        self.wait(1)\n        \n        # Move inequality up to make room\n        self.play(inequality.animate.to_edge(UP))\n        \n        # Explain partitions with simple circles\n        partition_text = Text(\"Partitions\")\n        partition_text.next_to(inequality, DOWN)\n        \n        # Simple circle visualization for partitions\n        circles = VGroup(\n            Circle(radius=0.3, color=BLUE).shift(LEFT * 2),\n            Circle(radius=0.3, color=BLUE),\n            Circle(radius=0.3, color=BLUE).shift(RIGHT * 2)\n        )\n        circles.next_to(partition_text, DOWN)\n        \n        self.play(Write(partition_text))\n        self.play(Create(circles))\n        self.wait(1)\n        \n        # When equality occurs\n        equality_text = Text(\"When Equality Occurs:\")\n        equality_equation = Text(\"a_i(x) = b_1(x) + b_2(x) + ... + b_k(x)\")\n        \n        equality_text.next_to(circles, DOWN, buff=1)\n        equality_equation.next_to(equality_text, DOWN)\n        \n        self.play(Write(equality_text))\n        self.play(Write(equality_equation))\n        self.wait(1)\n        \n        # Visualize balance with squares for binomials\n        squares = VGroup(\n            Square(side_length=0.6, color=GREEN).shift(LEFT * 2),\n            Square(side_length=0.6, color=GREEN),\n            Square(side_length=0.6, color=GREEN).shift(RIGHT * 2)\n        )\n        squares.next_to(equality_equation, DOWN)\n        \n        self.play(Create(squares))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Equality reveals balanced combinatorial structures\")\n        conclusion.to_edge(DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(\n            FadeOut(inequality),\n            FadeOut(partition_text),\n            FadeOut(circles),\n            FadeOut(equality_text),\n            FadeOut(equality_equation),\n            FadeOut(squares),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what scenarios does the Holladay Inequality become an equality, and what does this reveal about combinatorial structures?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually explains how to solve the definite integral of x^3 from 0 to 3 using the power rule of integration, and includes the following steps: introducing the problem, explaining the power rule, demonstrating how to apply the rule to our specific problem, evaluating the integral at the upper and lower limits, and presenting the final numerical solution?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Positioning(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        self.add(plane)\n\n        # next_to from episode 1\n        red_dot = Dot(color=RED)\n        green_dot = Dot(color=GREEN)\n        green_dot.next_to(red_dot, RIGHT + UP)  # RIGHT == [1, 0, 0]\n        self.add(red_dot, green_dot)\n\n        # shift\n        s = Square(color=ORANGE)\n        s.shift(2*UP + 4*RIGHT)\n        self.add(s)\n\n        # move_to\n        c = Circle(color=PURPLE)\n        c.move_to([-3, -2, 0])\n        self.add(c)\n\n        # align_to\n        c2 = Circle(radius=0.5, color=RED, fill_opacity=0.5)\n        c3 = c2.copy().set_color(YELLOW)\n        c4 = c2.copy().set_color(ORANGE)\n        c2.align_to(s, UP)\n        c3.align_to(s, RIGHT)\n        c4.align_to(s, UP + RIGHT)\n        self.add(c2, c3, c4)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually explains how to solve the definite integral of x^3 from 0 to 3 using the power rule of integration, and includes the following steps: introducing the problem, explaining the power rule, demonstrating how to apply the rule to our specific problem, evaluating the integral at the upper and lower limits, and presenting the final numerical solution?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually explains how to solve the definite integral of x^3 from 0 to 3 using the power rule of integration, and includes the following steps: introducing the problem, explaining the power rule, demonstrating how to apply the rule to our specific problem, evaluating the integral at the upper and lower limits, and presenting the final numerical solution?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Positioning(Scene):\n    def construct(self):\n        plane = NumberPlane()\n        self.add(plane)\n\n        # next_to from episode 1\n        red_dot = Dot(color=RED)\n        green_dot = Dot(color=GREEN)\n        green_dot.next_to(red_dot, RIGHT + UP)  # RIGHT == [1, 0, 0]\n        self.add(red_dot, green_dot)\n\n        # shift\n        s = Square(color=ORANGE)\n        s.shift(2*UP + 4*RIGHT)\n        self.add(s)\n\n        # move_to\n        c = Circle(color=PURPLE)\n        c.move_to([-3, -2, 0])\n        self.add(c)\n\n        # align_to\n        c2 = Circle(radius=0.5, color=RED, fill_opacity=0.5)\n        c3 = c2.copy().set_color(YELLOW)\n        c4 = c2.copy().set_color(ORANGE)\n        c2.align_to(s, UP)\n        c3.align_to(s, RIGHT)\n        c4.align_to(s, UP + RIGHT)\n        self.add(c2, c3, c4)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually explains how to solve the definite integral of x^3 from 0 to 3 using the power rule of integration, and includes the following steps: introducing the problem, explaining the power rule, demonstrating how to apply the rule to our specific problem, evaluating the integral at the upper and lower limits, and presenting the final numerical solution?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually demonstrates how to calculate the area under the curve y=x^2 from x=1 to x=3. Can we start by presenting the integral problem on the screen, followed by a step-by-step explanation that includes setting up the integral, performing the integration, and explaining the process of evaluating the integral at the upper and lower bounds? Finally, can we show the final solution, clear the scene, and then conclude by highlighting the final solution again?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Introduce the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2}\", \"=\",\n                          \"c^2\", r\"\\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Discuss the equation\n        eq_description = Text(\n            \"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(eq_description, shift=UP))\n        self.wait(2)\n\n        # Show the general solution to the equation\n        gen_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, gen_solution))\n        self.wait(2)\n\n        # Describe the general solution\n        solution_description = Text(\n            \"The solution represents traveling waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(eq_description, solution_description))\n        self.wait(2)\n\n        # Discuss characteristic lines\n        char_lines = MathTex(r\"x - ct = k_1, x + ct = k_2\",\n                             tex_environment=\"align*\")\n        self.play(FadeOut(eq_description), FadeOut(wave_eq), FadeIn(char_lines))\n        self.wait(2)\n\n        # Explain characteristic lines\n        char_lines_description = Text(\n            \"Characteristic lines of the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(char_lines_description))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.play(FadeIn(char_lines_description), FadeIn(char_lines))\n        self.wait(1)\n        self.play(FadeOut(char_lines_description), FadeOut(char_lines))\n        self.wait(1)\n\n        # Show initial and boundary conditions\n        init_boundary_conditions = Text(\n            \"Solutions also require initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Write(init_boundary_conditions))\n        self.wait(3)\n\n        # Conclude the scene\n        self.play(FadeOut(init_boundary_conditions))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually demonstrates how to calculate the area under the curve y=x^2 from x=1 to x=3. Can we start by presenting the integral problem on the screen, followed by a step-by-step explanation that includes setting up the integral, performing the integration, and explaining the process of evaluating the integral at the upper and lower bounds? Finally, can we show the final solution, clear the scene, and then conclude by highlighting the final solution again?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually demonstrates how to calculate the area under the curve y=x^2 from x=1 to x=3. can we start by presenting the integral problem on the screen, followed by a step-by-step explanation that includes setting up the integral, performing the integration, and explaining the process of evaluating the integral at the upper and lower bounds? finally, can we show the final solution, clear the scene, and then conclude by highlighting the final solution again?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationScene(Scene):\n    def construct(self):\n        # Introduce the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2}\", \"=\",\n                          \"c^2\", r\"\\frac{\\partial^2 u}{\\partial x^2}\")\n        self.play(Write(wave_eq))\n        self.wait(2)\n\n        # Discuss the equation\n        eq_description = Text(\n            \"This is the one-dimensional wave equation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(eq_description, shift=UP))\n        self.wait(2)\n\n        # Show the general solution to the equation\n        gen_solution = MathTex(r\"u(x, t) = f(x - ct) + g(x + ct)\")\n        self.play(Transform(wave_eq, gen_solution))\n        self.wait(2)\n\n        # Describe the general solution\n        solution_description = Text(\n            \"The solution represents traveling waves.\", font_size=24).to_edge(UP)\n        self.play(Transform(eq_description, solution_description))\n        self.wait(2)\n\n        # Discuss characteristic lines\n        char_lines = MathTex(r\"x - ct = k_1, x + ct = k_2\",\n                             tex_environment=\"align*\")\n        self.play(FadeOut(eq_description), FadeOut(wave_eq), FadeIn(char_lines))\n        self.wait(2)\n\n        # Explain characteristic lines\n        char_lines_description = Text(\n            \"Characteristic lines of the wave equation.\", font_size=24).to_edge(UP)\n        self.play(Write(char_lines_description))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.play(FadeIn(char_lines_description), FadeIn(char_lines))\n        self.wait(1)\n        self.play(FadeOut(char_lines_description), FadeOut(char_lines))\n        self.wait(1)\n\n        # Show initial and boundary conditions\n        init_boundary_conditions = Text(\n            \"Solutions also require initial and boundary conditions.\", font_size=24).to_edge(UP)\n        self.play(Write(init_boundary_conditions))\n        self.wait(3)\n\n        # Conclude the scene\n        self.play(FadeOut(init_boundary_conditions))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually demonstrates how to calculate the area under the curve y=x^2 from x=1 to x=3. Can we start by presenting the integral problem on the screen, followed by a step-by-step explanation that includes setting up the integral, performing the integration, and explaining the process of evaluating the integral at the upper and lower bounds? Finally, can we show the final solution, clear the scene, and then conclude by highlighting the final solution again?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated educational video that explains how to solve the first order ordinary differential equation y' - 3y = 0 using the separation of variables method, including steps to integrate and solve for y to find the general solution, and display this process step-by-step with equations, while providing brief textual explanations of each step at the top of the screen?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass Introduction(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = VGroup(\n            Tex(\"Sequ\u00eancias\"), \n            Tex(\"Num\u00e9ricas\")\n        )\n        title.arrange(DOWN)\n\n        inner_box = Square(2.7, stroke_color=WHITE)\n        outer_box = Square(3.7, color=RED, fill_opacity=1, stroke_color=WHITE)\n\n        number_group_1 = ImageMobject(\"./assets/NumberGroup1.png\")\n        number_group_1.next_to(outer_box, LEFT)\n        number_group_1.shift(7 * UP + 1.7 * RIGHT)\n        number_group_1.scale(0.4)\n\n        number_group_2 = ImageMobject(\"./assets/NumberGroup2.png\")\n        number_group_2.next_to(outer_box, RIGHT)\n        number_group_2.shift(7 * UP + 2.1 * LEFT)\n        number_group_2.scale(0.4)\n\n        rectangle_group_1 = Rectangle(color=RED, height=0.05, width=2, fill_opacity=1)\n        rectangle_group_1.next_to(outer_box, LEFT)\n        rectangle_group_1.shift(0.6 * UP + 0.2 * RIGHT)\n\n        rectangle_group_2 = Rectangle(color=RED, height=0.05, width=2.5, fill_opacity=1)\n        rectangle_group_2.next_to(outer_box, RIGHT)\n        rectangle_group_2.shift(0.6 * DOWN + 0.2 * LEFT)\n        \n\n        self.play(\n            FadeIn(rectangle_group_1),\n            FadeIn(rectangle_group_2),\n            FadeIn(outer_box),\n            FadeIn(inner_box),\n            FadeIn(title)\n        )\n        self.play(\n            number_group_1.animate.shift(6 * DOWN), \n            rate_func=rate_functions.rush_from\n        )\n        self.wait(0.8)\n        self.play(\n            number_group_2.animate.shift(7.2 * DOWN), \n            rate_func=rate_functions.rush_from, \n            run_time=1.2\n        )\n        self.wait(1.5)\n        self.play(*[\n            mobject.animate(rate_func=running_start, run_time=1.3).shift(LEFT * 15) \n            for mobject in self.mobjects\n        ])\n        self.remove(*self.mobjects)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated educational video that explains how to solve the first order ordinary differential equation y' - 3y = 0 using the separation of variables method, including steps to integrate and solve for y to find the general solution, and display this process step-by-step with equations, while providing brief textual explanations of each step at the top of the screen?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated educational video that explains how to solve the first order ordinary differential equation y' - 3y = 0 using the separation of variables method, including steps to integrate and solve for y to find the general solution, and display this process step-by-step with equations, while providing brief textual explanations of each step at the top of the screen?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\n\ndef running_start(t):\n    return rate_functions.running_start(t, -0.3)\n\ndef FibonacciSquare(size, color):\n    rect = Square(size / 5, color=color)\n\n    text = Tex(f\"{size}\", color=color)\n    text.scale(3 * min(1, size / 12))\n    text.move_to(rect)\n\n    return Group(rect, text)\n\nfrom manim import *\nfrom utils import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass Introduction(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = VGroup(\n            Tex(\"Sequ\u00eancias\"), \n            Tex(\"Num\u00e9ricas\")\n        )\n        title.arrange(DOWN)\n\n        inner_box = Square(2.7, stroke_color=WHITE)\n        outer_box = Square(3.7, color=RED, fill_opacity=1, stroke_color=WHITE)\n\n        number_group_1 = ImageMobject(\"./assets/NumberGroup1.png\")\n        number_group_1.next_to(outer_box, LEFT)\n        number_group_1.shift(7 * UP + 1.7 * RIGHT)\n        number_group_1.scale(0.4)\n\n        number_group_2 = ImageMobject(\"./assets/NumberGroup2.png\")\n        number_group_2.next_to(outer_box, RIGHT)\n        number_group_2.shift(7 * UP + 2.1 * LEFT)\n        number_group_2.scale(0.4)\n\n        rectangle_group_1 = Rectangle(color=RED, height=0.05, width=2, fill_opacity=1)\n        rectangle_group_1.next_to(outer_box, LEFT)\n        rectangle_group_1.shift(0.6 * UP + 0.2 * RIGHT)\n\n        rectangle_group_2 = Rectangle(color=RED, height=0.05, width=2.5, fill_opacity=1)\n        rectangle_group_2.next_to(outer_box, RIGHT)\n        rectangle_group_2.shift(0.6 * DOWN + 0.2 * LEFT)\n        \n\n        self.play(\n            FadeIn(rectangle_group_1),\n            FadeIn(rectangle_group_2),\n            FadeIn(outer_box),\n            FadeIn(inner_box),\n            FadeIn(title)\n        )\n        self.play(\n            number_group_1.animate.shift(6 * DOWN), \n            rate_func=rate_functions.rush_from\n        )\n        self.wait(0.8)\n        self.play(\n            number_group_2.animate.shift(7.2 * DOWN), \n            rate_func=rate_functions.rush_from, \n            run_time=1.2\n        )\n        self.wait(1.5)\n        self.play(*[\n            mobject.animate(rate_func=running_start, run_time=1.3).shift(LEFT * 15) \n            for mobject in self.mobjects\n        ])\n        self.remove(*self.mobjects)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated educational video that explains how to solve the first order ordinary differential equation y' - 3y = 0 using the separation of variables method, including steps to integrate and solve for y to find the general solution, and display this process step-by-step with equations, while providing brief textual explanations of each step at the top of the screen?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can we represent the reciprocity law through a 3D lattice visualization, where dimensions represent different primes and coordinates capture residue relationships?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QuadraticReciprocityScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Exploring Quadratic Reciprocity in 3D\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.shift(UP * 3))\n        \n        # Explanation of quadratic residues\n        explanation = Text(\"For a prime p, n is a quadratic residue if:\")\n        explanation.scale(0.7)\n        explanation.shift(UP * 1.5)\n        \n        # First equation - simplified\n        equation = Text(\"x\u00b2 \u2261 n (mod p)\")\n        equation.shift(UP * 0.5)\n        \n        self.play(Write(explanation))\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Clear screen for lattice visualization\n        self.play(\n            FadeOut(explanation),\n            FadeOut(equation)\n        )\n        \n        # Create a simplified \"3D\" lattice representation\n        dots = VGroup()\n        \n        # Create a grid of dots (3\u00d73)\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                dot = Dot(point=[i, j, 0])\n                dots.add(dot)\n        \n        # Add axis labels\n        x_label = Text(\"Prime p\").scale(0.5)\n        x_label.shift(RIGHT * 2)\n        \n        y_label = Text(\"Prime q\").scale(0.5)\n        y_label.shift(UP * 2)\n        \n        z_label = Text(\"Residues\").scale(0.5)\n        z_label.shift(LEFT * 2 + UP * 1)\n        \n        # Show the grid\n        self.play(Create(dots))\n        self.play(\n            Write(x_label),\n            Write(y_label),\n            Write(z_label)\n        )\n        self.wait(1)\n        \n        # Highlight certain dots to represent special residue relationships\n        highlighted_dots = []\n        highlight_positions = [(1, 1), (-1, 1), (0, -1)]\n        \n        for pos in highlight_positions:\n            i, j = pos\n            dot = Dot(point=[i, j, 0], color=YELLOW)\n            highlighted_dots.append(dot)\n        \n        self.play(*[FadeIn(dot) for dot in highlighted_dots])\n        self.wait(1)\n        \n        # Connect the dots to show relationships\n        lines = []\n        for i in range(len(highlighted_dots) - 1):\n            line = Line(\n                highlighted_dots[i].get_center(),\n                highlighted_dots[i+1].get_center(),\n                color=YELLOW\n            )\n            lines.append(line)\n        \n        self.play(*[Create(line) for line in lines])\n        self.wait(1)\n        \n        # Second equation - Fermat's Little Theorem (related to residues)\n        eq2 = Text(\"a^p \u2261 a (mod p)\")\n        eq2.shift(DOWN * 1.5)\n        \n        # Third equation - Simplified representation of quadratic reciprocity\n        eq3 = Text(\"x\u00b2 \u2261 y\u00b2 (mod p)\")\n        eq3.shift(DOWN * 2.5)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        self.play(Write(eq3))\n        self.wait(1)\n        \n        # Final message\n        final_msg = Text(\"The symmetry of reciprocity revealed in 3D\")\n        final_msg.scale(0.6)\n        final_msg.shift(DOWN * 3.5)\n        \n        self.play(Write(final_msg))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects]\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we represent the reciprocity law through a 3D lattice visualization, where dimensions represent different primes and coordinates capture residue relationships?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can we represent the reciprocity law through a 3d lattice visualization, where dimensions represent different primes and coordinates capture residue relationships?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QuadraticReciprocityScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Exploring Quadratic Reciprocity in 3D\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.shift(UP * 3))\n        \n        # Explanation of quadratic residues\n        explanation = Text(\"For a prime p, n is a quadratic residue if:\")\n        explanation.scale(0.7)\n        explanation.shift(UP * 1.5)\n        \n        # First equation - simplified\n        equation = Text(\"x\u00b2 \u2261 n (mod p)\")\n        equation.shift(UP * 0.5)\n        \n        self.play(Write(explanation))\n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Clear screen for lattice visualization\n        self.play(\n            FadeOut(explanation),\n            FadeOut(equation)\n        )\n        \n        # Create a simplified \"3D\" lattice representation\n        dots = VGroup()\n        \n        # Create a grid of dots (3\u00d73)\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                dot = Dot(point=[i, j, 0])\n                dots.add(dot)\n        \n        # Add axis labels\n        x_label = Text(\"Prime p\").scale(0.5)\n        x_label.shift(RIGHT * 2)\n        \n        y_label = Text(\"Prime q\").scale(0.5)\n        y_label.shift(UP * 2)\n        \n        z_label = Text(\"Residues\").scale(0.5)\n        z_label.shift(LEFT * 2 + UP * 1)\n        \n        # Show the grid\n        self.play(Create(dots))\n        self.play(\n            Write(x_label),\n            Write(y_label),\n            Write(z_label)\n        )\n        self.wait(1)\n        \n        # Highlight certain dots to represent special residue relationships\n        highlighted_dots = []\n        highlight_positions = [(1, 1), (-1, 1), (0, -1)]\n        \n        for pos in highlight_positions:\n            i, j = pos\n            dot = Dot(point=[i, j, 0], color=YELLOW)\n            highlighted_dots.append(dot)\n        \n        self.play(*[FadeIn(dot) for dot in highlighted_dots])\n        self.wait(1)\n        \n        # Connect the dots to show relationships\n        lines = []\n        for i in range(len(highlighted_dots) - 1):\n            line = Line(\n                highlighted_dots[i].get_center(),\n                highlighted_dots[i+1].get_center(),\n                color=YELLOW\n            )\n            lines.append(line)\n        \n        self.play(*[Create(line) for line in lines])\n        self.wait(1)\n        \n        # Second equation - Fermat's Little Theorem (related to residues)\n        eq2 = Text(\"a^p \u2261 a (mod p)\")\n        eq2.shift(DOWN * 1.5)\n        \n        # Third equation - Simplified representation of quadratic reciprocity\n        eq3 = Text(\"x\u00b2 \u2261 y\u00b2 (mod p)\")\n        eq3.shift(DOWN * 2.5)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        self.play(Write(eq3))\n        self.wait(1)\n        \n        # Final message\n        final_msg = Text(\"The symmetry of reciprocity revealed in 3D\")\n        final_msg.scale(0.6)\n        final_msg.shift(DOWN * 3.5)\n        \n        self.play(Write(final_msg))\n        self.wait(2)\n        \n        # Fade everything out\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects]\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we represent the reciprocity law through a 3D lattice visualization, where dimensions represent different primes and coordinates capture residue relationships?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the application of perturbation theory allow us to envision changes in energy levels of an electron in a hydrogen atom subjected to an external electric field?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PerturbationTheoryScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unveiling the Stark Effect\", font_size=32)\n        subtitle = Text(\"Perturbation Theory in Action\", font_size=24).next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: Hydrogen atom visualization\n        # Create a simple hydrogen atom (nucleus + electron)\n        nucleus = Dot(color=RED)\n        electron_orbit = Circle(radius=1, color=BLUE)\n        electron = Dot(color=BLUE).move_to(electron_orbit.point_at_angle(0))\n        \n        atom_group = VGroup(nucleus, electron_orbit, electron)\n        atom_label = Text(\"Hydrogen Atom\", font_size=24).next_to(atom_group, DOWN)\n        \n        # Animate the atom creation\n        self.play(Create(nucleus))\n        self.play(Create(electron_orbit))\n        self.play(Create(electron))\n        self.play(Write(atom_label))\n        \n        # Simple electron movement\n        self.play(electron.animate.move_to(electron_orbit.point_at_angle(PI)), run_time=1)\n        self.play(electron.animate.move_to(electron_orbit.point_at_angle(2*PI)), run_time=1)\n        self.wait(1)\n        \n        # Key Concept 2: External electric field\n        field_label = Text(\"External Electric Field\", font_size=24).to_edge(UP)\n        \n        # Simple arrows to represent the electric field\n        field_arrow1 = Arrow(LEFT * 3, LEFT, buff=0, color=YELLOW)\n        field_arrow2 = Arrow(RIGHT * 3, RIGHT, buff=0, color=YELLOW)\n        \n        # Show the electric field\n        self.play(Write(field_label))\n        self.play(Create(field_arrow1), Create(field_arrow2))\n        self.wait(1)\n        \n        # Clear screen for energy levels\n        self.play(\n            FadeOut(atom_group),\n            FadeOut(atom_label),\n            FadeOut(field_arrow1),\n            FadeOut(field_arrow2),\n            FadeOut(field_label)\n        )\n        \n        # Key Concept 3: Energy levels before perturbation\n        energy_title = Text(\"Unperturbed Energy Levels\", font_size=28).to_edge(UP)\n        \n        # Create three horizontal lines for energy levels\n        energy_levels = VGroup()\n        for i in range(3):\n            level = Line(LEFT * 2, RIGHT * 2, color=BLUE).shift(UP * (i + 1))\n            label = Text(f\"E_{i+1}\", font_size=24).next_to(level, LEFT)\n            energy_levels.add(VGroup(level, label))\n        \n        # Show the energy levels\n        self.play(Write(energy_title))\n        self.play(Create(energy_levels))\n        self.wait(1)\n        \n        # Show the perturbation equation\n        equation = MathTex(\"E_n = E_n^0 + \\\\epsilon E_n^1\").shift(DOWN * 2)\n        eq_label = Text(\"Perturbation Theory\", font_size=24).next_to(equation, DOWN)\n        \n        self.play(Write(equation))\n        self.play(Write(eq_label))\n        self.wait(1)\n        \n        # Key Insight: The Stark effect - energy level splitting\n        stark_title = Text(\"The Stark Effect\", font_size=28).to_edge(UP)\n        \n        # Change the title\n        self.play(\n            FadeOut(equation),\n            FadeOut(eq_label),\n            Transform(energy_title, stark_title)\n        )\n        \n        # Demonstrate energy level splitting for the middle level (E_2)\n        middle_level = energy_levels[1][0]  # The line for E_2\n        middle_label = energy_levels[1][1]  # The label for E_2\n        \n        # Create two new levels that show the split\n        upper_level = Line(LEFT * 2, RIGHT * 2, color=BLUE_D).shift(UP * 2.2)\n        lower_level = Line(LEFT * 2, RIGHT * 2, color=BLUE_D).shift(UP * 1.8)\n        \n        upper_label = Text(\"E_2'\", font_size=24).next_to(upper_level, LEFT)\n        lower_label = Text(\"E_2''\", font_size=24).next_to(lower_level, LEFT)\n        \n        # Animate the splitting\n        self.play(\n            Transform(middle_level, upper_level),\n            Transform(middle_label, upper_label)\n        )\n        \n        self.play(\n            Create(lower_level),\n            Write(lower_label)\n        )\n        \n        # Add a label explaining the splitting\n        split_label = Text(\"Energy Levels Split\", font_size=24).next_to(lower_level, RIGHT)\n        self.play(Write(split_label))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(energy_levels),\n            FadeOut(lower_level),\n            FadeOut(lower_label),\n            FadeOut(split_label),\n            FadeOut(energy_title)\n        )\n        \n        # Final message\n        conclusion = Text(\"Perturbation Theory\", font_size=32)\n        conclusion2 = Text(\"Unveiling Quantum Effects\", font_size=28).next_to(conclusion, DOWN)\n        \n        self.play(Write(conclusion))\n        self.play(Write(conclusion2))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(conclusion2))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the application of perturbation theory allow us to envision changes in energy levels of an electron in a hydrogen atom subjected to an external electric field?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the application of perturbation theory allow us to envision changes in energy levels of an electron in a hydrogen atom subjected to an external electric field?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PerturbationTheoryScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unveiling the Stark Effect\", font_size=32)\n        subtitle = Text(\"Perturbation Theory in Action\", font_size=24).next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: Hydrogen atom visualization\n        # Create a simple hydrogen atom (nucleus + electron)\n        nucleus = Dot(color=RED)\n        electron_orbit = Circle(radius=1, color=BLUE)\n        electron = Dot(color=BLUE).move_to(electron_orbit.point_at_angle(0))\n        \n        atom_group = VGroup(nucleus, electron_orbit, electron)\n        atom_label = Text(\"Hydrogen Atom\", font_size=24).next_to(atom_group, DOWN)\n        \n        # Animate the atom creation\n        self.play(Create(nucleus))\n        self.play(Create(electron_orbit))\n        self.play(Create(electron))\n        self.play(Write(atom_label))\n        \n        # Simple electron movement\n        self.play(electron.animate.move_to(electron_orbit.point_at_angle(PI)), run_time=1)\n        self.play(electron.animate.move_to(electron_orbit.point_at_angle(2*PI)), run_time=1)\n        self.wait(1)\n        \n        # Key Concept 2: External electric field\n        field_label = Text(\"External Electric Field\", font_size=24).to_edge(UP)\n        \n        # Simple arrows to represent the electric field\n        field_arrow1 = Arrow(LEFT * 3, LEFT, buff=0, color=YELLOW)\n        field_arrow2 = Arrow(RIGHT * 3, RIGHT, buff=0, color=YELLOW)\n        \n        # Show the electric field\n        self.play(Write(field_label))\n        self.play(Create(field_arrow1), Create(field_arrow2))\n        self.wait(1)\n        \n        # Clear screen for energy levels\n        self.play(\n            FadeOut(atom_group),\n            FadeOut(atom_label),\n            FadeOut(field_arrow1),\n            FadeOut(field_arrow2),\n            FadeOut(field_label)\n        )\n        \n        # Key Concept 3: Energy levels before perturbation\n        energy_title = Text(\"Unperturbed Energy Levels\", font_size=28).to_edge(UP)\n        \n        # Create three horizontal lines for energy levels\n        energy_levels = VGroup()\n        for i in range(3):\n            level = Line(LEFT * 2, RIGHT * 2, color=BLUE).shift(UP * (i + 1))\n            label = Text(f\"E_{i+1}\", font_size=24).next_to(level, LEFT)\n            energy_levels.add(VGroup(level, label))\n        \n        # Show the energy levels\n        self.play(Write(energy_title))\n        self.play(Create(energy_levels))\n        self.wait(1)\n        \n        # Show the perturbation equation\n        equation = MathTex(\"E_n = E_n^0 + \\\\epsilon E_n^1\").shift(DOWN * 2)\n        eq_label = Text(\"Perturbation Theory\", font_size=24).next_to(equation, DOWN)\n        \n        self.play(Write(equation))\n        self.play(Write(eq_label))\n        self.wait(1)\n        \n        # Key Insight: The Stark effect - energy level splitting\n        stark_title = Text(\"The Stark Effect\", font_size=28).to_edge(UP)\n        \n        # Change the title\n        self.play(\n            FadeOut(equation),\n            FadeOut(eq_label),\n            Transform(energy_title, stark_title)\n        )\n        \n        # Demonstrate energy level splitting for the middle level (E_2)\n        middle_level = energy_levels[1][0]  # The line for E_2\n        middle_label = energy_levels[1][1]  # The label for E_2\n        \n        # Create two new levels that show the split\n        upper_level = Line(LEFT * 2, RIGHT * 2, color=BLUE_D).shift(UP * 2.2)\n        lower_level = Line(LEFT * 2, RIGHT * 2, color=BLUE_D).shift(UP * 1.8)\n        \n        upper_label = Text(\"E_2'\", font_size=24).next_to(upper_level, LEFT)\n        lower_label = Text(\"E_2''\", font_size=24).next_to(lower_level, LEFT)\n        \n        # Animate the splitting\n        self.play(\n            Transform(middle_level, upper_level),\n            Transform(middle_label, upper_label)\n        )\n        \n        self.play(\n            Create(lower_level),\n            Write(lower_label)\n        )\n        \n        # Add a label explaining the splitting\n        split_label = Text(\"Energy Levels Split\", font_size=24).next_to(lower_level, RIGHT)\n        self.play(Write(split_label))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(energy_levels),\n            FadeOut(lower_level),\n            FadeOut(lower_label),\n            FadeOut(split_label),\n            FadeOut(energy_title)\n        )\n        \n        # Final message\n        conclusion = Text(\"Perturbation Theory\", font_size=32)\n        conclusion2 = Text(\"Unveiling Quantum Effects\", font_size=28).next_to(conclusion, DOWN)\n        \n        self.play(Write(conclusion))\n        self.play(Write(conclusion2))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(conclusion2))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the application of perturbation theory allow us to envision changes in energy levels of an electron in a hydrogen atom subjected to an external electric field?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the computational complexity of determining singular Betti numbers contrast with regular topological Betti numbers for a given algebraic variety?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BettiNumbersComplexity(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Complexity of Betti Numbers\", font_size=36)\n        subtitle = Text(\"A Journey Through Singularities\", font_size=28)\n        \n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        self.play(Write(subtitle.next_to(title, DOWN)))\n        self.wait(2)\n        \n        # Introduction\n        intro = Text(\"Betti numbers measure 'holes' in different dimensions\", font_size=28)\n        self.play(FadeOut(subtitle), Write(intro.next_to(title, DOWN)))\n        self.wait(2)\n        \n        # Visual 1: Smooth surface vs Surface with singularity\n        self.play(FadeOut(intro))\n        \n        # Smooth surface (represented by a circle)\n        smooth_surface = Circle(radius=2, color=BLUE)\n        smooth_label = Text(\"Regular Variety\", font_size=24).next_to(smooth_surface, DOWN)\n        \n        self.play(Create(smooth_surface))\n        self.play(Write(smooth_label))\n        self.wait(2)\n        \n        # Add a spike to represent singularity\n        spike = Triangle(color=RED).scale(0.4).move_to(smooth_surface.point_at_angle(PI/4))\n        singular_label = Text(\"Singular Variety\", font_size=24).next_to(smooth_surface, DOWN)\n        \n        self.play(Create(spike))\n        self.play(FadeOut(smooth_label), Write(singular_label))\n        self.wait(2)\n        \n        # Clear and show equations\n        self.play(FadeOut(smooth_surface), FadeOut(spike), FadeOut(singular_label))\n        \n        # Simplified equations\n        eq1 = Text(\"\u03b2_k = rank(H_k(X))\", font_size=36)\n        eq2 = Text(\"\u03b2_k^sing = rank(H_k^sing(X))\", font_size=36)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(eq1.animate.shift(UP))\n        self.play(Write(eq2.next_to(eq1, DOWN, buff=0.5)))\n        self.wait(2)\n        \n        # Visual comparison of computational complexity\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        # Simple vs complex computation visualization\n        easy_comp = Square(side_length=2, color=BLUE)\n        hard_comp = RegularPolygon(n=8, color=RED).scale(2)\n        \n        easy_label = Text(\"Regular: Simpler Computation\", font_size=22).next_to(easy_comp, DOWN)\n        hard_label = Text(\"Singular: Complex Computation\", font_size=22).next_to(hard_comp, DOWN)\n        \n        # Position the shapes and labels\n        easy_comp.move_to(LEFT * 3)\n        easy_label.move_to(LEFT * 3 + DOWN * 2.5)\n        hard_comp.move_to(RIGHT * 3)\n        hard_label.move_to(RIGHT * 3 + DOWN * 2.5)\n        \n        self.play(Create(easy_comp))\n        self.play(Write(easy_label))\n        self.wait(1)\n        self.play(Create(hard_comp))\n        self.play(Write(hard_label))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(easy_comp),\n            FadeOut(easy_label),\n            FadeOut(hard_comp),\n            FadeOut(hard_label)\n        )\n        \n        conclusion = Text(\n            \"Singularities transform our computational approach\", \n            font_size=28\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        final = Text(\"The Beauty of Mathematical Complexity\", font_size=32)\n        self.play(FadeOut(conclusion))\n        self.play(Write(final))\n        self.wait(2)\n        self.play(FadeOut(final), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the computational complexity of determining singular Betti numbers contrast with regular topological Betti numbers for a given algebraic variety?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the computational complexity of determining singular betti numbers contrast with regular topological betti numbers for a given algebraic variety?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BettiNumbersComplexity(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Complexity of Betti Numbers\", font_size=36)\n        subtitle = Text(\"A Journey Through Singularities\", font_size=28)\n        \n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        self.play(Write(subtitle.next_to(title, DOWN)))\n        self.wait(2)\n        \n        # Introduction\n        intro = Text(\"Betti numbers measure 'holes' in different dimensions\", font_size=28)\n        self.play(FadeOut(subtitle), Write(intro.next_to(title, DOWN)))\n        self.wait(2)\n        \n        # Visual 1: Smooth surface vs Surface with singularity\n        self.play(FadeOut(intro))\n        \n        # Smooth surface (represented by a circle)\n        smooth_surface = Circle(radius=2, color=BLUE)\n        smooth_label = Text(\"Regular Variety\", font_size=24).next_to(smooth_surface, DOWN)\n        \n        self.play(Create(smooth_surface))\n        self.play(Write(smooth_label))\n        self.wait(2)\n        \n        # Add a spike to represent singularity\n        spike = Triangle(color=RED).scale(0.4).move_to(smooth_surface.point_at_angle(PI/4))\n        singular_label = Text(\"Singular Variety\", font_size=24).next_to(smooth_surface, DOWN)\n        \n        self.play(Create(spike))\n        self.play(FadeOut(smooth_label), Write(singular_label))\n        self.wait(2)\n        \n        # Clear and show equations\n        self.play(FadeOut(smooth_surface), FadeOut(spike), FadeOut(singular_label))\n        \n        # Simplified equations\n        eq1 = Text(\"\u03b2_k = rank(H_k(X))\", font_size=36)\n        eq2 = Text(\"\u03b2_k^sing = rank(H_k^sing(X))\", font_size=36)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(eq1.animate.shift(UP))\n        self.play(Write(eq2.next_to(eq1, DOWN, buff=0.5)))\n        self.wait(2)\n        \n        # Visual comparison of computational complexity\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        # Simple vs complex computation visualization\n        easy_comp = Square(side_length=2, color=BLUE)\n        hard_comp = RegularPolygon(n=8, color=RED).scale(2)\n        \n        easy_label = Text(\"Regular: Simpler Computation\", font_size=22).next_to(easy_comp, DOWN)\n        hard_label = Text(\"Singular: Complex Computation\", font_size=22).next_to(hard_comp, DOWN)\n        \n        # Position the shapes and labels\n        easy_comp.move_to(LEFT * 3)\n        easy_label.move_to(LEFT * 3 + DOWN * 2.5)\n        hard_comp.move_to(RIGHT * 3)\n        hard_label.move_to(RIGHT * 3 + DOWN * 2.5)\n        \n        self.play(Create(easy_comp))\n        self.play(Write(easy_label))\n        self.wait(1)\n        self.play(Create(hard_comp))\n        self.play(Write(hard_label))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(easy_comp),\n            FadeOut(easy_label),\n            FadeOut(hard_comp),\n            FadeOut(hard_label)\n        )\n        \n        conclusion = Text(\n            \"Singularities transform our computational approach\", \n            font_size=28\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        final = Text(\"The Beauty of Mathematical Complexity\", font_size=32)\n        self.play(FadeOut(conclusion))\n        self.play(Write(final))\n        self.wait(2)\n        self.play(FadeOut(final), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the computational complexity of determining singular Betti numbers contrast with regular topological Betti numbers for a given algebraic variety?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animation where a text element first transforms into the words \"GrowFromPoint\" and moves upwards on the screen, then a dot appears in the upper right area, followed by a star that appears to grow from the exact position of that dot, after which both the dot and the star disappear? The entire sequence should be quick and dynamic."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^\\pi \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the definite integral\n        explanation1 = Text(\"Evaluate the definite integral of sine from 0 to \u03c0\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^\\pi\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for the antiderivative of sine\n        explanation2 = Text(\"Antiderivative of sine is -cosine\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the antiderivative at bounds\n        evaluation_step = MathTex(r\"= -\\cos(\\pi) - (-\\cos(0))\")\n        self.play(ReplacementTransform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Explanation for evaluating the bounds\n        explanation3 = Text(\"Evaluate -cosine at \u03c0 and 0\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a text element first transforms into the words \"GrowFromPoint\" and moves upwards on the screen, then a dot appears in the upper right area, followed by a star that appears to grow from the exact position of that dot, after which both the dot and the star disappear? The entire sequence should be quick and dynamic."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animation where a text element first transforms into the words \"growfrompoint\" and moves upwards on the screen, then a dot appears in the upper right area, followed by a star that appears to grow from the exact position of that dot, after which both the dot and the star disappear? the entire sequence should be quick and dynamic."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigonometricIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_0^\\pi \\sin(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of the definite integral\n        explanation1 = Text(\"Evaluate the definite integral of sine from 0 to \u03c0\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Integration step\n        integration_step = MathTex(r\"= [-\\cos(x)]_0^\\pi\")\n        self.play(ReplacementTransform(problem.copy(), integration_step))\n        self.wait(1)\n\n        # Explanation for the antiderivative of sine\n        explanation2 = Text(\"Antiderivative of sine is -cosine\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Evaluating the antiderivative at bounds\n        evaluation_step = MathTex(r\"= -\\cos(\\pi) - (-\\cos(0))\")\n        self.play(ReplacementTransform(integration_step, evaluation_step))\n        self.wait(1)\n\n        # Explanation for evaluating the bounds\n        explanation3 = Text(\"Evaluate -cosine at \u03c0 and 0\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= 2\")\n        self.play(ReplacementTransform(evaluation_step, final_solution))\n        self.wait(1)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animation where a text element first transforms into the words \"GrowFromPoint\" and moves upwards on the screen, then a dot appears in the upper right area, followed by a star that appears to grow from the exact position of that dot, after which both the dot and the star disappear? The entire sequence should be quick and dynamic."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_surrounding_rectangle.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass SurroundingRectangleTest(Scene):\n    def construct(self):\n        rectangle = Rectangle(width=1, height=1, color=WHITE, fill_opacity=1.0)\n        self.add(rectangle)\n\n        surrounding_rectangle = SurroundingRectangle(rectangle, color=GREEN, buff=0.0)\n        self.add(surrounding_rectangle)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_surrounding_rectangle.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_surrounding_rectangle.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass SurroundingRectangleTest(Scene):\n    def construct(self):\n        rectangle = Rectangle(width=1, height=1, color=WHITE, fill_opacity=1.0)\n        self.add(rectangle)\n\n        surrounding_rectangle = SurroundingRectangle(rectangle, color=GREEN, buff=0.0)\n        self.add(surrounding_rectangle)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_surrounding_rectangle.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Why is a Seifert surface essential in determining the knot signature, and how does it influence the signature's value?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DecodingKnotSignatures(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Decoding Knot Signatures with Seifert Surfaces\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n\n        # Introduction to knots\n        knot_text = Text(\"Knots are closed loops in 3D space\", font_size=30)\n        self.play(Write(knot_text))\n        self.wait(1)\n        self.play(FadeOut(knot_text))\n\n        # Simple knot representation\n        knot = Circle(radius=1.5, color=BLUE)\n        self.play(Create(knot))\n        self.wait(1)\n        \n        # Question about Seifert surfaces\n        question = Text(\"Why are Seifert surfaces vital for knots?\", font_size=30)\n        question.to_edge(UP)\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Introduce Seifert surface\n        surface = Circle(radius=1.5, color=RED_A, fill_opacity=0.5)\n        self.play(Create(surface))\n        self.wait(1)\n        \n        self.play(FadeOut(question))\n        \n        # Explain Seifert surface\n        surface_text = Text(\"A Seifert surface spans the knot\", font_size=30)\n        surface_text.to_edge(UP)\n        self.play(Write(surface_text))\n        self.wait(1)\n        \n        # Create intersection points\n        points_text = Text(\"Intersection points on the surface\", font_size=30)\n        points_text.to_edge(UP)\n        self.play(FadeOut(surface_text), Write(points_text))\n        \n        # Create dots to represent intersections\n        intersections = VGroup(\n            Dot(point=np.array([0.5, 0.5, 0]), color=YELLOW),\n            Dot(point=np.array([-0.5, 0.5, 0]), color=YELLOW),\n            Dot(point=np.array([0, -0.7, 0]), color=YELLOW)\n        )\n        \n        self.play(Create(intersections))\n        self.wait(1)\n        \n        # Transition to Seifert matrix\n        matrix_text = Text(\"These intersections form a Seifert matrix\", font_size=30)\n        matrix_text.to_edge(UP)\n        self.play(FadeOut(points_text), Write(matrix_text))\n        self.wait(1)\n        \n        # Transition to matrix visualization\n        self.play(FadeOut(knot), FadeOut(surface), FadeOut(intersections))\n        \n        # Display Seifert matrix\n        matrix = MathTex(r\"V = \\begin{bmatrix} 0 & 1 & -1 \\\\ -1 & 0 & 1 \\\\ 1 & -1 & 0 \\end{bmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n        \n        # Explain signature\n        signature_text = Text(\"The knot signature comes from this matrix\", font_size=30)\n        signature_text.to_edge(UP)\n        self.play(FadeOut(matrix_text), Write(signature_text))\n        \n        # Show signature formula\n        signature_formula = MathTex(r\"\\text{Signature}(K) = \\text{Signature}(V + V^T)\")\n        signature_formula.next_to(matrix, DOWN, buff=1)\n        \n        self.play(Write(signature_formula))\n        self.wait(1)\n        \n        # Highlight importance\n        importance = Text(\"The signature helps classify and distinguish knots\", font_size=24)\n        importance.to_edge(DOWN)\n        self.play(Write(importance))\n        self.wait(1)\n        \n        # Final message\n        self.play(\n            FadeOut(matrix), \n            FadeOut(signature_formula), \n            FadeOut(signature_text),\n            FadeOut(importance)\n        )\n        \n        final_text = Text(\"The beauty of math lies in its patterns\", font_size=36)\n        self.play(Write(final_text))\n        self.wait(2)\n        self.play(FadeOut(final_text))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why is a Seifert surface essential in determining the knot signature, and how does it influence the signature's value?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: why is a seifert surface essential in determining the knot signature, and how does it influence the signature's value?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DecodingKnotSignatures(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Decoding Knot Signatures with Seifert Surfaces\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n\n        # Introduction to knots\n        knot_text = Text(\"Knots are closed loops in 3D space\", font_size=30)\n        self.play(Write(knot_text))\n        self.wait(1)\n        self.play(FadeOut(knot_text))\n\n        # Simple knot representation\n        knot = Circle(radius=1.5, color=BLUE)\n        self.play(Create(knot))\n        self.wait(1)\n        \n        # Question about Seifert surfaces\n        question = Text(\"Why are Seifert surfaces vital for knots?\", font_size=30)\n        question.to_edge(UP)\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Introduce Seifert surface\n        surface = Circle(radius=1.5, color=RED_A, fill_opacity=0.5)\n        self.play(Create(surface))\n        self.wait(1)\n        \n        self.play(FadeOut(question))\n        \n        # Explain Seifert surface\n        surface_text = Text(\"A Seifert surface spans the knot\", font_size=30)\n        surface_text.to_edge(UP)\n        self.play(Write(surface_text))\n        self.wait(1)\n        \n        # Create intersection points\n        points_text = Text(\"Intersection points on the surface\", font_size=30)\n        points_text.to_edge(UP)\n        self.play(FadeOut(surface_text), Write(points_text))\n        \n        # Create dots to represent intersections\n        intersections = VGroup(\n            Dot(point=np.array([0.5, 0.5, 0]), color=YELLOW),\n            Dot(point=np.array([-0.5, 0.5, 0]), color=YELLOW),\n            Dot(point=np.array([0, -0.7, 0]), color=YELLOW)\n        )\n        \n        self.play(Create(intersections))\n        self.wait(1)\n        \n        # Transition to Seifert matrix\n        matrix_text = Text(\"These intersections form a Seifert matrix\", font_size=30)\n        matrix_text.to_edge(UP)\n        self.play(FadeOut(points_text), Write(matrix_text))\n        self.wait(1)\n        \n        # Transition to matrix visualization\n        self.play(FadeOut(knot), FadeOut(surface), FadeOut(intersections))\n        \n        # Display Seifert matrix\n        matrix = MathTex(r\"V = \\begin{bmatrix} 0 & 1 & -1 \\\\ -1 & 0 & 1 \\\\ 1 & -1 & 0 \\end{bmatrix}\")\n        self.play(Write(matrix))\n        self.wait(1)\n        \n        # Explain signature\n        signature_text = Text(\"The knot signature comes from this matrix\", font_size=30)\n        signature_text.to_edge(UP)\n        self.play(FadeOut(matrix_text), Write(signature_text))\n        \n        # Show signature formula\n        signature_formula = MathTex(r\"\\text{Signature}(K) = \\text{Signature}(V + V^T)\")\n        signature_formula.next_to(matrix, DOWN, buff=1)\n        \n        self.play(Write(signature_formula))\n        self.wait(1)\n        \n        # Highlight importance\n        importance = Text(\"The signature helps classify and distinguish knots\", font_size=24)\n        importance.to_edge(DOWN)\n        self.play(Write(importance))\n        self.wait(1)\n        \n        # Final message\n        self.play(\n            FadeOut(matrix), \n            FadeOut(signature_formula), \n            FadeOut(signature_text),\n            FadeOut(importance)\n        )\n        \n        final_text = Text(\"The beauty of math lies in its patterns\", font_size=36)\n        self.play(Write(final_text))\n        self.wait(2)\n        self.play(FadeOut(final_text))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Why is a Seifert surface essential in determining the knot signature, and how does it influence the signature's value?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_nn_scale.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, 7, 3, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 5, 3, 3, filter_spacing=0.32),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.scale(1.3)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_nn_scale.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_nn_scale.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, 7, 3, 3, filter_spacing=0.32),\n                Convolutional2DLayer(3, 5, 5, 3, 3, filter_spacing=0.32),\n                FeedForwardLayer(3),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        nn.scale(1.3)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_nn_scale.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "disentanglement.py"}, {"from": "assistant", "value": "```python\n\"\"\"This module is dedicated to visualizing VAE disentanglement\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\n\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport pickle\n\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef construct_image_mobject(input_image, height=2.3):\n    \"\"\"Constructs an ImageMobject from a numpy grayscale image\"\"\"\n    # Convert image to rgb\n    if len(input_image.shape) == 2:\n        input_image = np.repeat(input_image, 3, axis=0)\n        input_image = np.rollaxis(input_image, 0, start=3)\n    #  Make the ImageMobject\n    image_mobject = ImageMobject(input_image, image_mode=\"RGB\")\n    image_mobject.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n    image_mobject.height = height\n\n    return image_mobject\n\n\nclass DisentanglementVisualization(VGroup):\n    def __init__(\n        self,\n        model_path=ROOT_DIR\n        / \"examples/variational_autoencoder/autoencoder_models/saved_models/model_dim2.pth\",\n        image_height=0.35,\n    ):\n        self.model_path = model_path\n        self.image_height = image_height\n        # Load disentanglement image objects\n        with open(\n            ROOT_DIR\n            / \"examples/variational_autoencoder/autoencoder_models/disentanglement.pkl\",\n            \"rb\",\n        ) as f:\n            self.image_handler = pickle.load(f)\n\n    def make_disentanglement_generation_animation(self):\n        animation_list = []\n        for image_index, image in enumerate(self.image_handler[\"images\"]):\n            image_mobject = construct_image_mobject(image, height=self.image_height)\n            r, c = self.image_handler[\"bin_indices\"][image_index]\n            # Move the image to the correct location\n            r_offset = -1.2\n            c_offset = 0.25\n            image_location = [\n                c_offset + c * self.image_height,\n                r_offset + r * self.image_height,\n                0,\n            ]\n            image_mobject.move_to(image_location)\n            animation_list.append(FadeIn(image_mobject))\n\n        generation_animation = AnimationGroup(*animation_list[::-1], lag_ratio=1.0)\n        return generation_animation\n\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass DisentanglementScene(Scene):\n    \"\"\"Disentanglement Scene Object\"\"\"\n\n    def _construct_embedding(self, point_color=BLUE, dot_radius=0.05):\n        \"\"\"Makes a Gaussian-like embedding\"\"\"\n        embedding = VGroup()\n        # Sample points from a Gaussian\n        num_points = 200\n        standard_deviation = [0.6, 0.8]\n        mean = [0, 0]\n        points = np.random.normal(mean, standard_deviation, size=(num_points, 2))\n        # Make an axes\n        embedding.axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-3, 3],\n            x_length=2.2,\n            y_length=2.2,\n            tips=False,\n        )\n        # Add each point to the axes\n        self.point_dots = VGroup()\n        for point in points:\n            point_location = embedding.axes.coords_to_point(*point)\n            dot = Dot(point_location, color=point_color, radius=dot_radius / 2)\n            self.point_dots.add(dot)\n\n        embedding.add(self.point_dots)\n        return embedding\n\n    def construct(self):\n        # Make the VAE decoder\n        vae_decoder = NeuralNetwork(\n            [\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ],\n            layer_spacing=0.55,\n        )\n\n        vae_decoder.shift([-0.55, 0, 0])\n        self.play(Create(vae_decoder), run_time=1)\n        # Make the embedding\n        embedding = self._construct_embedding()\n        embedding.scale(0.9)\n        embedding.move_to(vae_decoder.get_left())\n        embedding.shift([-0.85, 0, 0])\n        self.play(Create(embedding))\n        # Make disentanglment visualization\n        disentanglement = DisentanglementVisualization()\n        disentanglement_animation = (\n            disentanglement.make_disentanglement_generation_animation()\n        )\n        self.play(disentanglement_animation, run_time=3)\n        self.play(Wait(2))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "disentanglement.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that disentanglement.py"}, {"from": "assistant", "value": "```python\n\"\"\"This module is dedicated to visualizing VAE disentanglement\"\"\"\nfrom pathlib import Path\n\nfrom manim import *\n\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport pickle\n\nROOT_DIR = Path(__file__).parents[2]\n\n\ndef construct_image_mobject(input_image, height=2.3):\n    \"\"\"Constructs an ImageMobject from a numpy grayscale image\"\"\"\n    # Convert image to rgb\n    if len(input_image.shape) == 2:\n        input_image = np.repeat(input_image, 3, axis=0)\n        input_image = np.rollaxis(input_image, 0, start=3)\n    #  Make the ImageMobject\n    image_mobject = ImageMobject(input_image, image_mode=\"RGB\")\n    image_mobject.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n    image_mobject.height = height\n\n    return image_mobject\n\n\nclass DisentanglementVisualization(VGroup):\n    def __init__(\n        self,\n        model_path=ROOT_DIR\n        / \"examples/variational_autoencoder/autoencoder_models/saved_models/model_dim2.pth\",\n        image_height=0.35,\n    ):\n        self.model_path = model_path\n        self.image_height = image_height\n        # Load disentanglement image objects\n        with open(\n            ROOT_DIR\n            / \"examples/variational_autoencoder/autoencoder_models/disentanglement.pkl\",\n            \"rb\",\n        ) as f:\n            self.image_handler = pickle.load(f)\n\n    def make_disentanglement_generation_animation(self):\n        animation_list = []\n        for image_index, image in enumerate(self.image_handler[\"images\"]):\n            image_mobject = construct_image_mobject(image, height=self.image_height)\n            r, c = self.image_handler[\"bin_indices\"][image_index]\n            # Move the image to the correct location\n            r_offset = -1.2\n            c_offset = 0.25\n            image_location = [\n                c_offset + c * self.image_height,\n                r_offset + r * self.image_height,\n                0,\n            ]\n            image_mobject.move_to(image_location)\n            animation_list.append(FadeIn(image_mobject))\n\n        generation_animation = AnimationGroup(*animation_list[::-1], lag_ratio=1.0)\n        return generation_animation\n\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 5.0\nconfig.frame_width = 5.0\n\n\nclass DisentanglementScene(Scene):\n    \"\"\"Disentanglement Scene Object\"\"\"\n\n    def _construct_embedding(self, point_color=BLUE, dot_radius=0.05):\n        \"\"\"Makes a Gaussian-like embedding\"\"\"\n        embedding = VGroup()\n        # Sample points from a Gaussian\n        num_points = 200\n        standard_deviation = [0.6, 0.8]\n        mean = [0, 0]\n        points = np.random.normal(mean, standard_deviation, size=(num_points, 2))\n        # Make an axes\n        embedding.axes = Axes(\n            x_range=[-3, 3],\n            y_range=[-3, 3],\n            x_length=2.2,\n            y_length=2.2,\n            tips=False,\n        )\n        # Add each point to the axes\n        self.point_dots = VGroup()\n        for point in points:\n            point_location = embedding.axes.coords_to_point(*point)\n            dot = Dot(point_location, color=point_color, radius=dot_radius / 2)\n            self.point_dots.add(dot)\n\n        embedding.add(self.point_dots)\n        return embedding\n\n    def construct(self):\n        # Make the VAE decoder\n        vae_decoder = NeuralNetwork(\n            [\n                FeedForwardLayer(3),\n                FeedForwardLayer(5),\n            ],\n            layer_spacing=0.55,\n        )\n\n        vae_decoder.shift([-0.55, 0, 0])\n        self.play(Create(vae_decoder), run_time=1)\n        # Make the embedding\n        embedding = self._construct_embedding()\n        embedding.scale(0.9)\n        embedding.move_to(vae_decoder.get_left())\n        embedding.shift([-0.85, 0, 0])\n        self.play(Create(embedding))\n        # Make disentanglment visualization\n        disentanglement = DisentanglementVisualization()\n        disentanglement_animation = (\n            disentanglement.make_disentanglement_generation_animation()\n        )\n        self.play(disentanglement_animation, run_time=3)\n        self.play(Wait(2))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "disentanglement.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animation that shows a labeled circle representing an electron. Can you make a customizable function where I can set the radius of the circle, its border color, border thickness, fill color, and the text inside it, along with the text's font size and color? Additionally, could you add a specific implementation of this function to depict an electron with appropriate colors and label?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChemicalCompoundScene(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=GREY_B).set_fill(GREY_B, opacity=1)\n        oxygen_text = Tex(\"O\", color=WHITE).scale(1.5)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=1)\n        hydrogen_text = Tex(\"H\", color=BLACK).scale(0.8)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position hydrogen atoms around the oxygen\n        hydrogen1 = hydrogen.copy().next_to(oxygen, UP, buff=0.6)\n        hydrogen2 = hydrogen.copy().next_to(oxygen, DOWN, buff=0.6)\n\n        # Create bond lines\n        bond1 = Line(oxygen.get_top(), hydrogen1.get_center(), color=WHITE)\n        bond2 = Line(oxygen.get_bottom(), hydrogen2.get_center(), color=WHITE)\n\n        # Group together the full molecule\n        water_molecule = VGroup(oxygen, hydrogen1, hydrogen2, bond1, bond2)\n\n        # Center the molecule and animate its creation\n        water_molecule.move_to(ORIGIN)\n        self.play(FadeIn(water_molecule, shift=UP), run_time=3)\n        self.wait()\n\n        # Label for the molecule\n        water_label = Tex(\"H$_2$O\", color=WHITE).next_to(water_molecule, DOWN)\n\n        # Animate the label\n        self.play(Write(water_label))\n        self.wait(2)\n\n        # Animate the dissociation of the water molecule\n        self.play(\n            FadeOut(hydrogen1),\n            FadeOut(bond1),\n            hydrogen2.shift, LEFT * 3,\n            oxygen.shift, RIGHT * 3,\n            FadeOut(bond2),\n            run_time=2\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animation that shows a labeled circle representing an electron. Can you make a customizable function where I can set the radius of the circle, its border color, border thickness, fill color, and the text inside it, along with the text's font size and color? Additionally, could you add a specific implementation of this function to depict an electron with appropriate colors and label?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animation that shows a labeled circle representing an electron. can you make a customizable function where i can set the radius of the circle, its border color, border thickness, fill color, and the text inside it, along with the text's font size and color? additionally, could you add a specific implementation of this function to depict an electron with appropriate colors and label?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ChemicalCompoundScene(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=GREY_B).set_fill(GREY_B, opacity=1)\n        oxygen_text = Tex(\"O\", color=WHITE).scale(1.5)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.2, color=WHITE).set_fill(WHITE, opacity=1)\n        hydrogen_text = Tex(\"H\", color=BLACK).scale(0.8)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position hydrogen atoms around the oxygen\n        hydrogen1 = hydrogen.copy().next_to(oxygen, UP, buff=0.6)\n        hydrogen2 = hydrogen.copy().next_to(oxygen, DOWN, buff=0.6)\n\n        # Create bond lines\n        bond1 = Line(oxygen.get_top(), hydrogen1.get_center(), color=WHITE)\n        bond2 = Line(oxygen.get_bottom(), hydrogen2.get_center(), color=WHITE)\n\n        # Group together the full molecule\n        water_molecule = VGroup(oxygen, hydrogen1, hydrogen2, bond1, bond2)\n\n        # Center the molecule and animate its creation\n        water_molecule.move_to(ORIGIN)\n        self.play(FadeIn(water_molecule, shift=UP), run_time=3)\n        self.wait()\n\n        # Label for the molecule\n        water_label = Tex(\"H$_2$O\", color=WHITE).next_to(water_molecule, DOWN)\n\n        # Animate the label\n        self.play(Write(water_label))\n        self.wait(2)\n\n        # Animate the dissociation of the water molecule\n        self.play(\n            FadeOut(hydrogen1),\n            FadeOut(bond1),\n            hydrogen2.shift, LEFT * 3,\n            oxygen.shift, RIGHT * 3,\n            FadeOut(bond2),\n            run_time=2\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animation that shows a labeled circle representing an electron. Can you make a customizable function where I can set the radius of the circle, its border color, border thickness, fill color, and the text inside it, along with the text's font size and color? Additionally, could you add a specific implementation of this function to depict an electron with appropriate colors and label?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that demonstrates the formation of an oxygen molecule by showing two oxygen atoms coming together, sharing an electron, creating a bond, and then having the entire molecule shift upwards, shrink in size, rotate, and finally disappear?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CircleAreaScene(Scene):\n    def construct(self):\n        # Write the equation of the circle area\n        equation = MathTex(\"A = \\pi r^2\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain the elements of the equation\n        explanation = Text(\"Area of a circle with radius r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Highlight the radius squared term\n        square_term = equation[2:5]\n        self.play(Indicate(square_term))\n        self.wait(1)\n\n        # Show a circle with its radius\n        circle = Circle(color=BLUE)\n        radius = Line(ORIGIN, RIGHT, color=GREEN).shift(DOWN)\n        radius_label = MathTex(\"r\").next_to(radius, DOWN)\n        self.play(Create(circle), GrowFromPoint(radius, ORIGIN), Write(radius_label))\n        self.wait(2)\n\n        # Calculate the area for r=1\n        area_calculation = MathTex(r\"A = \\pi \\cdot 1^2 = \\pi\")\n        self.play(Transform(equation, area_calculation))\n        self.wait(1)\n\n        # Show that for r=1, the area of the circle is \u03c0\n        circle_area_highlight = Circle(color=YELLOW).scale(np.sqrt(np.pi))\n        self.play(Transform(circle, circle_area_highlight), FadeOut(radius), FadeOut(radius_label))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_calculation))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that demonstrates the formation of an oxygen molecule by showing two oxygen atoms coming together, sharing an electron, creating a bond, and then having the entire molecule shift upwards, shrink in size, rotate, and finally disappear?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that demonstrates the formation of an oxygen molecule by showing two oxygen atoms coming together, sharing an electron, creating a bond, and then having the entire molecule shift upwards, shrink in size, rotate, and finally disappear?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CircleAreaScene(Scene):\n    def construct(self):\n        # Write the equation of the circle area\n        equation = MathTex(\"A = \\pi r^2\")\n        self.play(Write(equation))\n        self.wait(1)\n\n        # Explain the elements of the equation\n        explanation = Text(\"Area of a circle with radius r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(2)\n\n        # Highlight the radius squared term\n        square_term = equation[2:5]\n        self.play(Indicate(square_term))\n        self.wait(1)\n\n        # Show a circle with its radius\n        circle = Circle(color=BLUE)\n        radius = Line(ORIGIN, RIGHT, color=GREEN).shift(DOWN)\n        radius_label = MathTex(\"r\").next_to(radius, DOWN)\n        self.play(Create(circle), GrowFromPoint(radius, ORIGIN), Write(radius_label))\n        self.wait(2)\n\n        # Calculate the area for r=1\n        area_calculation = MathTex(r\"A = \\pi \\cdot 1^2 = \\pi\")\n        self.play(Transform(equation, area_calculation))\n        self.wait(1)\n\n        # Show that for r=1, the area of the circle is \u03c0\n        circle_area_highlight = Circle(color=YELLOW).scale(np.sqrt(np.pi))\n        self.play(Transform(circle, circle_area_highlight), FadeOut(radius), FadeOut(radius_label))\n        self.wait(1)\n\n        # Clear the scene and show the final area value\n        self.clear()\n        self.wait(1)\n        self.play(Write(area_calculation))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that demonstrates the formation of an oxygen molecule by showing two oxygen atoms coming together, sharing an electron, creating a bond, and then having the entire molecule shift upwards, shrink in size, rotate, and finally disappear?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the geometric interpretation of Morse indices on a 2-dimensional surface?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MorseTheoryBasics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Morse Theory: Unraveling the Curves of Reality\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP).scale(0.7))\n        \n        # Create critical points\n        peak = Dot(point=UP*2 + LEFT*3, color=RED)\n        saddle = Dot(point=ORIGIN, color=YELLOW)\n        valley = Dot(point=DOWN*2 + RIGHT*3, color=GREEN)\n        \n        # Labels\n        peak_label = Text(\"Peak (Index 2)\", font_size=24).next_to(peak, UP)\n        saddle_label = Text(\"Saddle (Index 1)\", font_size=24).next_to(saddle, UP)\n        valley_label = Text(\"Valley (Index 0)\", font_size=24).next_to(valley, UP)\n        \n        # Show peak with arrows\n        self.play(Create(peak), Write(peak_label))\n        peak_arrows = [Arrow(peak.get_center(), peak.get_center() + direction, color=RED) \n                    for direction in [LEFT, RIGHT, UP, DOWN]]\n        self.play(*[Create(arrow) for arrow in peak_arrows])\n        peak_text = Text(\"All directions downhill\", font_size=20).next_to(peak, DOWN)\n        self.play(Write(peak_text))\n        self.wait(1)\n        \n        # Show saddle with arrows\n        self.play(Create(saddle), Write(saddle_label))\n        saddle_arrows = [\n            Arrow(saddle.get_center(), saddle.get_center() + LEFT, color=RED),\n            Arrow(saddle.get_center(), saddle.get_center() + RIGHT, color=GREEN)\n        ]\n        self.play(*[Create(arrow) for arrow in saddle_arrows])\n        saddle_text = Text(\"One direction downhill\", font_size=20).next_to(saddle, DOWN)\n        self.play(Write(saddle_text))\n        self.wait(1)\n        \n        # Show valley with arrows\n        self.play(Create(valley), Write(valley_label))\n        valley_arrows = [Arrow(valley.get_center(), valley.get_center() + direction, color=GREEN) \n                      for direction in [LEFT, RIGHT, UP, DOWN]]\n        self.play(*[Create(arrow) for arrow in valley_arrows])\n        valley_text = Text(\"No downhill directions\", font_size=20).next_to(valley, DOWN)\n        self.play(Write(valley_text))\n        self.wait(1)\n        \n        # Show the first equation: gradient = 0\n        eq1 = MathTex(r\"\\nabla f = 0\")\n        eq1.to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Show a simplified version of the second equation\n        eq2 = Text(\"Morse Index = Number of downhill directions\", font_size=28)\n        eq2.next_to(eq1, UP)\n        self.play(Write(eq2))\n        self.wait(2)\n        \n        # Fade out everything - using a list for compatibility with all manim versions\n        all_objects = [title, peak, peak_label, peak_text,\n                      saddle, saddle_label, saddle_text,\n                      valley, valley_label, valley_text,\n                      eq1, eq2]\n        all_objects.extend(peak_arrows)\n        all_objects.extend(saddle_arrows)\n        all_objects.extend(valley_arrows)\n        self.play(FadeOut(*all_objects))\n\n# To render the animation with the specified output filename, run:\n# manim -pql <filename>.py MorseTheoryBasics -o video.mp4\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the geometric interpretation of Morse indices on a 2-dimensional surface?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the geometric interpretation of morse indices on a 2-dimensional surface?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MorseTheoryBasics(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Morse Theory: Unraveling the Curves of Reality\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP).scale(0.7))\n        \n        # Create critical points\n        peak = Dot(point=UP*2 + LEFT*3, color=RED)\n        saddle = Dot(point=ORIGIN, color=YELLOW)\n        valley = Dot(point=DOWN*2 + RIGHT*3, color=GREEN)\n        \n        # Labels\n        peak_label = Text(\"Peak (Index 2)\", font_size=24).next_to(peak, UP)\n        saddle_label = Text(\"Saddle (Index 1)\", font_size=24).next_to(saddle, UP)\n        valley_label = Text(\"Valley (Index 0)\", font_size=24).next_to(valley, UP)\n        \n        # Show peak with arrows\n        self.play(Create(peak), Write(peak_label))\n        peak_arrows = [Arrow(peak.get_center(), peak.get_center() + direction, color=RED) \n                    for direction in [LEFT, RIGHT, UP, DOWN]]\n        self.play(*[Create(arrow) for arrow in peak_arrows])\n        peak_text = Text(\"All directions downhill\", font_size=20).next_to(peak, DOWN)\n        self.play(Write(peak_text))\n        self.wait(1)\n        \n        # Show saddle with arrows\n        self.play(Create(saddle), Write(saddle_label))\n        saddle_arrows = [\n            Arrow(saddle.get_center(), saddle.get_center() + LEFT, color=RED),\n            Arrow(saddle.get_center(), saddle.get_center() + RIGHT, color=GREEN)\n        ]\n        self.play(*[Create(arrow) for arrow in saddle_arrows])\n        saddle_text = Text(\"One direction downhill\", font_size=20).next_to(saddle, DOWN)\n        self.play(Write(saddle_text))\n        self.wait(1)\n        \n        # Show valley with arrows\n        self.play(Create(valley), Write(valley_label))\n        valley_arrows = [Arrow(valley.get_center(), valley.get_center() + direction, color=GREEN) \n                      for direction in [LEFT, RIGHT, UP, DOWN]]\n        self.play(*[Create(arrow) for arrow in valley_arrows])\n        valley_text = Text(\"No downhill directions\", font_size=20).next_to(valley, DOWN)\n        self.play(Write(valley_text))\n        self.wait(1)\n        \n        # Show the first equation: gradient = 0\n        eq1 = MathTex(r\"\\nabla f = 0\")\n        eq1.to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        # Show a simplified version of the second equation\n        eq2 = Text(\"Morse Index = Number of downhill directions\", font_size=28)\n        eq2.next_to(eq1, UP)\n        self.play(Write(eq2))\n        self.wait(2)\n        \n        # Fade out everything - using a list for compatibility with all manim versions\n        all_objects = [title, peak, peak_label, peak_text,\n                      saddle, saddle_label, saddle_text,\n                      valley, valley_label, valley_text,\n                      eq1, eq2]\n        all_objects.extend(peak_arrows)\n        all_objects.extend(saddle_arrows)\n        all_objects.extend(valley_arrows)\n        self.play(FadeOut(*all_objects))\n\n# To render the animation with the specified output filename, run:\n# manim -pql <filename>.py MorseTheoryBasics -o video.mp4\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the geometric interpretation of Morse indices on a 2-dimensional surface?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What can graphical representations of Cayley graphs reveal about the homomorphisms between cyclic groups?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CayleyGraphHomomorphism(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Visualizing Group Mappings\", font_size=40)\n        subtitle = Text(\"Homomorphisms through Cayley Graphs\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title), Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create cyclic groups C4 and C2 side by side\n        # C4 group (left)\n        c4_radius = 2\n        c4_dots = []\n        \n        for i in range(4):\n            angle = i * PI/2\n            position = c4_radius * np.array([np.cos(angle), np.sin(angle), 0])\n            dot = Dot(position, color=BLUE)\n            label = Text(f\"g{i}\", font_size=24)\n            # Calculate the direction outward from center\n            direction = position / np.linalg.norm(position) if np.linalg.norm(position) > 0 else RIGHT\n            label.next_to(dot, direction, buff=0.2)\n            c4_dots.append(VGroup(dot, label))\n        \n        c4 = VGroup(*c4_dots).shift(LEFT * 3)\n        c4_label = Text(\"C4\", font_size=36).next_to(c4, UP)\n        \n        # C2 group (right)\n        c2_radius = 1.5\n        c2_dots = []\n        \n        for i in range(2):\n            angle = i * PI\n            position = c2_radius * np.array([np.cos(angle), np.sin(angle), 0])\n            dot = Dot(position, color=RED)\n            label = Text(f\"h{i}\", font_size=24)\n            # Calculate the direction outward from center\n            direction = position / np.linalg.norm(position) if np.linalg.norm(position) > 0 else RIGHT\n            label.next_to(dot, direction, buff=0.2)\n            c2_dots.append(VGroup(dot, label))\n        \n        c2 = VGroup(*c2_dots).shift(RIGHT * 3)\n        c2_label = Text(\"C2\", font_size=36).next_to(c2, UP)\n        \n        # Display both groups\n        self.play(Create(c4), Write(c4_label))\n        self.play(Create(c2), Write(c2_label))\n        self.wait(1)\n        \n        # Add Cayley graph edges\n        edges_c4 = []\n        for i in range(4):\n            start = c4_dots[i][0].get_center()\n            end = c4_dots[(i+1)%4][0].get_center()\n            edge = Arrow(start, end, buff=0.2, color=GREEN)\n            edges_c4.append(edge)\n        \n        edges_c2 = []\n        for i in range(2):\n            start = c2_dots[i][0].get_center()\n            end = c2_dots[(i+1)%2][0].get_center()\n            edge = Arrow(start, end, buff=0.2, color=GREEN)\n            edges_c2.append(edge)\n        \n        self.play(*[Create(edge) for edge in edges_c4])\n        self.play(*[Create(edge) for edge in edges_c2])\n        self.wait(1)\n        \n        # Show homomorphism equation\n        eq1 = Text(\"\u03c6: C4 \u2192 C2\", font_size=36).to_edge(UP)\n        eq2 = Text(\"\u03c6(g\u2081\u00b7g\u2082) = \u03c6(g\u2081)\u00b7\u03c6(g\u2082)\", font_size=30).next_to(eq1, DOWN)\n        \n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Show homomorphism mappings\n        mappings = []\n        # g0 -> h0, g2 -> h0\n        for i in [0, 2]:\n            start = c4_dots[i][0].get_center()\n            end = c2_dots[0][0].get_center()\n            mapping = Arrow(start, end, color=YELLOW, stroke_width=2)\n            mappings.append(mapping)\n        \n        # g1 -> h1, g3 -> h1\n        for i in [1, 3]:\n            start = c4_dots[i][0].get_center()\n            end = c2_dots[1][0].get_center()\n            mapping = Arrow(start, end, color=YELLOW, stroke_width=2)\n            mappings.append(mapping)\n        \n        for mapping in mappings:\n            self.play(Create(mapping), run_time=0.5)\n        \n        # Highlight structure preservation\n        insight = Text(\"Cayley graphs reveal structure-preserving maps\", font_size=30).to_edge(DOWN)\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What can graphical representations of Cayley graphs reveal about the homomorphisms between cyclic groups?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what can graphical representations of cayley graphs reveal about the homomorphisms between cyclic groups?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CayleyGraphHomomorphism(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Visualizing Group Mappings\", font_size=40)\n        subtitle = Text(\"Homomorphisms through Cayley Graphs\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title), Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create cyclic groups C4 and C2 side by side\n        # C4 group (left)\n        c4_radius = 2\n        c4_dots = []\n        \n        for i in range(4):\n            angle = i * PI/2\n            position = c4_radius * np.array([np.cos(angle), np.sin(angle), 0])\n            dot = Dot(position, color=BLUE)\n            label = Text(f\"g{i}\", font_size=24)\n            # Calculate the direction outward from center\n            direction = position / np.linalg.norm(position) if np.linalg.norm(position) > 0 else RIGHT\n            label.next_to(dot, direction, buff=0.2)\n            c4_dots.append(VGroup(dot, label))\n        \n        c4 = VGroup(*c4_dots).shift(LEFT * 3)\n        c4_label = Text(\"C4\", font_size=36).next_to(c4, UP)\n        \n        # C2 group (right)\n        c2_radius = 1.5\n        c2_dots = []\n        \n        for i in range(2):\n            angle = i * PI\n            position = c2_radius * np.array([np.cos(angle), np.sin(angle), 0])\n            dot = Dot(position, color=RED)\n            label = Text(f\"h{i}\", font_size=24)\n            # Calculate the direction outward from center\n            direction = position / np.linalg.norm(position) if np.linalg.norm(position) > 0 else RIGHT\n            label.next_to(dot, direction, buff=0.2)\n            c2_dots.append(VGroup(dot, label))\n        \n        c2 = VGroup(*c2_dots).shift(RIGHT * 3)\n        c2_label = Text(\"C2\", font_size=36).next_to(c2, UP)\n        \n        # Display both groups\n        self.play(Create(c4), Write(c4_label))\n        self.play(Create(c2), Write(c2_label))\n        self.wait(1)\n        \n        # Add Cayley graph edges\n        edges_c4 = []\n        for i in range(4):\n            start = c4_dots[i][0].get_center()\n            end = c4_dots[(i+1)%4][0].get_center()\n            edge = Arrow(start, end, buff=0.2, color=GREEN)\n            edges_c4.append(edge)\n        \n        edges_c2 = []\n        for i in range(2):\n            start = c2_dots[i][0].get_center()\n            end = c2_dots[(i+1)%2][0].get_center()\n            edge = Arrow(start, end, buff=0.2, color=GREEN)\n            edges_c2.append(edge)\n        \n        self.play(*[Create(edge) for edge in edges_c4])\n        self.play(*[Create(edge) for edge in edges_c2])\n        self.wait(1)\n        \n        # Show homomorphism equation\n        eq1 = Text(\"\u03c6: C4 \u2192 C2\", font_size=36).to_edge(UP)\n        eq2 = Text(\"\u03c6(g\u2081\u00b7g\u2082) = \u03c6(g\u2081)\u00b7\u03c6(g\u2082)\", font_size=30).next_to(eq1, DOWN)\n        \n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Show homomorphism mappings\n        mappings = []\n        # g0 -> h0, g2 -> h0\n        for i in [0, 2]:\n            start = c4_dots[i][0].get_center()\n            end = c2_dots[0][0].get_center()\n            mapping = Arrow(start, end, color=YELLOW, stroke_width=2)\n            mappings.append(mapping)\n        \n        # g1 -> h1, g3 -> h1\n        for i in [1, 3]:\n            start = c4_dots[i][0].get_center()\n            end = c2_dots[1][0].get_center()\n            mapping = Arrow(start, end, color=YELLOW, stroke_width=2)\n            mappings.append(mapping)\n        \n        for mapping in mappings:\n            self.play(Create(mapping), run_time=0.5)\n        \n        # Highlight structure preservation\n        insight = Text(\"Cayley graphs reveal structure-preserving maps\", font_size=30).to_edge(DOWN)\n        self.play(Write(insight))\n        self.wait(2)\n        \n        # Fade out everything\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What can graphical representations of Cayley graphs reveal about the homomorphisms between cyclic groups?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Is it possible to construct a 3D model where each layer is a Latin square that maintains the properties in all three dimensions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LatinCubeExploration(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Latin Squares in 3D\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # 1. Explain Latin Square\n        subtitle = Text(\"Latin Square\", font_size=36)\n        subtitle.to_edge(UP)\n        self.play(Write(subtitle))\n        \n        # Create a 3x3 grid\n        grid = VGroup()\n        for i in range(4):\n            h_line = Line(start=[-1.5, 1.5 - i, 0], end=[1.5, 1.5 - i, 0])\n            v_line = Line(start=[-1.5 + i, 1.5, 0], end=[-1.5 + i, -1.5, 0])\n            grid.add(h_line, v_line)\n        \n        self.play(Create(grid))\n        \n        # Add numbers to create a Latin square\n        numbers = VGroup()\n        values = [\n            [1, 2, 3],\n            [2, 3, 1],\n            [3, 1, 2]\n        ]\n        \n        for i in range(3):\n            for j in range(3):\n                num = Text(str(values[i][j]), font_size=36)\n                num.move_to([-1 + j, 1 - i, 0])\n                numbers.add(num)\n        \n        self.play(Write(numbers))\n        self.wait(1)\n        \n        # Highlight a row and column\n        row = Rectangle(width=3, height=0.8, color=YELLOW, fill_opacity=0.3)\n        row.move_to([0, 1, 0])\n        \n        col = Rectangle(width=0.8, height=3, color=BLUE, fill_opacity=0.3)\n        col.move_to([0, 0, 0])\n        \n        self.play(FadeIn(row))\n        self.wait(0.5)\n        self.play(FadeOut(row))\n        \n        self.play(FadeIn(col))\n        self.wait(0.5)\n        self.play(FadeOut(col))\n        \n        # Latin square equation\n        eq1 = Text(\"L(S) = {L1, L2, ..., Ln} where each Li is a Latin square\", font_size=24)\n        eq1.to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        self.play(FadeOut(grid), FadeOut(numbers), FadeOut(eq1), FadeOut(subtitle))\n        \n        # 2. Extend to 3D\n        subtitle = Text(\"3D Latin Cube\", font_size=36)\n        subtitle.to_edge(UP)\n        self.play(Write(subtitle))\n        \n        # Create a simplified 3D cube\n        front = Square(side_length=3, color=WHITE)\n        back = Square(side_length=3, color=WHITE)\n        back.shift(RIGHT * 1 + UP * 1)\n        \n        connections = VGroup()\n        for i in range(4):\n            start = front.get_vertices()[i]\n            end = back.get_vertices()[i]\n            connection = DashedLine(start=start, end=end)\n            connections.add(connection)\n        \n        cube = VGroup(front, back, connections)\n        \n        self.play(Create(cube))\n        self.wait(1)\n        \n        # Explanation of 3D Latin cube\n        insight = Text(\"Key Insight: Balance across all three dimensions\", font_size=28)\n        insight.next_to(subtitle, DOWN, buff=0.5)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # 3D Latin cube equation\n        eq2 = Text(\"L(i,j,k) = {1,2,...,n} without repetition in any dimension\", font_size=24)\n        eq2.to_edge(DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(cube), FadeOut(insight), FadeOut(eq2), FadeOut(subtitle))\n        \n        conclusion = Text(\"3D Latin cubes: Mathematical elegance in three dimensions\", font_size=32)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Is it possible to construct a 3D model where each layer is a Latin square that maintains the properties in all three dimensions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: is it possible to construct a 3d model where each layer is a latin square that maintains the properties in all three dimensions?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LatinCubeExploration(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Exploring Latin Squares in 3D\", font_size=40)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # 1. Explain Latin Square\n        subtitle = Text(\"Latin Square\", font_size=36)\n        subtitle.to_edge(UP)\n        self.play(Write(subtitle))\n        \n        # Create a 3x3 grid\n        grid = VGroup()\n        for i in range(4):\n            h_line = Line(start=[-1.5, 1.5 - i, 0], end=[1.5, 1.5 - i, 0])\n            v_line = Line(start=[-1.5 + i, 1.5, 0], end=[-1.5 + i, -1.5, 0])\n            grid.add(h_line, v_line)\n        \n        self.play(Create(grid))\n        \n        # Add numbers to create a Latin square\n        numbers = VGroup()\n        values = [\n            [1, 2, 3],\n            [2, 3, 1],\n            [3, 1, 2]\n        ]\n        \n        for i in range(3):\n            for j in range(3):\n                num = Text(str(values[i][j]), font_size=36)\n                num.move_to([-1 + j, 1 - i, 0])\n                numbers.add(num)\n        \n        self.play(Write(numbers))\n        self.wait(1)\n        \n        # Highlight a row and column\n        row = Rectangle(width=3, height=0.8, color=YELLOW, fill_opacity=0.3)\n        row.move_to([0, 1, 0])\n        \n        col = Rectangle(width=0.8, height=3, color=BLUE, fill_opacity=0.3)\n        col.move_to([0, 0, 0])\n        \n        self.play(FadeIn(row))\n        self.wait(0.5)\n        self.play(FadeOut(row))\n        \n        self.play(FadeIn(col))\n        self.wait(0.5)\n        self.play(FadeOut(col))\n        \n        # Latin square equation\n        eq1 = Text(\"L(S) = {L1, L2, ..., Ln} where each Li is a Latin square\", font_size=24)\n        eq1.to_edge(DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        \n        self.play(FadeOut(grid), FadeOut(numbers), FadeOut(eq1), FadeOut(subtitle))\n        \n        # 2. Extend to 3D\n        subtitle = Text(\"3D Latin Cube\", font_size=36)\n        subtitle.to_edge(UP)\n        self.play(Write(subtitle))\n        \n        # Create a simplified 3D cube\n        front = Square(side_length=3, color=WHITE)\n        back = Square(side_length=3, color=WHITE)\n        back.shift(RIGHT * 1 + UP * 1)\n        \n        connections = VGroup()\n        for i in range(4):\n            start = front.get_vertices()[i]\n            end = back.get_vertices()[i]\n            connection = DashedLine(start=start, end=end)\n            connections.add(connection)\n        \n        cube = VGroup(front, back, connections)\n        \n        self.play(Create(cube))\n        self.wait(1)\n        \n        # Explanation of 3D Latin cube\n        insight = Text(\"Key Insight: Balance across all three dimensions\", font_size=28)\n        insight.next_to(subtitle, DOWN, buff=0.5)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # 3D Latin cube equation\n        eq2 = Text(\"L(i,j,k) = {1,2,...,n} without repetition in any dimension\", font_size=24)\n        eq2.to_edge(DOWN)\n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(cube), FadeOut(insight), FadeOut(eq2), FadeOut(subtitle))\n        \n        conclusion = Text(\"3D Latin cubes: Mathematical elegance in three dimensions\", font_size=32)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Is it possible to construct a 3D model where each layer is a Latin square that maintains the properties in all three dimensions?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In a two-dimensional system, how do limit cycles surrounding a fixed point in the phase plane relate to the stability of that fixed point?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LimitCyclesStability(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Embracing Stability:\", font_size=40)\n        subtitle = Text(\"The Dance of Limit Cycles and Fixed Points\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a phase plane\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n        )\n        self.play(Create(axes))\n        \n        # Create a fixed point\n        fixed_point = Dot(axes.c2p(0, 0), color=RED)\n        fixed_point_label = Text(\"Fixed Point\", font_size=24).next_to(fixed_point, UP)\n        self.play(Create(fixed_point), Write(fixed_point_label))\n        \n        # Show system equations\n        equation = MathTex(r\"\\dot{x} = f(x, y)\", r\"\\\\\\dot{y} = g(x, y)\")\n        equation.to_corner(UL)\n        self.play(Write(equation))\n        \n        # Create a limit cycle\n        limit_cycle = Circle(radius=2, color=BLUE).move_to(axes.c2p(0, 0))\n        limit_cycle_label = Text(\"Limit Cycle\", font_size=24).next_to(limit_cycle, RIGHT)\n        self.play(Create(limit_cycle), Write(limit_cycle_label))\n        \n        # Show limit cycle equation\n        limit_cycle_eq = MathTex(r\"\\text{Limit cycles: }\\frac{d\\theta}{dt} = \\omega\")\n        limit_cycle_eq.next_to(equation, DOWN, aligned_edge=LEFT)\n        self.play(Write(limit_cycle_eq))\n        \n        # Show arrows on the limit cycle\n        cycle_arrows = VGroup()\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            point = axes.c2p(2*np.cos(angle), 2*np.sin(angle))\n            direction = np.array([-np.sin(angle), np.cos(angle), 0])\n            arrow = Arrow(point, point + 0.5*direction, color=BLUE, buff=0)\n            cycle_arrows.add(arrow)\n        self.play(Create(cycle_arrows))\n        \n        # Show outward arrows from fixed point (indicating instability)\n        outward_arrows = VGroup()\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            start = axes.c2p(0.5*np.cos(angle), 0.5*np.sin(angle))\n            end = axes.c2p(1.0*np.cos(angle), 1.0*np.sin(angle))\n            arrow = Arrow(start, end, color=RED, buff=0)\n            outward_arrows.add(arrow)\n        self.play(Create(outward_arrows))\n        \n        # Add a stability label\n        stability_label = Text(\"Unstable Fixed Point\", font_size=24, color=RED)\n        stability_label.to_edge(UP)\n        self.play(Write(stability_label))\n        \n        # Add a key insight text\n        insight = Text(\"Limit cycles indicate stability properties\", font_size=20)\n        insight.to_edge(DOWN)\n        self.play(Write(insight))\n        \n        # Conclusion\n        conclusion = Text(\"Limit cycles form boundaries in phase space\", font_size=30)\n        self.play(\n            FadeOut(axes), FadeOut(fixed_point), FadeOut(fixed_point_label),\n            FadeOut(limit_cycle), FadeOut(limit_cycle_label), FadeOut(cycle_arrows),\n            FadeOut(outward_arrows), FadeOut(stability_label), FadeOut(insight),\n            FadeOut(equation), FadeOut(limit_cycle_eq)\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In a two-dimensional system, how do limit cycles surrounding a fixed point in the phase plane relate to the stability of that fixed point?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in a two-dimensional system, how do limit cycles surrounding a fixed point in the phase plane relate to the stability of that fixed point?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LimitCyclesStability(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Embracing Stability:\", font_size=40)\n        subtitle = Text(\"The Dance of Limit Cycles and Fixed Points\", font_size=30)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create a phase plane\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n        )\n        self.play(Create(axes))\n        \n        # Create a fixed point\n        fixed_point = Dot(axes.c2p(0, 0), color=RED)\n        fixed_point_label = Text(\"Fixed Point\", font_size=24).next_to(fixed_point, UP)\n        self.play(Create(fixed_point), Write(fixed_point_label))\n        \n        # Show system equations\n        equation = MathTex(r\"\\dot{x} = f(x, y)\", r\"\\\\\\dot{y} = g(x, y)\")\n        equation.to_corner(UL)\n        self.play(Write(equation))\n        \n        # Create a limit cycle\n        limit_cycle = Circle(radius=2, color=BLUE).move_to(axes.c2p(0, 0))\n        limit_cycle_label = Text(\"Limit Cycle\", font_size=24).next_to(limit_cycle, RIGHT)\n        self.play(Create(limit_cycle), Write(limit_cycle_label))\n        \n        # Show limit cycle equation\n        limit_cycle_eq = MathTex(r\"\\text{Limit cycles: }\\frac{d\\theta}{dt} = \\omega\")\n        limit_cycle_eq.next_to(equation, DOWN, aligned_edge=LEFT)\n        self.play(Write(limit_cycle_eq))\n        \n        # Show arrows on the limit cycle\n        cycle_arrows = VGroup()\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            point = axes.c2p(2*np.cos(angle), 2*np.sin(angle))\n            direction = np.array([-np.sin(angle), np.cos(angle), 0])\n            arrow = Arrow(point, point + 0.5*direction, color=BLUE, buff=0)\n            cycle_arrows.add(arrow)\n        self.play(Create(cycle_arrows))\n        \n        # Show outward arrows from fixed point (indicating instability)\n        outward_arrows = VGroup()\n        for angle in np.linspace(0, 2*PI, 8, endpoint=False):\n            start = axes.c2p(0.5*np.cos(angle), 0.5*np.sin(angle))\n            end = axes.c2p(1.0*np.cos(angle), 1.0*np.sin(angle))\n            arrow = Arrow(start, end, color=RED, buff=0)\n            outward_arrows.add(arrow)\n        self.play(Create(outward_arrows))\n        \n        # Add a stability label\n        stability_label = Text(\"Unstable Fixed Point\", font_size=24, color=RED)\n        stability_label.to_edge(UP)\n        self.play(Write(stability_label))\n        \n        # Add a key insight text\n        insight = Text(\"Limit cycles indicate stability properties\", font_size=20)\n        insight.to_edge(DOWN)\n        self.play(Write(insight))\n        \n        # Conclusion\n        conclusion = Text(\"Limit cycles form boundaries in phase space\", font_size=30)\n        self.play(\n            FadeOut(axes), FadeOut(fixed_point), FadeOut(fixed_point_label),\n            FadeOut(limit_cycle), FadeOut(limit_cycle_label), FadeOut(cycle_arrows),\n            FadeOut(outward_arrows), FadeOut(stability_label), FadeOut(insight),\n            FadeOut(equation), FadeOut(limit_cycle_eq)\n        )\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In a two-dimensional system, how do limit cycles surrounding a fixed point in the phase plane relate to the stability of that fixed point?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do M\u00f6bius transformations map the interior and exterior of a given circle in the complex plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MobiusTransformation(Scene):\n    def construct(self):\n        # Colors for our visualization\n        plane_color = \"#3B5EA0\"  # Soft blue\n        highlight_color = \"#FFD700\"  # Gold\n        circle_color = \"#BF40BF\"  # Purple\n        \n        # Introduction: Title\n        title = Text(\"Twist of Geometry: Exploring M\u00f6bius Transformations\", font_size=32)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a complex plane with grid\n        plane = NumberPlane(\n            x_range=[-5, 5, 1],\n            y_range=[-5, 5, 1],\n            background_line_style={\"stroke_color\": plane_color, \"stroke_width\": 1, \"stroke_opacity\": 0.6}\n        )\n        \n        # Add some points to represent complex numbers\n        points = VGroup()\n        for x in range(-4, 5, 2):\n            for y in range(-4, 5, 2):\n                point = Dot(point=[x, y, 0], color=highlight_color)\n                points.add(point)\n        \n        self.play(Create(plane))\n        self.play(Create(points))\n        self.wait(1)\n        \n        # M\u00f6bius transformation formula\n        formula1 = MathTex(r\"f(z) = \\frac{az + b}{cz + d}\", font_size=36)\n        formula1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(formula1))\n        self.wait(1)\n        \n        # Additional formula\n        formula2 = MathTex(r\"f\\left(\\frac{w-\\alpha}{w-\\beta}\\right) = c\", font_size=36)\n        formula2.next_to(formula1, DOWN, buff=0.5)\n        self.play(Write(formula2))\n        self.wait(1)\n        \n        # Fade out formulas to make room for the circle demonstration\n        self.play(FadeOut(formula1), FadeOut(formula2))\n        \n        # Create a circle\n        circle = Circle(radius=2, color=circle_color)\n        inside_text = Text(\"Inside\", font_size=24, color=highlight_color)\n        inside_text.move_to(UP * 0.5)\n        \n        outside_text = Text(\"Outside\", font_size=24, color=highlight_color)\n        outside_text.move_to(DOWN * 3)\n        \n        self.play(Create(circle))\n        self.play(Write(inside_text), Write(outside_text))\n        self.wait(1)\n        \n        # Key insight about M\u00f6bius transformations\n        insight = Text(\"Key Insight: M\u00f6bius transformations\\ncan swap inside and outside\", font_size=24)\n        insight.set_color(highlight_color)\n        insight.to_edge(DOWN, buff=1)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Transformation animation - swapping inside and outside\n        self.play(\n            inside_text.animate.move_to(DOWN * 3),\n            outside_text.animate.move_to(UP * 0.5)\n        )\n        self.wait(1)\n        \n        # Change labels to show the transformation\n        new_inside = Text(\"New Inside\", font_size=24, color=circle_color)\n        new_inside.move_to(outside_text.get_center())\n        \n        new_outside = Text(\"New Outside\", font_size=24, color=circle_color)\n        new_outside.move_to(inside_text.get_center())\n        \n        self.play(\n            Transform(outside_text, new_inside),\n            Transform(inside_text, new_outside)\n        )\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"M\u00f6bius transformations preserve circles\\nbut can interchange their interior and exterior\", font_size=24)\n        conclusion.to_edge(DOWN, buff=1)\n        \n        self.play(FadeOut(insight))\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final cleanup\n        self.play(\n            FadeOut(title), FadeOut(plane), FadeOut(points),\n            FadeOut(circle), FadeOut(inside_text), FadeOut(outside_text),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do M\u00f6bius transformations map the interior and exterior of a given circle in the complex plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do m\u00f6bius transformations map the interior and exterior of a given circle in the complex plane?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MobiusTransformation(Scene):\n    def construct(self):\n        # Colors for our visualization\n        plane_color = \"#3B5EA0\"  # Soft blue\n        highlight_color = \"#FFD700\"  # Gold\n        circle_color = \"#BF40BF\"  # Purple\n        \n        # Introduction: Title\n        title = Text(\"Twist of Geometry: Exploring M\u00f6bius Transformations\", font_size=32)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a complex plane with grid\n        plane = NumberPlane(\n            x_range=[-5, 5, 1],\n            y_range=[-5, 5, 1],\n            background_line_style={\"stroke_color\": plane_color, \"stroke_width\": 1, \"stroke_opacity\": 0.6}\n        )\n        \n        # Add some points to represent complex numbers\n        points = VGroup()\n        for x in range(-4, 5, 2):\n            for y in range(-4, 5, 2):\n                point = Dot(point=[x, y, 0], color=highlight_color)\n                points.add(point)\n        \n        self.play(Create(plane))\n        self.play(Create(points))\n        self.wait(1)\n        \n        # M\u00f6bius transformation formula\n        formula1 = MathTex(r\"f(z) = \\frac{az + b}{cz + d}\", font_size=36)\n        formula1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(formula1))\n        self.wait(1)\n        \n        # Additional formula\n        formula2 = MathTex(r\"f\\left(\\frac{w-\\alpha}{w-\\beta}\\right) = c\", font_size=36)\n        formula2.next_to(formula1, DOWN, buff=0.5)\n        self.play(Write(formula2))\n        self.wait(1)\n        \n        # Fade out formulas to make room for the circle demonstration\n        self.play(FadeOut(formula1), FadeOut(formula2))\n        \n        # Create a circle\n        circle = Circle(radius=2, color=circle_color)\n        inside_text = Text(\"Inside\", font_size=24, color=highlight_color)\n        inside_text.move_to(UP * 0.5)\n        \n        outside_text = Text(\"Outside\", font_size=24, color=highlight_color)\n        outside_text.move_to(DOWN * 3)\n        \n        self.play(Create(circle))\n        self.play(Write(inside_text), Write(outside_text))\n        self.wait(1)\n        \n        # Key insight about M\u00f6bius transformations\n        insight = Text(\"Key Insight: M\u00f6bius transformations\\ncan swap inside and outside\", font_size=24)\n        insight.set_color(highlight_color)\n        insight.to_edge(DOWN, buff=1)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Transformation animation - swapping inside and outside\n        self.play(\n            inside_text.animate.move_to(DOWN * 3),\n            outside_text.animate.move_to(UP * 0.5)\n        )\n        self.wait(1)\n        \n        # Change labels to show the transformation\n        new_inside = Text(\"New Inside\", font_size=24, color=circle_color)\n        new_inside.move_to(outside_text.get_center())\n        \n        new_outside = Text(\"New Outside\", font_size=24, color=circle_color)\n        new_outside.move_to(inside_text.get_center())\n        \n        self.play(\n            Transform(outside_text, new_inside),\n            Transform(inside_text, new_outside)\n        )\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"M\u00f6bius transformations preserve circles\\nbut can interchange their interior and exterior\", font_size=24)\n        conclusion.to_edge(DOWN, buff=1)\n        \n        self.play(FadeOut(insight))\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final cleanup\n        self.play(\n            FadeOut(title), FadeOut(plane), FadeOut(points),\n            FadeOut(circle), FadeOut(inside_text), FadeOut(outside_text),\n            FadeOut(conclusion)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do M\u00f6bius transformations map the interior and exterior of a given circle in the complex plane?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation illustrating the step-by-step process of solving a triple integral. Start by showing the integral of the function xyz over the unit cube with limits from 0 to 1 for all variables. Then gradually integrate with respect to z, y, and finally x, each time updating the visual with the new integral expression after evaluating the previous variable. In between each step, have a short written explanation appear at the top saying which variable we're integrating with respect to next. After the final integration, display the numeric answer on the screen. Once the solution is shown, clear the screen momentarily before showing the final answer again. Can you create this animation in a smooth and understandable manner for teaching calculus students?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the equation of the ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Display the process of solving the ODE\n        solve_ode = Text(\"Solve the differential equation\", font_size=24).to_edge(UP)\n        self.play(Write(solve_ode))\n        self.wait(2)\n\n        # Display the integrating factor\n        int_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        self.play(Write(int_factor))\n        self.wait(1)\n\n        # Replace the Text with the next step\n        method_step = Text(\"Use the integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, method_step))\n        self.wait(2)\n\n        # Multiply through by integrating factor and solve\n        solution = MathTex(r\"y = Ce^{3x}\")\n        self.play(ReplacementTransform(int_factor, solution))\n        self.wait(2)\n\n        # Show the general solution\n        general_solution = MathTex(r\"y(x) = Ce^{3x}\")\n        general_solution.to_edge(DOWN)\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explain the general solution\n        explanation = Text(\"General solution of the first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Highlight general solution for the ODE\n        self.play(Write(general_solution.scale(1.5)))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation illustrating the step-by-step process of solving a triple integral. Start by showing the integral of the function xyz over the unit cube with limits from 0 to 1 for all variables. Then gradually integrate with respect to z, y, and finally x, each time updating the visual with the new integral expression after evaluating the previous variable. In between each step, have a short written explanation appear at the top saying which variable we're integrating with respect to next. After the final integration, display the numeric answer on the screen. Once the solution is shown, clear the screen momentarily before showing the final answer again. Can you create this animation in a smooth and understandable manner for teaching calculus students?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation illustrating the step-by-step process of solving a triple integral. start by showing the integral of the function xyz over the unit cube with limits from 0 to 1 for all variables. then gradually integrate with respect to z, y, and finally x, each time updating the visual with the new integral expression after evaluating the previous variable. in between each step, have a short written explanation appear at the top saying which variable we're integrating with respect to next. after the final integration, display the numeric answer on the screen. once the solution is shown, clear the screen momentarily before showing the final answer again. can you create this animation in a smooth and understandable manner for teaching calculus students?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the equation of the ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Display the process of solving the ODE\n        solve_ode = Text(\"Solve the differential equation\", font_size=24).to_edge(UP)\n        self.play(Write(solve_ode))\n        self.wait(2)\n\n        # Display the integrating factor\n        int_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        self.play(Write(int_factor))\n        self.wait(1)\n\n        # Replace the Text with the next step\n        method_step = Text(\"Use the integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, method_step))\n        self.wait(2)\n\n        # Multiply through by integrating factor and solve\n        solution = MathTex(r\"y = Ce^{3x}\")\n        self.play(ReplacementTransform(int_factor, solution))\n        self.wait(2)\n\n        # Show the general solution\n        general_solution = MathTex(r\"y(x) = Ce^{3x}\")\n        general_solution.to_edge(DOWN)\n        self.play(Write(general_solution))\n        self.wait(1)\n\n        # Explain the general solution\n        explanation = Text(\"General solution of the first-order ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(solve_ode, explanation))\n        self.wait(2)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Highlight general solution for the ODE\n        self.play(Write(general_solution.scale(1.5)))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation illustrating the step-by-step process of solving a triple integral. Start by showing the integral of the function xyz over the unit cube with limits from 0 to 1 for all variables. Then gradually integrate with respect to z, y, and finally x, each time updating the visual with the new integral expression after evaluating the previous variable. In between each step, have a short written explanation appear at the top saying which variable we're integrating with respect to next. After the final integration, display the numeric answer on the screen. Once the solution is shown, clear the screen momentarily before showing the final answer again. Can you create this animation in a smooth and understandable manner for teaching calculus students?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can the process of decomposing a semi-simple module into its simple summands be related to any real-world system or structure, like a data flow diagram?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SemiSimpleModules(Scene):\n    def construct(self):\n        # Set background color\n        self.camera.background_color = \"#111111\"\n        \n        # Title\n        title = Text(\"Building Networks: The Beauty of Semi-Simple Modules\", font_size=32)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Simple Modules visualization\n        simple_text = Text(\"Simple Modules: Independent Units\", font_size=24)\n        simple_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(simple_text))\n        \n        # Create colored circles representing simple modules\n        circles = VGroup()\n        colors = [BLUE_D, GREEN_D, RED_D, YELLOW_D]\n        positions = [[-3, 0, 0], [-1, 0, 0], [1, 0, 0], [3, 0, 0]]\n        \n        for i in range(4):\n            circle = Circle(radius=0.5, color=colors[i], fill_opacity=0.5)\n            circle.move_to(positions[i])\n            circles.add(circle)\n        \n        self.play(Create(circles))\n        \n        # Add labels to the circles\n        labels = VGroup()\n        for i in range(4):\n            label = Text(f\"M{i+1}\", font_size=24, color=WHITE)\n            label.move_to(circles[i].get_center())\n            labels.add(label)\n        \n        self.play(Write(labels))\n        self.wait(1)\n        \n        # Semi-Simple Module visualization\n        semisimple_text = Text(\"Semi-Simple Module: Network Structure\", font_size=24)\n        semisimple_text.next_to(title, DOWN, buff=0.5)\n        \n        self.play(\n            FadeOut(simple_text),\n            FadeIn(semisimple_text)\n        )\n        \n        # Move the circles to form a network\n        new_positions = [[-2, 1, 0], [-2, -1, 0], [2, 1, 0], [2, -1, 0]]\n        \n        # Move circles to new positions\n        self.play(*[circle.animate.move_to(pos) for circle, pos in zip(circles, new_positions)])\n        \n        # Update the labels positions\n        self.play(*[label.animate.move_to(pos) for label, pos in zip(labels, new_positions)])\n        \n        # Create connections between nodes\n        connections = VGroup()\n        connection_pairs = [(0, 1), (0, 2), (1, 3), (2, 3)]\n        \n        for i, j in connection_pairs:\n            connection = Line(\n                start=circles[i].get_center(),\n                end=circles[j].get_center(),\n                stroke_width=2,\n                color=WHITE\n            )\n            connections.add(connection)\n        \n        self.play(Create(connections))\n        self.wait(1)\n        \n        # Equation showing the decomposition\n        equation = MathTex(\n            \"M \\\\cong M_1 \\\\oplus M_2 \\\\oplus M_3 \\\\oplus M_4\",\n            font_size=32\n        )\n        equation.to_edge(DOWN, buff=1)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Highlight all nodes to show unified structure\n        self.play(\n            *[circle.animate.set_fill(opacity=0.8) for circle in circles],\n            *[connection.animate.set_stroke(width=3, color=BLUE_D) for connection in connections]\n        )\n        \n        # Final thought\n        conclusion = Text(\"Mathematics mirrors real-world networks\", font_size=24)\n        conclusion.next_to(equation, UP, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can the process of decomposing a semi-simple module into its simple summands be related to any real-world system or structure, like a data flow diagram?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can the process of decomposing a semi-simple module into its simple summands be related to any real-world system or structure, like a data flow diagram?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SemiSimpleModules(Scene):\n    def construct(self):\n        # Set background color\n        self.camera.background_color = \"#111111\"\n        \n        # Title\n        title = Text(\"Building Networks: The Beauty of Semi-Simple Modules\", font_size=32)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Simple Modules visualization\n        simple_text = Text(\"Simple Modules: Independent Units\", font_size=24)\n        simple_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(simple_text))\n        \n        # Create colored circles representing simple modules\n        circles = VGroup()\n        colors = [BLUE_D, GREEN_D, RED_D, YELLOW_D]\n        positions = [[-3, 0, 0], [-1, 0, 0], [1, 0, 0], [3, 0, 0]]\n        \n        for i in range(4):\n            circle = Circle(radius=0.5, color=colors[i], fill_opacity=0.5)\n            circle.move_to(positions[i])\n            circles.add(circle)\n        \n        self.play(Create(circles))\n        \n        # Add labels to the circles\n        labels = VGroup()\n        for i in range(4):\n            label = Text(f\"M{i+1}\", font_size=24, color=WHITE)\n            label.move_to(circles[i].get_center())\n            labels.add(label)\n        \n        self.play(Write(labels))\n        self.wait(1)\n        \n        # Semi-Simple Module visualization\n        semisimple_text = Text(\"Semi-Simple Module: Network Structure\", font_size=24)\n        semisimple_text.next_to(title, DOWN, buff=0.5)\n        \n        self.play(\n            FadeOut(simple_text),\n            FadeIn(semisimple_text)\n        )\n        \n        # Move the circles to form a network\n        new_positions = [[-2, 1, 0], [-2, -1, 0], [2, 1, 0], [2, -1, 0]]\n        \n        # Move circles to new positions\n        self.play(*[circle.animate.move_to(pos) for circle, pos in zip(circles, new_positions)])\n        \n        # Update the labels positions\n        self.play(*[label.animate.move_to(pos) for label, pos in zip(labels, new_positions)])\n        \n        # Create connections between nodes\n        connections = VGroup()\n        connection_pairs = [(0, 1), (0, 2), (1, 3), (2, 3)]\n        \n        for i, j in connection_pairs:\n            connection = Line(\n                start=circles[i].get_center(),\n                end=circles[j].get_center(),\n                stroke_width=2,\n                color=WHITE\n            )\n            connections.add(connection)\n        \n        self.play(Create(connections))\n        self.wait(1)\n        \n        # Equation showing the decomposition\n        equation = MathTex(\n            \"M \\\\cong M_1 \\\\oplus M_2 \\\\oplus M_3 \\\\oplus M_4\",\n            font_size=32\n        )\n        equation.to_edge(DOWN, buff=1)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Highlight all nodes to show unified structure\n        self.play(\n            *[circle.animate.set_fill(opacity=0.8) for circle in circles],\n            *[connection.animate.set_stroke(width=3, color=BLUE_D) for connection in connections]\n        )\n        \n        # Final thought\n        conclusion = Text(\"Mathematics mirrors real-world networks\", font_size=24)\n        conclusion.next_to(equation, UP, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can the process of decomposing a semi-simple module into its simple summands be related to any real-world system or structure, like a data flow diagram?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display 3D axes. Show a red checkerboard-patterned sphere. Place the light source above the sphere. Set the camera orientation to a specific angle. "}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDLightSourcePosition(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        sphere = Surface(\n            lambda u, v: np.array([\n                1.5 * np.cos(u) * np.cos(v),\n                1.5 * np.cos(u) * np.sin(v),\n                1.5 * np.sin(u)\n            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],\n            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)\n        )\n        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, sphere)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes. Show a red checkerboard-patterned sphere. Place the light source above the sphere. Set the camera orientation to a specific angle. "}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display 3d axes. show a red checkerboard-patterned sphere. place the light source above the sphere. set the camera orientation to a specific angle. "}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDLightSourcePosition(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        sphere = Surface(\n            lambda u, v: np.array([\n                1.5 * np.cos(u) * np.cos(v),\n                1.5 * np.cos(u) * np.sin(v),\n                1.5 * np.sin(u)\n            ]), v_range=[0, TAU], u_range=[-PI / 2, PI / 2],\n            checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)\n        )\n        self.renderer.camera.light_source.move_to(3*IN) # changes the source of the light\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes, sphere)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes. Show a red checkerboard-patterned sphere. Place the light source above the sphere. Set the camera orientation to a specific angle. "}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a standard cross shape centered on the screen, formed by two intersecting rectangles\u2014one vertical and one horizontal\u2014creating a simple \u201cX\u201d mark."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleCross(Scene):\n    def construct(self):\n        cross = Cross()\n        self.add(cross)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a standard cross shape centered on the screen, formed by two intersecting rectangles\u2014one vertical and one horizontal\u2014creating a simple \u201cX\u201d mark."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a standard cross shape centered on the screen, formed by two intersecting rectangles\u2014one vertical and one horizontal\u2014creating a simple \u201cx\u201d mark."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleCross(Scene):\n    def construct(self):\n        cross = Cross()\n        self.add(cross)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a standard cross shape centered on the screen, formed by two intersecting rectangles\u2014one vertical and one horizontal\u2014creating a simple \u201cX\u201d mark."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a row of four shapes\u2014square, circle, triangle, and star\u2014arranged horizontally. Then, animate them cycling their positions to the right four times, so that each shape moves to the next position in the sequence, creating a rotating effect among the group."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a row of four shapes\u2014square, circle, triangle, and star\u2014arranged horizontally. Then, animate them cycling their positions to the right four times, so that each shape moves to the next position in the sequence, creating a rotating effect among the group."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a row of four shapes\u2014square, circle, triangle, and star\u2014arranged horizontally. then, animate them cycling their positions to the right four times, so that each shape moves to the next position in the sequence, creating a rotating effect among the group."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CyclicReplaceExample(Scene):\n    def construct(self):\n        group = VGroup(Square(), Circle(), Triangle(), Star())\n        group.arrange(RIGHT)\n        self.add(group)\n\n        for _ in range(4):\n            self.play(CyclicReplace(*group))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a row of four shapes\u2014square, circle, triangle, and star\u2014arranged horizontally. Then, animate them cycling their positions to the right four times, so that each shape moves to the next position in the sequence, creating a rotating effect among the group."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "activation_functions.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(\n                    3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"\n                ),\n                FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "activation_functions.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that activation_functions.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(\n                    3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"\n                ),\n                FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.play(ChangeSpeed(forward_pass, speedinfo={}), run_time=10)\n        self.wait(1)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "activation_functions.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a stationary line from left to right. Show a second line rotating around a point on the left, forming an angle with the stationary line. Label the angle with the Greek letter theta (\u03b8). Animate the rotating line to change its angle, updating the angle and its label dynamically. Change the color of the theta label to red briefly."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a stationary line from left to right. Show a second line rotating around a point on the left, forming an angle with the stationary line. Label the angle with the Greek letter theta (\u03b8). Animate the rotating line to change its angle, updating the angle and its label dynamically. Change the color of the theta label to red briefly."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a stationary line from left to right. show a second line rotating around a point on the left, forming an angle with the stationary line. label the angle with the greek letter theta (\u03b8). animate the rotating line to change its angle, updating the angle and its label dynamically. change the color of the theta label to red briefly."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MovingAngle(Scene):\n    def construct(self):\n        rotation_center = LEFT\n\n        theta_tracker = ValueTracker(110)\n        line1 = Line(LEFT, RIGHT)\n        line_moving = Line(LEFT, RIGHT)\n        line_ref = line_moving.copy()\n        line_moving.rotate(\n            theta_tracker.get_value() * DEGREES, about_point=rotation_center\n        )\n        a = Angle(line1, line_moving, radius=0.5, other_angle=False)\n        tex = MathTex(r\"\\theta\").move_to(\n            Angle(\n                line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n            ).point_from_proportion(0.5)\n        )\n\n        self.add(line1, line_moving, a, tex)\n        self.wait()\n\n        line_moving.add_updater(\n            lambda x: x.become(line_ref.copy()).rotate(\n                theta_tracker.get_value() * DEGREES, about_point=rotation_center\n            )\n        )\n\n        a.add_updater(\n            lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))\n        )\n        tex.add_updater(\n            lambda x: x.move_to(\n                Angle(\n                    line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False\n                ).point_from_proportion(0.5)\n            )\n        )\n\n        self.play(theta_tracker.animate.set_value(40))\n        self.play(theta_tracker.animate.increment_value(140))\n        self.play(tex.animate.set_color(RED), run_time=0.5)\n        self.play(theta_tracker.animate.set_value(350))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a stationary line from left to right. Show a second line rotating around a point on the left, forming an angle with the stationary line. Label the angle with the Greek letter theta (\u03b8). Animate the rotating line to change its angle, updating the angle and its label dynamically. Change the color of the theta label to red briefly."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a row of green quarter-circle arcs, each with a thick stroke and a different cap style (such as butt, round, or square). The arcs are evenly spaced horizontally, and each one is labeled below with the name of its corresponding cap style, helping to visually compare the stroke end variations."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CapStyleVariants(Scene):\n    def construct(self):\n        arcs = VGroup(*[\n            Arc(\n                radius=1,\n                start_angle=0,\n                angle=TAU / 4,\n                stroke_width=20,\n                color=GREEN,\n                cap_style=cap_style,\n            )\n            for cap_style in CapStyleType\n        ])\n        arcs.arrange(RIGHT, buff=1)\n        self.add(arcs)\n        for arc in arcs:\n            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n            self.add(label)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a row of green quarter-circle arcs, each with a thick stroke and a different cap style (such as butt, round, or square). The arcs are evenly spaced horizontally, and each one is labeled below with the name of its corresponding cap style, helping to visually compare the stroke end variations."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a row of green quarter-circle arcs, each with a thick stroke and a different cap style (such as butt, round, or square). the arcs are evenly spaced horizontally, and each one is labeled below with the name of its corresponding cap style, helping to visually compare the stroke end variations."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CapStyleVariants(Scene):\n    def construct(self):\n        arcs = VGroup(*[\n            Arc(\n                radius=1,\n                start_angle=0,\n                angle=TAU / 4,\n                stroke_width=20,\n                color=GREEN,\n                cap_style=cap_style,\n            )\n            for cap_style in CapStyleType\n        ])\n        arcs.arrange(RIGHT, buff=1)\n        self.add(arcs)\n        for arc in arcs:\n            label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n            self.add(label)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a row of green quarter-circle arcs, each with a thick stroke and a different cap style (such as butt, round, or square). The arcs are evenly spaced horizontally, and each one is labeled below with the name of its corresponding cap style, helping to visually compare the stroke end variations."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the Argument Principle apply when considering functions with essential singularities inside the contour?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArgumentPrincipleScene(Scene):\n    def construct(self):\n        # Set background color\n        self.camera.background_color = \"#0A2647\"  # Deep blue\n        \n        # Title\n        title = Text(\"Argument Principle & Essential Singularities\", font_size=32, color=YELLOW)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction - Complex plane\n        complex_plane = NumberPlane(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            background_line_style={\n                \"stroke_color\": BLUE_D,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.3\n            }\n        )\n        \n        intro_text = Text(\"Welcome to complex analysis\", font_size=24, color=WHITE)\n        intro_text.next_to(title, DOWN, buff=0.5)\n        \n        self.play(Create(complex_plane), Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Argument Principle equation\n        equation = MathTex(r\"\\oint_C \\frac{f'(z)}{f(z)} \\, dz = 2\\pi i (N - P)\")\n        equation.set_color(YELLOW)\n        equation.next_to(title, DOWN, buff=1)\n        \n        eq_text = Text(\"This counts zeros and poles inside a contour\", font_size=24, color=WHITE)\n        eq_text.next_to(equation, DOWN)\n        \n        self.play(Write(equation))\n        self.play(Write(eq_text))\n        self.wait(1.5)\n        \n        # Create a contour and points\n        contour = Circle(radius=2, color=YELLOW)\n        \n        zero = Dot(np.array([1, 1, 0]), color=BLUE)\n        pole = Dot(np.array([-1, 1, 0]), color=RED)\n        essential = Dot(np.array([0, 0, 0]), color=GREEN)\n        \n        zero_label = Text(\"Zero\", color=BLUE, font_size=20).next_to(zero, DOWN)\n        pole_label = Text(\"Pole\", color=RED, font_size=20).next_to(pole, DOWN)\n        essential_label = Text(\"Essential\", color=GREEN, font_size=20).next_to(essential, DOWN)\n        \n        self.play(\n            FadeOut(equation),\n            FadeOut(eq_text),\n            Create(contour)\n        )\n        self.play(\n            Create(zero), Write(zero_label),\n            Create(pole), Write(pole_label),\n            Create(essential), Write(essential_label)\n        )\n        self.wait(1)\n        \n        # Focus on essential singularity\n        self.play(\n            FadeOut(zero), FadeOut(zero_label),\n            FadeOut(pole), FadeOut(pole_label)\n        )\n        \n        singularity_text = Text(\"Essential singularities create chaos\", font_size=24, color=WHITE)\n        singularity_text.next_to(title, DOWN, buff=0.5)\n        \n        self.play(Write(singularity_text))\n        self.wait(1)\n        \n        # Simple chaotic lines\n        chaotic_lines = VGroup()\n        for i in range(6):\n            angle = i * PI / 3\n            line = Line(\n                0.3 * np.array([np.cos(angle), np.sin(angle), 0]),\n                1.5 * np.array([np.cos(angle+0.7), np.sin(angle+0.7), 0]),\n                color=YELLOW\n            )\n            chaotic_lines.add(line)\n        \n        self.play(Create(chaotic_lines))\n        self.wait(1)\n        \n        # Simple spiral\n        spiral_text = Text(\"Arguments wind infinitely\", font_size=24, color=WHITE)\n        spiral_text.next_to(singularity_text, DOWN, buff=0.5)\n        \n        spiral = VMobject(color=WHITE)\n        points = []\n        for t in np.linspace(0, 4*PI, 40):\n            r = 0.2 + 0.1 * t / (2*PI)\n            x = r * np.cos(t)\n            y = r * np.sin(t)\n            points.append([x, y, 0])\n        spiral.set_points_as_corners(points)\n        \n        self.play(Write(spiral_text))\n        self.play(Create(spiral))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(spiral),\n            FadeOut(chaotic_lines),\n            FadeOut(spiral_text),\n            FadeOut(singularity_text),\n            FadeOut(essential),\n            FadeOut(essential_label),\n            FadeOut(contour)\n        )\n        \n        conclusion_text = Text(\"Order within chaos\", font_size=28, color=YELLOW)\n        conclusion_text.next_to(title, DOWN, buff=1)\n        \n        # Simple harmonizing pattern\n        circle1 = Circle(radius=1.5, color=BLUE)\n        circle2 = Circle(radius=1, color=YELLOW)\n        \n        self.play(Write(conclusion_text))\n        self.play(Create(circle1), Create(circle2))\n        self.wait(1)\n        \n        self.play(\n            FadeOut(circle1),\n            FadeOut(circle2),\n            FadeOut(conclusion_text),\n            FadeOut(title),\n            FadeOut(complex_plane)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Argument Principle apply when considering functions with essential singularities inside the contour?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the argument principle apply when considering functions with essential singularities inside the contour?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArgumentPrincipleScene(Scene):\n    def construct(self):\n        # Set background color\n        self.camera.background_color = \"#0A2647\"  # Deep blue\n        \n        # Title\n        title = Text(\"Argument Principle & Essential Singularities\", font_size=32, color=YELLOW)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction - Complex plane\n        complex_plane = NumberPlane(\n            x_range=[-4, 4, 1],\n            y_range=[-3, 3, 1],\n            background_line_style={\n                \"stroke_color\": BLUE_D,\n                \"stroke_width\": 1,\n                \"stroke_opacity\": 0.3\n            }\n        )\n        \n        intro_text = Text(\"Welcome to complex analysis\", font_size=24, color=WHITE)\n        intro_text.next_to(title, DOWN, buff=0.5)\n        \n        self.play(Create(complex_plane), Write(intro_text))\n        self.wait(1)\n        self.play(FadeOut(intro_text))\n        \n        # Argument Principle equation\n        equation = MathTex(r\"\\oint_C \\frac{f'(z)}{f(z)} \\, dz = 2\\pi i (N - P)\")\n        equation.set_color(YELLOW)\n        equation.next_to(title, DOWN, buff=1)\n        \n        eq_text = Text(\"This counts zeros and poles inside a contour\", font_size=24, color=WHITE)\n        eq_text.next_to(equation, DOWN)\n        \n        self.play(Write(equation))\n        self.play(Write(eq_text))\n        self.wait(1.5)\n        \n        # Create a contour and points\n        contour = Circle(radius=2, color=YELLOW)\n        \n        zero = Dot(np.array([1, 1, 0]), color=BLUE)\n        pole = Dot(np.array([-1, 1, 0]), color=RED)\n        essential = Dot(np.array([0, 0, 0]), color=GREEN)\n        \n        zero_label = Text(\"Zero\", color=BLUE, font_size=20).next_to(zero, DOWN)\n        pole_label = Text(\"Pole\", color=RED, font_size=20).next_to(pole, DOWN)\n        essential_label = Text(\"Essential\", color=GREEN, font_size=20).next_to(essential, DOWN)\n        \n        self.play(\n            FadeOut(equation),\n            FadeOut(eq_text),\n            Create(contour)\n        )\n        self.play(\n            Create(zero), Write(zero_label),\n            Create(pole), Write(pole_label),\n            Create(essential), Write(essential_label)\n        )\n        self.wait(1)\n        \n        # Focus on essential singularity\n        self.play(\n            FadeOut(zero), FadeOut(zero_label),\n            FadeOut(pole), FadeOut(pole_label)\n        )\n        \n        singularity_text = Text(\"Essential singularities create chaos\", font_size=24, color=WHITE)\n        singularity_text.next_to(title, DOWN, buff=0.5)\n        \n        self.play(Write(singularity_text))\n        self.wait(1)\n        \n        # Simple chaotic lines\n        chaotic_lines = VGroup()\n        for i in range(6):\n            angle = i * PI / 3\n            line = Line(\n                0.3 * np.array([np.cos(angle), np.sin(angle), 0]),\n                1.5 * np.array([np.cos(angle+0.7), np.sin(angle+0.7), 0]),\n                color=YELLOW\n            )\n            chaotic_lines.add(line)\n        \n        self.play(Create(chaotic_lines))\n        self.wait(1)\n        \n        # Simple spiral\n        spiral_text = Text(\"Arguments wind infinitely\", font_size=24, color=WHITE)\n        spiral_text.next_to(singularity_text, DOWN, buff=0.5)\n        \n        spiral = VMobject(color=WHITE)\n        points = []\n        for t in np.linspace(0, 4*PI, 40):\n            r = 0.2 + 0.1 * t / (2*PI)\n            x = r * np.cos(t)\n            y = r * np.sin(t)\n            points.append([x, y, 0])\n        spiral.set_points_as_corners(points)\n        \n        self.play(Write(spiral_text))\n        self.play(Create(spiral))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(spiral),\n            FadeOut(chaotic_lines),\n            FadeOut(spiral_text),\n            FadeOut(singularity_text),\n            FadeOut(essential),\n            FadeOut(essential_label),\n            FadeOut(contour)\n        )\n        \n        conclusion_text = Text(\"Order within chaos\", font_size=28, color=YELLOW)\n        conclusion_text.next_to(title, DOWN, buff=1)\n        \n        # Simple harmonizing pattern\n        circle1 = Circle(radius=1.5, color=BLUE)\n        circle2 = Circle(radius=1, color=YELLOW)\n        \n        self.play(Write(conclusion_text))\n        self.play(Create(circle1), Create(circle2))\n        self.wait(1)\n        \n        self.play(\n            FadeOut(circle1),\n            FadeOut(circle2),\n            FadeOut(conclusion_text),\n            FadeOut(title),\n            FadeOut(complex_plane)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Argument Principle apply when considering functions with essential singularities inside the contour?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What are the implications of node feature permutation invariance in designing graph neural networks?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphPermutationInvariance(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Permutation Invariance in Graph Neural Networks\", font_size=30)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Move title to top\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Welcome to the world of graph neural networks!\", font_size=24)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(FadeOut(intro))\n        \n        # Key Concept 1\n        concept1 = Text(\"Node Feature Permutation Invariance\", font_size=26)\n        concept1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept1))\n        self.wait(1)\n        \n        # Create a simple graph with 4 nodes\n        graph1 = VGroup()\n        positions = [[-2, 0, 0], [0, 2, 0], [2, 0, 0], [0, -2, 0]]\n        \n        # Create nodes\n        for i, pos in enumerate(positions):\n            node = Circle(radius=0.3, color=BLUE).move_to(pos)\n            label = Text(str(i+1), font_size=24).move_to(pos)\n            graph1.add(node, label)\n        \n        # Create edges\n        edge_pairs = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\n        for i, j in edge_pairs:\n            edge = Line(positions[i], positions[j], color=WHITE)\n            graph1.add(edge)\n        \n        # Show the first graph\n        self.play(Create(graph1))\n        self.wait(1)\n        \n        explanation1 = Text(\"Original Graph with Node Ordering: 1,2,3,4\", font_size=20)\n        explanation1.next_to(graph1, DOWN, buff=0.5)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Key Concept 2\n        self.play(FadeOut(graph1), FadeOut(explanation1), FadeOut(concept1))\n        \n        concept2 = Text(\"Same Graph, Different Labels\", font_size=26)\n        concept2.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept2))\n        self.wait(1)\n        \n        # Second graph - permuted ordering\n        graph2 = VGroup()\n        permuted_labels = [\"3\", \"2\", \"1\", \"4\"]  # Permuted ordering\n        \n        # Create nodes with permuted labels\n        for i, pos in enumerate(positions):\n            node = Circle(radius=0.3, color=GREEN).move_to(pos)\n            label = Text(permuted_labels[i], font_size=24).move_to(pos)\n            graph2.add(node, label)\n        \n        # Create the same edges\n        for i, j in edge_pairs:\n            edge = Line(positions[i], positions[j], color=WHITE)\n            graph2.add(edge)\n        \n        self.play(Create(graph2))\n        self.wait(1)\n        \n        explanation2 = Text(\"Different labels, same underlying structure\", font_size=20)\n        explanation2.next_to(graph2, DOWN, buff=0.5)\n        self.play(Write(explanation2))\n        self.wait(2)\n        \n        # Key Insight\n        self.play(FadeOut(graph2), FadeOut(explanation2), FadeOut(concept2))\n        \n        insight = Text(\"Key Insight: GNNs must be Permutation Invariant\", font_size=24)\n        insight.next_to(title, DOWN, buff=0.5)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Equation\n        equation = MathTex(r\"f(G) = f(\\sigma(G))\")\n        equation.next_to(insight, DOWN, buff=0.7)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        eq_explanation = Text(\"Same output regardless of node ordering (\u03c3 is permutation)\", font_size=20)\n        eq_explanation.next_to(equation, DOWN, buff=0.5)\n        self.play(Write(eq_explanation))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(insight), FadeOut(equation), FadeOut(eq_explanation))\n        \n        conclusion = Text(\"Conclusion\", font_size=28)\n        conclusion.next_to(title, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        summary = Text(\"Permutation invariance ensures reliable graph analysis\", font_size=22)\n        summary.next_to(conclusion, DOWN, buff=0.7)\n        self.play(Write(summary))\n        self.wait(2)\n        \n        # Final fadeout\n        self.play(FadeOut(title), FadeOut(conclusion), FadeOut(summary))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the implications of node feature permutation invariance in designing graph neural networks?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what are the implications of node feature permutation invariance in designing graph neural networks?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass GraphPermutationInvariance(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Permutation Invariance in Graph Neural Networks\", font_size=30)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Move title to top\n        self.play(title.animate.to_edge(UP))\n        \n        # Introduction\n        intro = Text(\"Welcome to the world of graph neural networks!\", font_size=24)\n        intro.next_to(title, DOWN, buff=0.5)\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(FadeOut(intro))\n        \n        # Key Concept 1\n        concept1 = Text(\"Node Feature Permutation Invariance\", font_size=26)\n        concept1.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept1))\n        self.wait(1)\n        \n        # Create a simple graph with 4 nodes\n        graph1 = VGroup()\n        positions = [[-2, 0, 0], [0, 2, 0], [2, 0, 0], [0, -2, 0]]\n        \n        # Create nodes\n        for i, pos in enumerate(positions):\n            node = Circle(radius=0.3, color=BLUE).move_to(pos)\n            label = Text(str(i+1), font_size=24).move_to(pos)\n            graph1.add(node, label)\n        \n        # Create edges\n        edge_pairs = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\n        for i, j in edge_pairs:\n            edge = Line(positions[i], positions[j], color=WHITE)\n            graph1.add(edge)\n        \n        # Show the first graph\n        self.play(Create(graph1))\n        self.wait(1)\n        \n        explanation1 = Text(\"Original Graph with Node Ordering: 1,2,3,4\", font_size=20)\n        explanation1.next_to(graph1, DOWN, buff=0.5)\n        self.play(Write(explanation1))\n        self.wait(2)\n        \n        # Key Concept 2\n        self.play(FadeOut(graph1), FadeOut(explanation1), FadeOut(concept1))\n        \n        concept2 = Text(\"Same Graph, Different Labels\", font_size=26)\n        concept2.next_to(title, DOWN, buff=0.5)\n        self.play(Write(concept2))\n        self.wait(1)\n        \n        # Second graph - permuted ordering\n        graph2 = VGroup()\n        permuted_labels = [\"3\", \"2\", \"1\", \"4\"]  # Permuted ordering\n        \n        # Create nodes with permuted labels\n        for i, pos in enumerate(positions):\n            node = Circle(radius=0.3, color=GREEN).move_to(pos)\n            label = Text(permuted_labels[i], font_size=24).move_to(pos)\n            graph2.add(node, label)\n        \n        # Create the same edges\n        for i, j in edge_pairs:\n            edge = Line(positions[i], positions[j], color=WHITE)\n            graph2.add(edge)\n        \n        self.play(Create(graph2))\n        self.wait(1)\n        \n        explanation2 = Text(\"Different labels, same underlying structure\", font_size=20)\n        explanation2.next_to(graph2, DOWN, buff=0.5)\n        self.play(Write(explanation2))\n        self.wait(2)\n        \n        # Key Insight\n        self.play(FadeOut(graph2), FadeOut(explanation2), FadeOut(concept2))\n        \n        insight = Text(\"Key Insight: GNNs must be Permutation Invariant\", font_size=24)\n        insight.next_to(title, DOWN, buff=0.5)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Equation\n        equation = MathTex(r\"f(G) = f(\\sigma(G))\")\n        equation.next_to(insight, DOWN, buff=0.7)\n        self.play(Write(equation))\n        self.wait(1)\n        \n        eq_explanation = Text(\"Same output regardless of node ordering (\u03c3 is permutation)\", font_size=20)\n        eq_explanation.next_to(equation, DOWN, buff=0.5)\n        self.play(Write(eq_explanation))\n        self.wait(2)\n        \n        # Conclusion\n        self.play(FadeOut(insight), FadeOut(equation), FadeOut(eq_explanation))\n        \n        conclusion = Text(\"Conclusion\", font_size=28)\n        conclusion.next_to(title, DOWN, buff=0.5)\n        self.play(Write(conclusion))\n        self.wait(1)\n        \n        summary = Text(\"Permutation invariance ensures reliable graph analysis\", font_size=22)\n        summary.next_to(conclusion, DOWN, buff=0.7)\n        self.play(Write(summary))\n        self.wait(2)\n        \n        # Final fadeout\n        self.play(FadeOut(title), FadeOut(conclusion), FadeOut(summary))\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the implications of node feature permutation invariance in designing graph neural networks?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that depicts the Sun, Earth, and the Moon where the Sun is stationary at the center, the Earth orbits around the Sun, and the Moon orbits the Earth in a smaller circular path? The Sun should be yellow and the largest, the Earth should be blue and smaller than the Sun, and the Moon should be white and the smallest of all. Make sure the Earth's orbit is not visible, but the Earth itself should be seen clearly revolving. The animation should show the Moon completing its orbit around the Earth at a visible but slow pace, and the whole scene should last approximately 50 seconds."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AtomDiagram(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=BLUE)\n        oxygen_atom.set_fill(BLUE, opacity=0.5)\n        oxygen_text = Text(\"O\", color=WHITE)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.3, color=GREY)\n        hydrogen_atom.set_fill(GREY, opacity=0.5)\n        hydrogen_text = Text(\"H\", color=WHITE)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position the hydrogen atoms around the oxygen\n        hydrogen.move_to(oxygen.get_edge_center(UP) + UP * 0.4)\n        hydrogen_copy1 = hydrogen.copy().shift(LEFT * 0.8 + DOWN * 0.4)\n        hydrogen_copy2 = hydrogen.copy().shift(RIGHT * 0.8 + DOWN * 0.4)\n\n        # Connect the atoms with lines to indicate bonds\n        bond1 = Line(hydrogen.get_center(), oxygen.get_edge_center(UP))\n        bond2 = Line(hydrogen_copy1.get_center(), oxygen.get_edge_center(DL))\n        bond3 = Line(hydrogen_copy2.get_center(), oxygen.get_edge_center(DR))\n\n        # Create a water molecule group\n        water_molecule = VGroup(oxygen, hydrogen, hydrogen_copy1, hydrogen_copy2, bond1, bond2, bond3)\n\n        # Display the water molecule\n        self.play(FadeIn(water_molecule))\n        self.wait(2)\n        self.play(FadeOut(water_molecule))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that depicts the Sun, Earth, and the Moon where the Sun is stationary at the center, the Earth orbits around the Sun, and the Moon orbits the Earth in a smaller circular path? The Sun should be yellow and the largest, the Earth should be blue and smaller than the Sun, and the Moon should be white and the smallest of all. Make sure the Earth's orbit is not visible, but the Earth itself should be seen clearly revolving. The animation should show the Moon completing its orbit around the Earth at a visible but slow pace, and the whole scene should last approximately 50 seconds."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that depicts the sun, earth, and the moon where the sun is stationary at the center, the earth orbits around the sun, and the moon orbits the earth in a smaller circular path? the sun should be yellow and the largest, the earth should be blue and smaller than the sun, and the moon should be white and the smallest of all. make sure the earth's orbit is not visible, but the earth itself should be seen clearly revolving. the animation should show the moon completing its orbit around the earth at a visible but slow pace, and the whole scene should last approximately 50 seconds."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AtomDiagram(Scene):\n    def construct(self):\n        # Create an oxygen atom\n        oxygen_atom = Circle(radius=0.5, color=BLUE)\n        oxygen_atom.set_fill(BLUE, opacity=0.5)\n        oxygen_text = Text(\"O\", color=WHITE)\n        oxygen = VGroup(oxygen_atom, oxygen_text)\n\n        # Create a hydrogen atom\n        hydrogen_atom = Circle(radius=0.3, color=GREY)\n        hydrogen_atom.set_fill(GREY, opacity=0.5)\n        hydrogen_text = Text(\"H\", color=WHITE)\n        hydrogen = VGroup(hydrogen_atom, hydrogen_text)\n\n        # Position the hydrogen atoms around the oxygen\n        hydrogen.move_to(oxygen.get_edge_center(UP) + UP * 0.4)\n        hydrogen_copy1 = hydrogen.copy().shift(LEFT * 0.8 + DOWN * 0.4)\n        hydrogen_copy2 = hydrogen.copy().shift(RIGHT * 0.8 + DOWN * 0.4)\n\n        # Connect the atoms with lines to indicate bonds\n        bond1 = Line(hydrogen.get_center(), oxygen.get_edge_center(UP))\n        bond2 = Line(hydrogen_copy1.get_center(), oxygen.get_edge_center(DL))\n        bond3 = Line(hydrogen_copy2.get_center(), oxygen.get_edge_center(DR))\n\n        # Create a water molecule group\n        water_molecule = VGroup(oxygen, hydrogen, hydrogen_copy1, hydrogen_copy2, bond1, bond2, bond3)\n\n        # Display the water molecule\n        self.play(FadeIn(water_molecule))\n        self.wait(2)\n        self.play(FadeOut(water_molecule))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that depicts the Sun, Earth, and the Moon where the Sun is stationary at the center, the Earth orbits around the Sun, and the Moon orbits the Earth in a smaller circular path? The Sun should be yellow and the largest, the Earth should be blue and smaller than the Sun, and the Moon should be white and the smallest of all. Make sure the Earth's orbit is not visible, but the Earth itself should be seen clearly revolving. The animation should show the Moon completing its orbit around the Earth at a visible but slow pace, and the whole scene should last approximately 50 seconds."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the word \"Hello\" in which all letters except the first and last are blue, positioned to the left. Next to it on the right, display the word \"World\" with the letters \"r\" and \"l\" in red."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Textt2cExample(Scene):\n    def construct(self):\n        t2cindices = Text('Hello', t2c={'[1:-1]': BLUE}).move_to(LEFT)\n        t2cwords = Text('World',t2c={'rl':RED}).next_to(t2cindices, RIGHT)\n        self.add(t2cindices, t2cwords)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \"Hello\" in which all letters except the first and last are blue, positioned to the left. Next to it on the right, display the word \"World\" with the letters \"r\" and \"l\" in red."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the word \"hello\" in which all letters except the first and last are blue, positioned to the left. next to it on the right, display the word \"world\" with the letters \"r\" and \"l\" in red."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Textt2cExample(Scene):\n    def construct(self):\n        t2cindices = Text('Hello', t2c={'[1:-1]': BLUE}).move_to(LEFT)\n        t2cwords = Text('World',t2c={'rl':RED}).next_to(t2cindices, RIGHT)\n        self.add(t2cindices, t2cwords)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the word \"Hello\" in which all letters except the first and last are blue, positioned to the left. Next to it on the right, display the word \"World\" with the letters \"r\" and \"l\" in red."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like to create an educational animation that visualizes the movement of an electron through a complex path on a grid. The grid should have 4 rows and 4 columns, and each cell should be fairly small. I imagine an electron starting at a specific point and then moving through a predefined zigzag path that represents a complex trajectory before disappearing from the grid. Can you illustrate this concept in a simple and clear animation, including the grid appearing at first and then fading out with the electron after the path is complete?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LimitConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 5, 1])\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        explanation = Tex(\"As $x$ approaches 2, the value of $x^2$ approaches 4.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        dot = Dot(color=RED).move_to(axes.c2p(2, 4))\n        approaching_line = DashedLine(start=axes.c2p(2, 0), end=axes.c2p(2, 4), color=YELLOW)\n\n        self.play(Create(approaching_line), FadeIn(dot))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an educational animation that visualizes the movement of an electron through a complex path on a grid. The grid should have 4 rows and 4 columns, and each cell should be fairly small. I imagine an electron starting at a specific point and then moving through a predefined zigzag path that represents a complex trajectory before disappearing from the grid. Can you illustrate this concept in a simple and clear animation, including the grid appearing at first and then fading out with the electron after the path is complete?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like to create an educational animation that visualizes the movement of an electron through a complex path on a grid. the grid should have 4 rows and 4 columns, and each cell should be fairly small. i imagine an electron starting at a specific point and then moving through a predefined zigzag path that represents a complex trajectory before disappearing from the grid. can you illustrate this concept in a simple and clear animation, including the grid appearing at first and then fading out with the electron after the path is complete?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LimitConcept(Scene):\n    def construct(self):\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-1, 5, 1])\n        graph = axes.plot(lambda x: x**2, color=BLUE)\n        self.play(Create(axes), Create(graph))\n        self.wait(1)\n\n        explanation = Tex(\"As $x$ approaches 2, the value of $x^2$ approaches 4.\")\n        explanation.to_edge(UP)\n        self.play(Write(explanation))\n        self.wait(1)\n\n        dot = Dot(color=RED).move_to(axes.c2p(2, 4))\n        approaching_line = DashedLine(start=axes.c2p(2, 0), end=axes.c2p(2, 4), color=YELLOW)\n\n        self.play(Create(approaching_line), FadeIn(dot))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like to create an educational animation that visualizes the movement of an electron through a complex path on a grid. The grid should have 4 rows and 4 columns, and each cell should be fairly small. I imagine an electron starting at a specific point and then moving through a predefined zigzag path that represents a complex trajectory before disappearing from the grid. Can you illustrate this concept in a simple and clear animation, including the grid appearing at first and then fading out with the electron after the path is complete?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_activation_function.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(\n                    3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"\n                ),\n                FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=30)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_activation_function.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_activation_function.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom PIL import Image\nimport numpy as np\n\nfrom manim_ml.neural_network.layers.convolutional_2d import Convolutional2DLayer\nfrom manim_ml.neural_network.layers.feed_forward import FeedForwardLayer\nfrom manim_ml.neural_network.layers.image import ImageLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\n# Make the specific scene\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\n\nclass CombinedScene(ThreeDScene):\n    def construct(self):\n        image = Image.open(\"../assets/mnist/digit.jpeg\")\n        numpy_image = np.asarray(image)\n        # Make nn\n        nn = NeuralNetwork(\n            [\n                ImageLayer(numpy_image, height=1.5),\n                Convolutional2DLayer(1, 7, filter_spacing=0.32),\n                Convolutional2DLayer(\n                    3, 5, 3, filter_spacing=0.32, activation_function=\"ReLU\"\n                ),\n                FeedForwardLayer(3, activation_function=\"Sigmoid\"),\n            ],\n            layer_spacing=0.25,\n        )\n        # Center the nn\n        nn.move_to(ORIGIN)\n        self.add(nn)\n        # Play animation\n        forward_pass = nn.make_forward_pass_animation()\n        self.wait(1)\n        self.play(forward_pass, run_time=30)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_activation_function.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated video tutorial that explains how to solve a surface integral problem, including the steps of parameterizing the surface, computing the surface element, converting the integral into a more solvable form, and then finding the final solution? Specifically, can the video demonstrate solving the integral of a function over a spherical surface, starting with the integral of (x^2 + y^2) over a sphere, parameterizing the sphere using spherical coordinates (theta and phi), finding the expression for the surface element in these coordinates, substituting into the integral, and performing the integration to arrive at the final result? Additionally, can each step in the tutorial be accompanied by a written explanation on the screen that guides viewers through the problem-solving process?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CircleToSquare(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Transform the circle into a square\n        square = Square()\n        self.play(ReplacementTransform(circle, square))\n        self.wait(1)\n\n        # Animate the square changing color\n        self.play(square.animate.set_fill(BLUE, opacity=0.5))\n        self.wait(1)\n\n        # Rotate the square\n        self.play(Rotate(square, PI / 4))\n        self.wait(1)\n\n        # Clear the scene and fade in a text\n        self.clear()\n        final_text = Text(\"Transformation complete!\", font_size=36)\n        self.play(FadeIn(final_text))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video tutorial that explains how to solve a surface integral problem, including the steps of parameterizing the surface, computing the surface element, converting the integral into a more solvable form, and then finding the final solution? Specifically, can the video demonstrate solving the integral of a function over a spherical surface, starting with the integral of (x^2 + y^2) over a sphere, parameterizing the sphere using spherical coordinates (theta and phi), finding the expression for the surface element in these coordinates, substituting into the integral, and performing the integration to arrive at the final result? Additionally, can each step in the tutorial be accompanied by a written explanation on the screen that guides viewers through the problem-solving process?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated video tutorial that explains how to solve a surface integral problem, including the steps of parameterizing the surface, computing the surface element, converting the integral into a more solvable form, and then finding the final solution? specifically, can the video demonstrate solving the integral of a function over a spherical surface, starting with the integral of (x^2 + y^2) over a sphere, parameterizing the sphere using spherical coordinates (theta and phi), finding the expression for the surface element in these coordinates, substituting into the integral, and performing the integration to arrive at the final result? additionally, can each step in the tutorial be accompanied by a written explanation on the screen that guides viewers through the problem-solving process?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CircleToSquare(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        self.play(Create(circle))\n        self.wait(1)\n\n        # Transform the circle into a square\n        square = Square()\n        self.play(ReplacementTransform(circle, square))\n        self.wait(1)\n\n        # Animate the square changing color\n        self.play(square.animate.set_fill(BLUE, opacity=0.5))\n        self.wait(1)\n\n        # Rotate the square\n        self.play(Rotate(square, PI / 4))\n        self.wait(1)\n\n        # Clear the scene and fade in a text\n        self.clear()\n        final_text = Text(\"Transformation complete!\", font_size=36)\n        self.play(FadeIn(final_text))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video tutorial that explains how to solve a surface integral problem, including the steps of parameterizing the surface, computing the surface element, converting the integral into a more solvable form, and then finding the final solution? Specifically, can the video demonstrate solving the integral of a function over a spherical surface, starting with the integral of (x^2 + y^2) over a sphere, parameterizing the sphere using spherical coordinates (theta and phi), finding the expression for the surface element in these coordinates, substituting into the integral, and performing the integration to arrive at the final result? Additionally, can each step in the tutorial be accompanied by a written explanation on the screen that guides viewers through the problem-solving process?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can we visualize the distribution of quadratic residues and non-residues modulo a prime on the number line?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QuadraticResiduesScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Secrets of Quadratic Residues Revealed\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Definition of quadratic residues\n        definition = Text(\"Quadratic Residue: a number that can be expressed as x\u00b2 mod p\", font_size=30)\n        self.play(Write(definition))\n        self.wait(2)\n        \n        # Show the mathematical equation\n        equation = Text(\"x\u00b2 \u2261 a (mod p)\", font_size=32)\n        equation.next_to(definition, DOWN, buff=0.5)\n        self.play(Write(equation))\n        self.wait(2)\n        self.play(FadeOut(definition), FadeOut(equation))\n        \n        # Number line for p=7\n        line = Line(LEFT * 3, RIGHT * 3)\n        self.play(Create(line))\n        \n        # Add numbers from 0 to 6\n        numbers = VGroup()\n        for i in range(7):\n            # Calculate position along the line (fixed division)\n            x_pos = -3 + i * (6/6)\n            position = np.array([x_pos, 0, 0])\n            number = Text(str(i), font_size=28)\n            number.next_to(position, DOWN, buff=0.3)\n            numbers.add(number)\n        \n        self.play(Write(numbers))\n        \n        # Add title for the number line\n        mod_text = Text(\"Number line modulo 7\", font_size=32)\n        mod_text.to_edge(UP)\n        self.play(Write(mod_text))\n        self.wait(1)\n        \n        # Quadratic residues for p=7 are 0, 1, 2, 4\n        # Create dots to mark residues and non-residues\n        dots = VGroup()\n        for i in range(7):\n            x_pos = -3 + i * (6/6)\n            position = np.array([x_pos, 0, 0])\n            # 0, 1, 2, 4 are residues (green), others are non-residues (red)\n            color = GREEN if i in [0, 1, 2, 4] else RED\n            dot = Dot(position, color=color, radius=0.2)\n            dots.add(dot)\n        \n        # Show all dots at once\n        self.play(Create(dots))\n        \n        # Add a legend\n        legend = VGroup(\n            Text(\"Green: Residue\", color=GREEN, font_size=24),\n            Text(\"Red: Non-Residue\", color=RED, font_size=24)\n        )\n        legend.arrange(DOWN, aligned_edge=LEFT)\n        legend.to_corner(UR)\n        \n        self.play(Write(legend))\n        self.wait(1)\n        \n        # Show the specific example mentioned in requirements\n        example = Text(\"x\u00b2 \u2261 1 (mod 7)\", font_size=32)\n        example.to_edge(DOWN)\n        self.play(Write(example))\n        self.wait(2)\n        \n        # Highlight the specific residue in the example\n        highlight = Circle(radius=0.3, color=YELLOW)\n        highlight.move_to(dots[1].get_center())  # Position 1 on number line\n        self.play(Create(highlight))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Quadratic residues reveal hidden patterns in numbers\", font_size=32)\n        self.play(\n            FadeOut(mod_text),\n            FadeOut(line),\n            FadeOut(numbers),\n            FadeOut(dots),\n            FadeOut(legend),\n            FadeOut(example),\n            FadeOut(highlight),\n            Write(conclusion)\n        )\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we visualize the distribution of quadratic residues and non-residues modulo a prime on the number line?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can we visualize the distribution of quadratic residues and non-residues modulo a prime on the number line?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QuadraticResiduesScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Secrets of Quadratic Residues Revealed\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Definition of quadratic residues\n        definition = Text(\"Quadratic Residue: a number that can be expressed as x\u00b2 mod p\", font_size=30)\n        self.play(Write(definition))\n        self.wait(2)\n        \n        # Show the mathematical equation\n        equation = Text(\"x\u00b2 \u2261 a (mod p)\", font_size=32)\n        equation.next_to(definition, DOWN, buff=0.5)\n        self.play(Write(equation))\n        self.wait(2)\n        self.play(FadeOut(definition), FadeOut(equation))\n        \n        # Number line for p=7\n        line = Line(LEFT * 3, RIGHT * 3)\n        self.play(Create(line))\n        \n        # Add numbers from 0 to 6\n        numbers = VGroup()\n        for i in range(7):\n            # Calculate position along the line (fixed division)\n            x_pos = -3 + i * (6/6)\n            position = np.array([x_pos, 0, 0])\n            number = Text(str(i), font_size=28)\n            number.next_to(position, DOWN, buff=0.3)\n            numbers.add(number)\n        \n        self.play(Write(numbers))\n        \n        # Add title for the number line\n        mod_text = Text(\"Number line modulo 7\", font_size=32)\n        mod_text.to_edge(UP)\n        self.play(Write(mod_text))\n        self.wait(1)\n        \n        # Quadratic residues for p=7 are 0, 1, 2, 4\n        # Create dots to mark residues and non-residues\n        dots = VGroup()\n        for i in range(7):\n            x_pos = -3 + i * (6/6)\n            position = np.array([x_pos, 0, 0])\n            # 0, 1, 2, 4 are residues (green), others are non-residues (red)\n            color = GREEN if i in [0, 1, 2, 4] else RED\n            dot = Dot(position, color=color, radius=0.2)\n            dots.add(dot)\n        \n        # Show all dots at once\n        self.play(Create(dots))\n        \n        # Add a legend\n        legend = VGroup(\n            Text(\"Green: Residue\", color=GREEN, font_size=24),\n            Text(\"Red: Non-Residue\", color=RED, font_size=24)\n        )\n        legend.arrange(DOWN, aligned_edge=LEFT)\n        legend.to_corner(UR)\n        \n        self.play(Write(legend))\n        self.wait(1)\n        \n        # Show the specific example mentioned in requirements\n        example = Text(\"x\u00b2 \u2261 1 (mod 7)\", font_size=32)\n        example.to_edge(DOWN)\n        self.play(Write(example))\n        self.wait(2)\n        \n        # Highlight the specific residue in the example\n        highlight = Circle(radius=0.3, color=YELLOW)\n        highlight.move_to(dots[1].get_center())  # Position 1 on number line\n        self.play(Create(highlight))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Quadratic residues reveal hidden patterns in numbers\", font_size=32)\n        self.play(\n            FadeOut(mod_text),\n            FadeOut(line),\n            FadeOut(numbers),\n            FadeOut(dots),\n            FadeOut(legend),\n            FadeOut(example),\n            FadeOut(highlight),\n            Write(conclusion)\n        )\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can we visualize the distribution of quadratic residues and non-residues modulo a prime on the number line?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What are the implications for convergence if the standard topology on a metric space were modified to one where every point is an isolated open set?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IsolatedOpenSets(Scene):\n    def construct(self):\n        # Display the title\n        title = Text(\"Isolated Open Sets in Topology\", color=BLUE)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Section 1: Standard Topology\n        standard_text = Text(\"Standard Topology\", color=GOLD)\n        standard_text.next_to(title, DOWN)\n        self.play(Write(standard_text))\n        \n        # Create dots for a converging sequence\n        dots = VGroup()\n        for i in range(1, 6):\n            dot = Dot(color=BLUE)\n            dot.move_to(RIGHT * (3/i))  # Converges to origin as i increases\n            dots.add(dot)\n        \n        self.play(Create(dots))\n        \n        # Show convergence equation\n        conv_eq = MathTex(\"d(x_n, x) \\\\rightarrow 0\")\n        conv_eq.next_to(dots, DOWN)\n        self.play(Write(conv_eq))\n        \n        self.wait(1)\n        self.play(FadeOut(standard_text), FadeOut(dots), FadeOut(conv_eq))\n        \n        # Section 2: Isolated Open Sets Topology\n        isolated_text = Text(\"Topology with Isolated Open Sets\", color=GOLD)\n        isolated_text.next_to(title, DOWN)\n        self.play(Write(isolated_text))\n        \n        # Create isolated points, each with its own neighborhood\n        isolated_points = VGroup()\n        for i in range(5):\n            # Each dot is isolated (an open set by itself)\n            point = Dot(color=RED)\n            point.move_to(RIGHT * (i - 2))\n            # Circle represents the open neighborhood containing only this point\n            circle = Circle(radius=0.3, color=GOLD)\n            circle.move_to(point.get_center())\n            isolated_points.add(VGroup(point, circle))\n        \n        self.play(Create(isolated_points))\n        \n        # Show that convergence is impossible\n        non_conv_eq = MathTex(\"d(x_n, x) \\\\not\\\\rightarrow 0\")\n        non_conv_eq.next_to(isolated_points, DOWN)\n        self.play(Write(non_conv_eq))\n        \n        self.wait(1)\n        self.play(FadeOut(isolated_text), FadeOut(isolated_points), FadeOut(non_conv_eq))\n        \n        # Conclusion\n        conclusion = Text(\"In isolated point topology,\\nsequences cannot converge!\", color=BLUE)\n        conclusion.next_to(title, DOWN)\n        self.play(Write(conclusion))\n        \n        self.wait(2)\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the implications for convergence if the standard topology on a metric space were modified to one where every point is an isolated open set?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what are the implications for convergence if the standard topology on a metric space were modified to one where every point is an isolated open set?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass IsolatedOpenSets(Scene):\n    def construct(self):\n        # Display the title\n        title = Text(\"Isolated Open Sets in Topology\", color=BLUE)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Section 1: Standard Topology\n        standard_text = Text(\"Standard Topology\", color=GOLD)\n        standard_text.next_to(title, DOWN)\n        self.play(Write(standard_text))\n        \n        # Create dots for a converging sequence\n        dots = VGroup()\n        for i in range(1, 6):\n            dot = Dot(color=BLUE)\n            dot.move_to(RIGHT * (3/i))  # Converges to origin as i increases\n            dots.add(dot)\n        \n        self.play(Create(dots))\n        \n        # Show convergence equation\n        conv_eq = MathTex(\"d(x_n, x) \\\\rightarrow 0\")\n        conv_eq.next_to(dots, DOWN)\n        self.play(Write(conv_eq))\n        \n        self.wait(1)\n        self.play(FadeOut(standard_text), FadeOut(dots), FadeOut(conv_eq))\n        \n        # Section 2: Isolated Open Sets Topology\n        isolated_text = Text(\"Topology with Isolated Open Sets\", color=GOLD)\n        isolated_text.next_to(title, DOWN)\n        self.play(Write(isolated_text))\n        \n        # Create isolated points, each with its own neighborhood\n        isolated_points = VGroup()\n        for i in range(5):\n            # Each dot is isolated (an open set by itself)\n            point = Dot(color=RED)\n            point.move_to(RIGHT * (i - 2))\n            # Circle represents the open neighborhood containing only this point\n            circle = Circle(radius=0.3, color=GOLD)\n            circle.move_to(point.get_center())\n            isolated_points.add(VGroup(point, circle))\n        \n        self.play(Create(isolated_points))\n        \n        # Show that convergence is impossible\n        non_conv_eq = MathTex(\"d(x_n, x) \\\\not\\\\rightarrow 0\")\n        non_conv_eq.next_to(isolated_points, DOWN)\n        self.play(Write(non_conv_eq))\n        \n        self.wait(1)\n        self.play(FadeOut(isolated_text), FadeOut(isolated_points), FadeOut(non_conv_eq))\n        \n        # Conclusion\n        conclusion = Text(\"In isolated point topology,\\nsequences cannot converge!\", color=BLUE)\n        conclusion.next_to(title, DOWN)\n        self.play(Write(conclusion))\n        \n        self.wait(2)\n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What are the implications for convergence if the standard topology on a metric space were modified to one where every point is an isolated open set?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the text \u201cWelcome to\u201d at the center of the screen, followed by the Manim logo banner appearing below it. The text is written with a smooth animation that continues updating as it's being drawn, and after a short pause, the banner expands into view with a quick animation, completing the welcoming scene."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \u201cWelcome to\u201d at the center of the screen, followed by the Manim logo banner appearing below it. The text is written with a smooth animation that continues updating as it's being drawn, and after a short pause, the banner expands into view with a quick animation, completing the welcoming scene."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the text \u201cwelcome to\u201d at the center of the screen, followed by the manim logo banner appearing below it. the text is written with a smooth animation that continues updating as it's being drawn, and after a short pause, the banner expands into view with a quick animation, completing the welcoming scene."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WelcomeToManim(Scene):\n    def construct(self):\n        words = Text(\"Welcome to\")\n        banner = ManimBanner().scale(0.5)\n        VGroup(words, banner).arrange(DOWN)\n\n        turn_animation_into_updater(Write(words, run_time=0.9))\n        self.add(words)\n        self.wait(0.5)\n        self.play(banner.expand(), run_time=0.5)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \u201cWelcome to\u201d at the center of the screen, followed by the Manim logo banner appearing below it. The text is written with a smooth animation that continues updating as it's being drawn, and after a short pause, the banner expands into view with a quick animation, completing the welcoming scene."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation that visually explains the concept of the fifth roots of unity using colors to distinguish between the roots and the lines connecting them to the center of a complex plane, and label the axes for clearer understanding?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_points\").shift(UP*2.5)), run_time=0.5)\n            circ = Circle(fill_color=RED, fill_opacity=0.8).shift(RIGHT*1.5)\n            square = Square(fill_color=BLUE, fill_opacity=0.2).shift(LEFT*1.5)\n            self.add(circ,square)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)\n            self.play(FadeOut(circ),FadeOut(square))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visually explains the concept of the fifth roots of unity using colors to distinguish between the roots and the lines connecting them to the center of a complex plane, and label the axes for clearer understanding?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation that visually explains the concept of the fifth roots of unity using colors to distinguish between the roots and the lines connecting them to the center of a complex plane, and label the axes for clearer understanding?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.match_points\").shift(UP*2.5)), run_time=0.5)\n            circ = Circle(fill_color=RED, fill_opacity=0.8).shift(RIGHT*1.5)\n            square = Square(fill_color=BLUE, fill_opacity=0.2).shift(LEFT*1.5)\n            self.add(circ,square)\n            self.wait(0.5)\n            self.play(circ.animate.match_points(square))\n            self.wait(0.5)\n            self.play(FadeOut(circ),FadeOut(square))\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation that visually explains the concept of the fifth roots of unity using colors to distinguish between the roots and the lines connecting them to the center of a complex plane, and label the axes for clearer understanding?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like a step-by-step animated video that explains how to solve the integral of the square root of (1+x^2) using trigonometric substitution. Could you illustrate the process starting with the integral, introducing the substitution x=tan(theta), converting dx and the function under the square root to theta, and simplifying the resulting integral using a trigonometric identity? After simplification, can you mention that this requires advanced integration techniques such as reduction formulae and then show the final solution? Please ensure that each step appears sequentially and gives me some time to understand the changes before moving on to the next step."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\")\n        self.play(Transform(problem, char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solving for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = \\pm i \\omega\")\n        self.play(Transform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = A \\cos(\\omega x) + B \\sin(\\omega x)\")\n        self.play(FadeIn(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Conclusion with the general solution\n        self.play(FadeOut(explanation1), FadeOut(roots))\n        self.wait(1)\n        conclusion = Text(\"Simple harmonic motion equation.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion), FadeOut(general_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like a step-by-step animated video that explains how to solve the integral of the square root of (1+x^2) using trigonometric substitution. Could you illustrate the process starting with the integral, introducing the substitution x=tan(theta), converting dx and the function under the square root to theta, and simplifying the resulting integral using a trigonometric identity? After simplification, can you mention that this requires advanced integration techniques such as reduction formulae and then show the final solution? Please ensure that each step appears sequentially and gives me some time to understand the changes before moving on to the next step."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like a step-by-step animated video that explains how to solve the integral of the square root of (1+x^2) using trigonometric substitution. could you illustrate the process starting with the integral, introducing the substitution x=tan(theta), converting dx and the function under the square root to theta, and simplifying the resulting integral using a trigonometric identity? after simplification, can you mention that this requires advanced integration techniques such as reduction formulae and then show the final solution? please ensure that each step appears sequentially and gives me some time to understand the changes before moving on to the next step."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SimpleHarmonicMotionExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"y'' + \\omega^2 y = 0\")\n        self.play(FadeIn(problem))\n        self.wait(1)\n\n        # Explanation for characteristic equation\n        explanation1 = Text(\"Characteristic equation\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Characteristic equation\n        char_eq = MathTex(r\"r^2 + \\omega^2 = 0\")\n        self.play(Transform(problem, char_eq))\n        self.wait(1)\n\n        # Explanation for solving the characteristic equation\n        explanation2 = Text(\"Solving for r\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Roots of the characteristic equation\n        roots = MathTex(r\"r = \\pm i \\omega\")\n        self.play(Transform(char_eq, roots))\n        self.wait(1)\n\n        # General solution\n        general_solution = MathTex(r\"y = A \\cos(\\omega x) + B \\sin(\\omega x)\")\n        self.play(FadeIn(general_solution))\n        self.wait(1)\n\n        # Explanation for general solution\n        explanation3 = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Conclusion with the general solution\n        self.play(FadeOut(explanation1), FadeOut(roots))\n        self.wait(1)\n        conclusion = Text(\"Simple harmonic motion equation.\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n        self.play(FadeOut(conclusion), FadeOut(general_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like a step-by-step animated video that explains how to solve the integral of the square root of (1+x^2) using trigonometric substitution. Could you illustrate the process starting with the integral, introducing the substitution x=tan(theta), converting dx and the function under the square root to theta, and simplifying the resulting integral using a trigonometric identity? After simplification, can you mention that this requires advanced integration techniques such as reduction formulae and then show the final solution? Please ensure that each step appears sequentially and gives me some time to understand the changes before moving on to the next step."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that visually demonstrates the concept of finding the area under a curve, specifically the area under the graph of \\(x^2\\) from 0 to 2, and also show the calculation of the definite integral of \\(x^2\\) from 0 to 2 using ManimCE? The animation should include the graph of the function, the shaded area under the curve, the step-by-step integral calculation, and finally display the numerical value of the area. Also, ensure that the elements are introduced in a sequence that aids understanding and that there is a clear statement of the final result. After the conclusion, please fade out all elements from the scene."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Function to graph\n        curve = lambda x: 0.1 * (x - 3) ** 2\n\n        # Displaying the function\n        graph = FunctionGraph(curve, x_range=[0, 5])\n        graph_label = MathTex(\"f(x) = 0.1(x - 3)^2\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Indicate the area under the curve\n        area = area = self.get_area(graph, [1, 4])\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem to solve\n        problem = MathTex(r\"\\int_1^4 0.1(x - 3)^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the definite integral\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Evaluation of integral\n        evaluation = MathTex(r\"= [\\frac{0.1}{3}(x - 3)^3]_1^4\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(2)\n\n        # Final solution\n        solution = MathTex(r\"= \\frac{0.1}{3}(4 - 3)^3 - \\frac{0.1}{3}(1 - 3)^3\", r\"= \\frac{0.1}{3}\")\n        self.play(ReplacementTransform(evaluation, solution))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually demonstrates the concept of finding the area under a curve, specifically the area under the graph of \\(x^2\\) from 0 to 2, and also show the calculation of the definite integral of \\(x^2\\) from 0 to 2 using ManimCE? The animation should include the graph of the function, the shaded area under the curve, the step-by-step integral calculation, and finally display the numerical value of the area. Also, ensure that the elements are introduced in a sequence that aids understanding and that there is a clear statement of the final result. After the conclusion, please fade out all elements from the scene."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that visually demonstrates the concept of finding the area under a curve, specifically the area under the graph of \\(x^2\\) from 0 to 2, and also show the calculation of the definite integral of \\(x^2\\) from 0 to 2 using manimce? the animation should include the graph of the function, the shaded area under the curve, the step-by-step integral calculation, and finally display the numerical value of the area. also, ensure that the elements are introduced in a sequence that aids understanding and that there is a clear statement of the final result. after the conclusion, please fade out all elements from the scene."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AreaUnderCurveExample(Scene):\n    def construct(self):\n        # Function to graph\n        curve = lambda x: 0.1 * (x - 3) ** 2\n\n        # Displaying the function\n        graph = FunctionGraph(curve, x_range=[0, 5])\n        graph_label = MathTex(\"f(x) = 0.1(x - 3)^2\").next_to(graph, UP)\n        self.play(Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Indicate the area under the curve\n        area = area = self.get_area(graph, [1, 4])\n        self.play(FadeIn(area))\n        self.wait(1)\n\n        # Problem to solve\n        problem = MathTex(r\"\\int_1^4 0.1(x - 3)^2 \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explaining the definite integral\n        explanation1 = Text(\"Calculate the area under the curve\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Evaluation of integral\n        evaluation = MathTex(r\"= [\\frac{0.1}{3}(x - 3)^3]_1^4\")\n        self.play(ReplacementTransform(problem.copy(), evaluation))\n        self.wait(2)\n\n        # Final solution\n        solution = MathTex(r\"= \\frac{0.1}{3}(4 - 3)^3 - \\frac{0.1}{3}(1 - 3)^3\", r\"= \\frac{0.1}{3}\")\n        self.play(ReplacementTransform(evaluation, solution))\n        self.wait(1)\n\n        # Clearing the scene\n        self.clear()\n        self.play(Write(solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that visually demonstrates the concept of finding the area under a curve, specifically the area under the graph of \\(x^2\\) from 0 to 2, and also show the calculation of the definite integral of \\(x^2\\) from 0 to 2 using ManimCE? The animation should include the graph of the function, the shaded area under the curve, the step-by-step integral calculation, and finally display the numerical value of the area. Also, ensure that the elements are introduced in a sequence that aids understanding and that there is a clear statement of the final result. After the conclusion, please fade out all elements from the scene."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the impact of selecting different bases on the graphical representation of dual spaces?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DualSpacesScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating Dual Spaces\", font_size=36)\n        subtitle = Text(\"A Journey through Bases\", font_size=24).next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Vector space - left side\n        v_axes = Axes(\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n            axis_config={\"color\": BLUE},\n        ).scale(0.8).shift(LEFT*3)\n        \n        # Original square basis\n        v1 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(1, 0), color=GREEN, buff=0)\n        v2 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(0, 1), color=RED, buff=0)\n        \n        v1_label = Text(\"v\u2081\", font_size=20, color=GREEN).next_to(v1, DOWN)\n        v2_label = Text(\"v\u2082\", font_size=20, color=RED).next_to(v2, LEFT)\n        \n        vector_space_title = Text(\"Vector Space\", font_size=24, color=BLUE).next_to(v_axes, UP)\n        \n        # Vector space equation\n        v_eq = MathTex(\"V = \\\\text{span}(\\\\{v_1, v_2\\\\})\").scale(0.7).next_to(v_axes, DOWN)\n        \n        # Create vector space\n        self.play(Create(v_axes), Write(vector_space_title))\n        self.play(Create(v1), Create(v2))\n        self.play(Write(v1_label), Write(v2_label))\n        self.play(Write(v_eq))\n        self.wait(1)\n        \n        # Dual space - right side\n        d_axes = Axes(\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n            axis_config={\"color\": ORANGE},\n        ).scale(0.8).shift(RIGHT*3)\n        \n        # Dual basis (represented as dashed lines)\n        f1 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(1, 0), color=YELLOW)\n        f2 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(0, 1), color=GOLD)\n        \n        f1_label = Text(\"f\u2081\", font_size=20, color=YELLOW).next_to(f1, DOWN)\n        f2_label = Text(\"f\u2082\", font_size=20, color=GOLD).next_to(f2, LEFT)\n        \n        dual_space_title = Text(\"Dual Space\", font_size=24, color=ORANGE).next_to(d_axes, UP)\n        \n        # Dual space equation\n        d_eq = MathTex(\"V^* = \\\\text{span}(\\\\{f_1, f_2\\\\})\").scale(0.7).next_to(d_axes, DOWN)\n        \n        # Create dual space\n        self.play(Create(d_axes), Write(dual_space_title))\n        self.play(Create(f1), Create(f2))\n        self.play(Write(f1_label), Write(f2_label))\n        self.play(Write(d_eq))\n        self.wait(1)\n        \n        # Change basis - transform square to diamond\n        change_text = Text(\"Changing the basis...\", font_size=28).to_edge(UP)\n        self.play(Write(change_text))\n        \n        # New diamond-shaped basis vectors\n        new_v1 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(0.7, 0.7), color=GREEN, buff=0)\n        new_v2 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(0.7, -0.7), color=RED, buff=0)\n        \n        new_v1_label = Text(\"v\u2081\", font_size=20, color=GREEN).next_to(new_v1, UP+RIGHT, buff=0.1)\n        new_v2_label = Text(\"v\u2082\", font_size=20, color=RED).next_to(new_v2, DOWN+RIGHT, buff=0.1)\n        \n        # Transform vector space basis\n        self.play(\n            Transform(v1, new_v1),\n            Transform(v2, new_v2),\n            Transform(v1_label, new_v1_label),\n            Transform(v2_label, new_v2_label)\n        )\n        \n        # Transform dual space basis\n        new_f1 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(0.7, 0.7), color=YELLOW)\n        new_f2 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(0.7, -0.7), color=GOLD)\n        \n        new_f1_label = Text(\"f\u2081\", font_size=20, color=YELLOW).next_to(new_f1, UP+RIGHT, buff=0.1)\n        new_f2_label = Text(\"f\u2082\", font_size=20, color=GOLD).next_to(new_f2, DOWN+RIGHT, buff=0.1)\n        \n        self.play(\n            Transform(f1, new_f1),\n            Transform(f2, new_f2),\n            Transform(f1_label, new_f1_label),\n            Transform(f2_label, new_f2_label)\n        )\n        \n        self.play(FadeOut(change_text))\n        self.wait(1)\n        \n        # Matrix representation\n        matrix_eq = MathTex(\"M_{V,V^*} = \\\\begin{bmatrix} a & b \\\\\\\\ c & d \\\\end{bmatrix}\").scale(0.8)\n        matrix_text = Text(\"Matrix Representation\", font_size=24).next_to(matrix_eq, UP)\n        \n        # Group equations and titles\n        self.play(FadeOut(v_eq), FadeOut(d_eq))\n        \n        self.play(Write(matrix_text), Write(matrix_eq))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Basis choice impacts dual space representation\", font_size=28).to_edge(UP)\n        self.play(FadeOut(matrix_text), FadeOut(matrix_eq))\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final cleanup\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the impact of selecting different bases on the graphical representation of dual spaces?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the impact of selecting different bases on the graphical representation of dual spaces?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DualSpacesScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Navigating Dual Spaces\", font_size=36)\n        subtitle = Text(\"A Journey through Bases\", font_size=24).next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Vector space - left side\n        v_axes = Axes(\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n            axis_config={\"color\": BLUE},\n        ).scale(0.8).shift(LEFT*3)\n        \n        # Original square basis\n        v1 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(1, 0), color=GREEN, buff=0)\n        v2 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(0, 1), color=RED, buff=0)\n        \n        v1_label = Text(\"v\u2081\", font_size=20, color=GREEN).next_to(v1, DOWN)\n        v2_label = Text(\"v\u2082\", font_size=20, color=RED).next_to(v2, LEFT)\n        \n        vector_space_title = Text(\"Vector Space\", font_size=24, color=BLUE).next_to(v_axes, UP)\n        \n        # Vector space equation\n        v_eq = MathTex(\"V = \\\\text{span}(\\\\{v_1, v_2\\\\})\").scale(0.7).next_to(v_axes, DOWN)\n        \n        # Create vector space\n        self.play(Create(v_axes), Write(vector_space_title))\n        self.play(Create(v1), Create(v2))\n        self.play(Write(v1_label), Write(v2_label))\n        self.play(Write(v_eq))\n        self.wait(1)\n        \n        # Dual space - right side\n        d_axes = Axes(\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n            axis_config={\"color\": ORANGE},\n        ).scale(0.8).shift(RIGHT*3)\n        \n        # Dual basis (represented as dashed lines)\n        f1 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(1, 0), color=YELLOW)\n        f2 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(0, 1), color=GOLD)\n        \n        f1_label = Text(\"f\u2081\", font_size=20, color=YELLOW).next_to(f1, DOWN)\n        f2_label = Text(\"f\u2082\", font_size=20, color=GOLD).next_to(f2, LEFT)\n        \n        dual_space_title = Text(\"Dual Space\", font_size=24, color=ORANGE).next_to(d_axes, UP)\n        \n        # Dual space equation\n        d_eq = MathTex(\"V^* = \\\\text{span}(\\\\{f_1, f_2\\\\})\").scale(0.7).next_to(d_axes, DOWN)\n        \n        # Create dual space\n        self.play(Create(d_axes), Write(dual_space_title))\n        self.play(Create(f1), Create(f2))\n        self.play(Write(f1_label), Write(f2_label))\n        self.play(Write(d_eq))\n        self.wait(1)\n        \n        # Change basis - transform square to diamond\n        change_text = Text(\"Changing the basis...\", font_size=28).to_edge(UP)\n        self.play(Write(change_text))\n        \n        # New diamond-shaped basis vectors\n        new_v1 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(0.7, 0.7), color=GREEN, buff=0)\n        new_v2 = Arrow(start=v_axes.get_origin(), end=v_axes.c2p(0.7, -0.7), color=RED, buff=0)\n        \n        new_v1_label = Text(\"v\u2081\", font_size=20, color=GREEN).next_to(new_v1, UP+RIGHT, buff=0.1)\n        new_v2_label = Text(\"v\u2082\", font_size=20, color=RED).next_to(new_v2, DOWN+RIGHT, buff=0.1)\n        \n        # Transform vector space basis\n        self.play(\n            Transform(v1, new_v1),\n            Transform(v2, new_v2),\n            Transform(v1_label, new_v1_label),\n            Transform(v2_label, new_v2_label)\n        )\n        \n        # Transform dual space basis\n        new_f1 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(0.7, 0.7), color=YELLOW)\n        new_f2 = DashedLine(start=d_axes.get_origin(), end=d_axes.c2p(0.7, -0.7), color=GOLD)\n        \n        new_f1_label = Text(\"f\u2081\", font_size=20, color=YELLOW).next_to(new_f1, UP+RIGHT, buff=0.1)\n        new_f2_label = Text(\"f\u2082\", font_size=20, color=GOLD).next_to(new_f2, DOWN+RIGHT, buff=0.1)\n        \n        self.play(\n            Transform(f1, new_f1),\n            Transform(f2, new_f2),\n            Transform(f1_label, new_f1_label),\n            Transform(f2_label, new_f2_label)\n        )\n        \n        self.play(FadeOut(change_text))\n        self.wait(1)\n        \n        # Matrix representation\n        matrix_eq = MathTex(\"M_{V,V^*} = \\\\begin{bmatrix} a & b \\\\\\\\ c & d \\\\end{bmatrix}\").scale(0.8)\n        matrix_text = Text(\"Matrix Representation\", font_size=24).next_to(matrix_eq, UP)\n        \n        # Group equations and titles\n        self.play(FadeOut(v_eq), FadeOut(d_eq))\n        \n        self.play(Write(matrix_text), Write(matrix_eq))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Basis choice impacts dual space representation\", font_size=28).to_edge(UP)\n        self.play(FadeOut(matrix_text), FadeOut(matrix_eq))\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Final cleanup\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the impact of selecting different bases on the graphical representation of dual spaces?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like an animation that starts by creating a 5 by 5 grid of red circles, each labeled with the text \"Li+\" representing lithium ions. Then I want an animation of a small white electron moving in a complex path around and through the lithium ion grid. The electron's path should include upwards, downwards, and diagonal movements, but it should pause momentarily at certain points before continuing on the path. It's important that the electron's animation is smooth and takes a total of 3 seconds to complete the journey around the grid. Can you create and show me this animated scene?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-y^2}} x^2 dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{3}x^3]_{0}^{\\sqrt{1-y^2}} dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{3}(1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for evaluation\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution (elaborate as necessary for the math at hand)\n        final_solution = MathTex(r\"= \\frac{1}{3} \\int_{0}^{1} (1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that starts by creating a 5 by 5 grid of red circles, each labeled with the text \"Li+\" representing lithium ions. Then I want an animation of a small white electron moving in a complex path around and through the lithium ion grid. The electron's path should include upwards, downwards, and diagonal movements, but it should pause momentarily at certain points before continuing on the path. It's important that the electron's animation is smooth and takes a total of 3 seconds to complete the journey around the grid. Can you create and show me this animated scene?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like an animation that starts by creating a 5 by 5 grid of red circles, each labeled with the text \"li+\" representing lithium ions. then i want an animation of a small white electron moving in a complex path around and through the lithium ion grid. the electron's path should include upwards, downwards, and diagonal movements, but it should pause momentarily at certain points before continuing on the path. it's important that the electron's animation is smooth and takes a total of 3 seconds to complete the journey around the grid. can you create and show me this animated scene?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{1} \\int_{0}^{\\sqrt{1-y^2}} x^2 dx\\,dy\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to x first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{1} [\\frac{1}{3}x^3]_{0}^{\\sqrt{1-y^2}} dy\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for outer integral\n        explanation2 = Text(\"Now integrate with respect to y\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= \\int_{0}^{1} \\frac{1}{3}(1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(inner_integral, final_integral))\n        self.wait(1)\n\n        # Explanation for evaluation\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution (elaborate as necessary for the math at hand)\n        final_solution = MathTex(r\"= \\frac{1}{3} \\int_{0}^{1} (1-y^2)^{\\frac{3}{2}} dy\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like an animation that starts by creating a 5 by 5 grid of red circles, each labeled with the text \"Li+\" representing lithium ions. Then I want an animation of a small white electron moving in a complex path around and through the lithium ion grid. The electron's path should include upwards, downwards, and diagonal movements, but it should pause momentarily at certain points before continuing on the path. It's important that the electron's animation is smooth and takes a total of 3 seconds to complete the journey around the grid. Can you create and show me this animated scene?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_color_scheme.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nimport manim_ml\n\nmanim_ml.config.color_scheme = \"light_mode\"\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass FeedForwardScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork([\n            FeedForwardLayer(3), \n            FeedForwardLayer(5), \n            FeedForwardLayer(3)\n        ])\n\n        self.add(nn)\n        self.play(nn.make_forward_pass_animation())\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_color_scheme.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_color_scheme.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim_ml.neural_network import NeuralNetwork, FeedForwardLayer\nimport manim_ml\n\nmanim_ml.config.color_scheme = \"light_mode\"\n\nconfig.pixel_height = 1200\nconfig.pixel_width = 1900\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass FeedForwardScene(Scene):\n    def construct(self):\n        nn = NeuralNetwork([\n            FeedForwardLayer(3), \n            FeedForwardLayer(5), \n            FeedForwardLayer(3)\n        ])\n\n        self.add(nn)\n        self.play(nn.make_forward_pass_animation())\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_color_scheme.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "First, transform a circle into a square, then transform that square into a triangle, and finally fade out the triangle. After a brief pause, repeat the sequence using replacement transforms: replace the circle with a square, then replace the square with a triangle, and finally fade out the triangle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TwoTransforms(Scene):\n    def transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(Transform(a, b))\n        self.play(Transform(a, c))\n        self.play(FadeOut(a))\n\n    def replacement_transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(ReplacementTransform(a, b))\n        self.play(ReplacementTransform(b, c))\n        self.play(FadeOut(c))\n\n    def construct(self):\n        self.transform()\n        self.wait(0.5)  # wait for 0.5 seconds\n        self.replacement_transform()\n```"}], "metadata": {"source": "manimbench", "original_description": "First, transform a circle into a square, then transform that square into a triangle, and finally fade out the triangle. After a brief pause, repeat the sequence using replacement transforms: replace the circle with a square, then replace the square with a triangle, and finally fade out the triangle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that first, transform a circle into a square, then transform that square into a triangle, and finally fade out the triangle. after a brief pause, repeat the sequence using replacement transforms: replace the circle with a square, then replace the square with a triangle, and finally fade out the triangle."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TwoTransforms(Scene):\n    def transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(Transform(a, b))\n        self.play(Transform(a, c))\n        self.play(FadeOut(a))\n\n    def replacement_transform(self):\n        a = Circle()\n        b = Square()\n        c = Triangle()\n        self.play(ReplacementTransform(a, b))\n        self.play(ReplacementTransform(b, c))\n        self.play(FadeOut(c))\n\n    def construct(self):\n        self.transform()\n        self.wait(0.5)  # wait for 0.5 seconds\n        self.replacement_transform()\n```"}], "metadata": {"source": "manimbench", "original_description": "First, transform a circle into a square, then transform that square into a triangle, and finally fade out the triangle. After a brief pause, repeat the sequence using replacement transforms: replace the circle with a square, then replace the square with a triangle, and finally fade out the triangle."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that illustrates the concept of finding the area under a curve? In the animation, please show a graph of a quadratic function, let's say f(x) = 0.1(x - 3)^2 + 1, and highlight the region between x=1 and x=5 to represent the area under the curve between those points. Then, can you display the bounds of the integral for the area as text on the screen, followed by the integral expression? After that, replace it with the approximate numerical result of the integral. Once the calculation is shown, clear everything and display the final result again for emphasis."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iint_S (x^2+y^2) \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(r, \\theta) = (r\\cos\\theta, r\\sin\\theta, h(r))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for the calculation of dS\n        explanation2 = Text(\"Calculate differential area element dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Differential area step\n        differential_area = MathTex(r\"dS = |S_r \\times S_\\theta| \\, drd\\theta\")\n        self.play(ReplacementTransform(parameterization, differential_area))\n        self.wait(1)\n\n        # Explanation for setting limits of integration\n        explanation3 = Text(\"Set limits of integration for r and \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Limits of integration step\n        limits_of_integration = MathTex(r\"\\int_0^R \\int_0^{2\\pi} (r^2) |S_r \\times S_\\theta| \\,drd\\theta\")\n        self.play(ReplacementTransform(differential_area, limits_of_integration))\n        self.wait(1)\n\n        # Explanation for final evaluation\n        explanation4 = Text(\"Evaluate the integrals\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_0^R \\int_0^{2\\pi} r^3 \\,drd\\theta\")\n        self.play(ReplacementTransform(limits_of_integration, final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates the concept of finding the area under a curve? In the animation, please show a graph of a quadratic function, let's say f(x) = 0.1(x - 3)^2 + 1, and highlight the region between x=1 and x=5 to represent the area under the curve between those points. Then, can you display the bounds of the integral for the area as text on the screen, followed by the integral expression? After that, replace it with the approximate numerical result of the integral. Once the calculation is shown, clear everything and display the final result again for emphasis."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that illustrates the concept of finding the area under a curve? in the animation, please show a graph of a quadratic function, let's say f(x) = 0.1(x - 3)^2 + 1, and highlight the region between x=1 and x=5 to represent the area under the curve between those points. then, can you display the bounds of the integral for the area as text on the screen, followed by the integral expression? after that, replace it with the approximate numerical result of the integral. once the calculation is shown, clear everything and display the final result again for emphasis."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\iint_S (x^2+y^2) \\, dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Parameterization step\n        parameterization = MathTex(r\"S(r, \\theta) = (r\\cos\\theta, r\\sin\\theta, h(r))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(1)\n\n        # Explanation for the calculation of dS\n        explanation2 = Text(\"Calculate differential area element dS\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Differential area step\n        differential_area = MathTex(r\"dS = |S_r \\times S_\\theta| \\, drd\\theta\")\n        self.play(ReplacementTransform(parameterization, differential_area))\n        self.wait(1)\n\n        # Explanation for setting limits of integration\n        explanation3 = Text(\"Set limits of integration for r and \\( \\theta \\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Limits of integration step\n        limits_of_integration = MathTex(r\"\\int_0^R \\int_0^{2\\pi} (r^2) |S_r \\times S_\\theta| \\,drd\\theta\")\n        self.play(ReplacementTransform(differential_area, limits_of_integration))\n        self.wait(1)\n\n        # Explanation for final evaluation\n        explanation4 = Text(\"Evaluate the integrals\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= \\int_0^R \\int_0^{2\\pi} r^3 \\,drd\\theta\")\n        self.play(ReplacementTransform(limits_of_integration, final_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates the concept of finding the area under a curve? In the animation, please show a graph of a quadratic function, let's say f(x) = 0.1(x - 3)^2 + 1, and highlight the region between x=1 and x=5 to represent the area under the curve between those points. Then, can you display the bounds of the integral for the area as text on the screen, followed by the integral expression? After that, replace it with the approximate numerical result of the integral. Once the calculation is shown, clear everything and display the final result again for emphasis."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "interpolation.py"}, {"from": "assistant", "value": "```python\n\"\"\"Visualization of VAE Interpolation\"\"\"\nimport sys\nimport os\n\nsys.path.append(os.environ[\"PROJECT_ROOT\"])\nfrom manim import *\nimport pickle\nimport numpy as np\nimport manim_ml.neural_network as neural_network\nimport examples.variational_autoencoder.variational_autoencoder as variational_autoencoder\n\n\"\"\"\n    The VAE Scene for the twitter video. \n\"\"\"\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n# Set random seed so point distribution is constant\nnp.random.seed(1)\n\n\nclass InterpolationScene(MovingCameraScene):\n    \"\"\"Scene object for a Variational Autoencoder and Autoencoder\"\"\"\n\n    def construct(self):\n        # Set Scene config\n        vae = variational_autoencoder.VariationalAutoencoder(\n            dot_radius=0.035, layer_spacing=0.5\n        )\n        vae.move_to(ORIGIN)\n        vae.encoder.shift(LEFT * 0.5)\n        vae.decoder.shift(RIGHT * 0.5)\n        mnist_image_handler = variational_autoencoder.MNISTImageHandler()\n        image_pair = mnist_image_handler.image_pairs[3]\n        # Make forward pass animation and DO NOT run it\n        forward_pass_animation = vae.make_forward_pass_animation(image_pair)\n        # Make the interpolation animation\n        interpolation_images = mnist_image_handler.interpolation_images\n        interpolation_animation = vae.make_interpolation_animation(interpolation_images)\n        embedding_zoom_animation = self.camera.auto_zoom(\n            [vae.embedding, vae.decoder, vae.output_image], margin=0.5\n        )\n        # Make animations\n        forward_pass_animations = []\n        for i in range(7):\n            anim = vae.decoder.make_forward_propagation_animation(run_time=0.5)\n            forward_pass_animations.append(anim)\n        forward_pass_animation_group = AnimationGroup(\n            *forward_pass_animations, lag_ratio=1.0\n        )\n        # Make forward pass animations\n        self.play(Create(vae), run_time=1.5)\n        self.play(FadeOut(vae.encoder), run_time=1.0)\n        self.play(embedding_zoom_animation, run_time=1.5)\n        interpolation_animation = AnimationGroup(\n            forward_pass_animation_group, interpolation_animation\n        )\n        self.play(interpolation_animation, run_time=9.0)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "interpolation.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that interpolation.py"}, {"from": "assistant", "value": "```python\n\"\"\"Visualization of VAE Interpolation\"\"\"\nimport sys\nimport os\n\nsys.path.append(os.environ[\"PROJECT_ROOT\"])\nfrom manim import *\nimport pickle\nimport numpy as np\nimport manim_ml.neural_network as neural_network\nimport examples.variational_autoencoder.variational_autoencoder as variational_autoencoder\n\n\"\"\"\n    The VAE Scene for the twitter video. \n\"\"\"\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n# Set random seed so point distribution is constant\nnp.random.seed(1)\n\n\nclass InterpolationScene(MovingCameraScene):\n    \"\"\"Scene object for a Variational Autoencoder and Autoencoder\"\"\"\n\n    def construct(self):\n        # Set Scene config\n        vae = variational_autoencoder.VariationalAutoencoder(\n            dot_radius=0.035, layer_spacing=0.5\n        )\n        vae.move_to(ORIGIN)\n        vae.encoder.shift(LEFT * 0.5)\n        vae.decoder.shift(RIGHT * 0.5)\n        mnist_image_handler = variational_autoencoder.MNISTImageHandler()\n        image_pair = mnist_image_handler.image_pairs[3]\n        # Make forward pass animation and DO NOT run it\n        forward_pass_animation = vae.make_forward_pass_animation(image_pair)\n        # Make the interpolation animation\n        interpolation_images = mnist_image_handler.interpolation_images\n        interpolation_animation = vae.make_interpolation_animation(interpolation_images)\n        embedding_zoom_animation = self.camera.auto_zoom(\n            [vae.embedding, vae.decoder, vae.output_image], margin=0.5\n        )\n        # Make animations\n        forward_pass_animations = []\n        for i in range(7):\n            anim = vae.decoder.make_forward_propagation_animation(run_time=0.5)\n            forward_pass_animations.append(anim)\n        forward_pass_animation_group = AnimationGroup(\n            *forward_pass_animations, lag_ratio=1.0\n        )\n        # Make forward pass animations\n        self.play(Create(vae), run_time=1.5)\n        self.play(FadeOut(vae.encoder), run_time=1.0)\n        self.play(embedding_zoom_animation, run_time=1.5)\n        interpolation_animation = AnimationGroup(\n            forward_pass_animation_group, interpolation_animation\n        )\n        self.play(interpolation_animation, run_time=9.0)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "interpolation.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "How can I create an animation using a math animation engine where a piece of text transforms into another with the words \"animate.align_on_border\" and then shifts upwards, followed by a square shape animating to align itself with the top border and then disappearing from the scene?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CalculateEulerNumber(Scene):\n    def construct(self):\n        # Describe the problem\n        problem_text = MathTex(r\"e = \\lim_{{n \\to \\infty}} \\left(1 + \\frac{1}{n}\\right)^n\")\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Introduce the approximation concept\n        approximation_explanation = Text(\n            \"Approximate with a large value of n\", font_size=24\n        ).to_edge(UP)\n        self.play(Write(approximation_explanation))\n        self.wait(2)\n\n        # Show the approximation with a tangible n\n        approximation = MathTex(r\"\\approx \\left(1 + \\frac{1}{100}\\right)^{100}\")\n        self.play(ReplacementTransform(problem_text.copy(), approximation))\n        self.wait(1)\n\n        # Calculate the numerical approximation\n        numerical_result_text = Text(\"Numerical result\", font_size=24).to_edge(UP)\n        self.play(Transform(approximation_explanation, numerical_result_text))\n        self.wait(2)\n\n        # Show numerical result\n        numerical_result = MathTex(fr\"\\approx {round((1 + 1/100)**100, 8)}\")\n        self.play(ReplacementTransform(approximation, numerical_result))\n        self.wait(1)\n\n        # Clear the scene and show the calculated value of e\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(f\"Calculated value of e: {round((1 + 1/100)**100, 8)}\", font_size=24)))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an animation using a math animation engine where a piece of text transforms into another with the words \"animate.align_on_border\" and then shifts upwards, followed by a square shape animating to align itself with the top border and then disappearing from the scene?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that how can i create an animation using a math animation engine where a piece of text transforms into another with the words \"animate.align_on_border\" and then shifts upwards, followed by a square shape animating to align itself with the top border and then disappearing from the scene?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass CalculateEulerNumber(Scene):\n    def construct(self):\n        # Describe the problem\n        problem_text = MathTex(r\"e = \\lim_{{n \\to \\infty}} \\left(1 + \\frac{1}{n}\\right)^n\")\n        self.play(Write(problem_text))\n        self.wait(1)\n\n        # Introduce the approximation concept\n        approximation_explanation = Text(\n            \"Approximate with a large value of n\", font_size=24\n        ).to_edge(UP)\n        self.play(Write(approximation_explanation))\n        self.wait(2)\n\n        # Show the approximation with a tangible n\n        approximation = MathTex(r\"\\approx \\left(1 + \\frac{1}{100}\\right)^{100}\")\n        self.play(ReplacementTransform(problem_text.copy(), approximation))\n        self.wait(1)\n\n        # Calculate the numerical approximation\n        numerical_result_text = Text(\"Numerical result\", font_size=24).to_edge(UP)\n        self.play(Transform(approximation_explanation, numerical_result_text))\n        self.wait(2)\n\n        # Show numerical result\n        numerical_result = MathTex(fr\"\\approx {round((1 + 1/100)**100, 8)}\")\n        self.play(ReplacementTransform(approximation, numerical_result))\n        self.wait(1)\n\n        # Clear the scene and show the calculated value of e\n        self.clear()\n        self.wait(1)\n        self.play(Write(Text(f\"Calculated value of e: {round((1 + 1/100)**100, 8)}\", font_size=24)))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "How can I create an animation using a math animation engine where a piece of text transforms into another with the words \"animate.align_on_border\" and then shifts upwards, followed by a square shape animating to align itself with the top border and then disappearing from the scene?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the Euler characteristic of a polyhedron change when edges are continuously subdivided?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerCharacteristic(Scene):\n    def construct(self):\n        # Set background color to grayscale\n        self.camera.background_color = \"#333333\"\n        \n        # Introduction\n        title = Text(\"The Marvel of Euler's Characteristic\", color=BLUE)\n        subtitle = Text(\"in Subdividing Polyhedrons\", color=BLUE, font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Element 1: Create a simple 2D representation of a cube\n        square = Square(side_length=3, color=BLUE)\n        diag1 = Line(square.get_corner(UL), square.get_corner(DR), color=BLUE)\n        diag2 = Line(square.get_corner(UR), square.get_corner(DL), color=BLUE)\n        \n        # Add dots for vertices\n        vertices = VGroup(*[Dot(p, color=YELLOW) for p in [\n            square.get_corner(UL), square.get_corner(UR),\n            square.get_corner(DL), square.get_corner(DR)\n        ]])\n        \n        cube_title = Text(\"A Cube:\", font_size=24, color=BLUE).to_edge(UP)\n        \n        self.play(Write(cube_title))\n        self.play(Create(square))\n        self.play(Create(diag1), Create(diag2))\n        self.play(Create(vertices))\n        self.wait(1)\n        \n        # Element 2: Show the Euler characteristic equation\n        v_label = Text(\"V = 8\", color=YELLOW).to_edge(LEFT)\n        e_label = Text(\"E = 12\", color=GREEN).next_to(v_label, DOWN)\n        f_label = Text(\"F = 6\", color=RED).next_to(e_label, DOWN)\n        \n        self.play(Write(v_label), Write(e_label), Write(f_label))\n        \n        euler_eq = Text(\"V - E + F = 2\", color=BLUE).to_edge(RIGHT)\n        euler_calc = Text(\"8 - 12 + 6 = 2\", color=GOLD).next_to(euler_eq, DOWN)\n        \n        self.play(Write(euler_eq))\n        self.play(Write(euler_calc))\n        self.wait(1)\n        \n        # Element 3: Subdivide an edge\n        self.play(FadeOut(cube_title))\n        \n        subdiv_title = Text(\"Subdividing an Edge:\", font_size=24, color=BLUE).to_edge(UP)\n        self.play(Write(subdiv_title))\n        \n        # Add a new vertex on an edge\n        new_vertex = Dot(square.get_top(), color=YELLOW)\n        self.play(FadeIn(new_vertex))\n        self.wait(1)\n        \n        # Element 4: Update the counts\n        subdiv_text = Text(\"Add 1 vertex and 1 edge\", font_size=20).next_to(subdiv_title, DOWN)\n        self.play(Write(subdiv_text))\n        \n        new_v_label = Text(\"V = 9\", color=YELLOW).to_edge(LEFT)\n        new_e_label = Text(\"E = 13\", color=GREEN).next_to(new_v_label, DOWN)\n        \n        self.play(\n            Transform(v_label, new_v_label),\n            Transform(e_label, new_e_label)\n        )\n        self.wait(1)\n        \n        # Element 5: Show the new Euler calculation\n        new_euler_calc = Text(\"9 - 13 + 6 = 2\", color=GOLD).next_to(euler_eq, DOWN)\n        \n        self.play(Transform(euler_calc, new_euler_calc))\n        self.wait(1)\n        \n        # Key Insight - Euler characteristic's invariance\n        self.play(\n            FadeOut(subdiv_title),\n            FadeOut(subdiv_text)\n        )\n        \n        insight = Text(\"The Euler characteristic remains unchanged!\", color=GOLD, font_size=24)\n        insight.to_edge(UP)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Element 6: Conclusion\n        self.play(\n            FadeOut(square),\n            FadeOut(diag1),\n            FadeOut(diag2),\n            FadeOut(vertices),\n            FadeOut(v_label),\n            FadeOut(e_label),\n            FadeOut(f_label),\n            FadeOut(new_vertex),\n            FadeOut(euler_eq),\n            FadeOut(euler_calc),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"Complexity may change,\\nbut the Euler characteristic remains constant.\", \n                      font_size=28, color=BLUE)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Euler characteristic of a polyhedron change when edges are continuously subdivided?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the euler characteristic of a polyhedron change when edges are continuously subdivided?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass EulerCharacteristic(Scene):\n    def construct(self):\n        # Set background color to grayscale\n        self.camera.background_color = \"#333333\"\n        \n        # Introduction\n        title = Text(\"The Marvel of Euler's Characteristic\", color=BLUE)\n        subtitle = Text(\"in Subdividing Polyhedrons\", color=BLUE, font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(FadeIn(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Element 1: Create a simple 2D representation of a cube\n        square = Square(side_length=3, color=BLUE)\n        diag1 = Line(square.get_corner(UL), square.get_corner(DR), color=BLUE)\n        diag2 = Line(square.get_corner(UR), square.get_corner(DL), color=BLUE)\n        \n        # Add dots for vertices\n        vertices = VGroup(*[Dot(p, color=YELLOW) for p in [\n            square.get_corner(UL), square.get_corner(UR),\n            square.get_corner(DL), square.get_corner(DR)\n        ]])\n        \n        cube_title = Text(\"A Cube:\", font_size=24, color=BLUE).to_edge(UP)\n        \n        self.play(Write(cube_title))\n        self.play(Create(square))\n        self.play(Create(diag1), Create(diag2))\n        self.play(Create(vertices))\n        self.wait(1)\n        \n        # Element 2: Show the Euler characteristic equation\n        v_label = Text(\"V = 8\", color=YELLOW).to_edge(LEFT)\n        e_label = Text(\"E = 12\", color=GREEN).next_to(v_label, DOWN)\n        f_label = Text(\"F = 6\", color=RED).next_to(e_label, DOWN)\n        \n        self.play(Write(v_label), Write(e_label), Write(f_label))\n        \n        euler_eq = Text(\"V - E + F = 2\", color=BLUE).to_edge(RIGHT)\n        euler_calc = Text(\"8 - 12 + 6 = 2\", color=GOLD).next_to(euler_eq, DOWN)\n        \n        self.play(Write(euler_eq))\n        self.play(Write(euler_calc))\n        self.wait(1)\n        \n        # Element 3: Subdivide an edge\n        self.play(FadeOut(cube_title))\n        \n        subdiv_title = Text(\"Subdividing an Edge:\", font_size=24, color=BLUE).to_edge(UP)\n        self.play(Write(subdiv_title))\n        \n        # Add a new vertex on an edge\n        new_vertex = Dot(square.get_top(), color=YELLOW)\n        self.play(FadeIn(new_vertex))\n        self.wait(1)\n        \n        # Element 4: Update the counts\n        subdiv_text = Text(\"Add 1 vertex and 1 edge\", font_size=20).next_to(subdiv_title, DOWN)\n        self.play(Write(subdiv_text))\n        \n        new_v_label = Text(\"V = 9\", color=YELLOW).to_edge(LEFT)\n        new_e_label = Text(\"E = 13\", color=GREEN).next_to(new_v_label, DOWN)\n        \n        self.play(\n            Transform(v_label, new_v_label),\n            Transform(e_label, new_e_label)\n        )\n        self.wait(1)\n        \n        # Element 5: Show the new Euler calculation\n        new_euler_calc = Text(\"9 - 13 + 6 = 2\", color=GOLD).next_to(euler_eq, DOWN)\n        \n        self.play(Transform(euler_calc, new_euler_calc))\n        self.wait(1)\n        \n        # Key Insight - Euler characteristic's invariance\n        self.play(\n            FadeOut(subdiv_title),\n            FadeOut(subdiv_text)\n        )\n        \n        insight = Text(\"The Euler characteristic remains unchanged!\", color=GOLD, font_size=24)\n        insight.to_edge(UP)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Element 6: Conclusion\n        self.play(\n            FadeOut(square),\n            FadeOut(diag1),\n            FadeOut(diag2),\n            FadeOut(vertices),\n            FadeOut(v_label),\n            FadeOut(e_label),\n            FadeOut(f_label),\n            FadeOut(new_vertex),\n            FadeOut(euler_eq),\n            FadeOut(euler_calc),\n            FadeOut(insight)\n        )\n        \n        conclusion = Text(\"Complexity may change,\\nbut the Euler characteristic remains constant.\", \n                      font_size=28, color=BLUE)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the Euler characteristic of a polyhedron change when edges are continuously subdivided?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a 3D scene with the camera angled slightly from above and to the side. Show three colored spheres: a small red sphere positioned to the right, a large green sphere placed in the lower-left area, and a large blue sphere located in the upper-left area. All spheres appear simultaneously and remain static in the scene."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleSphere(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\n        sphere1 = Sphere(\n            center=(3, 0, 0),\n            radius=1,\n            resolution=(20, 20),\n            u_range=[0.001, PI - 0.001],\n            v_range=[0, TAU]\n        )\n        sphere1.set_color(RED)\n        self.add(sphere1)\n        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\n        sphere2.set_color(GREEN)\n        self.add(sphere2)\n        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\n        sphere3.set_color(BLUE)\n        self.add(sphere3)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D scene with the camera angled slightly from above and to the side. Show three colored spheres: a small red sphere positioned to the right, a large green sphere placed in the lower-left area, and a large blue sphere located in the upper-left area. All spheres appear simultaneously and remain static in the scene."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a 3d scene with the camera angled slightly from above and to the side. show three colored spheres: a small red sphere positioned to the right, a large green sphere placed in the lower-left area, and a large blue sphere located in the upper-left area. all spheres appear simultaneously and remain static in the scene."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ExampleSphere(ThreeDScene):\n    def construct(self):\n        self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\n        sphere1 = Sphere(\n            center=(3, 0, 0),\n            radius=1,\n            resolution=(20, 20),\n            u_range=[0.001, PI - 0.001],\n            v_range=[0, TAU]\n        )\n        sphere1.set_color(RED)\n        self.add(sphere1)\n        sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\n        sphere2.set_color(GREEN)\n        self.add(sphere2)\n        sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\n        sphere3.set_color(BLUE)\n        self.add(sphere3)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a 3D scene with the camera angled slightly from above and to the side. Show three colored spheres: a small red sphere positioned to the right, a large green sphere placed in the lower-left area, and a large blue sphere located in the upper-left area. All spheres appear simultaneously and remain static in the scene."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animated video showing a simple water molecule with one oxygen atom and two hydrogen atoms. The oxygen atom should appear as a larger red circle with the letter 'O' in the center, and the hydrogen atoms should be smaller blue circles each with the letter 'H' in the center. All atoms should be connected with lines representing chemical bonds. Can the animation start by fading in the molecule, then scale it up to be twice its initial size over a couple of seconds, and end by fading out the entire molecule?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import ConvolutionalLayer, PoolingLayer, FullyConnectedLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Define the structure of the Convolutional Neural Network\n        cnn = NeuralNetwork([\n            ConvolutionalLayer(feature_maps=1, kernel_size=(3, 3), input_shape=(28, 28, 1)),\n            PoolingLayer(pool_size=(2, 2)),\n            ConvolutionalLayer(feature_maps=3, kernel_size=(3, 3)),\n            PoolingLayer(pool_size=(2, 2)),\n            FullyConnectedLayer(units=120),\n            FullyConnectedLayer(units=84),\n            FullyConnectedLayer(units=10, activation='softmax')\n        ], layer_spacing=0.2, neural_network_type='CNN')\n\n        cnn.scale(0.5)\n        cnn.move_to(ORIGIN)\n\n        # Animate the construction and forward pass of the CNN\n        self.play(AnimationGroup(\n            Create(cnn),\n            cnn.make_forward_pass_animation(),\n            lag_ratio=0.1,\n            run_time=4\n        ))\n\n        # Hold the final scene\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video showing a simple water molecule with one oxygen atom and two hydrogen atoms. The oxygen atom should appear as a larger red circle with the letter 'O' in the center, and the hydrogen atoms should be smaller blue circles each with the letter 'H' in the center. All atoms should be connected with lines representing chemical bonds. Can the animation start by fading in the molecule, then scale it up to be twice its initial size over a couple of seconds, and end by fading out the entire molecule?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animated video showing a simple water molecule with one oxygen atom and two hydrogen atoms. the oxygen atom should appear as a larger red circle with the letter 'o' in the center, and the hydrogen atoms should be smaller blue circles each with the letter 'h' in the center. all atoms should be connected with lines representing chemical bonds. can the animation start by fading in the molecule, then scale it up to be twice its initial size over a couple of seconds, and end by fading out the entire molecule?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nfrom manim_ml.neural_network.layers import ConvolutionalLayer, PoolingLayer, FullyConnectedLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\n\nconfig.pixel_height = 720\nconfig.pixel_width = 1280\nconfig.frame_height = 6.0\nconfig.frame_width = 6.0\n\nclass CNNVisualizationScene(Scene):\n    def construct(self):\n        # Define the structure of the Convolutional Neural Network\n        cnn = NeuralNetwork([\n            ConvolutionalLayer(feature_maps=1, kernel_size=(3, 3), input_shape=(28, 28, 1)),\n            PoolingLayer(pool_size=(2, 2)),\n            ConvolutionalLayer(feature_maps=3, kernel_size=(3, 3)),\n            PoolingLayer(pool_size=(2, 2)),\n            FullyConnectedLayer(units=120),\n            FullyConnectedLayer(units=84),\n            FullyConnectedLayer(units=10, activation='softmax')\n        ], layer_spacing=0.2, neural_network_type='CNN')\n\n        cnn.scale(0.5)\n        cnn.move_to(ORIGIN)\n\n        # Animate the construction and forward pass of the CNN\n        self.play(AnimationGroup(\n            Create(cnn),\n            cnn.make_forward_pass_animation(),\n            lag_ratio=0.1,\n            run_time=4\n        ))\n\n        # Hold the final scene\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video showing a simple water molecule with one oxygen atom and two hydrogen atoms. The oxygen atom should appear as a larger red circle with the letter 'O' in the center, and the hydrogen atoms should be smaller blue circles each with the letter 'H' in the center. All atoms should be connected with lines representing chemical bonds. Can the animation start by fading in the molecule, then scale it up to be twice its initial size over a couple of seconds, and end by fading out the entire molecule?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a blue dot on the left and a red dot on the right, each with a short horizontal line extending from them. A smooth cubic B\u00e9zier curve connects the ends of these lines, arching from the blue dot\u2019s line to the red dot\u2019s line, forming a flowing S-shaped path across the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BezierSplineExample(Scene):\n    def construct(self):\n        p1 = np.array([-3, 1, 0])\n        p1b = p1 + [1, 0, 0]\n        d1 = Dot(point=p1).set_color(BLUE)\n        l1 = Line(p1, p1b)\n        p2 = np.array([3, -1, 0])\n        p2b = p2 - [1, 0, 0]\n        d2 = Dot(point=p2).set_color(RED)\n        l2 = Line(p2, p2b)\n        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\n        self.add(l1, d1, l2, d2, bezier)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue dot on the left and a red dot on the right, each with a short horizontal line extending from them. A smooth cubic B\u00e9zier curve connects the ends of these lines, arching from the blue dot\u2019s line to the red dot\u2019s line, forming a flowing S-shaped path across the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a blue dot on the left and a red dot on the right, each with a short horizontal line extending from them. a smooth cubic b\u00e9zier curve connects the ends of these lines, arching from the blue dot\u2019s line to the red dot\u2019s line, forming a flowing s-shaped path across the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass BezierSplineExample(Scene):\n    def construct(self):\n        p1 = np.array([-3, 1, 0])\n        p1b = p1 + [1, 0, 0]\n        d1 = Dot(point=p1).set_color(BLUE)\n        l1 = Line(p1, p1b)\n        p2 = np.array([3, -1, 0])\n        p2b = p2 - [1, 0, 0]\n        d2 = Dot(point=p2).set_color(RED)\n        l2 = Line(p2, p2b)\n        bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\n        self.add(l1, d1, l2, d2, bezier)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a blue dot on the left and a red dot on the right, each with a short horizontal line extending from them. A smooth cubic B\u00e9zier curve connects the ends of these lines, arching from the blue dot\u2019s line to the red dot\u2019s line, forming a flowing S-shaped path across the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do spectral properties of the adjacency matrix of a bipartite graph reveal about its structure and possible partitionings?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpectralSecretsOfBipartiteGraphs(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Spectral Secrets of Bipartite Graphs\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Create bipartite graph\n        # Left vertices (teal)\n        v_left1 = Dot(point=[-2, 1, 0], color=TEAL)\n        v_left2 = Dot(point=[-2, -1, 0], color=TEAL)\n        \n        # Right vertices (orange)\n        v_right1 = Dot(point=[2, 1, 0], color=ORANGE)\n        v_right2 = Dot(point=[2, -1, 0], color=ORANGE)\n        \n        # Edges\n        edge1 = Line(v_left1.get_center(), v_right1.get_center())\n        edge2 = Line(v_left1.get_center(), v_right2.get_center())\n        edge3 = Line(v_left2.get_center(), v_right1.get_center())\n        \n        # Groups\n        vertices = VGroup(v_left1, v_left2, v_right1, v_right2)\n        edges = VGroup(edge1, edge2, edge3)\n        graph = VGroup(vertices, edges)\n        \n        # Display graph\n        self.play(Create(vertices))\n        self.play(Create(edges))\n        \n        # Text description\n        text1 = Text(\"Bipartite Graph\", font_size=24)\n        text1.next_to(graph, DOWN)\n        self.play(Write(text1))\n        self.wait(1)\n        \n        # Move graph and show adjacency matrix\n        self.play(\n            graph.animate.scale(0.7).to_edge(LEFT),\n            FadeOut(text1)\n        )\n        \n        # Adjacency matrix\n        matrix = MathTex(r\"A = \\begin{bmatrix}0 & 1 & 1 \\\\ 1 & 0 & 0 \\\\ 1 & 0 & 0 \\end{bmatrix}\")\n        matrix.next_to(graph, RIGHT, buff=1)\n        \n        matrix_text = Text(\"Adjacency Matrix\", font_size=24)\n        matrix_text.next_to(matrix, UP)\n        \n        self.play(Write(matrix_text), Write(matrix))\n        self.wait(1)\n        \n        # Eigenvalue symmetry\n        eigen_eq = MathTex(r\"\\lambda_i = -\\lambda_j\")\n        eigen_text = Text(\"Eigenvalues are symmetric\", font_size=24)\n        \n        eigen_group = VGroup(eigen_eq, eigen_text).arrange(DOWN)\n        eigen_group.next_to(matrix, DOWN, buff=1)\n        \n        self.play(Write(eigen_group))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph),\n            FadeOut(matrix),\n            FadeOut(matrix_text),\n            FadeOut(eigen_group)\n        )\n        \n        conclusion = Text(\"Spectral properties reveal bipartite structure\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do spectral properties of the adjacency matrix of a bipartite graph reveal about its structure and possible partitionings?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do spectral properties of the adjacency matrix of a bipartite graph reveal about its structure and possible partitionings?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SpectralSecretsOfBipartiteGraphs(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Spectral Secrets of Bipartite Graphs\", font_size=36)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Create bipartite graph\n        # Left vertices (teal)\n        v_left1 = Dot(point=[-2, 1, 0], color=TEAL)\n        v_left2 = Dot(point=[-2, -1, 0], color=TEAL)\n        \n        # Right vertices (orange)\n        v_right1 = Dot(point=[2, 1, 0], color=ORANGE)\n        v_right2 = Dot(point=[2, -1, 0], color=ORANGE)\n        \n        # Edges\n        edge1 = Line(v_left1.get_center(), v_right1.get_center())\n        edge2 = Line(v_left1.get_center(), v_right2.get_center())\n        edge3 = Line(v_left2.get_center(), v_right1.get_center())\n        \n        # Groups\n        vertices = VGroup(v_left1, v_left2, v_right1, v_right2)\n        edges = VGroup(edge1, edge2, edge3)\n        graph = VGroup(vertices, edges)\n        \n        # Display graph\n        self.play(Create(vertices))\n        self.play(Create(edges))\n        \n        # Text description\n        text1 = Text(\"Bipartite Graph\", font_size=24)\n        text1.next_to(graph, DOWN)\n        self.play(Write(text1))\n        self.wait(1)\n        \n        # Move graph and show adjacency matrix\n        self.play(\n            graph.animate.scale(0.7).to_edge(LEFT),\n            FadeOut(text1)\n        )\n        \n        # Adjacency matrix\n        matrix = MathTex(r\"A = \\begin{bmatrix}0 & 1 & 1 \\\\ 1 & 0 & 0 \\\\ 1 & 0 & 0 \\end{bmatrix}\")\n        matrix.next_to(graph, RIGHT, buff=1)\n        \n        matrix_text = Text(\"Adjacency Matrix\", font_size=24)\n        matrix_text.next_to(matrix, UP)\n        \n        self.play(Write(matrix_text), Write(matrix))\n        self.wait(1)\n        \n        # Eigenvalue symmetry\n        eigen_eq = MathTex(r\"\\lambda_i = -\\lambda_j\")\n        eigen_text = Text(\"Eigenvalues are symmetric\", font_size=24)\n        \n        eigen_group = VGroup(eigen_eq, eigen_text).arrange(DOWN)\n        eigen_group.next_to(matrix, DOWN, buff=1)\n        \n        self.play(Write(eigen_group))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(graph),\n            FadeOut(matrix),\n            FadeOut(matrix_text),\n            FadeOut(eigen_group)\n        )\n        \n        conclusion = Text(\"Spectral properties reveal bipartite structure\", font_size=30)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion), FadeOut(title))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do spectral properties of the adjacency matrix of a bipartite graph reveal about its structure and possible partitionings?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What visual patterns emerge when examining the number of random bits needed versus the error probability in PCPs?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PCPTheoremScene(Scene):\n    def construct(self):\n        # Set up title\n        title = Text(\"The Dance Between Randomness and Error in PCPs\")\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction\n        intro_text = Text(\"Interactive Proof Systems & PCP Theorem\", font_size=24)\n        intro_text.next_to(title, DOWN, buff=0.5)\n        self.play(FadeIn(intro_text))\n        self.wait(1)\n        \n        # Transition to landscape visualization\n        self.play(FadeOut(intro_text))\n        \n        # Create landscape (hills and valleys)\n        landscape_text = Text(\"Imagine a landscape of hills and valleys...\", font_size=24)\n        landscape_text.to_edge(UP, buff=1.5)\n        \n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 1, 0.5],\n            axis_config={\"color\": WHITE},\n        )\n        axes.shift(DOWN)\n        \n        # Create a curve representing landscape\n        landscape = axes.plot(lambda x: np.sin(x)*np.cos(2*x), color=GREEN)\n        \n        self.play(Write(landscape_text))\n        self.wait(1)\n        self.play(Create(axes), Create(landscape))\n        self.wait(1)\n        \n        # Transition to trade-off visualization\n        self.play(FadeOut(landscape_text), FadeOut(landscape))\n        \n        trade_off_text = Text(\"In PCPs, we see a trade-off between randomness and error\", font_size=24)\n        trade_off_text.to_edge(UP, buff=1.5)\n        \n        self.play(Write(trade_off_text))\n        self.wait(1)\n        \n        # Relabel axes for the trade-off\n        x_label = Text(\"Random Bits\", font_size=20)\n        x_label.next_to(axes.x_axis, DOWN)\n        \n        y_label = Text(\"Error Probability\", font_size=20)\n        y_label.next_to(axes.y_axis, LEFT)\n        \n        self.play(FadeIn(x_label), FadeIn(y_label))\n        self.wait(1)\n        \n        # Create trade-off curve\n        trade_off_curve = axes.plot(\n            lambda x: 0.8 * (1 / (abs(x) + 1)),\n            x_range=[-3, 3],\n            color=YELLOW\n        )\n        \n        self.play(Create(trade_off_curve))\n        self.wait(1)\n        \n        # Highlight interesting region\n        highlight = Rectangle(width=1.5, height=1, color=BLUE, fill_opacity=0.2)\n        highlight.move_to(axes.c2p(1, 0.4))\n        \n        highlight_text = Text(\"Critical region\", font_size=16, color=BLUE)\n        highlight_text.next_to(highlight, UP)\n        \n        self.play(FadeIn(highlight), Write(highlight_text))\n        self.wait(1)\n        \n        self.play(FadeOut(highlight), FadeOut(highlight_text), FadeOut(trade_off_text))\n        \n        # Show the key equations\n        eq1 = Text(\"Randomness-Error Trade-off: f(n) = O(1/\u03b5^k)\", font_size=24)\n        eq1.to_edge(UP, buff=1.5)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        \n        eq2 = Text(\"PCP Theorem: NP = PCP(log n, O(1))\", font_size=24)\n        eq2.next_to(eq1, DOWN, buff=0.5)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        conclusion_text = Text(\"Discover the beautiful patterns in PCPs!\", font_size=28)\n        conclusion_text.to_edge(UP, buff=1.5)\n        \n        self.play(Write(conclusion_text))\n        self.wait(1)\n        \n        # Final fade out\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=2\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What visual patterns emerge when examining the number of random bits needed versus the error probability in PCPs?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what visual patterns emerge when examining the number of random bits needed versus the error probability in pcps?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PCPTheoremScene(Scene):\n    def construct(self):\n        # Set up title\n        title = Text(\"The Dance Between Randomness and Error in PCPs\")\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Introduction\n        intro_text = Text(\"Interactive Proof Systems & PCP Theorem\", font_size=24)\n        intro_text.next_to(title, DOWN, buff=0.5)\n        self.play(FadeIn(intro_text))\n        self.wait(1)\n        \n        # Transition to landscape visualization\n        self.play(FadeOut(intro_text))\n        \n        # Create landscape (hills and valleys)\n        landscape_text = Text(\"Imagine a landscape of hills and valleys...\", font_size=24)\n        landscape_text.to_edge(UP, buff=1.5)\n        \n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 1, 0.5],\n            axis_config={\"color\": WHITE},\n        )\n        axes.shift(DOWN)\n        \n        # Create a curve representing landscape\n        landscape = axes.plot(lambda x: np.sin(x)*np.cos(2*x), color=GREEN)\n        \n        self.play(Write(landscape_text))\n        self.wait(1)\n        self.play(Create(axes), Create(landscape))\n        self.wait(1)\n        \n        # Transition to trade-off visualization\n        self.play(FadeOut(landscape_text), FadeOut(landscape))\n        \n        trade_off_text = Text(\"In PCPs, we see a trade-off between randomness and error\", font_size=24)\n        trade_off_text.to_edge(UP, buff=1.5)\n        \n        self.play(Write(trade_off_text))\n        self.wait(1)\n        \n        # Relabel axes for the trade-off\n        x_label = Text(\"Random Bits\", font_size=20)\n        x_label.next_to(axes.x_axis, DOWN)\n        \n        y_label = Text(\"Error Probability\", font_size=20)\n        y_label.next_to(axes.y_axis, LEFT)\n        \n        self.play(FadeIn(x_label), FadeIn(y_label))\n        self.wait(1)\n        \n        # Create trade-off curve\n        trade_off_curve = axes.plot(\n            lambda x: 0.8 * (1 / (abs(x) + 1)),\n            x_range=[-3, 3],\n            color=YELLOW\n        )\n        \n        self.play(Create(trade_off_curve))\n        self.wait(1)\n        \n        # Highlight interesting region\n        highlight = Rectangle(width=1.5, height=1, color=BLUE, fill_opacity=0.2)\n        highlight.move_to(axes.c2p(1, 0.4))\n        \n        highlight_text = Text(\"Critical region\", font_size=16, color=BLUE)\n        highlight_text.next_to(highlight, UP)\n        \n        self.play(FadeIn(highlight), Write(highlight_text))\n        self.wait(1)\n        \n        self.play(FadeOut(highlight), FadeOut(highlight_text), FadeOut(trade_off_text))\n        \n        # Show the key equations\n        eq1 = Text(\"Randomness-Error Trade-off: f(n) = O(1/\u03b5^k)\", font_size=24)\n        eq1.to_edge(UP, buff=1.5)\n        \n        self.play(Write(eq1))\n        self.wait(1)\n        \n        eq2 = Text(\"PCP Theorem: NP = PCP(log n, O(1))\", font_size=24)\n        eq2.next_to(eq1, DOWN, buff=0.5)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(eq1), FadeOut(eq2))\n        \n        conclusion_text = Text(\"Discover the beautiful patterns in PCPs!\", font_size=28)\n        conclusion_text.to_edge(UP, buff=1.5)\n        \n        self.play(Write(conclusion_text))\n        self.wait(1)\n        \n        # Final fade out\n        self.play(\n            *[FadeOut(mob) for mob in self.mobjects],\n            run_time=2\n        )\n        self.wait(1)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What visual patterns emerge when examining the number of random bits needed versus the error probability in PCPs?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_expand_image_patches.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Tests animation for converting \n\"\"\"\n\nfrom manim import *\n\nimport sys\nsys.path.append(\"..\")\nfrom examples.cross_attention_vis.cross_attention_vis import ImagePatches, ExpandPatches\n\nconfig.background_color = WHITE\n\nclass ConvertImageToPatches(Scene):\n\n    def construct(self):\n        # Load image mobject\n        image = ImageMobject(\"images/image.jpeg\")\n        image.move_to(ORIGIN)\n        image.scale(10)\n        self.add(image)\n        self.wait(1)\n        patches = ImagePatches(image, grid_width=2)\n        self.remove(image)\n        self.add(patches)\n        self.wait(1)\n        # Expand the patches\n        self.play(ExpandPatches(patches))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_expand_image_patches.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_expand_image_patches.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Tests animation for converting \n\"\"\"\n\nfrom manim import *\n\nimport sys\nsys.path.append(\"..\")\nfrom examples.cross_attention_vis.cross_attention_vis import ImagePatches, ExpandPatches\n\nconfig.background_color = WHITE\n\nclass ConvertImageToPatches(Scene):\n\n    def construct(self):\n        # Load image mobject\n        image = ImageMobject(\"images/image.jpeg\")\n        image.move_to(ORIGIN)\n        image.scale(10)\n        self.add(image)\n        self.wait(1)\n        patches = ImagePatches(image, grid_width=2)\n        self.remove(image)\n        self.add(patches)\n        self.wait(1)\n        # Expand the patches\n        self.play(ExpandPatches(patches))\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_expand_image_patches.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can fractals be used to represent chaotic systems, and how do fractals like the Mandelbrot set reveal hidden order?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport random\n\nclass FractalsAndChaos(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fractals and the Hidden Order in Chaos\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Opening scene with confetti\n        confetti = VGroup(*[Dot(radius=0.05, color=random.choice([RED, GREEN, BLUE, YELLOW])) \n                          for _ in range(20)])\n        \n        # Position confetti randomly\n        for dot in confetti:\n            dot.move_to(np.array([random.uniform(-5, 5), random.uniform(-3, 3), 0]))\n        \n        self.play(Create(confetti))\n        self.wait(1)\n        \n        # Text about chaos\n        chaos_text = Text(\"Chaos appears random at first glance\", font_size=36)\n        self.play(FadeOut(confetti), Write(chaos_text))\n        self.wait(1)\n        self.play(FadeOut(chaos_text))\n        \n        # Introduction to fractals - Sierpinski triangle\n        fractal_text = Text(\"Fractals show self-similarity\", font_size=36)\n        self.play(Write(fractal_text))\n        self.wait(1)\n        self.play(FadeOut(fractal_text))\n        \n        # Simple Sierpinski triangle\n        triangle = Triangle(fill_opacity=0.5, color=BLUE)\n        triangle.scale(2)\n        \n        self.play(Create(triangle))\n        self.wait(1)\n        \n        # Transform into smaller triangles\n        small_triangles = VGroup(\n            Triangle(fill_opacity=0.5, color=RED).scale(1).shift(UP * 0.8),\n            Triangle(fill_opacity=0.5, color=GREEN).scale(1).shift(DOWN * 0.4 + LEFT * 0.8),\n            Triangle(fill_opacity=0.5, color=YELLOW).scale(1).shift(DOWN * 0.4 + RIGHT * 0.8)\n        )\n        \n        self.play(Transform(triangle, small_triangles))\n        self.wait(1)\n        self.play(FadeOut(triangle))\n        \n        # Mandelbrot set\n        mandelbrot_text = Text(\"The Mandelbrot set reveals hidden patterns\", font_size=36)\n        self.play(Write(mandelbrot_text))\n        self.wait(1)\n        self.play(FadeOut(mandelbrot_text))\n        \n        # Simple representation of Mandelbrot set\n        mandelbrot = Circle(radius=1.5, color=PURPLE, fill_opacity=0.5)\n        small_circle = Circle(radius=0.75, color=BLUE, fill_opacity=0.5).shift(RIGHT * 0.75)\n        \n        mandelbrot_group = VGroup(mandelbrot, small_circle)\n        \n        self.play(Create(mandelbrot_group))\n        self.wait(1)\n        \n        # The iterative formula\n        formula = MathTex(r\"z_{n+1} = z_n^2 + c\")\n        formula.next_to(mandelbrot_group, DOWN)\n        \n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Simple zoom effect to suggest infinite complexity\n        self.play(mandelbrot_group.animate.scale(1.5))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(mandelbrot_group), FadeOut(formula))\n        \n        conclusion = Text(\"Fractals bridge chaos and order\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can fractals be used to represent chaotic systems, and how do fractals like the Mandelbrot set reveal hidden order?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can fractals be used to represent chaotic systems, and how do fractals like the mandelbrot set reveal hidden order?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport random\n\nclass FractalsAndChaos(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Fractals and the Hidden Order in Chaos\")\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Opening scene with confetti\n        confetti = VGroup(*[Dot(radius=0.05, color=random.choice([RED, GREEN, BLUE, YELLOW])) \n                          for _ in range(20)])\n        \n        # Position confetti randomly\n        for dot in confetti:\n            dot.move_to(np.array([random.uniform(-5, 5), random.uniform(-3, 3), 0]))\n        \n        self.play(Create(confetti))\n        self.wait(1)\n        \n        # Text about chaos\n        chaos_text = Text(\"Chaos appears random at first glance\", font_size=36)\n        self.play(FadeOut(confetti), Write(chaos_text))\n        self.wait(1)\n        self.play(FadeOut(chaos_text))\n        \n        # Introduction to fractals - Sierpinski triangle\n        fractal_text = Text(\"Fractals show self-similarity\", font_size=36)\n        self.play(Write(fractal_text))\n        self.wait(1)\n        self.play(FadeOut(fractal_text))\n        \n        # Simple Sierpinski triangle\n        triangle = Triangle(fill_opacity=0.5, color=BLUE)\n        triangle.scale(2)\n        \n        self.play(Create(triangle))\n        self.wait(1)\n        \n        # Transform into smaller triangles\n        small_triangles = VGroup(\n            Triangle(fill_opacity=0.5, color=RED).scale(1).shift(UP * 0.8),\n            Triangle(fill_opacity=0.5, color=GREEN).scale(1).shift(DOWN * 0.4 + LEFT * 0.8),\n            Triangle(fill_opacity=0.5, color=YELLOW).scale(1).shift(DOWN * 0.4 + RIGHT * 0.8)\n        )\n        \n        self.play(Transform(triangle, small_triangles))\n        self.wait(1)\n        self.play(FadeOut(triangle))\n        \n        # Mandelbrot set\n        mandelbrot_text = Text(\"The Mandelbrot set reveals hidden patterns\", font_size=36)\n        self.play(Write(mandelbrot_text))\n        self.wait(1)\n        self.play(FadeOut(mandelbrot_text))\n        \n        # Simple representation of Mandelbrot set\n        mandelbrot = Circle(radius=1.5, color=PURPLE, fill_opacity=0.5)\n        small_circle = Circle(radius=0.75, color=BLUE, fill_opacity=0.5).shift(RIGHT * 0.75)\n        \n        mandelbrot_group = VGroup(mandelbrot, small_circle)\n        \n        self.play(Create(mandelbrot_group))\n        self.wait(1)\n        \n        # The iterative formula\n        formula = MathTex(r\"z_{n+1} = z_n^2 + c\")\n        formula.next_to(mandelbrot_group, DOWN)\n        \n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Simple zoom effect to suggest infinite complexity\n        self.play(mandelbrot_group.animate.scale(1.5))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(mandelbrot_group), FadeOut(formula))\n        \n        conclusion = Text(\"Fractals bridge chaos and order\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can fractals be used to represent chaotic systems, and how do fractals like the Mandelbrot set reveal hidden order?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the effect of intersecting an affine algebraic variety with a hyperplane on its components and structure?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AffineVarietyHyperplaneIntersection(Scene):\n    def construct(self):\n        # Introduction: Title\n        title = Text(\"The Dance of Dimensions\", font_size=36)\n        subtitle = Text(\"Affine Varieties Meet Hyperplanes\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n\n        # Create a simple coordinate system\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": WHITE},\n        ).scale(0.8)\n        \n        # Create a simple variety (parabola)\n        parabola = axes.plot(lambda x: x**2, color=BLUE)\n        variety_label = Text(\"Affine variety: y - x\u00b2 = 0 (dimension 1)\", font_size=24).to_edge(UP)\n        \n        self.play(Create(axes))\n        self.play(Create(parabola))\n        self.play(Write(variety_label))\n        self.wait(1)\n\n        # Basic equation\n        variety_eq = Text(\"V(f) = {(x,y) | f(x,y) = 0}\", font_size=24)\n        variety_eq.to_edge(DOWN)\n        self.play(Write(variety_eq))\n        self.wait(1)\n\n        # Introduce a hyperplane (line in 2D)\n        line = axes.plot(lambda x: 1, color=RED)\n        hyperplane_label = Text(\"Hyperplane: y = 1\", font_size=24).to_edge(UP)\n        \n        self.play(FadeOut(variety_label))\n        self.play(Create(line))\n        self.play(Write(hyperplane_label))\n        self.wait(1)\n\n        # Highlight the intersection points\n        intersection_points = [axes.c2p(-1, 1), axes.c2p(1, 1)]\n        dots = VGroup(*[Dot(point, color=YELLOW, radius=0.1) for point in intersection_points])\n        \n        self.play(Create(dots))\n        intersection_text = Text(\"Intersection points (dimension 0)\", font_size=24)\n        intersection_text.to_edge(UP)\n        self.play(FadeOut(hyperplane_label))\n        self.play(Write(intersection_text))\n        self.wait(1)\n        \n        # Dimension reduction text\n        dim_text = Text(\"Dimension reduced: 1D curve \u2192 0D points\", font_size=24)\n        dim_text.to_edge(DOWN)\n        self.play(FadeOut(variety_eq))\n        self.play(Write(dim_text))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(axes),\n            FadeOut(parabola),\n            FadeOut(line),\n            FadeOut(dots),\n            FadeOut(intersection_text),\n            FadeOut(dim_text)\n        )\n        \n        conclusion = Text(\"Hyperplane intersections reveal\\nthe structure of varieties\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the effect of intersecting an affine algebraic variety with a hyperplane on its components and structure?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the effect of intersecting an affine algebraic variety with a hyperplane on its components and structure?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass AffineVarietyHyperplaneIntersection(Scene):\n    def construct(self):\n        # Introduction: Title\n        title = Text(\"The Dance of Dimensions\", font_size=36)\n        subtitle = Text(\"Affine Varieties Meet Hyperplanes\", font_size=28)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n\n        # Create a simple coordinate system\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            axis_config={\"color\": WHITE},\n        ).scale(0.8)\n        \n        # Create a simple variety (parabola)\n        parabola = axes.plot(lambda x: x**2, color=BLUE)\n        variety_label = Text(\"Affine variety: y - x\u00b2 = 0 (dimension 1)\", font_size=24).to_edge(UP)\n        \n        self.play(Create(axes))\n        self.play(Create(parabola))\n        self.play(Write(variety_label))\n        self.wait(1)\n\n        # Basic equation\n        variety_eq = Text(\"V(f) = {(x,y) | f(x,y) = 0}\", font_size=24)\n        variety_eq.to_edge(DOWN)\n        self.play(Write(variety_eq))\n        self.wait(1)\n\n        # Introduce a hyperplane (line in 2D)\n        line = axes.plot(lambda x: 1, color=RED)\n        hyperplane_label = Text(\"Hyperplane: y = 1\", font_size=24).to_edge(UP)\n        \n        self.play(FadeOut(variety_label))\n        self.play(Create(line))\n        self.play(Write(hyperplane_label))\n        self.wait(1)\n\n        # Highlight the intersection points\n        intersection_points = [axes.c2p(-1, 1), axes.c2p(1, 1)]\n        dots = VGroup(*[Dot(point, color=YELLOW, radius=0.1) for point in intersection_points])\n        \n        self.play(Create(dots))\n        intersection_text = Text(\"Intersection points (dimension 0)\", font_size=24)\n        intersection_text.to_edge(UP)\n        self.play(FadeOut(hyperplane_label))\n        self.play(Write(intersection_text))\n        self.wait(1)\n        \n        # Dimension reduction text\n        dim_text = Text(\"Dimension reduced: 1D curve \u2192 0D points\", font_size=24)\n        dim_text.to_edge(DOWN)\n        self.play(FadeOut(variety_eq))\n        self.play(Write(dim_text))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(\n            FadeOut(axes),\n            FadeOut(parabola),\n            FadeOut(line),\n            FadeOut(dots),\n            FadeOut(intersection_text),\n            FadeOut(dim_text)\n        )\n        \n        conclusion = Text(\"Hyperplane intersections reveal\\nthe structure of varieties\", font_size=36)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the effect of intersecting an affine algebraic variety with a hyperplane on its components and structure?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display an orange dot at the left end of a horizontal line. As the dot moves smoothly along the line to the right, an orange line dynamically extends from the left endpoint to the moving dot, visually tracing its path in real time similar to a filling progress bar."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        l2 = VMobject()\n        self.add(d1, l1, l2)\n        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n        self.play(MoveAlongPath(d1, l1), rate_func=linear)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display an orange dot at the left end of a horizontal line. As the dot moves smoothly along the line to the right, an orange line dynamically extends from the left endpoint to the moving dot, visually tracing its path in real time similar to a filling progress bar."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display an orange dot at the left end of a horizontal line. as the dot moves smoothly along the line to the right, an orange line dynamically extends from the left endpoint to the moving dot, visually tracing its path in real time similar to a filling progress bar."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MoveAlongPathExample(Scene):\n    def construct(self):\n        d1 = Dot().set_color(ORANGE)\n        l1 = Line(LEFT, RIGHT)\n        l2 = VMobject()\n        self.add(d1, l1, l2)\n        l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n        self.play(MoveAlongPath(d1, l1), rate_func=linear)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display an orange dot at the left end of a horizontal line. As the dot moves smoothly along the line to the right, an orange line dynamically extends from the left endpoint to the moving dot, visually tracing its path in real time similar to a filling progress bar."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated video that explains the classical wave equation using visual aids? The video should begin by displaying the mathematical formula of the wave equation. After showing the formula, add a brief text description stating \"This is the classical wave equation.\" Then, proceed to clarify that in the equation, the 'c' symbol represents the speed of waves with another piece of text. Next, replace the wave equation with the general solution formula for a one-dimensional wave and accompany it with text that explains it's the general solution for the one-dimensional wave equation. Finally, clear all previous content and conclude the video by showing just the solution formula on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} (r^2 \\sin(\\theta))\\,r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{r^4}{4} \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4} \\sin(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion of solution\n        conclusion = MathTex(r\"= 0\")\n        self.play(Transform(final_solution, conclusion))\n        self.wait(2)\n\n        # Final message\n        final_message = Text(\"The polar double integral evaluates to 0\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_message))\n        self.wait(3)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video that explains the classical wave equation using visual aids? The video should begin by displaying the mathematical formula of the wave equation. After showing the formula, add a brief text description stating \"This is the classical wave equation.\" Then, proceed to clarify that in the equation, the 'c' symbol represents the speed of waves with another piece of text. Next, replace the wave equation with the general solution formula for a one-dimensional wave and accompany it with text that explains it's the general solution for the one-dimensional wave equation. Finally, clear all previous content and conclude the video by showing just the solution formula on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated video that explains the classical wave equation using visual aids? the video should begin by displaying the mathematical formula of the wave equation. after showing the formula, add a brief text description stating \"this is the classical wave equation.\" then, proceed to clarify that in the equation, the 'c' symbol represents the speed of waves with another piece of text. next, replace the wave equation with the general solution formula for a one-dimensional wave and accompany it with text that explains it's the general solution for the one-dimensional wave equation. finally, clear all previous content and conclude the video by showing just the solution formula on the screen."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{1} (r^2 \\sin(\\theta))\\,r\\,dr\\,d\\theta\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for inner integral\n        explanation1 = Text(\"Integrate with respect to r\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{r^4}{4} \\sin(\\theta)]_{0}^{1} d\\theta\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Explanation for final integral\n        explanation2 = Text(\"Now integrate with respect to \\(\\theta\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= [\\frac{1}{4} \\sin(\\theta)]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(inner_integral, final_solution))\n        self.wait(1)\n\n        # Conclusion of solution\n        conclusion = MathTex(r\"= 0\")\n        self.play(Transform(final_solution, conclusion))\n        self.wait(2)\n\n        # Final message\n        final_message = Text(\"The polar double integral evaluates to 0\", font_size=24).to_edge(DOWN)\n        self.play(Write(final_message))\n        self.wait(3)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video that explains the classical wave equation using visual aids? The video should begin by displaying the mathematical formula of the wave equation. After showing the formula, add a brief text description stating \"This is the classical wave equation.\" Then, proceed to clarify that in the equation, the 'c' symbol represents the speed of waves with another piece of text. Next, replace the wave equation with the general solution formula for a one-dimensional wave and accompany it with text that explains it's the general solution for the one-dimensional wave equation. Finally, clear all previous content and conclude the video by showing just the solution formula on the screen."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How can the concept of saddle points in optimization be visualized within the context of the minimax theorem?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MinimaxTheoremScene(Scene):\n    def construct(self):\n        # Define colors from the required color palette\n        navy = \"#1A2B63\"  # Navy Blue\n        teal = \"#008080\"  # Teal\n        orange = \"#FF7F50\"  # Orange highlight\n        \n        # Introduction - Title\n        title = Text(\"Minimax Theorem\", color=navy)\n        subtitle = Text(\"Saddle Points in Game Theory\", color=teal).scale(0.7)\n        \n        # Animate title and subtitle\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(subtitle))\n        \n        # Simple game representation (chess/poker reference)\n        square = Square(side_length=2, color=teal).set_fill(opacity=0.1)\n        game_text = Text(\"Strategic Games\", color=teal).scale(0.7).next_to(square, DOWN)\n        \n        self.play(Create(square))\n        self.play(Write(game_text))\n        self.wait(1)\n        self.play(FadeOut(square), FadeOut(game_text))\n        \n        # Basic saddle point visualization\n        # Horizontal line representing maximization\n        h_line = Line(LEFT*2, RIGHT*2, color=teal)\n        # Vertical line representing minimization\n        v_line = Line(UP*2, DOWN*2, color=navy)\n        # The saddle point at intersection\n        dot = Dot(color=orange)\n        \n        saddle_text = Text(\"Saddle Point\", color=orange).scale(0.7).next_to(dot, DOWN)\n        \n        # Animate the saddle point elements\n        self.play(Create(h_line), Create(v_line))\n        self.play(Create(dot))\n        self.play(Write(saddle_text))\n        self.wait(1)\n        self.play(FadeOut(h_line), FadeOut(v_line), FadeOut(dot), FadeOut(saddle_text))\n        \n        # Simple equation (using Text instead of complex MathTex)\n        eq = Text(\"V(x) = max min <x, Av + b>\", color=navy)\n        \n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Key insight\n        insight = Text(\"Equilibrium in zero-sum games\", color=orange).scale(0.7)\n        insight.next_to(eq, DOWN)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Optimal strategies in game theory\", color=teal).scale(0.7)\n        conclusion.next_to(insight, DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out at the end\n        self.play(FadeOut(title), FadeOut(eq), FadeOut(insight), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the concept of saddle points in optimization be visualized within the context of the minimax theorem?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how can the concept of saddle points in optimization be visualized within the context of the minimax theorem?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass MinimaxTheoremScene(Scene):\n    def construct(self):\n        # Define colors from the required color palette\n        navy = \"#1A2B63\"  # Navy Blue\n        teal = \"#008080\"  # Teal\n        orange = \"#FF7F50\"  # Orange highlight\n        \n        # Introduction - Title\n        title = Text(\"Minimax Theorem\", color=navy)\n        subtitle = Text(\"Saddle Points in Game Theory\", color=teal).scale(0.7)\n        \n        # Animate title and subtitle\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(subtitle))\n        \n        # Simple game representation (chess/poker reference)\n        square = Square(side_length=2, color=teal).set_fill(opacity=0.1)\n        game_text = Text(\"Strategic Games\", color=teal).scale(0.7).next_to(square, DOWN)\n        \n        self.play(Create(square))\n        self.play(Write(game_text))\n        self.wait(1)\n        self.play(FadeOut(square), FadeOut(game_text))\n        \n        # Basic saddle point visualization\n        # Horizontal line representing maximization\n        h_line = Line(LEFT*2, RIGHT*2, color=teal)\n        # Vertical line representing minimization\n        v_line = Line(UP*2, DOWN*2, color=navy)\n        # The saddle point at intersection\n        dot = Dot(color=orange)\n        \n        saddle_text = Text(\"Saddle Point\", color=orange).scale(0.7).next_to(dot, DOWN)\n        \n        # Animate the saddle point elements\n        self.play(Create(h_line), Create(v_line))\n        self.play(Create(dot))\n        self.play(Write(saddle_text))\n        self.wait(1)\n        self.play(FadeOut(h_line), FadeOut(v_line), FadeOut(dot), FadeOut(saddle_text))\n        \n        # Simple equation (using Text instead of complex MathTex)\n        eq = Text(\"V(x) = max min <x, Av + b>\", color=navy)\n        \n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Key insight\n        insight = Text(\"Equilibrium in zero-sum games\", color=orange).scale(0.7)\n        insight.next_to(eq, DOWN)\n        \n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Optimal strategies in game theory\", color=teal).scale(0.7)\n        conclusion.next_to(insight, DOWN)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        # Fade everything out at the end\n        self.play(FadeOut(title), FadeOut(eq), FadeOut(insight), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How can the concept of saddle points in optimization be visualized within the context of the minimax theorem?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What patterns emerge if we visualize the gaps between consecutive prime numbers?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n# Set background color to dark blue (space theme)\nconfig.background_color = \"#0A1128\"\n\nclass PrimeGapsScene(Scene):\n    def construct(self):\n        # Create a starry background effect\n        stars = VGroup()\n        for _ in range(50):\n            x = np.random.uniform(-7, 7)\n            y = np.random.uniform(-4, 4)\n            star = Dot(point=[x, y, 0], radius=0.02, color=WHITE)\n            stars.add(star)\n        \n        self.play(FadeIn(stars))\n        \n        # Title\n        title = Text(\"Unlocking Patterns in Prime Number Gaps\", font_size=32, color=WHITE)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a number line\n        number_line = NumberLine(\n            x_range=[0, 30, 1],\n            length=10,\n            include_numbers=True,\n            color=WHITE\n        )\n        number_line.to_edge(DOWN, buff=2)\n        self.play(Create(number_line))\n        \n        # Highlight prime numbers on the number line\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        prime_dots = VGroup()\n        \n        for prime in primes:\n            dot = Dot(number_line.number_to_point(prime), color=YELLOW)\n            prime_dots.add(dot)\n        \n        self.play(Create(prime_dots))\n        self.wait(1)\n        \n        # Show gaps between consecutive primes\n        gap_text = Text(\"Gaps between consecutive primes\", font_size=24, color=WHITE)\n        gap_text.next_to(title, DOWN, buff=1)\n        self.play(Write(gap_text))\n        \n        # Highlight gaps with arrows\n        gap_arrows = VGroup()\n        for i in range(len(primes) - 1):\n            start_point = number_line.number_to_point(primes[i])\n            end_point = number_line.number_to_point(primes[i+1])\n            arrow = Arrow(start_point, end_point, buff=0, color=RED)\n            gap_arrows.add(arrow)\n        \n        self.play(Create(gap_arrows))\n        self.wait(1)\n        \n        # Show the gap formula\n        formula = MathTex(r\"\\text{Prime Gap } = p_{n+1} - p_{n}\", color=WHITE)\n        formula.next_to(gap_text, DOWN, buff=1)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Create axes for the graph (prepare for transition)\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"include_numbers\": True, \"color\": WHITE},\n            x_length=8,\n            y_length=5\n        )\n        axes.center()\n        \n        # Clear for graph and show axes\n        self.play(\n            FadeOut(gap_text),\n            FadeOut(formula),\n            FadeOut(prime_dots),\n            FadeOut(gap_arrows),\n            FadeOut(number_line),\n            Create(axes)\n        )\n        \n        # Label the axes\n        x_label = Text(\"Prime Count\", font_size=20, color=WHITE)\n        x_label.next_to(axes.x_axis, DOWN)\n        y_label = Text(\"Gap Size\", font_size=20, color=WHITE)\n        y_label.next_to(axes.y_axis, LEFT)\n        \n        self.play(\n            Write(x_label),\n            Write(y_label)\n        )\n        \n        # Plot the gaps\n        gaps = [primes[i+1] - primes[i] for i in range(len(primes) - 1)]\n        dots = VGroup()\n        \n        for i, gap in enumerate(gaps):\n            dot = Dot(axes.c2p(i+1, gap), color=YELLOW)\n            dots.add(dot)\n        \n        self.play(Create(dots))\n        \n        # Connect the dots to form a line graph\n        line = VMobject()\n        line.set_points_as_corners([axes.c2p(i+1, gap) for i, gap in enumerate(gaps)])\n        line.set_color(YELLOW)\n        \n        self.play(Create(line))\n        self.wait(1)\n        \n        # Show limit equation\n        limit_eq = MathTex(r\"\\lim_{{n \\to \\infty}} \\frac{p_{n+1} - p_{n}}{\\log n} = 1\", color=WHITE)\n        limit_eq.next_to(title, DOWN, buff=1)\n        self.play(Write(limit_eq))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion_text = Text(\"In chaos, there is pattern and beauty\", font_size=24, color=WHITE)\n        conclusion_text.to_edge(DOWN, buff=1)\n        self.play(\n            FadeOut(limit_eq),\n            Write(conclusion_text)\n        )\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(stars),\n            FadeOut(title),\n            FadeOut(axes),\n            FadeOut(x_label),\n            FadeOut(y_label),\n            FadeOut(dots),\n            FadeOut(line),\n            FadeOut(conclusion_text)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What patterns emerge if we visualize the gaps between consecutive prime numbers?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what patterns emerge if we visualize the gaps between consecutive prime numbers?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n# Set background color to dark blue (space theme)\nconfig.background_color = \"#0A1128\"\n\nclass PrimeGapsScene(Scene):\n    def construct(self):\n        # Create a starry background effect\n        stars = VGroup()\n        for _ in range(50):\n            x = np.random.uniform(-7, 7)\n            y = np.random.uniform(-4, 4)\n            star = Dot(point=[x, y, 0], radius=0.02, color=WHITE)\n            stars.add(star)\n        \n        self.play(FadeIn(stars))\n        \n        # Title\n        title = Text(\"Unlocking Patterns in Prime Number Gaps\", font_size=32, color=WHITE)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n        \n        # Create a number line\n        number_line = NumberLine(\n            x_range=[0, 30, 1],\n            length=10,\n            include_numbers=True,\n            color=WHITE\n        )\n        number_line.to_edge(DOWN, buff=2)\n        self.play(Create(number_line))\n        \n        # Highlight prime numbers on the number line\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        prime_dots = VGroup()\n        \n        for prime in primes:\n            dot = Dot(number_line.number_to_point(prime), color=YELLOW)\n            prime_dots.add(dot)\n        \n        self.play(Create(prime_dots))\n        self.wait(1)\n        \n        # Show gaps between consecutive primes\n        gap_text = Text(\"Gaps between consecutive primes\", font_size=24, color=WHITE)\n        gap_text.next_to(title, DOWN, buff=1)\n        self.play(Write(gap_text))\n        \n        # Highlight gaps with arrows\n        gap_arrows = VGroup()\n        for i in range(len(primes) - 1):\n            start_point = number_line.number_to_point(primes[i])\n            end_point = number_line.number_to_point(primes[i+1])\n            arrow = Arrow(start_point, end_point, buff=0, color=RED)\n            gap_arrows.add(arrow)\n        \n        self.play(Create(gap_arrows))\n        self.wait(1)\n        \n        # Show the gap formula\n        formula = MathTex(r\"\\text{Prime Gap } = p_{n+1} - p_{n}\", color=WHITE)\n        formula.next_to(gap_text, DOWN, buff=1)\n        self.play(Write(formula))\n        self.wait(1)\n        \n        # Create axes for the graph (prepare for transition)\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[0, 6, 1],\n            axis_config={\"include_numbers\": True, \"color\": WHITE},\n            x_length=8,\n            y_length=5\n        )\n        axes.center()\n        \n        # Clear for graph and show axes\n        self.play(\n            FadeOut(gap_text),\n            FadeOut(formula),\n            FadeOut(prime_dots),\n            FadeOut(gap_arrows),\n            FadeOut(number_line),\n            Create(axes)\n        )\n        \n        # Label the axes\n        x_label = Text(\"Prime Count\", font_size=20, color=WHITE)\n        x_label.next_to(axes.x_axis, DOWN)\n        y_label = Text(\"Gap Size\", font_size=20, color=WHITE)\n        y_label.next_to(axes.y_axis, LEFT)\n        \n        self.play(\n            Write(x_label),\n            Write(y_label)\n        )\n        \n        # Plot the gaps\n        gaps = [primes[i+1] - primes[i] for i in range(len(primes) - 1)]\n        dots = VGroup()\n        \n        for i, gap in enumerate(gaps):\n            dot = Dot(axes.c2p(i+1, gap), color=YELLOW)\n            dots.add(dot)\n        \n        self.play(Create(dots))\n        \n        # Connect the dots to form a line graph\n        line = VMobject()\n        line.set_points_as_corners([axes.c2p(i+1, gap) for i, gap in enumerate(gaps)])\n        line.set_color(YELLOW)\n        \n        self.play(Create(line))\n        self.wait(1)\n        \n        # Show limit equation\n        limit_eq = MathTex(r\"\\lim_{{n \\to \\infty}} \\frac{p_{n+1} - p_{n}}{\\log n} = 1\", color=WHITE)\n        limit_eq.next_to(title, DOWN, buff=1)\n        self.play(Write(limit_eq))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion_text = Text(\"In chaos, there is pattern and beauty\", font_size=24, color=WHITE)\n        conclusion_text.to_edge(DOWN, buff=1)\n        self.play(\n            FadeOut(limit_eq),\n            Write(conclusion_text)\n        )\n        self.wait(2)\n        \n        # Final fade out\n        self.play(\n            FadeOut(stars),\n            FadeOut(title),\n            FadeOut(axes),\n            FadeOut(x_label),\n            FadeOut(y_label),\n            FadeOut(dots),\n            FadeOut(line),\n            FadeOut(conclusion_text)\n        )\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What patterns emerge if we visualize the gaps between consecutive prime numbers?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an animated video where a piece of text moves upwards and at the same time I want to see a circle move diagonally upwards to the right and then have the circle disappear from the screen. Can you help me make this animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the first order ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation for moving y term\n        move_y_explanation = Text(\"Rearrange terms\", font_size=24).to_edge(UP)\n        self.play(Write(move_y_explanation))\n        self.wait(2)\n\n        # Rearranged ODE step\n        rearranged_ode = MathTex(r\"y' = 3y\")\n        self.play(ReplacementTransform(ode, rearranged_ode))\n        self.wait(1)\n\n        # Explanation for integrating factor\n        integrating_factor_explanation = Text(\"Use an integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, integrating_factor_explanation))\n        self.wait(2)\n\n        # Integrating factor and transformed ODE\n        integrating_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        transformed_ode = MathTex(r\"\\frac{d}{dx}( ye^{3x} ) = 0\")\n        self.play(\n            ReplacementTransform(rearranged_ode, transformed_ode),\n            Write(integrating_factor)\n        )\n        self.wait(1)\n\n        # Explanation for general solution\n        general_solution_explanation = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, general_solution_explanation))\n        self.wait(2)\n\n        # Writing the general solution\n        general_solution = MathTex(r\"y = C e^{-3x}\")\n        self.play(Transform(transformed_ode, general_solution))\n        self.wait(1)\n        \n        # Conclusion statement\n        conclusion = Text(\"The function y(x) solves the ODE\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final general solution only\n        self.play(Write(general_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video where a piece of text moves upwards and at the same time I want to see a circle move diagonally upwards to the right and then have the circle disappear from the screen. Can you help me make this animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an animated video where a piece of text moves upwards and at the same time i want to see a circle move diagonally upwards to the right and then have the circle disappear from the screen. can you help me make this animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass FirstOrderODEExample(Scene):\n    def construct(self):\n        # Display the first order ODE\n        ode = MathTex(r\"y' - 3y = 0\")\n        self.play(Write(ode))\n        self.wait(1)\n\n        # Explanation for moving y term\n        move_y_explanation = Text(\"Rearrange terms\", font_size=24).to_edge(UP)\n        self.play(Write(move_y_explanation))\n        self.wait(2)\n\n        # Rearranged ODE step\n        rearranged_ode = MathTex(r\"y' = 3y\")\n        self.play(ReplacementTransform(ode, rearranged_ode))\n        self.wait(1)\n\n        # Explanation for integrating factor\n        integrating_factor_explanation = Text(\"Use an integrating factor\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, integrating_factor_explanation))\n        self.wait(2)\n\n        # Integrating factor and transformed ODE\n        integrating_factor = MathTex(r\"\\mu(x) = e^{3x}\")\n        transformed_ode = MathTex(r\"\\frac{d}{dx}( ye^{3x} ) = 0\")\n        self.play(\n            ReplacementTransform(rearranged_ode, transformed_ode),\n            Write(integrating_factor)\n        )\n        self.wait(1)\n\n        # Explanation for general solution\n        general_solution_explanation = Text(\"General solution of the ODE\", font_size=24).to_edge(UP)\n        self.play(Transform(move_y_explanation, general_solution_explanation))\n        self.wait(2)\n\n        # Writing the general solution\n        general_solution = MathTex(r\"y = C e^{-3x}\")\n        self.play(Transform(transformed_ode, general_solution))\n        self.wait(1)\n        \n        # Conclusion statement\n        conclusion = Text(\"The function y(x) solves the ODE\", font_size=24).to_edge(DOWN)\n        self.play(Write(conclusion))\n        self.wait(1)\n\n        # Clear the scene\n        self.clear()\n        self.wait(1)\n\n        # Show the final general solution only\n        self.play(Write(general_solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an animated video where a piece of text moves upwards and at the same time I want to see a circle move diagonally upwards to the right and then have the circle disappear from the screen. Can you help me make this animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: What is the geometric interpretation of Euler's criterion for quadratic residues?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QuadraticResiduesScene(Scene):\n    def construct(self):\n        # Color scheme\n        blue_color = \"#3070B3\"\n        gold_color = \"#FFD700\"\n        \n        # Title\n        title = Text(\"A Geometric Journey Through Quadratic Residues\", font_size=28, color=blue_color)\n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction to quadratic residues\n        eq1 = Text(\"x\u00b2 \u2261 a (mod p)\", font_size=28)\n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(eq1.animate.scale(0.8).to_corner(UL, buff=1))\n        \n        # Euler's criterion\n        eq2 = Text(\"a^((p-1)/2) \u2261 \u00b11 (mod p)\", font_size=28)\n        self.play(Write(eq2))\n        self.wait(1)\n        self.play(eq2.animate.scale(0.8).to_corner(UR, buff=1))\n        \n        # Geometric visualization - Circle for modular arithmetic\n        circle = Circle(radius=2, color=blue_color)\n        self.play(Create(circle))\n        \n        # Add points on the circle for values mod p\n        p = 7  # Using a small prime for clarity\n        dots = VGroup()\n        labels = VGroup()\n        \n        for i in range(p):\n            angle = i * (2 * PI / p)\n            point = circle.point_at_angle(angle)\n            dot = Dot(point, color=gold_color)\n            label = Text(str(i), font_size=20).next_to(dot, direction=point/2, buff=0.2)\n            \n            dots.add(dot)\n            labels.add(label)\n            \n        self.play(Create(dots), Write(labels))\n        self.wait(0.5)\n        \n        # Highlight quadratic residues for p=7\n        # Quadratic residues for p=7 are 1, 2, 4 (1\u00b2\u22611, 3\u00b2\u22612, 2\u00b2\u22614)\n        residue_indices = [1, 2, 4]\n        residue_dots = VGroup(*[dots[i] for i in residue_indices])\n        \n        self.play(residue_dots.animate.set_color(RED))\n        \n        # Text explaining quadratic residues\n        residue_text = Text(\"Quadratic Residues: 1, 2, 4\", font_size=24)\n        residue_text.to_edge(DOWN, buff=1)\n        self.play(Write(residue_text))\n        \n        # Connect the residues to form a triangle (geometric pattern)\n        lines = VGroup()\n        for i in range(len(residue_indices)):\n            line = Line(\n                dots[residue_indices[i]].get_center(),\n                dots[residue_indices[(i+1) % len(residue_indices)]].get_center(),\n                color=gold_color\n            )\n            lines.add(line)\n        \n        self.play(Create(lines))\n        self.wait(0.5)\n        \n        # Text explaining the geometric interpretation\n        geometry_text = Text(\"Geometric symmetry reveals Euler's criterion\", font_size=24)\n        geometry_text.next_to(residue_text, UP, buff=0.5)\n        \n        self.play(Write(geometry_text))\n        self.wait(1)\n        \n        # Final cleanup and conclusion\n        conclusion = Text(\"The harmony of number theory and geometry\", font_size=28, color=blue_color)\n        conclusion.move_to(ORIGIN)\n        \n        self.play(\n            FadeOut(eq1),\n            FadeOut(eq2),\n            FadeOut(residue_text),\n            FadeOut(geometry_text),\n            FadeOut(dots),\n            FadeOut(labels),\n            FadeOut(lines),\n            FadeOut(circle),\n            Write(conclusion)\n        )\n        self.wait(1)\n        \n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the geometric interpretation of Euler's criterion for quadratic residues?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: what is the geometric interpretation of euler's criterion for quadratic residues?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass QuadraticResiduesScene(Scene):\n    def construct(self):\n        # Color scheme\n        blue_color = \"#3070B3\"\n        gold_color = \"#FFD700\"\n        \n        # Title\n        title = Text(\"A Geometric Journey Through Quadratic Residues\", font_size=28, color=blue_color)\n        self.play(Write(title))\n        self.wait(0.5)\n        self.play(title.animate.scale(0.6).to_edge(UP))\n        \n        # Introduction to quadratic residues\n        eq1 = Text(\"x\u00b2 \u2261 a (mod p)\", font_size=28)\n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(eq1.animate.scale(0.8).to_corner(UL, buff=1))\n        \n        # Euler's criterion\n        eq2 = Text(\"a^((p-1)/2) \u2261 \u00b11 (mod p)\", font_size=28)\n        self.play(Write(eq2))\n        self.wait(1)\n        self.play(eq2.animate.scale(0.8).to_corner(UR, buff=1))\n        \n        # Geometric visualization - Circle for modular arithmetic\n        circle = Circle(radius=2, color=blue_color)\n        self.play(Create(circle))\n        \n        # Add points on the circle for values mod p\n        p = 7  # Using a small prime for clarity\n        dots = VGroup()\n        labels = VGroup()\n        \n        for i in range(p):\n            angle = i * (2 * PI / p)\n            point = circle.point_at_angle(angle)\n            dot = Dot(point, color=gold_color)\n            label = Text(str(i), font_size=20).next_to(dot, direction=point/2, buff=0.2)\n            \n            dots.add(dot)\n            labels.add(label)\n            \n        self.play(Create(dots), Write(labels))\n        self.wait(0.5)\n        \n        # Highlight quadratic residues for p=7\n        # Quadratic residues for p=7 are 1, 2, 4 (1\u00b2\u22611, 3\u00b2\u22612, 2\u00b2\u22614)\n        residue_indices = [1, 2, 4]\n        residue_dots = VGroup(*[dots[i] for i in residue_indices])\n        \n        self.play(residue_dots.animate.set_color(RED))\n        \n        # Text explaining quadratic residues\n        residue_text = Text(\"Quadratic Residues: 1, 2, 4\", font_size=24)\n        residue_text.to_edge(DOWN, buff=1)\n        self.play(Write(residue_text))\n        \n        # Connect the residues to form a triangle (geometric pattern)\n        lines = VGroup()\n        for i in range(len(residue_indices)):\n            line = Line(\n                dots[residue_indices[i]].get_center(),\n                dots[residue_indices[(i+1) % len(residue_indices)]].get_center(),\n                color=gold_color\n            )\n            lines.add(line)\n        \n        self.play(Create(lines))\n        self.wait(0.5)\n        \n        # Text explaining the geometric interpretation\n        geometry_text = Text(\"Geometric symmetry reveals Euler's criterion\", font_size=24)\n        geometry_text.next_to(residue_text, UP, buff=0.5)\n        \n        self.play(Write(geometry_text))\n        self.wait(1)\n        \n        # Final cleanup and conclusion\n        conclusion = Text(\"The harmony of number theory and geometry\", font_size=28, color=blue_color)\n        conclusion.move_to(ORIGIN)\n        \n        self.play(\n            FadeOut(eq1),\n            FadeOut(eq2),\n            FadeOut(residue_text),\n            FadeOut(geometry_text),\n            FadeOut(dots),\n            FadeOut(labels),\n            FadeOut(lines),\n            FadeOut(circle),\n            Write(conclusion)\n        )\n        self.wait(1)\n        \n        self.play(FadeOut(title), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: What is the geometric interpretation of Euler's criterion for quadratic residues?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an educational animation in Manim that illustrates the flow of electrons from the anode to the cathode and back in a battery setup? The animation should include clearly labeled anode and cathode terminals, and I'd like to visibly track an electron's path as it moves in a zigzag pattern between these two terminals, with the entire journey taking approximately 5 seconds and the motion being such that the electron travels to the cathode and then back to the anode. The electrodes must be vertically aligned and colored distinctly, and the electron should become visible when it starts at the anode."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the initial surface integral problem\n        problem = MathTex(r\"\\iint_{S} (x^2 + y^2 + z^2) dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization of S\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Surface parameterization\n        parameterization = MathTex(r\"S(\\theta, \\phi) = (\\sin(\\phi)\\cos(\\theta), \\sin(\\phi)\\sin(\\theta), \\cos(\\phi))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(2)\n\n        # Explanation for using the parameterization\n        explanation2 = Text(\"Substitute parameterization into integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integral with parameterization substituted\n        integral_param = MathTex(r\"\\int_0^{2\\pi}\\int_0^{\\pi} \\sin^3(\\phi) d\\phi d\\theta\")\n        self.play(ReplacementTransform(parameterization, integral_param))\n        self.wait(1)\n\n        # Explanation for integrating over theta\n        explanation3 = Text(\"Integrate with respect to \\(\\\\theta\\) first\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Integrate over theta\n        integral_theta = MathTex(r\"\\int_0^{\\pi} [\\theta \\sin^3(\\phi)]_0^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(integral_param, integral_theta))\n        self.wait(2)\n\n        # Explanation for final integration over phi\n        explanation4 = Text(\"Now integrate with respect to \\(\\\\phi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final integration over phi\n        final_solution = MathTex(r\"(2\\pi) \\int_0^{\\pi} \\sin^3(\\phi) d\\phi\")\n        self.play(ReplacementTransform(integral_theta, final_solution))\n        self.wait(2)\n\n        # Final evaluation of integral\n        solution = MathTex(r\"= (2\\pi) \\left[ -\\frac{\\cos(\\phi)\\sin^2(\\phi)}{3} - \\frac{2\\cos^3(\\phi)}{9} \\right]_0^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation in Manim that illustrates the flow of electrons from the anode to the cathode and back in a battery setup? The animation should include clearly labeled anode and cathode terminals, and I'd like to visibly track an electron's path as it moves in a zigzag pattern between these two terminals, with the entire journey taking approximately 5 seconds and the motion being such that the electron travels to the cathode and then back to the anode. The electrodes must be vertically aligned and colored distinctly, and the electron should become visible when it starts at the anode."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an educational animation in manim that illustrates the flow of electrons from the anode to the cathode and back in a battery setup? the animation should include clearly labeled anode and cathode terminals, and i'd like to visibly track an electron's path as it moves in a zigzag pattern between these two terminals, with the entire journey taking approximately 5 seconds and the motion being such that the electron travels to the cathode and then back to the anode. the electrodes must be vertically aligned and colored distinctly, and the electron should become visible when it starts at the anode."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SurfaceIntegralExample(Scene):\n    def construct(self):\n        # Display the initial surface integral problem\n        problem = MathTex(r\"\\iint_{S} (x^2 + y^2 + z^2) dS\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for parameterization of S\n        explanation1 = Text(\"Parameterize surface S\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Surface parameterization\n        parameterization = MathTex(r\"S(\\theta, \\phi) = (\\sin(\\phi)\\cos(\\theta), \\sin(\\phi)\\sin(\\theta), \\cos(\\phi))\")\n        self.play(ReplacementTransform(problem.copy(), parameterization))\n        self.wait(2)\n\n        # Explanation for using the parameterization\n        explanation2 = Text(\"Substitute parameterization into integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Integral with parameterization substituted\n        integral_param = MathTex(r\"\\int_0^{2\\pi}\\int_0^{\\pi} \\sin^3(\\phi) d\\phi d\\theta\")\n        self.play(ReplacementTransform(parameterization, integral_param))\n        self.wait(1)\n\n        # Explanation for integrating over theta\n        explanation3 = Text(\"Integrate with respect to \\(\\\\theta\\) first\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Integrate over theta\n        integral_theta = MathTex(r\"\\int_0^{\\pi} [\\theta \\sin^3(\\phi)]_0^{2\\pi} d\\phi\")\n        self.play(ReplacementTransform(integral_param, integral_theta))\n        self.wait(2)\n\n        # Explanation for final integration over phi\n        explanation4 = Text(\"Now integrate with respect to \\(\\\\phi\\)\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation4))\n        self.wait(2)\n\n        # Final integration over phi\n        final_solution = MathTex(r\"(2\\pi) \\int_0^{\\pi} \\sin^3(\\phi) d\\phi\")\n        self.play(ReplacementTransform(integral_theta, final_solution))\n        self.wait(2)\n\n        # Final evaluation of integral\n        solution = MathTex(r\"= (2\\pi) \\left[ -\\frac{\\cos(\\phi)\\sin^2(\\phi)}{3} - \\frac{2\\cos^3(\\phi)}{9} \\right]_0^{\\pi}\")\n        self.play(ReplacementTransform(final_solution, solution))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an educational animation in Manim that illustrates the flow of electrons from the anode to the cathode and back in a battery setup? The animation should include clearly labeled anode and cathode terminals, and I'd like to visibly track an electron's path as it moves in a zigzag pattern between these two terminals, with the entire journey taking approximately 5 seconds and the motion being such that the electron travels to the cathode and then back to the anode. The electrodes must be vertically aligned and colored distinctly, and the electron should become visible when it starts at the anode."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the dimension of the irreducible representation of the symmetric group relate to the standard Young tableau?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass YoungTableauxScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unlocking the Secrets of Young Tableaux\", color=BLUE)\n        subtitle = Text(\"A Combinatorial Journey\", color=BLUE).scale(0.8)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: Young Diagram\n        concept_title = Text(\"Young Diagram\", color=BLUE).to_edge(UP)\n        self.play(Write(concept_title))\n        \n        # Create a simple Young diagram (shape 3,2)\n        square_size = 0.8\n        young_diagram = VGroup()\n        \n        # First row (3 boxes)\n        for i in range(3):\n            square = Square(side_length=square_size).set_stroke(BLUE)\n            square.move_to([i*square_size - square_size, 0, 0])\n            young_diagram.add(square)\n        \n        # Second row (2 boxes)\n        for i in range(2):\n            square = Square(side_length=square_size).set_stroke(BLUE)\n            square.move_to([i*square_size - square_size, -square_size, 0])\n            young_diagram.add(square)\n        \n        young_diagram.move_to(ORIGIN)\n        self.play(Create(young_diagram))\n        self.wait(1)\n        \n        # Key Concept 2: Standard Young Tableau\n        tableau_title = Text(\"Standard Young Tableau\", color=BLUE).to_edge(UP)\n        self.play(Transform(concept_title, tableau_title))\n        \n        # Fill in with numbers to create a standard Young tableau\n        numbers = VGroup()\n        positions = [\n            [0, 0, 0],             # 1\n            [square_size, 0, 0],   # 2\n            [2*square_size, 0, 0], # 3\n            [0, -square_size, 0],  # 4\n            [square_size, -square_size, 0]  # 5\n        ]\n        \n        for i, pos in enumerate(positions):\n            number = Text(str(i+1), color=GREEN).scale(0.6)\n            number.move_to(pos)\n            numbers.add(number)\n            self.play(Write(number), run_time=0.3)\n        \n        self.wait(1)\n        \n        # Group the tableau and move it\n        tableau = VGroup(young_diagram, numbers)\n        self.play(tableau.animate.scale(0.8).to_edge(LEFT))\n        \n        # Key Concept 3: Hook-length\n        hook_title = Text(\"Hook-length Formula\", color=BLUE).to_edge(UP)\n        self.play(Transform(concept_title, hook_title))\n        \n        # Explain hook length for the first box\n        box = tableau[0][0].copy()\n        self.play(box.animate.set_fill(YELLOW, opacity=0.5))\n        \n        # Draw the hook\n        hook_right = Line(\n            box.get_center(),\n            [box.get_center()[0] + 2*square_size*0.8, box.get_center()[1], 0],\n            color=RED\n        )\n        hook_down = Line(\n            box.get_center(),\n            [box.get_center()[0], box.get_center()[1] - square_size*0.8, 0],\n            color=RED\n        )\n        \n        self.play(Create(hook_right), Create(hook_down))\n        \n        # Hook length explanation\n        hook_text = Text(\"Hook Length = 3\", color=RED).scale(0.8)\n        hook_text.next_to(tableau, RIGHT)\n        self.play(Write(hook_text))\n        \n        self.wait(1)\n        \n        # Key Insight: The formula\n        self.play(\n            FadeOut(hook_text), \n            FadeOut(hook_right), \n            FadeOut(hook_down), \n            FadeOut(box)\n        )\n        \n        formula_title = Text(\"Dimension Formula\", color=BLUE).to_edge(UP)\n        self.play(Transform(concept_title, formula_title))\n        \n        formula_text = Text(\"Number of standard tableaux = \", color=GREEN).scale(0.7)\n        formula = Text(\"n! / (product of hook lengths)\", color=GREEN).scale(0.7)\n        formula.next_to(formula_text, DOWN)\n        \n        formula_group = VGroup(formula_text, formula)\n        formula_group.next_to(tableau, RIGHT)\n        \n        self.play(Write(formula_text))\n        self.play(Write(formula))\n        \n        # Example calculation\n        calc = Text(\"For this tableau: 5! / (3\u00d72\u00d71\u00d71\u00d71) = 20\", color=GREEN).scale(0.7)\n        calc.next_to(formula_group, DOWN, buff=0.5)\n        self.play(Write(calc))\n        \n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(tableau),\n            FadeOut(concept_title),\n            FadeOut(formula_text),\n            FadeOut(formula),\n            FadeOut(calc)\n        )\n        \n        conclusion = Text(\"Young Tableaux connect\\ncombinatorics and representation theory\", color=BLUE)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the dimension of the irreducible representation of the symmetric group relate to the standard Young tableau?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the dimension of the irreducible representation of the symmetric group relate to the standard young tableau?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass YoungTableauxScene(Scene):\n    def construct(self):\n        # Introduction\n        title = Text(\"Unlocking the Secrets of Young Tableaux\", color=BLUE)\n        subtitle = Text(\"A Combinatorial Journey\", color=BLUE).scale(0.8)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title))\n        self.play(Write(subtitle))\n        self.wait(1)\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Key Concept 1: Young Diagram\n        concept_title = Text(\"Young Diagram\", color=BLUE).to_edge(UP)\n        self.play(Write(concept_title))\n        \n        # Create a simple Young diagram (shape 3,2)\n        square_size = 0.8\n        young_diagram = VGroup()\n        \n        # First row (3 boxes)\n        for i in range(3):\n            square = Square(side_length=square_size).set_stroke(BLUE)\n            square.move_to([i*square_size - square_size, 0, 0])\n            young_diagram.add(square)\n        \n        # Second row (2 boxes)\n        for i in range(2):\n            square = Square(side_length=square_size).set_stroke(BLUE)\n            square.move_to([i*square_size - square_size, -square_size, 0])\n            young_diagram.add(square)\n        \n        young_diagram.move_to(ORIGIN)\n        self.play(Create(young_diagram))\n        self.wait(1)\n        \n        # Key Concept 2: Standard Young Tableau\n        tableau_title = Text(\"Standard Young Tableau\", color=BLUE).to_edge(UP)\n        self.play(Transform(concept_title, tableau_title))\n        \n        # Fill in with numbers to create a standard Young tableau\n        numbers = VGroup()\n        positions = [\n            [0, 0, 0],             # 1\n            [square_size, 0, 0],   # 2\n            [2*square_size, 0, 0], # 3\n            [0, -square_size, 0],  # 4\n            [square_size, -square_size, 0]  # 5\n        ]\n        \n        for i, pos in enumerate(positions):\n            number = Text(str(i+1), color=GREEN).scale(0.6)\n            number.move_to(pos)\n            numbers.add(number)\n            self.play(Write(number), run_time=0.3)\n        \n        self.wait(1)\n        \n        # Group the tableau and move it\n        tableau = VGroup(young_diagram, numbers)\n        self.play(tableau.animate.scale(0.8).to_edge(LEFT))\n        \n        # Key Concept 3: Hook-length\n        hook_title = Text(\"Hook-length Formula\", color=BLUE).to_edge(UP)\n        self.play(Transform(concept_title, hook_title))\n        \n        # Explain hook length for the first box\n        box = tableau[0][0].copy()\n        self.play(box.animate.set_fill(YELLOW, opacity=0.5))\n        \n        # Draw the hook\n        hook_right = Line(\n            box.get_center(),\n            [box.get_center()[0] + 2*square_size*0.8, box.get_center()[1], 0],\n            color=RED\n        )\n        hook_down = Line(\n            box.get_center(),\n            [box.get_center()[0], box.get_center()[1] - square_size*0.8, 0],\n            color=RED\n        )\n        \n        self.play(Create(hook_right), Create(hook_down))\n        \n        # Hook length explanation\n        hook_text = Text(\"Hook Length = 3\", color=RED).scale(0.8)\n        hook_text.next_to(tableau, RIGHT)\n        self.play(Write(hook_text))\n        \n        self.wait(1)\n        \n        # Key Insight: The formula\n        self.play(\n            FadeOut(hook_text), \n            FadeOut(hook_right), \n            FadeOut(hook_down), \n            FadeOut(box)\n        )\n        \n        formula_title = Text(\"Dimension Formula\", color=BLUE).to_edge(UP)\n        self.play(Transform(concept_title, formula_title))\n        \n        formula_text = Text(\"Number of standard tableaux = \", color=GREEN).scale(0.7)\n        formula = Text(\"n! / (product of hook lengths)\", color=GREEN).scale(0.7)\n        formula.next_to(formula_text, DOWN)\n        \n        formula_group = VGroup(formula_text, formula)\n        formula_group.next_to(tableau, RIGHT)\n        \n        self.play(Write(formula_text))\n        self.play(Write(formula))\n        \n        # Example calculation\n        calc = Text(\"For this tableau: 5! / (3\u00d72\u00d71\u00d71\u00d71) = 20\", color=GREEN).scale(0.7)\n        calc.next_to(formula_group, DOWN, buff=0.5)\n        self.play(Write(calc))\n        \n        self.wait(2)\n        \n        # Conclusion\n        self.play(\n            FadeOut(tableau),\n            FadeOut(concept_title),\n            FadeOut(formula_text),\n            FadeOut(formula),\n            FadeOut(calc)\n        )\n        \n        conclusion = Text(\"Young Tableaux connect\\ncombinatorics and representation theory\", color=BLUE)\n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the dimension of the irreducible representation of the symmetric group relate to the standard Young tableau?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create an animated video explaining how to evaluate the double integral of the function x^2 over a circular region with radius 1, centered at the origin, by integrating first with respect to x and then with respect to y. The video should start by displaying the double integral in mathematical notation, followed by a step-by-step integration process. Each step should be clarified with a short text explanation that appears at the top, such as when to integrate with respect to x, then y, and finally how to evaluate the definite integral. The result should show the entire integral process in a way that's easy to follow for someone learning about double integrals in polar coordinates."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Defining the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Displaying the concept of angular frequency\n        angular_freq = Text(\"Angular Frequency: \" r\"\\(\\omega^2 = \\frac{k}{m}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(angular_freq))\n        self.wait(2)\n\n        # Relating to the differential equation\n        ang_freq_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(ReplacementTransform(diff_eq.copy(), ang_freq_eq))\n        self.wait(1)\n\n        # Displaying solution approach\n        solution_approach = Text(\"Assume a solution of the form\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, solution_approach))\n        self.wait(2)\n\n        # Assumed solution\n        assumed_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(ReplacementTransform(ang_freq_eq, assumed_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation_solution = Text(\"General solution of the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, explanation_solution))\n        self.wait(2)\n\n        # Clear the scene and display only the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(assumed_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Create an animated video explaining how to evaluate the double integral of the function x^2 over a circular region with radius 1, centered at the origin, by integrating first with respect to x and then with respect to y. The video should start by displaying the double integral in mathematical notation, followed by a step-by-step integration process. Each step should be clarified with a short text explanation that appears at the top, such as when to integrate with respect to x, then y, and finally how to evaluate the definite integral. The result should show the entire integral process in a way that's easy to follow for someone learning about double integrals in polar coordinates."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create an animated video explaining how to evaluate the double integral of the function x^2 over a circular region with radius 1, centered at the origin, by integrating first with respect to x and then with respect to y. the video should start by displaying the double integral in mathematical notation, followed by a step-by-step integration process. each step should be clarified with a short text explanation that appears at the top, such as when to integrate with respect to x, then y, and finally how to evaluate the definite integral. the result should show the entire integral process in a way that's easy to follow for someone learning about double integrals in polar coordinates."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HarmonicOscillatorScene(Scene):\n    def construct(self):\n        # Defining the differential equation\n        diff_eq = MathTex(r\"m\\frac{d^2x}{dt^2} + kx = 0\")\n        self.play(Write(diff_eq))\n        self.wait(1)\n\n        # Displaying the concept of angular frequency\n        angular_freq = Text(\"Angular Frequency: \" r\"\\(\\omega^2 = \\frac{k}{m}\\)\", font_size=24).to_edge(UP)\n        self.play(Write(angular_freq))\n        self.wait(2)\n\n        # Relating to the differential equation\n        ang_freq_eq = MathTex(r\"\\omega^2 = \\frac{k}{m}\")\n        self.play(ReplacementTransform(diff_eq.copy(), ang_freq_eq))\n        self.wait(1)\n\n        # Displaying solution approach\n        solution_approach = Text(\"Assume a solution of the form\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, solution_approach))\n        self.wait(2)\n\n        # Assumed solution\n        assumed_solution = MathTex(r\"x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\")\n        self.play(ReplacementTransform(ang_freq_eq, assumed_solution))\n        self.wait(1)\n\n        # Explanation for the general solution\n        explanation_solution = Text(\"General solution of the harmonic oscillator\", font_size=24).to_edge(UP)\n        self.play(Transform(angular_freq, explanation_solution))\n        self.wait(2)\n\n        # Clear the scene and display only the solution\n        self.clear()\n        self.wait(1)\n        self.play(Write(assumed_solution))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Create an animated video explaining how to evaluate the double integral of the function x^2 over a circular region with radius 1, centered at the origin, by integrating first with respect to x and then with respect to y. The video should start by displaying the double integral in mathematical notation, followed by a step-by-step integration process. Each step should be clarified with a short text explanation that appears at the top, such as when to integrate with respect to x, then y, and finally how to evaluate the definite integral. The result should show the entire integral process in a way that's easy to follow for someone learning about double integrals in polar coordinates."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation illustrating atomic interactions. I'm envisioning starting with a blank screen and then seeing electrons fade into view, arranged in a grid pattern. After that, one electron should transform into an oxygen atom at the center of the grid while the other electrons expand outward from the center. Following this, a grid of lithium ions should appear above the central oxygen and then fade in. Finally, I want the lithium ions to move in a complex, predetermined path around the oxygen. Can we make an animation like that, which also includes some pauses throughout to allow for explanations during a presentation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Define series problem\n        series_problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(2)\n\n        # Explanation for series convergence test\n        convergence_test = Text(\"Apply the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(convergence_test))\n        self.wait(2)\n\n        # Showing that p > 1\n        p_value = MathTex(r\"p = 2 > 1\")\n        self.play(Write(p_value))\n        self.wait(2)\n\n        # Explanation for result\n        result_explanation = Text(\"The series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(convergence_test, result_explanation))\n        self.wait(2)\n\n        # Write the final conclusion\n        final_conclusion = MathTex(r\"\\text{The series is convergent}\")\n        self.play(ReplacementTransform(series_problem, final_conclusion))\n        self.wait(3)\n\n        # Clean up the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation illustrating atomic interactions. I'm envisioning starting with a blank screen and then seeing electrons fade into view, arranged in a grid pattern. After that, one electron should transform into an oxygen atom at the center of the grid while the other electrons expand outward from the center. Following this, a grid of lithium ions should appear above the central oxygen and then fade in. Finally, I want the lithium ions to move in a complex, predetermined path around the oxygen. Can we make an animation like that, which also includes some pauses throughout to allow for explanations during a presentation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation illustrating atomic interactions. i'm envisioning starting with a blank screen and then seeing electrons fade into view, arranged in a grid pattern. after that, one electron should transform into an oxygen atom at the center of the grid while the other electrons expand outward from the center. following this, a grid of lithium ions should appear above the central oxygen and then fade in. finally, i want the lithium ions to move in a complex, predetermined path around the oxygen. can we make an animation like that, which also includes some pauses throughout to allow for explanations during a presentation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass SeriesConvergenceExample(Scene):\n    def construct(self):\n        # Define series problem\n        series_problem = MathTex(r\"\\sum_{n=1}^\\infty \\frac{1}{n^2}\")\n        self.play(Write(series_problem))\n        self.wait(2)\n\n        # Explanation for series convergence test\n        convergence_test = Text(\"Apply the p-test for convergence\", font_size=24).to_edge(UP)\n        self.play(Write(convergence_test))\n        self.wait(2)\n\n        # Showing that p > 1\n        p_value = MathTex(r\"p = 2 > 1\")\n        self.play(Write(p_value))\n        self.wait(2)\n\n        # Explanation for result\n        result_explanation = Text(\"The series converges\", font_size=24).to_edge(UP)\n        self.play(Transform(convergence_test, result_explanation))\n        self.wait(2)\n\n        # Write the final conclusion\n        final_conclusion = MathTex(r\"\\text{The series is convergent}\")\n        self.play(ReplacementTransform(series_problem, final_conclusion))\n        self.wait(3)\n\n        # Clean up the scene\n        self.clear()\n        self.wait(1)\n        self.play(Write(final_conclusion))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation illustrating atomic interactions. I'm envisioning starting with a blank screen and then seeing electrons fade into view, arranged in a grid pattern. After that, one electron should transform into an oxygen atom at the center of the grid while the other electrons expand outward from the center. Following this, a grid of lithium ions should appear above the central oxygen and then fade in. Finally, I want the lithium ions to move in a complex, predetermined path around the oxygen. Can we make an animation like that, which also includes some pauses throughout to allow for explanations during a presentation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_succession.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass TestSuccession(Scene):\n    def construct(self):\n        white_dot = Dot(color=WHITE)\n        white_dot.shift(UP)\n\n        red_dot = Dot(color=RED)\n\n        self.play(\n            Succession(\n                Create(white_dot),\n                white_dot.animate.shift(RIGHT),\n                Create(red_dot),\n                Wait(1),\n                Uncreate(red_dot),\n            )\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_succession.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_succession.py"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\n\nclass TestSuccession(Scene):\n    def construct(self):\n        white_dot = Dot(color=WHITE)\n        white_dot.shift(UP)\n\n        red_dot = Dot(color=RED)\n\n        self.play(\n            Succession(\n                Create(white_dot),\n                white_dot.animate.shift(RIGHT),\n                Create(red_dot),\n                Wait(1),\n                Uncreate(red_dot),\n            )\n        )\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_succession.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that shows me how to calculate the definite integral of a quadratic function, specifically the integral of x squared from 1 to 2, with a step-by-step explanation including the power rule of integration and how to evaluate the integral at the given bounds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Write\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here is more text\")\n            self.play(Write(some_text))\n            self.play(Transform(text,Text(\"Unwrite\").shift(UP*2.5)), run_time=0.5)\n            self.play(Unwrite(some_text))\n            self.remove(some_text)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that shows me how to calculate the definite integral of a quadratic function, specifically the integral of x squared from 1 to 2, with a step-by-step explanation including the power rule of integration and how to evaluate the integral at the given bounds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that shows me how to calculate the definite integral of a quadratic function, specifically the integral of x squared from 1 to 2, with a step-by-step explanation including the power rule of integration and how to evaluate the integral at the given bounds?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"Write\").shift(UP*2.5)), run_time=0.5)\n            some_text = Text(\"Here is more text\")\n            self.play(Write(some_text))\n            self.play(Transform(text,Text(\"Unwrite\").shift(UP*2.5)), run_time=0.5)\n            self.play(Unwrite(some_text))\n            self.remove(some_text)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that shows me how to calculate the definite integral of a quadratic function, specifically the integral of x squared from 1 to 2, with a step-by-step explanation including the power rule of integration and how to evaluate the integral at the given bounds?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: In what ways can pseudo-differential operators be used to solve elliptic boundary value problems, and how do they generalize classical solution techniques?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PseudoDifferentialOperators(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling Pseudo-Differential Operators\", font_size=30)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction - Boundary Value Problem\n        intro_text = Text(\"Boundary Value Problem\", font_size=30)\n        self.play(Write(intro_text))\n        self.wait(1)\n        \n        # Create a simple puzzle representation\n        puzzle = Square(side_length=2)\n        puzzle.set_stroke(WHITE)\n        \n        self.play(FadeOut(intro_text))\n        self.play(Create(puzzle))\n        \n        # Show elliptic equation\n        elliptic_eq = MathTex(r\"-\\Delta u + a u = f\")\n        elliptic_eq.next_to(puzzle, DOWN)\n        \n        self.play(Write(elliptic_eq))\n        self.wait(1)\n        self.play(FadeOut(puzzle), FadeOut(elliptic_eq))\n        \n        # Key Concept 1 - Fourier Transform\n        concept1_text = Text(\"Fourier Transform\", font_size=30)\n        self.play(Write(concept1_text))\n        self.wait(1)\n        self.play(FadeOut(concept1_text))\n        \n        # Simple sine wave\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 1, 0.5],\n            axis_config={\"include_tip\": False}\n        )\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        fourier_eq = MathTex(r\"\\int e^{ix\\xi}u(x) dx\")\n        fourier_eq.next_to(axes, DOWN)\n        \n        self.play(Create(axes), Create(sin_graph))\n        self.play(Write(fourier_eq))\n        self.wait(1)\n        \n        # Transform to complex wave\n        complex_wave = axes.plot(lambda x: 0.5*np.sin(2*x), color=GREEN)\n        self.play(Transform(sin_graph, complex_wave))\n        self.wait(1)\n        self.play(FadeOut(axes), FadeOut(sin_graph), FadeOut(fourier_eq))\n        \n        # Key Concept 2 - Treadmill/Operator\n        concept2_text = Text(\"Pseudo-Differential Operators\", font_size=30)\n        self.play(Write(concept2_text))\n        self.wait(1)\n        self.play(FadeOut(concept2_text))\n        \n        # Simple treadmill representation\n        treadmill = Rectangle(height=1, width=3, color=GRAY)\n        \n        # Create a sine wave on the treadmill\n        wave = ParametricFunction(\n            lambda t: np.array([t, 0.2*np.sin(2*t), 0]),\n            t_range=[-1.5, 1.5],\n            color=BLUE\n        )\n        wave.shift(UP*0.5)\n        \n        self.play(Create(treadmill))\n        self.play(Create(wave))\n        \n        # Move the wave\n        wave2 = wave.copy().shift(RIGHT*0.5)\n        self.play(Transform(wave, wave2))\n        self.wait(1)\n        self.play(FadeOut(treadmill), FadeOut(wave))\n        \n        # Key Concept 3 - Local to Global\n        concept3_text = Text(\"Local to Global Solutions\", font_size=30)\n        self.play(Write(concept3_text))\n        self.wait(1)\n        self.play(FadeOut(concept3_text))\n        \n        # Local view\n        local_view = Square(side_length=1, color=BLUE)\n        self.play(Create(local_view))\n        \n        # Highlight corner\n        corner_dot = Dot(color=YELLOW).move_to(local_view.get_corner(UR))\n        self.play(FadeIn(corner_dot))\n        self.wait(1)\n        \n        # Global view\n        global_view = Square(side_length=3, color=GREEN)\n        self.play(Transform(local_view, global_view), FadeOut(corner_dot))\n        self.wait(1)\n        self.play(FadeOut(local_view))\n        \n        # Key Insight - Bridge\n        insight_text = Text(\"Bridging Local and Global\", font_size=30)\n        self.play(Write(insight_text))\n        self.wait(1)\n        self.play(FadeOut(insight_text))\n        \n        # Bridge\n        line = Line(LEFT*3, RIGHT*3, color=GREEN)\n        arc = Arc(radius=1.5, start_angle=0, angle=PI, color=BLUE)\n        arc.shift(DOWN)\n        \n        self.play(Create(line))\n        self.play(Create(arc))\n        \n        # Symbol crossing bridge\n        symbol = MathTex(r\"\\nabla\").set_color(YELLOW)\n        symbol.next_to(arc, LEFT+UP)\n        self.play(FadeIn(symbol))\n        self.play(symbol.animate.next_to(arc, RIGHT+UP))\n        \n        self.wait(1)\n        self.play(FadeOut(line), FadeOut(arc), FadeOut(symbol))\n        \n        # Conclusion\n        conclusion = Text(\"The Power of Pseudo-Differential Operators\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can pseudo-differential operators be used to solve elliptic boundary value problems, and how do they generalize classical solution techniques?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: in what ways can pseudo-differential operators be used to solve elliptic boundary value problems, and how do they generalize classical solution techniques?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PseudoDifferentialOperators(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling Pseudo-Differential Operators\", font_size=30)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Introduction - Boundary Value Problem\n        intro_text = Text(\"Boundary Value Problem\", font_size=30)\n        self.play(Write(intro_text))\n        self.wait(1)\n        \n        # Create a simple puzzle representation\n        puzzle = Square(side_length=2)\n        puzzle.set_stroke(WHITE)\n        \n        self.play(FadeOut(intro_text))\n        self.play(Create(puzzle))\n        \n        # Show elliptic equation\n        elliptic_eq = MathTex(r\"-\\Delta u + a u = f\")\n        elliptic_eq.next_to(puzzle, DOWN)\n        \n        self.play(Write(elliptic_eq))\n        self.wait(1)\n        self.play(FadeOut(puzzle), FadeOut(elliptic_eq))\n        \n        # Key Concept 1 - Fourier Transform\n        concept1_text = Text(\"Fourier Transform\", font_size=30)\n        self.play(Write(concept1_text))\n        self.wait(1)\n        self.play(FadeOut(concept1_text))\n        \n        # Simple sine wave\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 1, 0.5],\n            axis_config={\"include_tip\": False}\n        )\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        fourier_eq = MathTex(r\"\\int e^{ix\\xi}u(x) dx\")\n        fourier_eq.next_to(axes, DOWN)\n        \n        self.play(Create(axes), Create(sin_graph))\n        self.play(Write(fourier_eq))\n        self.wait(1)\n        \n        # Transform to complex wave\n        complex_wave = axes.plot(lambda x: 0.5*np.sin(2*x), color=GREEN)\n        self.play(Transform(sin_graph, complex_wave))\n        self.wait(1)\n        self.play(FadeOut(axes), FadeOut(sin_graph), FadeOut(fourier_eq))\n        \n        # Key Concept 2 - Treadmill/Operator\n        concept2_text = Text(\"Pseudo-Differential Operators\", font_size=30)\n        self.play(Write(concept2_text))\n        self.wait(1)\n        self.play(FadeOut(concept2_text))\n        \n        # Simple treadmill representation\n        treadmill = Rectangle(height=1, width=3, color=GRAY)\n        \n        # Create a sine wave on the treadmill\n        wave = ParametricFunction(\n            lambda t: np.array([t, 0.2*np.sin(2*t), 0]),\n            t_range=[-1.5, 1.5],\n            color=BLUE\n        )\n        wave.shift(UP*0.5)\n        \n        self.play(Create(treadmill))\n        self.play(Create(wave))\n        \n        # Move the wave\n        wave2 = wave.copy().shift(RIGHT*0.5)\n        self.play(Transform(wave, wave2))\n        self.wait(1)\n        self.play(FadeOut(treadmill), FadeOut(wave))\n        \n        # Key Concept 3 - Local to Global\n        concept3_text = Text(\"Local to Global Solutions\", font_size=30)\n        self.play(Write(concept3_text))\n        self.wait(1)\n        self.play(FadeOut(concept3_text))\n        \n        # Local view\n        local_view = Square(side_length=1, color=BLUE)\n        self.play(Create(local_view))\n        \n        # Highlight corner\n        corner_dot = Dot(color=YELLOW).move_to(local_view.get_corner(UR))\n        self.play(FadeIn(corner_dot))\n        self.wait(1)\n        \n        # Global view\n        global_view = Square(side_length=3, color=GREEN)\n        self.play(Transform(local_view, global_view), FadeOut(corner_dot))\n        self.wait(1)\n        self.play(FadeOut(local_view))\n        \n        # Key Insight - Bridge\n        insight_text = Text(\"Bridging Local and Global\", font_size=30)\n        self.play(Write(insight_text))\n        self.wait(1)\n        self.play(FadeOut(insight_text))\n        \n        # Bridge\n        line = Line(LEFT*3, RIGHT*3, color=GREEN)\n        arc = Arc(radius=1.5, start_angle=0, angle=PI, color=BLUE)\n        arc.shift(DOWN)\n        \n        self.play(Create(line))\n        self.play(Create(arc))\n        \n        # Symbol crossing bridge\n        symbol = MathTex(r\"\\nabla\").set_color(YELLOW)\n        symbol.next_to(arc, LEFT+UP)\n        self.play(FadeIn(symbol))\n        self.play(symbol.animate.next_to(arc, RIGHT+UP))\n        \n        self.wait(1)\n        self.play(FadeOut(line), FadeOut(arc), FadeOut(symbol))\n        \n        # Conclusion\n        conclusion = Text(\"The Power of Pseudo-Differential Operators\", font_size=24)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: In what ways can pseudo-differential operators be used to solve elliptic boundary value problems, and how do they generalize classical solution techniques?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an educational animation that illustrates the convergence of a mathematical series using the p-test? The animation should display the series sum from n=1 to infinity of 1/n^2, then introduce the concept of the p-test for convergence with the condition p > 1. Afterwards, it should show that for our series p equals 2, which satisfies the p-test, leading to the conclusion that the series converges. Each step of this process should be accompanied by a visual text or mathematical notation on the screen, with pauses between each step for emphasis. The final conclusion should stand out clearly and the entire sequence should be clear and engaging for students learning about series convergence for the first time."}, {"from": "assistant", "value": "```python\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass EqualDivisions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividida em partes iguais\", color=BLACK)\n        title.scale(1.5)\n        title.shift(4 * UP)\n        title[0][10:].set_color(\"#a346eb\")\n        rect = Rectangle(color=LIGHT_RED_COLOR, height=3, width=4, fill_opacity=0.3)\n        rect_vdiv = Line(rect.get_top(), rect.get_bottom(), color=LIGHT_RED_COLOR)\n        rect_hdiv = Line(rect.get_left(), rect.get_right(), color=LIGHT_RED_COLOR)\n        circ = Circle(1.5, color=LIGHT_GREEN_COLOR, fill_opacity=0.3)\n        circ_div = Line(circ.get_top(), circ.get_bottom(), color=LIGHT_GREEN_COLOR)\n        rect_divisions = VGroup(\n            rect_vdiv.copy().shift(RIGHT),\n            rect_vdiv.copy(),\n            rect_vdiv.copy().shift(LEFT),\n            rect_hdiv.copy().shift(1/2 * UP),\n            rect_hdiv.copy().shift(- 1/2 * UP)\n        )\n        circ_divisions = VGroup(*[circ_div.copy().rotate(i * 45 * DEGREES) for i in range(8)])\n        circ_n_rect = VGroup(\n            VGroup(rect, rect_divisions), \n            VGroup(circ, circ_divisions)\n        )\n        circ_n_rect.arrange(DOWN, buff=1)\n\n        self.play(\n            Create(rect),\n            Create(circ),\n            run_time=1.5\n        )\n        self.play(Create(rect_divisions))\n        self.play(Create(circ_divisions), run_time=1.8)\n        self.play(circ_n_rect.animate.shift(DOWN), run_time=0.2)\n        self.play(Write(title), run_time=0.8)\n        self.wait(0.5)\n        self.play(\n            circ_n_rect.animate.shift(9 * LEFT), \n            title.animate.shift(9 * LEFT),\n            run_time=0.8\n        )\n        self.remove(circ_n_rect, title)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates the convergence of a mathematical series using the p-test? The animation should display the series sum from n=1 to infinity of 1/n^2, then introduce the concept of the p-test for convergence with the condition p > 1. Afterwards, it should show that for our series p equals 2, which satisfies the p-test, leading to the conclusion that the series converges. Each step of this process should be accompanied by a visual text or mathematical notation on the screen, with pauses between each step for emphasis. The final conclusion should stand out clearly and the entire sequence should be clear and engaging for students learning about series convergence for the first time."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an educational animation that illustrates the convergence of a mathematical series using the p-test? the animation should display the series sum from n=1 to infinity of 1/n^2, then introduce the concept of the p-test for convergence with the condition p > 1. afterwards, it should show that for our series p equals 2, which satisfies the p-test, leading to the conclusion that the series converges. each step of this process should be accompanied by a visual text or mathematical notation on the screen, with pauses between each step for emphasis. the final conclusion should stand out clearly and the entire sequence should be clear and engaging for students learning about series convergence for the first time."}, {"from": "assistant", "value": "```python\nBACKGROUND_COLOR = \"#faf4e1\"\nTEXT_COLOR = \"#434343\"\nLIGHT_RED_COLOR = \"#f55e61\"\nLIGHT_GREEN_COLOR = \"#5fcb50\"\nLIGHT_BLUE_COLOR = \"#408ef5\"\nLIGHT_ORANGE_COLOR = \"#e3883d\"\nLIGHT_PURPLE_COLOR = \"#a346eb\"\nAQUA_GREEN_COLOR = \"#0dc786\"\nGREEN_COLOR = \"#34a853\"\nDARK_RED_COLOR = \"#bf2626\"\nDARK_BLUE_COLOR = \"#3333FF\"\n\nfrom manim import *\n\nconfig.frame_size = 1080, 1920 \nconfig.frame_width = 9\nconfig.frame_height = 16\n\nclass EqualDivisions(Scene):\n    def construct(self):\n        self.camera.background_color = BACKGROUND_COLOR\n\n        title = Tex(\"Dividida em partes iguais\", color=BLACK)\n        title.scale(1.5)\n        title.shift(4 * UP)\n        title[0][10:].set_color(\"#a346eb\")\n        rect = Rectangle(color=LIGHT_RED_COLOR, height=3, width=4, fill_opacity=0.3)\n        rect_vdiv = Line(rect.get_top(), rect.get_bottom(), color=LIGHT_RED_COLOR)\n        rect_hdiv = Line(rect.get_left(), rect.get_right(), color=LIGHT_RED_COLOR)\n        circ = Circle(1.5, color=LIGHT_GREEN_COLOR, fill_opacity=0.3)\n        circ_div = Line(circ.get_top(), circ.get_bottom(), color=LIGHT_GREEN_COLOR)\n        rect_divisions = VGroup(\n            rect_vdiv.copy().shift(RIGHT),\n            rect_vdiv.copy(),\n            rect_vdiv.copy().shift(LEFT),\n            rect_hdiv.copy().shift(1/2 * UP),\n            rect_hdiv.copy().shift(- 1/2 * UP)\n        )\n        circ_divisions = VGroup(*[circ_div.copy().rotate(i * 45 * DEGREES) for i in range(8)])\n        circ_n_rect = VGroup(\n            VGroup(rect, rect_divisions), \n            VGroup(circ, circ_divisions)\n        )\n        circ_n_rect.arrange(DOWN, buff=1)\n\n        self.play(\n            Create(rect),\n            Create(circ),\n            run_time=1.5\n        )\n        self.play(Create(rect_divisions))\n        self.play(Create(circ_divisions), run_time=1.8)\n        self.play(circ_n_rect.animate.shift(DOWN), run_time=0.2)\n        self.play(Write(title), run_time=0.8)\n        self.wait(0.5)\n        self.play(\n            circ_n_rect.animate.shift(9 * LEFT), \n            title.animate.shift(9 * LEFT),\n            run_time=0.8\n        )\n        self.remove(circ_n_rect, title)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an educational animation that illustrates the convergence of a mathematical series using the p-test? The animation should display the series sum from n=1 to infinity of 1/n^2, then introduce the concept of the p-test for convergence with the condition p > 1. Afterwards, it should show that for our series p equals 2, which satisfies the p-test, leading to the conclusion that the series converges. Each step of this process should be accompanied by a visual text or mathematical notation on the screen, with pauses between each step for emphasis. The final conclusion should stand out clearly and the entire sequence should be clear and engaging for students learning about series convergence for the first time."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How does the geometry of a complete orthonormal set in L\u00b2 spaces visually compare to that in finite dimensions, and what challenges arise in visualization?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HilbertSpaceGeometry(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Hidden Geometry of Hilbert Spaces\", color=BLUE).scale(0.7)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Simplified grid for vastness\n        grid = VGroup()\n        # Horizontal lines\n        for y in range(-5, 6):\n            line = Line(LEFT*5, RIGHT*5, color=BLUE_E).set_opacity(0.3)\n            line.move_to([0, y, 0])\n            grid.add(line)\n        # Vertical lines\n        for x in range(-5, 6):\n            line = Line(DOWN*5, UP*5, color=BLUE_E).set_opacity(0.3)\n            line.move_to([x, 0, 0])\n            grid.add(line)\n        \n        self.play(Create(grid), run_time=2)\n        \n        # Text for finite dimensions\n        finite_text = Text(\"In finite dimensions:\", color=BLUE).scale(0.6)\n        finite_text.to_edge(UP)\n        self.play(Write(finite_text))\n        \n        # Finite dimensional basis - simplified to 3D\n        x_axis = Arrow(start=ORIGIN, end=RIGHT*2, color=RED)\n        y_axis = Arrow(start=ORIGIN, end=UP*2, color=GREEN)\n        z_axis = Arrow(start=ORIGIN, end=LEFT+UP, color=BLUE)  # Simplified 3D effect\n        \n        axes_group = VGroup(x_axis, y_axis, z_axis)\n        axes_label = Text(\"Simple orthonormal basis\", color=WHITE).scale(0.5)\n        axes_label.next_to(axes_group, DOWN)\n        \n        self.play(Create(axes_group), Write(axes_label))\n        self.wait(1)\n        \n        # Clear for next section\n        self.play(FadeOut(finite_text), FadeOut(axes_group), FadeOut(axes_label))\n        \n        # Text for Hilbert spaces\n        hilbert_text = Text(\"In Hilbert Spaces:\", color=BLUE).scale(0.6)\n        hilbert_text.to_edge(UP)\n        self.play(Write(hilbert_text))\n        \n        # Orthonormal vectors in Hilbert spaces\n        vectors = VGroup()\n        for i in range(8):\n            angle = i * PI / 4\n            vector = Arrow(\n                start=ORIGIN,\n                end=[np.cos(angle), np.sin(angle), 0],\n                color=YELLOW\n            )\n            vectors.add(vector)\n        \n        vectors_label = Text(\"Infinite orthonormal set\", color=WHITE).scale(0.5)\n        vectors_label.next_to(vectors, DOWN)\n        \n        self.play(Create(vectors), Write(vectors_label))\n        self.wait(1)\n        \n        # Orthonormality equation\n        eq = MathTex(r\"\\langle u, v \\rangle = \\delta_{uv}\").scale(0.7)\n        eq.move_to(DOWN*2)\n        \n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Clear for lattice visualization\n        self.play(FadeOut(vectors), FadeOut(vectors_label), FadeOut(eq), FadeOut(hilbert_text))\n        \n        # Simplified lattice visualization\n        challenge_text = Text(\"Visualization challenge:\", color=BLUE).scale(0.6)\n        challenge_text.to_edge(UP)\n        self.play(Write(challenge_text))\n        \n        # Create a 5x5 grid of dots to represent the lattice\n        dot_grid = VGroup()\n        for x in range(-2, 3):\n            for y in range(-2, 3):\n                # Using small circles instead of dots for better visibility\n                dot = Circle(radius=0.1, color=BLUE, fill_opacity=1).move_to([x, y, 0])\n                dot_grid.add(dot)\n        \n        lattice_label = Text(\"Infinite dimensions in a finite space\", color=WHITE).scale(0.5)\n        lattice_label.next_to(dot_grid, DOWN)\n        \n        self.play(Create(dot_grid), Write(lattice_label))\n        self.wait(1)\n        \n        # Completeness equation\n        eq2 = MathTex(r\"\\sum_{i=1}^{\\infty}\\|e_i\\|^2 = 1\").scale(0.7)\n        eq2.move_to(DOWN*2)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(challenge_text), FadeOut(dot_grid), FadeOut(lattice_label), \n                  FadeOut(eq2), FadeOut(grid))\n        \n        conclusion = Text(\"Understanding the geometry of infinite dimensions\", color=BLUE).scale(0.7)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the geometry of a complete orthonormal set in L\u00b2 spaces visually compare to that in finite dimensions, and what challenges arise in visualization?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how does the geometry of a complete orthonormal set in l\u00b2 spaces visually compare to that in finite dimensions, and what challenges arise in visualization?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass HilbertSpaceGeometry(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Unveiling the Hidden Geometry of Hilbert Spaces\", color=BLUE).scale(0.7)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(FadeOut(title))\n        \n        # Simplified grid for vastness\n        grid = VGroup()\n        # Horizontal lines\n        for y in range(-5, 6):\n            line = Line(LEFT*5, RIGHT*5, color=BLUE_E).set_opacity(0.3)\n            line.move_to([0, y, 0])\n            grid.add(line)\n        # Vertical lines\n        for x in range(-5, 6):\n            line = Line(DOWN*5, UP*5, color=BLUE_E).set_opacity(0.3)\n            line.move_to([x, 0, 0])\n            grid.add(line)\n        \n        self.play(Create(grid), run_time=2)\n        \n        # Text for finite dimensions\n        finite_text = Text(\"In finite dimensions:\", color=BLUE).scale(0.6)\n        finite_text.to_edge(UP)\n        self.play(Write(finite_text))\n        \n        # Finite dimensional basis - simplified to 3D\n        x_axis = Arrow(start=ORIGIN, end=RIGHT*2, color=RED)\n        y_axis = Arrow(start=ORIGIN, end=UP*2, color=GREEN)\n        z_axis = Arrow(start=ORIGIN, end=LEFT+UP, color=BLUE)  # Simplified 3D effect\n        \n        axes_group = VGroup(x_axis, y_axis, z_axis)\n        axes_label = Text(\"Simple orthonormal basis\", color=WHITE).scale(0.5)\n        axes_label.next_to(axes_group, DOWN)\n        \n        self.play(Create(axes_group), Write(axes_label))\n        self.wait(1)\n        \n        # Clear for next section\n        self.play(FadeOut(finite_text), FadeOut(axes_group), FadeOut(axes_label))\n        \n        # Text for Hilbert spaces\n        hilbert_text = Text(\"In Hilbert Spaces:\", color=BLUE).scale(0.6)\n        hilbert_text.to_edge(UP)\n        self.play(Write(hilbert_text))\n        \n        # Orthonormal vectors in Hilbert spaces\n        vectors = VGroup()\n        for i in range(8):\n            angle = i * PI / 4\n            vector = Arrow(\n                start=ORIGIN,\n                end=[np.cos(angle), np.sin(angle), 0],\n                color=YELLOW\n            )\n            vectors.add(vector)\n        \n        vectors_label = Text(\"Infinite orthonormal set\", color=WHITE).scale(0.5)\n        vectors_label.next_to(vectors, DOWN)\n        \n        self.play(Create(vectors), Write(vectors_label))\n        self.wait(1)\n        \n        # Orthonormality equation\n        eq = MathTex(r\"\\langle u, v \\rangle = \\delta_{uv}\").scale(0.7)\n        eq.move_to(DOWN*2)\n        \n        self.play(Write(eq))\n        self.wait(1)\n        \n        # Clear for lattice visualization\n        self.play(FadeOut(vectors), FadeOut(vectors_label), FadeOut(eq), FadeOut(hilbert_text))\n        \n        # Simplified lattice visualization\n        challenge_text = Text(\"Visualization challenge:\", color=BLUE).scale(0.6)\n        challenge_text.to_edge(UP)\n        self.play(Write(challenge_text))\n        \n        # Create a 5x5 grid of dots to represent the lattice\n        dot_grid = VGroup()\n        for x in range(-2, 3):\n            for y in range(-2, 3):\n                # Using small circles instead of dots for better visibility\n                dot = Circle(radius=0.1, color=BLUE, fill_opacity=1).move_to([x, y, 0])\n                dot_grid.add(dot)\n        \n        lattice_label = Text(\"Infinite dimensions in a finite space\", color=WHITE).scale(0.5)\n        lattice_label.next_to(dot_grid, DOWN)\n        \n        self.play(Create(dot_grid), Write(lattice_label))\n        self.wait(1)\n        \n        # Completeness equation\n        eq2 = MathTex(r\"\\sum_{i=1}^{\\infty}\\|e_i\\|^2 = 1\").scale(0.7)\n        eq2.move_to(DOWN*2)\n        \n        self.play(Write(eq2))\n        self.wait(1)\n        \n        # Conclusion\n        self.play(FadeOut(challenge_text), FadeOut(dot_grid), FadeOut(lattice_label), \n                  FadeOut(eq2), FadeOut(grid))\n        \n        conclusion = Text(\"Understanding the geometry of infinite dimensions\", color=BLUE).scale(0.7)\n        self.play(Write(conclusion))\n        self.wait(2)\n        self.play(FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How does the geometry of a complete orthonormal set in L\u00b2 spaces visually compare to that in finite dimensions, and what challenges arise in visualization?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a coordinate grid with axes visible. A linear transformation is applied using the matrix \\(\\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix}\\), which shears the grid horizontally. Ghost vectors are left behind to show the original positions before the transformation, helping visualize the effect of the matrix on the space."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LinearTransformationSceneExample(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a coordinate grid with axes visible. A linear transformation is applied using the matrix \\(\\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix}\\), which shears the grid horizontally. Ghost vectors are left behind to show the original positions before the transformation, helping visualize the effect of the matrix on the space."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a coordinate grid with axes visible. a linear transformation is applied using the matrix \\(\\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix}\\), which shears the grid horizontally. ghost vectors are left behind to show the original positions before the transformation, helping visualize the effect of the matrix on the space."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass LinearTransformationSceneExample(LinearTransformationScene):\n    def __init__(self, **kwargs):\n        LinearTransformationScene.__init__(\n            self,\n            show_coordinates=True,\n            leave_ghost_vectors=True,\n            **kwargs\n        )\n\n    def construct(self):\n        matrix = [[1, 1], [0, 1]]\n        self.apply_matrix(matrix)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a coordinate grid with axes visible. A linear transformation is applied using the matrix \\(\\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\end{bmatrix}\\), which shears the grid horizontally. Ghost vectors are left behind to show the original positions before the transformation, helping visualize the effect of the matrix on the space."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: If you randomly place 13 socks into 5 drawers, what is the minimum number of socks in one drawer to ensure at least two of the socks have a matching color?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PigeonholePrinciple(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Sock Drawer Conundrum\", font_size=36)\n        subtitle = Text(\"Understanding the Pigeonhole Principle\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title), Write(subtitle))\n        self.wait(1)\n        \n        # Clear the screen for main content\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create 5 drawers\n        drawers = VGroup()\n        for i in range(5):\n            drawer = Rectangle(height=1, width=1.2)\n            drawer.set_stroke(WHITE)\n            drawer.set_fill(DARK_GRAY, opacity=0.5)\n            \n            # Add drawer number\n            num = Text(str(i+1), font_size=24)\n            num.move_to(drawer)\n            \n            drawer_group = VGroup(drawer, num)\n            drawers.add(drawer_group)\n        \n        drawers.arrange(RIGHT, buff=0.5)\n        \n        self.play(Create(drawers))\n        self.wait(0.5)\n        \n        # Explanation text\n        explanation = Text(\"We have 13 socks and 5 drawers\", font_size=28)\n        explanation.to_edge(UP, buff=1)\n        \n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Create and show first 5 socks\n        colors = [RED, GREEN, BLUE, YELLOW, PURPLE]\n        first_socks = VGroup()\n        \n        for i in range(5):\n            sock = Circle(radius=0.2)\n            sock.set_stroke(WHITE)\n            sock.set_fill(colors[i], opacity=0.8)\n            sock.move_to(drawers[i].get_center())\n            first_socks.add(sock)\n        \n        self.play(FadeIn(first_socks))\n        self.wait(0.5)\n        \n        # Update explanation\n        new_explanation = Text(\"One sock in each drawer...\", font_size=28)\n        new_explanation.to_edge(UP, buff=1)\n        \n        self.play(Transform(explanation, new_explanation))\n        self.wait(1)\n        \n        # Show remaining 8 socks\n        more_colors = [ORANGE, PINK, TEAL, MAROON, GOLD, \"#8B4513\", GRAY, LIGHT_GRAY]\n        more_socks = VGroup()\n        \n        for i in range(8):\n            sock = Circle(radius=0.2)\n            sock.set_stroke(WHITE)\n            sock.set_fill(more_colors[i], opacity=0.8)\n            sock.move_to(UP * 2 + RIGHT * (i-3.5))\n            more_socks.add(sock)\n        \n        self.play(FadeIn(more_socks))\n        \n        # Update explanation again\n        final_explanation = Text(\"But we still have 8 more socks!\", font_size=28)\n        final_explanation.to_edge(UP, buff=1)\n        \n        self.play(Transform(explanation, final_explanation))\n        self.wait(1)\n        \n        # Show pigeonhole principle\n        self.play(FadeOut(explanation), FadeOut(more_socks))\n        \n        principle = Text(\"By the Pigeonhole Principle:\", font_size=32)\n        principle.to_edge(UP, buff=1)\n        \n        self.play(Write(principle))\n        self.wait(0.5)\n        \n        # Show equation\n        equation = MathTex(r\"\\left\\lceil \\frac{13}{5} \\right\\rceil = 3\")\n        equation.next_to(principle, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Show conclusion\n        conclusion = Text(\"At least one drawer must contain at least 3 socks!\", font_size=28)\n        conclusion.next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: If you randomly place 13 socks into 5 drawers, what is the minimum number of socks in one drawer to ensure at least two of the socks have a matching color?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: if you randomly place 13 socks into 5 drawers, what is the minimum number of socks in one drawer to ensure at least two of the socks have a matching color?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass PigeonholePrinciple(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"The Sock Drawer Conundrum\", font_size=36)\n        subtitle = Text(\"Understanding the Pigeonhole Principle\", font_size=24)\n        subtitle.next_to(title, DOWN)\n        \n        self.play(Write(title), Write(subtitle))\n        self.wait(1)\n        \n        # Clear the screen for main content\n        self.play(FadeOut(title), FadeOut(subtitle))\n        \n        # Create 5 drawers\n        drawers = VGroup()\n        for i in range(5):\n            drawer = Rectangle(height=1, width=1.2)\n            drawer.set_stroke(WHITE)\n            drawer.set_fill(DARK_GRAY, opacity=0.5)\n            \n            # Add drawer number\n            num = Text(str(i+1), font_size=24)\n            num.move_to(drawer)\n            \n            drawer_group = VGroup(drawer, num)\n            drawers.add(drawer_group)\n        \n        drawers.arrange(RIGHT, buff=0.5)\n        \n        self.play(Create(drawers))\n        self.wait(0.5)\n        \n        # Explanation text\n        explanation = Text(\"We have 13 socks and 5 drawers\", font_size=28)\n        explanation.to_edge(UP, buff=1)\n        \n        self.play(Write(explanation))\n        self.wait(1)\n        \n        # Create and show first 5 socks\n        colors = [RED, GREEN, BLUE, YELLOW, PURPLE]\n        first_socks = VGroup()\n        \n        for i in range(5):\n            sock = Circle(radius=0.2)\n            sock.set_stroke(WHITE)\n            sock.set_fill(colors[i], opacity=0.8)\n            sock.move_to(drawers[i].get_center())\n            first_socks.add(sock)\n        \n        self.play(FadeIn(first_socks))\n        self.wait(0.5)\n        \n        # Update explanation\n        new_explanation = Text(\"One sock in each drawer...\", font_size=28)\n        new_explanation.to_edge(UP, buff=1)\n        \n        self.play(Transform(explanation, new_explanation))\n        self.wait(1)\n        \n        # Show remaining 8 socks\n        more_colors = [ORANGE, PINK, TEAL, MAROON, GOLD, \"#8B4513\", GRAY, LIGHT_GRAY]\n        more_socks = VGroup()\n        \n        for i in range(8):\n            sock = Circle(radius=0.2)\n            sock.set_stroke(WHITE)\n            sock.set_fill(more_colors[i], opacity=0.8)\n            sock.move_to(UP * 2 + RIGHT * (i-3.5))\n            more_socks.add(sock)\n        \n        self.play(FadeIn(more_socks))\n        \n        # Update explanation again\n        final_explanation = Text(\"But we still have 8 more socks!\", font_size=28)\n        final_explanation.to_edge(UP, buff=1)\n        \n        self.play(Transform(explanation, final_explanation))\n        self.wait(1)\n        \n        # Show pigeonhole principle\n        self.play(FadeOut(explanation), FadeOut(more_socks))\n        \n        principle = Text(\"By the Pigeonhole Principle:\", font_size=32)\n        principle.to_edge(UP, buff=1)\n        \n        self.play(Write(principle))\n        self.wait(0.5)\n        \n        # Show equation\n        equation = MathTex(r\"\\left\\lceil \\frac{13}{5} \\right\\rceil = 3\")\n        equation.next_to(principle, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.wait(1)\n        \n        # Show conclusion\n        conclusion = Text(\"At least one drawer must contain at least 3 socks!\", font_size=28)\n        conclusion.next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(conclusion))\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: If you randomly place 13 socks into 5 drawers, what is the minimum number of socks in one drawer to ensure at least two of the socks have a matching color?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that visually demonstrates the process of calculating a triple integral. The triple integral should be set up to integrate over x from 0 to 1, y from -1 to 1, and z from 0 to 2 of the function xyz. The animation should show the step-by-step integration in the following order: first with respect to z, then y, and finally x. After each integration step, I want a text explanation stating which variable we are integrating with respect to next. At the end of the animation, present the final numerical solution of the triple integral. Can you do this?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2} \\rho^3 \\sin\\varphi d\\rho d\\varphi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{\\rho^4}{4}]_{0}^{2} \\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplify the inner integral\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} 4\\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [-4\\cos\\varphi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -4(\\cos(\\pi) - \\cos(0))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= -4(-1 - 1)\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(simplified_solution, final_answer))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually demonstrates the process of calculating a triple integral. The triple integral should be set up to integrate over x from 0 to 1, y from -1 to 1, and z from 0 to 2 of the function xyz. The animation should show the step-by-step integration in the following order: first with respect to z, then y, and finally x. After each integration step, I want a text explanation stating which variable we are integrating with respect to next. At the end of the animation, present the final numerical solution of the triple integral. Can you do this?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that visually demonstrates the process of calculating a triple integral. the triple integral should be set up to integrate over x from 0 to 1, y from -1 to 1, and z from 0 to 2 of the function xyz. the animation should show the step-by-step integration in the following order: first with respect to z, then y, and finally x. after each integration step, i want a text explanation stating which variable we are integrating with respect to next. at the end of the animation, present the final numerical solution of the triple integral. can you do this?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass DoubleIntegralPolarExample(Scene):\n    def construct(self):\n        # Display the integral problem\n        problem = MathTex(r\"\\int_{0}^{\\pi} \\int_{0}^{2} \\rho^3 \\sin\\varphi d\\rho d\\varphi\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation for the inner integral\n        explanation1 = Text(\"Integrate with respect to rho first\", font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Inner integral step\n        inner_integral = MathTex(r\"= \\int_{0}^{\\pi} [\\frac{\\rho^4}{4}]_{0}^{2} \\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(problem.copy(), inner_integral))\n        self.wait(1)\n\n        # Simplify the inner integral\n        simplified_inner = MathTex(r\"= \\int_{0}^{\\pi} 4\\sin\\varphi d\\varphi\")\n        self.play(ReplacementTransform(inner_integral, simplified_inner))\n        self.wait(1)\n\n        # Explanation for the outer integral\n        explanation2 = Text(\"Now integrate with respect to phi\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation2))\n        self.wait(2)\n\n        # Final integral step\n        final_integral = MathTex(r\"= [-4\\cos\\varphi]_{0}^{\\pi}\")\n        self.play(ReplacementTransform(simplified_inner, final_integral))\n        self.wait(1)\n\n        # Explanation for the final result\n        explanation3 = Text(\"Evaluate the definite integral\", font_size=24).to_edge(UP)\n        self.play(Transform(explanation1, explanation3))\n        self.wait(2)\n\n        # Final solution\n        final_solution = MathTex(r\"= -4(\\cos(\\pi) - \\cos(0))\")\n        self.play(ReplacementTransform(final_integral, final_solution))\n        self.wait(1)\n\n        # Simplifying the final solution\n        simplified_solution = MathTex(r\"= -4(-1 - 1)\")\n        self.play(ReplacementTransform(final_solution, simplified_solution))\n        self.wait(1)\n\n        # Display final answer\n        final_answer = MathTex(r\"= 8\")\n        self.play(ReplacementTransform(simplified_solution, final_answer))\n        self.wait(2)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that visually demonstrates the process of calculating a triple integral. The triple integral should be set up to integrate over x from 0 to 1, y from -1 to 1, and z from 0 to 2 of the function xyz. The animation should show the step-by-step integration in the following order: first with respect to z, then y, and finally x. After each integration step, I want a text explanation stating which variable we are integrating with respect to next. At the end of the animation, present the final numerical solution of the triple integral. Can you do this?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a square centered on the screen. Animate the square moving upward over a duration of three seconds. Then pause for one second."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RunTime(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n        self.play(square.animate.shift(UP), run_time=3)\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a square centered on the screen. Animate the square moving upward over a duration of three seconds. Then pause for one second."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a square centered on the screen. animate the square moving upward over a duration of three seconds. then pause for one second."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RunTime(Scene):\n    def construct(self):\n        square = Square()\n        self.add(square)\n        self.play(square.animate.shift(UP), run_time=3)\n        self.wait(1)\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a square centered on the screen. Animate the square moving upward over a duration of three seconds. Then pause for one second."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Could you create an animation where a red dot starts on the left of the screen and a pointer is continuously pointing to it from the left as it moves horizontally to the right at a constant speed? Additionally, can you make all the objects in the scene gradually change in size depending on how far they are from the center of the screen? The closer they are to the center, the larger they should be, and the farther away, the smaller. Please make sure this scaling effect happens in real-time as the dot moves. Let the animation last for 5 seconds."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_height\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_height(3))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation where a red dot starts on the left of the screen and a pointer is continuously pointing to it from the left as it moves horizontally to the right at a constant speed? Additionally, can you make all the objects in the scene gradually change in size depending on how far they are from the center of the screen? The closer they are to the center, the larger they should be, and the farther away, the smaller. Please make sure this scaling effect happens in real-time as the dot moves. Let the animation last for 5 seconds."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that could you create an animation where a red dot starts on the left of the screen and a pointer is continuously pointing to it from the left as it moves horizontally to the right at a constant speed? additionally, can you make all the objects in the scene gradually change in size depending on how far they are from the center of the screen? the closer they are to the center, the larger they should be, and the farther away, the smaller. please make sure this scaling effect happens in real-time as the dot moves. let the animation last for 5 seconds."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass Main(Scene):\n    def construct(self):\n            self.play(Transform(text,Text(\"animate.scale_to_fit_height\").shift(UP*2.5)), run_time=0.5)\n            square = Square()\n            self.play(square.animate.scale_to_fit_height(3))\n            self.remove(square)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Could you create an animation where a red dot starts on the left of the screen and a pointer is continuously pointing to it from the left as it moves horizontally to the right at a constant speed? Additionally, can you make all the objects in the scene gradually change in size depending on how far they are from the center of the screen? The closer they are to the center, the larger they should be, and the farther away, the smaller. Please make sure this scaling effect happens in real-time as the dot moves. Let the animation last for 5 seconds."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display a semicircular arc centered on screen, starting from the right and sweeping counterclockwise to the left."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArcExample(Scene):\n    def construct(self):\n        self.add(Arc(angle=PI))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a semicircular arc centered on screen, starting from the right and sweeping counterclockwise to the left."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display a semicircular arc centered on screen, starting from the right and sweeping counterclockwise to the left."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ArcExample(Scene):\n    def construct(self):\n        self.add(Arc(angle=PI))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display a semicircular arc centered on screen, starting from the right and sweeping counterclockwise to the left."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I would like to create an educational animation that walks through the process of evaluating a double integral in polar coordinates. Specifically, I\u2019m interested in an animation that shows the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta goes from 0 to pi. I want the animation to visually display the problem, then demonstrate step-by-step integration with respect to r first, followed by integrating with respect to theta. After each integration step, I would like the results to be displayed in mathematical notation, along with a brief text explanation of what is being done. Finally, the solution should be simplified to show the final numeric answer. Can you create such an animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigonometricFunctionIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of using a trigonometric identity\n        explanation1 = Text(\"Use the identity: sin(2x) = 2sin(x)cos(x)\",\n                            font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        identity_applied = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_applied))\n        self.wait(1)\n\n        # Integration of sin(2x)\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(identity_applied, integration_step))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that walks through the process of evaluating a double integral in polar coordinates. Specifically, I\u2019m interested in an animation that shows the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta goes from 0 to pi. I want the animation to visually display the problem, then demonstrate step-by-step integration with respect to r first, followed by integrating with respect to theta. After each integration step, I would like the results to be displayed in mathematical notation, along with a brief text explanation of what is being done. Finally, the solution should be simplified to show the final numeric answer. Can you create such an animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i would like to create an educational animation that walks through the process of evaluating a double integral in polar coordinates. specifically, i\u2019m interested in an animation that shows the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta goes from 0 to pi. i want the animation to visually display the problem, then demonstrate step-by-step integration with respect to r first, followed by integrating with respect to theta. after each integration step, i would like the results to be displayed in mathematical notation, along with a brief text explanation of what is being done. finally, the solution should be simplified to show the final numeric answer. can you create such an animation?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TrigonometricFunctionIntegration(Scene):\n    def construct(self):\n        # Displaying the problem\n        problem = MathTex(r\"\\int \\sin(x) \\cos(x) \\,dx\")\n        self.play(Write(problem))\n        self.wait(1)\n\n        # Explanation of using a trigonometric identity\n        explanation1 = Text(\"Use the identity: sin(2x) = 2sin(x)cos(x)\",\n                            font_size=24).to_edge(UP)\n        self.play(Write(explanation1))\n        self.wait(2)\n\n        # Applying the identity\n        identity_applied = MathTex(r\"= \\frac{1}{2} \\int \\sin(2x) \\,dx\")\n        self.play(ReplacementTransform(problem, identity_applied))\n        self.wait(1)\n\n        # Integration of sin(2x)\n        integration_step = MathTex(r\"= -\\frac{1}{4} \\cos(2x) + C\")\n        self.play(ReplacementTransform(identity_applied, integration_step))\n        self.wait(2)\n\n        # Clear the scene and conclude\n        self.clear()\n        self.wait(1)\n        self.play(Write(integration_step))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I would like to create an educational animation that walks through the process of evaluating a double integral in polar coordinates. Specifically, I\u2019m interested in an animation that shows the integral of r^2 sin(theta) with respect to r and theta, where r goes from 0 to 1 and theta goes from 0 to pi. I want the animation to visually display the problem, then demonstrate step-by-step integration with respect to r first, followed by integrating with respect to theta. After each integration step, I would like the results to be displayed in mathematical notation, along with a brief text explanation of what is being done. Finally, the solution should be simplified to show the final numeric answer. Can you create such an animation?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: How do we construct a self-avoiding walk derived from a standard Brownian motion, and what are the implications for modeling polymer chains?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass BrownianMotionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dancing Through Disarray: Taming the Brownian Beast\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Introduction to Brownian Motion\n        brownian_text = Text(\"Standard Brownian Motion\", font_size=28)\n        brownian_text.next_to(title, DOWN, buff=1)\n        self.play(Write(brownian_text))\n        \n        # Visualize simple Brownian Motion path\n        brownian_dot = Dot(color=BLUE)\n        brownian_dot.move_to(LEFT * 3)\n        \n        # Create a simple path for demonstration\n        brownian_path = VMobject(color=YELLOW)\n        brownian_points = [brownian_dot.get_center()]\n        \n        # Generate a few random points for the path\n        for _ in range(8):\n            last_point = brownian_points[-1]\n            new_point = last_point + np.array([0.5, np.random.uniform(-0.8, 0.8), 0])\n            brownian_points.append(new_point)\n        \n        brownian_path.set_points_as_corners(brownian_points)\n        \n        # Show the dot and draw the path\n        self.play(FadeIn(brownian_dot))\n        self.play(Create(brownian_path), run_time=2)\n        \n        # Move dot along the path\n        for point in brownian_points[1:]:\n            self.play(brownian_dot.animate.move_to(point), run_time=0.3)\n        \n        # Equation for Brownian Motion\n        eq_brownian = Text(\"X(t) = \u221at \u00b7 W_t\", font_size=24)\n        eq_brownian.next_to(brownian_text, DOWN)\n        self.play(Write(eq_brownian))\n        self.wait(1)\n        \n        # Introduce Self-Avoiding Walk\n        saw_text = Text(\"Self-Avoiding Walk\", font_size=28)\n        saw_text.next_to(eq_brownian, DOWN, buff=1)\n        self.play(Write(saw_text))\n        \n        # Create a simple self-avoiding walk\n        saw_dot = Dot(color=BLUE)\n        saw_dot.move_to(LEFT * 3)\n        \n        # Predetermined self-avoiding path\n        saw_points = [\n            saw_dot.get_center(),\n            saw_dot.get_center() + np.array([0.5, 0.8, 0]),\n            saw_dot.get_center() + np.array([1.0, 0.0, 0]),\n            saw_dot.get_center() + np.array([1.5, -0.8, 0]),\n            saw_dot.get_center() + np.array([2.0, 0.0, 0]),\n            saw_dot.get_center() + np.array([2.5, 0.8, 0]),\n            saw_dot.get_center() + np.array([3.0, 0.0, 0]),\n            saw_dot.get_center() + np.array([3.5, -0.8, 0]),\n            saw_dot.get_center() + np.array([4.0, 0.0, 0])\n        ]\n        \n        saw_path = VMobject(color=BLUE)\n        saw_path.set_points_as_corners(saw_points)\n        \n        # Show the new dot and draw the path\n        self.play(\n            FadeOut(brownian_dot),\n            FadeOut(brownian_path),\n            FadeIn(saw_dot)\n        )\n        self.play(Create(saw_path), run_time=2)\n        \n        # Move dot along the path\n        for point in saw_points[1:]:\n            self.play(saw_dot.animate.move_to(point), run_time=0.3)\n        \n        # Equation for Self-Avoiding Walk\n        eq_saw = Text(\"P_SAW(n) ~ \u03bc^n n^(\u03b3-1)\", font_size=24)\n        eq_saw.next_to(saw_text, DOWN)\n        self.play(Write(eq_saw))\n        self.wait(1)\n        \n        # Polymer application\n        polymer_text = Text(\"Application: Polymer Chain Modeling\", font_size=24)\n        polymer_text.next_to(eq_saw, DOWN, buff=1)\n        self.play(Write(polymer_text))\n        self.wait(1)\n        \n        # Key insight\n        insight = Text(\"Self-avoiding walks create realistic polymer structures\", font_size=20)\n        insight.next_to(polymer_text, DOWN)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Every step in mathematics is part of a bigger dance.\", font_size=24)\n        self.play(\n            FadeOut(saw_dot),\n            FadeOut(saw_path),\n            FadeOut(brownian_text),\n            FadeOut(saw_text),\n            FadeOut(eq_brownian),\n            FadeOut(eq_saw),\n            FadeOut(polymer_text),\n            FadeOut(insight),\n            FadeOut(title),\n            FadeIn(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do we construct a self-avoiding walk derived from a standard Brownian motion, and what are the implications for modeling polymer chains?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: how do we construct a self-avoiding walk derived from a standard brownian motion, and what are the implications for modeling polymer chains?"}, {"from": "assistant", "value": "```python\nfrom manim import *\nimport numpy as np\n\nclass BrownianMotionScene(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Dancing Through Disarray: Taming the Brownian Beast\", font_size=24)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.scale(0.7).to_edge(UP))\n        \n        # Introduction to Brownian Motion\n        brownian_text = Text(\"Standard Brownian Motion\", font_size=28)\n        brownian_text.next_to(title, DOWN, buff=1)\n        self.play(Write(brownian_text))\n        \n        # Visualize simple Brownian Motion path\n        brownian_dot = Dot(color=BLUE)\n        brownian_dot.move_to(LEFT * 3)\n        \n        # Create a simple path for demonstration\n        brownian_path = VMobject(color=YELLOW)\n        brownian_points = [brownian_dot.get_center()]\n        \n        # Generate a few random points for the path\n        for _ in range(8):\n            last_point = brownian_points[-1]\n            new_point = last_point + np.array([0.5, np.random.uniform(-0.8, 0.8), 0])\n            brownian_points.append(new_point)\n        \n        brownian_path.set_points_as_corners(brownian_points)\n        \n        # Show the dot and draw the path\n        self.play(FadeIn(brownian_dot))\n        self.play(Create(brownian_path), run_time=2)\n        \n        # Move dot along the path\n        for point in brownian_points[1:]:\n            self.play(brownian_dot.animate.move_to(point), run_time=0.3)\n        \n        # Equation for Brownian Motion\n        eq_brownian = Text(\"X(t) = \u221at \u00b7 W_t\", font_size=24)\n        eq_brownian.next_to(brownian_text, DOWN)\n        self.play(Write(eq_brownian))\n        self.wait(1)\n        \n        # Introduce Self-Avoiding Walk\n        saw_text = Text(\"Self-Avoiding Walk\", font_size=28)\n        saw_text.next_to(eq_brownian, DOWN, buff=1)\n        self.play(Write(saw_text))\n        \n        # Create a simple self-avoiding walk\n        saw_dot = Dot(color=BLUE)\n        saw_dot.move_to(LEFT * 3)\n        \n        # Predetermined self-avoiding path\n        saw_points = [\n            saw_dot.get_center(),\n            saw_dot.get_center() + np.array([0.5, 0.8, 0]),\n            saw_dot.get_center() + np.array([1.0, 0.0, 0]),\n            saw_dot.get_center() + np.array([1.5, -0.8, 0]),\n            saw_dot.get_center() + np.array([2.0, 0.0, 0]),\n            saw_dot.get_center() + np.array([2.5, 0.8, 0]),\n            saw_dot.get_center() + np.array([3.0, 0.0, 0]),\n            saw_dot.get_center() + np.array([3.5, -0.8, 0]),\n            saw_dot.get_center() + np.array([4.0, 0.0, 0])\n        ]\n        \n        saw_path = VMobject(color=BLUE)\n        saw_path.set_points_as_corners(saw_points)\n        \n        # Show the new dot and draw the path\n        self.play(\n            FadeOut(brownian_dot),\n            FadeOut(brownian_path),\n            FadeIn(saw_dot)\n        )\n        self.play(Create(saw_path), run_time=2)\n        \n        # Move dot along the path\n        for point in saw_points[1:]:\n            self.play(saw_dot.animate.move_to(point), run_time=0.3)\n        \n        # Equation for Self-Avoiding Walk\n        eq_saw = Text(\"P_SAW(n) ~ \u03bc^n n^(\u03b3-1)\", font_size=24)\n        eq_saw.next_to(saw_text, DOWN)\n        self.play(Write(eq_saw))\n        self.wait(1)\n        \n        # Polymer application\n        polymer_text = Text(\"Application: Polymer Chain Modeling\", font_size=24)\n        polymer_text.next_to(eq_saw, DOWN, buff=1)\n        self.play(Write(polymer_text))\n        self.wait(1)\n        \n        # Key insight\n        insight = Text(\"Self-avoiding walks create realistic polymer structures\", font_size=20)\n        insight.next_to(polymer_text, DOWN)\n        self.play(Write(insight))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"Every step in mathematics is part of a bigger dance.\", font_size=24)\n        self.play(\n            FadeOut(saw_dot),\n            FadeOut(saw_path),\n            FadeOut(brownian_text),\n            FadeOut(saw_text),\n            FadeOut(eq_brownian),\n            FadeOut(eq_saw),\n            FadeOut(polymer_text),\n            FadeOut(insight),\n            FadeOut(title),\n            FadeIn(conclusion)\n        )\n        self.wait(2)\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: How do we construct a self-avoiding walk derived from a standard Brownian motion, and what are the implications for modeling polymer chains?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "logo.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\n\nimport manim_ml\nmanim_ml.config.color_scheme = \"light_mode\"\n\nfrom manim_ml.neural_network.architectures.feed_forward import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 1000\nconfig.pixel_width = 1000\nconfig.frame_height = 4.0\nconfig.frame_width = 4.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.text = Text(\"ManimML\", color=manim_ml.config.color_scheme.text_color)\n        self.text.scale(1.0)\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 6, 3], layer_spacing=0.3, node_color=BLUE\n        )\n        self.neural_network.scale(1.0)\n        self.neural_network.move_to(self.text.get_bottom())\n        self.neural_network.shift(1.25 * DOWN)\n        self.logo_group = Group(self.text, self.neural_network)\n        self.logo_group.scale(1.0)\n        self.logo_group.move_to(ORIGIN)\n        self.play(Write(self.text), run_time=1.0)\n        self.play(Create(self.neural_network), run_time=3.0)\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            # Create(self.surrounding_rectangle)\n        )\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            #    Create(self.surrounding_rectangle)\n        )\n        self.play(animation_group, runtime=5.0)\n        self.wait(5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "logo.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that logo.py"}, {"from": "assistant", "value": "```python\n\"\"\"\n    Logo for Manim Machine Learning\n\"\"\"\nfrom manim import *\n\nimport manim_ml\nmanim_ml.config.color_scheme = \"light_mode\"\n\nfrom manim_ml.neural_network.architectures.feed_forward import FeedForwardNeuralNetwork\n\nconfig.pixel_height = 1000\nconfig.pixel_width = 1000\nconfig.frame_height = 4.0\nconfig.frame_width = 4.0\n\n\nclass ManimMLLogo(Scene):\n    def construct(self):\n        self.text = Text(\"ManimML\", color=manim_ml.config.color_scheme.text_color)\n        self.text.scale(1.0)\n        self.neural_network = FeedForwardNeuralNetwork(\n            [3, 5, 3, 6, 3], layer_spacing=0.3, node_color=BLUE\n        )\n        self.neural_network.scale(1.0)\n        self.neural_network.move_to(self.text.get_bottom())\n        self.neural_network.shift(1.25 * DOWN)\n        self.logo_group = Group(self.text, self.neural_network)\n        self.logo_group.scale(1.0)\n        self.logo_group.move_to(ORIGIN)\n        self.play(Write(self.text), run_time=1.0)\n        self.play(Create(self.neural_network), run_time=3.0)\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            # Create(self.surrounding_rectangle)\n        )\n        # self.surrounding_rectangle = SurroundingRectangle(self.logo_group, buff=0.3, color=BLUE)\n        underline = Underline(self.text, color=BLACK)\n        animation_group = AnimationGroup(\n            self.neural_network.make_forward_pass_animation(run_time=5),\n            Create(underline),\n            #    Create(self.surrounding_rectangle)\n        )\n        self.play(animation_group, runtime=5.0)\n        self.wait(5)\n```"}], "metadata": {"source": "thanks-manim", "original_description": "logo.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display the text \"Hello World!\" at the center of the screen, then animate it scaling up to twice its original size while remaining anchored in place."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \"Hello World!\" at the center of the screen, then animate it scaling up to twice its original size while remaining anchored in place."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display the text \"hello world!\" at the center of the screen, then animate it scaling up to twice its original size while remaining anchored in place."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ScaleInPlaceExample(Scene):\n    def construct(self):\n        self.play(ScaleInPlace(Text(\"Hello World!\"), 2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display the text \"Hello World!\" at the center of the screen, then animate it scaling up to twice its original size while remaining anchored in place."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation to demonstrate: Can a coherent visual model be constructed to conceptualize sets that do not contain themselves as a way to explain Russell's Paradox?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RussellsParadox(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Russell's Paradox\", color=BLUE)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Book metaphor\n        book_text = Text(\"Books that don't mention themselves\", color=BLUE).scale(0.7)\n        book_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(book_text))\n        \n        # Create a simple book visual\n        normal_book = Rectangle(height=1.2, width=0.8, color=BLUE)\n        normal_book.shift(LEFT * 2)\n        \n        paradox_book = Rectangle(height=1.2, width=0.8, color=RED)\n        paradox_book.shift(RIGHT * 2)\n        \n        books = VGroup(normal_book, paradox_book)\n        books.next_to(book_text, DOWN, buff=0.5)\n        \n        self.play(Create(books))\n        \n        # Question for the paradoxical book\n        question = Text(\"?\", color=YELLOW).scale(1.2)\n        question.move_to(paradox_book.get_center())\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Transition to set visualization\n        self.play(FadeOut(book_text), FadeOut(books), FadeOut(question))\n        \n        # Set visualization\n        set_text = Text(\"Sets that don't contain themselves\", color=BLUE).scale(0.7)\n        set_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(set_text))\n        \n        # Simple nested circles\n        outer_circle = Circle(radius=2, color=BLUE)\n        inner_circle = Circle(radius=1, color=RED)\n        \n        outer_circle.move_to(ORIGIN)\n        inner_circle.move_to(ORIGIN)\n        \n        self.play(Create(outer_circle))\n        self.play(Create(inner_circle))\n        \n        # Labels\n        outer_label = Text(\"Normal Sets\", color=BLUE).scale(0.5)\n        outer_label.next_to(outer_circle, UP, buff=0.2)\n        \n        inner_label = Text(\"Paradoxical Set\", color=RED).scale(0.5)\n        inner_label.move_to(inner_circle.get_center())\n        \n        self.play(Write(outer_label), Write(inner_label))\n        self.wait(1)\n        \n        # Mathematical formulation\n        self.play(FadeOut(set_text), FadeOut(outer_circle), FadeOut(inner_circle), \n                  FadeOut(outer_label), FadeOut(inner_label))\n        \n        equation = MathTex(r\"\\text{Let } S = \\{ x \\, | \\, x \\not\\in x \\}\")\n        question = MathTex(r\"\\text{Is } S \\in S \\text{?}\")\n        \n        equation.next_to(title, DOWN, buff=1)\n        question.next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"A fundamental paradox in mathematics\", color=BLUE).scale(0.7)\n        conclusion.next_to(question, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        self.play(FadeOut(title), FadeOut(equation), FadeOut(question), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can a coherent visual model be constructed to conceptualize sets that do not contain themselves as a way to explain Russell's Paradox?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that create a manim animation to demonstrate: can a coherent visual model be constructed to conceptualize sets that do not contain themselves as a way to explain russell's paradox?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass RussellsParadox(Scene):\n    def construct(self):\n        # Title\n        title = Text(\"Russell's Paradox\", color=BLUE)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n        \n        # Book metaphor\n        book_text = Text(\"Books that don't mention themselves\", color=BLUE).scale(0.7)\n        book_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(book_text))\n        \n        # Create a simple book visual\n        normal_book = Rectangle(height=1.2, width=0.8, color=BLUE)\n        normal_book.shift(LEFT * 2)\n        \n        paradox_book = Rectangle(height=1.2, width=0.8, color=RED)\n        paradox_book.shift(RIGHT * 2)\n        \n        books = VGroup(normal_book, paradox_book)\n        books.next_to(book_text, DOWN, buff=0.5)\n        \n        self.play(Create(books))\n        \n        # Question for the paradoxical book\n        question = Text(\"?\", color=YELLOW).scale(1.2)\n        question.move_to(paradox_book.get_center())\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Transition to set visualization\n        self.play(FadeOut(book_text), FadeOut(books), FadeOut(question))\n        \n        # Set visualization\n        set_text = Text(\"Sets that don't contain themselves\", color=BLUE).scale(0.7)\n        set_text.next_to(title, DOWN, buff=0.5)\n        self.play(Write(set_text))\n        \n        # Simple nested circles\n        outer_circle = Circle(radius=2, color=BLUE)\n        inner_circle = Circle(radius=1, color=RED)\n        \n        outer_circle.move_to(ORIGIN)\n        inner_circle.move_to(ORIGIN)\n        \n        self.play(Create(outer_circle))\n        self.play(Create(inner_circle))\n        \n        # Labels\n        outer_label = Text(\"Normal Sets\", color=BLUE).scale(0.5)\n        outer_label.next_to(outer_circle, UP, buff=0.2)\n        \n        inner_label = Text(\"Paradoxical Set\", color=RED).scale(0.5)\n        inner_label.move_to(inner_circle.get_center())\n        \n        self.play(Write(outer_label), Write(inner_label))\n        self.wait(1)\n        \n        # Mathematical formulation\n        self.play(FadeOut(set_text), FadeOut(outer_circle), FadeOut(inner_circle), \n                  FadeOut(outer_label), FadeOut(inner_label))\n        \n        equation = MathTex(r\"\\text{Let } S = \\{ x \\, | \\, x \\not\\in x \\}\")\n        question = MathTex(r\"\\text{Is } S \\in S \\text{?}\")\n        \n        equation.next_to(title, DOWN, buff=1)\n        question.next_to(equation, DOWN, buff=0.5)\n        \n        self.play(Write(equation))\n        self.play(Write(question))\n        self.wait(1)\n        \n        # Conclusion\n        conclusion = Text(\"A fundamental paradox in mathematics\", color=BLUE).scale(0.7)\n        conclusion.next_to(question, DOWN, buff=1)\n        self.play(Write(conclusion))\n        self.wait(2)\n        \n        self.play(FadeOut(title), FadeOut(equation), FadeOut(question), FadeOut(conclusion))\n```"}], "metadata": {"source": "bespoke-manim", "original_description": "Create a Manim animation to demonstrate: Can a coherent visual model be constructed to conceptualize sets that do not contain themselves as a way to explain Russell's Paradox?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around the scene horizontally at a slow rate. Stop the camera rotation and reset the camera to the original orientation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDCameraRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around the scene horizontally at a slow rate. Stop the camera rotation and reset the camera to the original orientation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display 3d axes and a circle. set the camera orientation to a specific angle. begin rotating the camera around the scene horizontally at a slow rate. stop the camera rotation and reset the camera to the original orientation."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass ThreeDCameraRotation(ThreeDScene):\n    def construct(self):\n        axes = ThreeDAxes()\n        circle=Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle,axes)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()\n```"}], "metadata": {"source": "manimbench", "original_description": "Display 3D axes and a circle. Set the camera orientation to a specific angle. Begin rotating the camera around the scene horizontally at a slow rate. Stop the camera rotation and reset the camera to the original orientation."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "I'd like an animated educational video that explains what a Fourier series is and shows the equation of a Fourier series. First, display the equation with a brief pause. Then, in simple terms, describe what a Fourier series does, mentioning its ability to break down periodic functions into sums of sines and cosines, with each point appearing in succession. Afterward, give an example of its applications in fields like signal processing and physics. Furthermore, show how a partial sum of the series can be used to approximate functions, and conclude by indicating that we can approximate the functions using a finite number of terms. Finally, clear the screen and end with a statement summarizing the significance of the Fourier series in harmonic analysis. Ensure that each step is accompanied by appropriate pauses."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of the wave equation\n        description = Text(\"This equation describes wave propagation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(description, shift=UP))\n        self.wait(2)\n\n        # Introduce a specific solution\n        solution_text = Text(\"A particular solution is the sine wave function\", font_size=24).to_edge(UP)\n        self.play(Transform(description, solution_text))\n        self.wait(2)\n\n        # Displaying a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(1)\n\n        # Discuss the parameters of the sine wave solution\n        params_text = Text(\"Here, A is the amplitude, k is the wavenumber, \\omega is the frequency, and \\phi is the phase offset.\", font_size=20, line_spacing=1.5).to_edge(UP)\n        self.play(Transform(description, params_text))\n        self.wait(2)\n\n        # Clearing the screen\n        self.play(FadeOut(description), FadeOut(specific_solution))\n        self.wait(1)\n\n        # Conclude by writing a simplified version of the sine wave without a phase offset\n        simple_wave = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Write(simple_wave))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like an animated educational video that explains what a Fourier series is and shows the equation of a Fourier series. First, display the equation with a brief pause. Then, in simple terms, describe what a Fourier series does, mentioning its ability to break down periodic functions into sums of sines and cosines, with each point appearing in succession. Afterward, give an example of its applications in fields like signal processing and physics. Furthermore, show how a partial sum of the series can be used to approximate functions, and conclude by indicating that we can approximate the functions using a finite number of terms. Finally, clear the screen and end with a statement summarizing the significance of the Fourier series in harmonic analysis. Ensure that each step is accompanied by appropriate pauses."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that i'd like an animated educational video that explains what a fourier series is and shows the equation of a fourier series. first, display the equation with a brief pause. then, in simple terms, describe what a fourier series does, mentioning its ability to break down periodic functions into sums of sines and cosines, with each point appearing in succession. afterward, give an example of its applications in fields like signal processing and physics. furthermore, show how a partial sum of the series can be used to approximate functions, and conclude by indicating that we can approximate the functions using a finite number of terms. finally, clear the screen and end with a statement summarizing the significance of the fourier series in harmonic analysis. ensure that each step is accompanied by appropriate pauses."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass WaveEquationExample(Scene):\n    def construct(self):\n        # Displaying the wave equation\n        wave_eq = MathTex(r\"\\frac{\\partial^2 u}{\\partial t^2} - c^2 \\frac{\\partial^2 u}{\\partial x^2} = 0\")\n        self.play(Write(wave_eq))\n        self.wait(1)\n\n        # Description of the wave equation\n        description = Text(\"This equation describes wave propagation.\", font_size=24).to_edge(UP)\n        self.play(FadeIn(description, shift=UP))\n        self.wait(2)\n\n        # Introduce a specific solution\n        solution_text = Text(\"A particular solution is the sine wave function\", font_size=24).to_edge(UP)\n        self.play(Transform(description, solution_text))\n        self.wait(2)\n\n        # Displaying a specific solution\n        specific_solution = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t + \\phi)\")\n        self.play(ReplacementTransform(wave_eq, specific_solution))\n        self.wait(1)\n\n        # Discuss the parameters of the sine wave solution\n        params_text = Text(\"Here, A is the amplitude, k is the wavenumber, \\omega is the frequency, and \\phi is the phase offset.\", font_size=20, line_spacing=1.5).to_edge(UP)\n        self.play(Transform(description, params_text))\n        self.wait(2)\n\n        # Clearing the screen\n        self.play(FadeOut(description), FadeOut(specific_solution))\n        self.wait(1)\n\n        # Conclude by writing a simplified version of the sine wave without a phase offset\n        simple_wave = MathTex(r\"u(x, t) = A \\sin(kx - \\omega t)\")\n        self.play(Write(simple_wave))\n        self.wait(1)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "I'd like an animated educational video that explains what a Fourier series is and shows the equation of a Fourier series. First, display the equation with a brief pause. Then, in simple terms, describe what a Fourier series does, mentioning its ability to break down periodic functions into sums of sines and cosines, with each point appearing in succession. Afterward, give an example of its applications in fields like signal processing and physics. Furthermore, show how a partial sum of the series can be used to approximate functions, and conclude by indicating that we can approximate the functions using a finite number of terms. Finally, clear the screen and end with a statement summarizing the significance of the Fourier series in harmonic analysis. Ensure that each step is accompanied by appropriate pauses."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Can you create an animated video that visually explains the process of solving a double integral in polar coordinates, specifically the integral of r from 0 to 1 and theta from 0 to pi/2? The video should start by showing the double integral formula, then step-by-step display the integration in terms of r first, replacing r with its limits and simplifying it. Next, it should show the integration in terms of theta and simplifying to get the final answer, emphasizing each step of the calculation. Can you also include explanatory texts that guide me through the stages of integrating with respect to r first and then with respect to theta, ensuring each step is clearly shown and waits long enough for me to follow?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TorusSurface(ThreeDScene):\n    def construct(self):\n        resolution_fa = 22\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n\n        def param_surface(u, v):\n            R = 1\n            r = 0.25\n            return np.array([\n                (R + r * np.cos(v)) * np.cos(u),\n                (R + r * np.cos(v)) * np.sin(u),\n                r * np.sin(v)\n            ])\n\n        surface = ParametricSurface(\n            param_surface,\n            u_range=[0, TAU],\n            v_range=[0, TAU],\n            resolution=(resolution_fa, resolution_fa)\n        )\n        surface.set_style(fill_opacity=0.5, stroke_color=BLUE)\n        \n        self.play(Create(surface), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.3)\n        self.wait(10)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video that visually explains the process of solving a double integral in polar coordinates, specifically the integral of r from 0 to 1 and theta from 0 to pi/2? The video should start by showing the double integral formula, then step-by-step display the integration in terms of r first, replacing r with its limits and simplifying it. Next, it should show the integration in terms of theta and simplifying to get the final answer, emphasizing each step of the calculation. Can you also include explanatory texts that guide me through the stages of integrating with respect to r first and then with respect to theta, ensuring each step is clearly shown and waits long enough for me to follow?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that can you create an animated video that visually explains the process of solving a double integral in polar coordinates, specifically the integral of r from 0 to 1 and theta from 0 to pi/2? the video should start by showing the double integral formula, then step-by-step display the integration in terms of r first, replacing r with its limits and simplifying it. next, it should show the integration in terms of theta and simplifying to get the final answer, emphasizing each step of the calculation. can you also include explanatory texts that guide me through the stages of integrating with respect to r first and then with respect to theta, ensuring each step is clearly shown and waits long enough for me to follow?"}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nclass TorusSurface(ThreeDScene):\n    def construct(self):\n        resolution_fa = 22\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n\n        def param_surface(u, v):\n            R = 1\n            r = 0.25\n            return np.array([\n                (R + r * np.cos(v)) * np.cos(u),\n                (R + r * np.cos(v)) * np.sin(u),\n                r * np.sin(v)\n            ])\n\n        surface = ParametricSurface(\n            param_surface,\n            u_range=[0, TAU],\n            v_range=[0, TAU],\n            resolution=(resolution_fa, resolution_fa)\n        )\n        surface.set_style(fill_opacity=0.5, stroke_color=BLUE)\n        \n        self.play(Create(surface), run_time=3)\n        self.begin_ambient_camera_rotation(rate=0.3)\n        self.wait(10)\n```"}], "metadata": {"source": "manim-codegen", "original_description": "Can you create an animated video that visually explains the process of solving a double integral in polar coordinates, specifically the integral of r from 0 to 1 and theta from 0 to pi/2? The video should start by showing the double integral formula, then step-by-step display the integration in terms of r first, replacing r with its limits and simplifying it. Next, it should show the integration in terms of theta and simplifying to get the final answer, emphasizing each step of the calculation. Can you also include explanatory texts that guide me through the stages of integrating with respect to r first and then with respect to theta, ensuring each step is clearly shown and waits long enough for me to follow?"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "test_opengl_shader.py"}, {"from": "assistant", "value": "```python\nimport manim.utils.opengl as opengl\nfrom manim import *\nfrom manim.opengl import *  # type: ignore\n\n\nclass InlineShaderExample(Scene):\n    def construct(self):\n        config[\"background_color\"] = \"#333333\"\n\n        c = Circle(fill_opacity=0.7).shift(UL)\n        self.add(c)\n\n        shader = Shader(\n            self.renderer.context,\n            source={\n                \"vertex_shader\": \"\"\"\n                #version 330\n                in vec4 in_vert;\n                in vec4 in_color;\n                out vec4 v_color;\n                uniform mat4 u_model_view_matrix;\n                uniform mat4 u_projection_matrix;\n                void main() {\n                    v_color = in_color;\n                    vec4 camera_space_vertex = u_model_view_matrix * in_vert;\n                    vec4 clip_space_vertex = u_projection_matrix * camera_space_vertex;\n                    gl_Position = clip_space_vertex;\n                }\n            \"\"\",\n                \"fragment_shader\": \"\"\"\n            #version 330\n            in vec4 v_color;\n            out vec4 frag_color;\n            void main() {\n              frag_color = v_color;\n            }\n\n            void main () {\n                // Previously, you'd have rendered your complete scene into a texture\n                // bound to \"fullScreenTexture.\"\n                vec4 rValue = texture2D(fullscreenTexture, gl_TexCoords[0] - rOffset);  \n                vec4 gValue = texture2D(fullscreenTexture, gl_TexCoords[0] - gOffset);\n                vec4 bValue = texture2D(fullscreenTexture, gl_TexCoords[0] - bOffset);  \n\n                // Combine the offset colors.\n                gl_FragColor = vec4(rValue.r, gValue.g, bValue.b, 1.0);\n            }\n            \"\"\",\n            },\n        )\n        shader.set_uniform(\"u_model_view_matrix\", opengl.view_matrix())\n        shader.set_uniform(\n            \"u_projection_matrix\",\n            opengl.orthographic_projection_matrix(),\n        )\n\n        attributes = np.zeros(\n            6,\n            dtype=[\n                (\"in_vert\", np.float32, (4,)),\n                (\"in_color\", np.float32, (4,)),\n            ],\n        )\n        attributes[\"in_vert\"] = np.array(\n            [\n                [-1, -1, 0, 1],\n                [-1, 1, 0, 1],\n                [1, 1, 0, 1],\n                [-1, -1, 0, 1],\n                [1, -1, 0, 1],\n                [1, 1, 0, 1],\n            ],\n        )\n        attributes[\"in_color\"] = np.array(\n            [\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n            ],\n        )\n        mesh = Mesh(shader, attributes)\n        self.add(mesh)\n\n        self.wait(5)\n        # self.embed_2()\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_opengl_shader.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that test_opengl_shader.py"}, {"from": "assistant", "value": "```python\nimport manim.utils.opengl as opengl\nfrom manim import *\nfrom manim.opengl import *  # type: ignore\n\n\nclass InlineShaderExample(Scene):\n    def construct(self):\n        config[\"background_color\"] = \"#333333\"\n\n        c = Circle(fill_opacity=0.7).shift(UL)\n        self.add(c)\n\n        shader = Shader(\n            self.renderer.context,\n            source={\n                \"vertex_shader\": \"\"\"\n                #version 330\n                in vec4 in_vert;\n                in vec4 in_color;\n                out vec4 v_color;\n                uniform mat4 u_model_view_matrix;\n                uniform mat4 u_projection_matrix;\n                void main() {\n                    v_color = in_color;\n                    vec4 camera_space_vertex = u_model_view_matrix * in_vert;\n                    vec4 clip_space_vertex = u_projection_matrix * camera_space_vertex;\n                    gl_Position = clip_space_vertex;\n                }\n            \"\"\",\n                \"fragment_shader\": \"\"\"\n            #version 330\n            in vec4 v_color;\n            out vec4 frag_color;\n            void main() {\n              frag_color = v_color;\n            }\n\n            void main () {\n                // Previously, you'd have rendered your complete scene into a texture\n                // bound to \"fullScreenTexture.\"\n                vec4 rValue = texture2D(fullscreenTexture, gl_TexCoords[0] - rOffset);  \n                vec4 gValue = texture2D(fullscreenTexture, gl_TexCoords[0] - gOffset);\n                vec4 bValue = texture2D(fullscreenTexture, gl_TexCoords[0] - bOffset);  \n\n                // Combine the offset colors.\n                gl_FragColor = vec4(rValue.r, gValue.g, bValue.b, 1.0);\n            }\n            \"\"\",\n            },\n        )\n        shader.set_uniform(\"u_model_view_matrix\", opengl.view_matrix())\n        shader.set_uniform(\n            \"u_projection_matrix\",\n            opengl.orthographic_projection_matrix(),\n        )\n\n        attributes = np.zeros(\n            6,\n            dtype=[\n                (\"in_vert\", np.float32, (4,)),\n                (\"in_color\", np.float32, (4,)),\n            ],\n        )\n        attributes[\"in_vert\"] = np.array(\n            [\n                [-1, -1, 0, 1],\n                [-1, 1, 0, 1],\n                [1, 1, 0, 1],\n                [-1, -1, 0, 1],\n                [1, -1, 0, 1],\n                [1, 1, 0, 1],\n            ],\n        )\n        attributes[\"in_color\"] = np.array(\n            [\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n                [0, 0, 1, 1],\n            ],\n        )\n        mesh = Mesh(shader, attributes)\n        self.add(mesh)\n\n        self.wait(5)\n        # self.embed_2()\n```"}], "metadata": {"source": "thanks-manim", "original_description": "test_opengl_shader.py"}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Display three groups of arrows demonstrating different arrow properties:\n\n1. The first group shows two gold arrows pointing left\u2014one with a default triangular tip and one with a square tip\u2014stacked vertically.\n2. The second group shows two right-pointing arrows near a maroon square\u2014one with default spacing from the square and one with no spacing (buff), placed just above the first group.\n3. The third group shows two vertical arrows on the left side\u2014one long arrow extending from the center to the top of the screen, and one shorter arrow with a smaller tip and thinner stroke, both aligned vertically.\n\nAll three groups are arranged horizontally with space between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim.mobject.geometry.tips import ArrowSquareTip\nclass ArrowExample(Scene):\n    def construct(self):\n        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\n        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\n        g1 = Group(arrow_1, arrow_2)\n\n        # the effect of buff\n        square = Square(color=MAROON_A)\n        arrow_3 = Arrow(start=LEFT, end=RIGHT)\n        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\n        g2 = Group(arrow_3, arrow_4, square)\n\n        # a shorter arrow has a shorter tip and smaller stroke width\n        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\n        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\n        g3 = Group(arrow_5, arrow_6)\n\n        self.add(Group(g1, g2, g3).arrange(buff=2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display three groups of arrows demonstrating different arrow properties:\n\n1. The first group shows two gold arrows pointing left\u2014one with a default triangular tip and one with a square tip\u2014stacked vertically.\n2. The second group shows two right-pointing arrows near a maroon square\u2014one with default spacing from the square and one with no spacing (buff), placed just above the first group.\n3. The third group shows two vertical arrows on the left side\u2014one long arrow extending from the center to the top of the screen, and one shorter arrow with a smaller tip and thinner stroke, both aligned vertically.\n\nAll three groups are arranged horizontally with space between them."}}
{"conversations": [{"from": "system", "value": "You are a Manim code generator. Create clean, working Manim animations using ManimCE syntax. Always wrap code in Python code blocks."}, {"from": "user", "value": "Create a Manim animation that display three groups of arrows demonstrating different arrow properties:\n\n1. the first group shows two gold arrows pointing left\u2014one with a default triangular tip and one with a square tip\u2014stacked vertically.\n2. the second group shows two right-pointing arrows near a maroon square\u2014one with default spacing from the square and one with no spacing (buff), placed just above the first group.\n3. the third group shows two vertical arrows on the left side\u2014one long arrow extending from the center to the top of the screen, and one shorter arrow with a smaller tip and thinner stroke, both aligned vertically.\n\nall three groups are arranged horizontally with space between them."}, {"from": "assistant", "value": "```python\nfrom manim import *\n\nfrom manim.mobject.geometry.tips import ArrowSquareTip\nclass ArrowExample(Scene):\n    def construct(self):\n        arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\n        arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\n        g1 = Group(arrow_1, arrow_2)\n\n        # the effect of buff\n        square = Square(color=MAROON_A)\n        arrow_3 = Arrow(start=LEFT, end=RIGHT)\n        arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\n        g2 = Group(arrow_3, arrow_4, square)\n\n        # a shorter arrow has a shorter tip and smaller stroke width\n        arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\n        arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\n        g3 = Group(arrow_5, arrow_6)\n\n        self.add(Group(g1, g2, g3).arrange(buff=2))\n```"}], "metadata": {"source": "manimbench", "original_description": "Display three groups of arrows demonstrating different arrow properties:\n\n1. The first group shows two gold arrows pointing left\u2014one with a default triangular tip and one with a square tip\u2014stacked vertically.\n2. The second group shows two right-pointing arrows near a maroon square\u2014one with default spacing from the square and one with no spacing (buff), placed just above the first group.\n3. The third group shows two vertical arrows on the left side\u2014one long arrow extending from the center to the top of the screen, and one shorter arrow with a smaller tip and thinner stroke, both aligned vertically.\n\nAll three groups are arranged horizontally with space between them."}}
